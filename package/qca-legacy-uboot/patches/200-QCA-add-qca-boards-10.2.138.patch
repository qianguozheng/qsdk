diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap120/ap120.c u-boot_1.1//board/ar7240/ap120/ap120.c
--- u-boot//board/ar7240/ap120/ap120.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap120/ap120.c	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/*  Enable xLNBIAS signal on GPIO (19, 20) */
+	ar7240_reg_wr (AR7240_GPIO_FUNC4, ((ar7240_reg_rd(AR7240_GPIO_FUNC4) & 0x00ffffff)) | 0x2f000000);
+	ar7240_reg_wr (AR7240_GPIO_FUNC5, ((ar7240_reg_rd(AR7240_GPIO_FUNC5) & 0xffffff00)) | 0x2e);
+	ar7240_reg_wr (AR7240_GPIO_OE, (ar7240_reg_rd(AR7240_GPIO_OE) & 0xffe7ffff));
+
+#if 0
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ar7240_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ar7240_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ar7240_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ar7240_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+#ifdef CONFIG_AP123
+	extern void ath_ddr_tap_cal(void);
+#endif
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+#ifdef CONFIG_AP123
+	ath_ddr_tap_cal();
+
+#ifndef COMPRESSED_UBOOT
+	printf("Tap value selected = 0x%x [0x%x - 0x%x]\n",
+		ar7240_reg_rd(AR7240_DDR_TAP_CONTROL0),
+		ar7240_reg_rd(0xbd007f10), ar7240_reg_rd(0xbd007f14));
+#endif
+#endif
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */ 
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot AP120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot AP120\n");
+#endif
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap120/config.mk u-boot_1.1//board/ar7240/ap120/config.mk
--- u-boot//board/ar7240/ap120/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap120/config.mk	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,41 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap120/flash.c u-boot_1.1//board/ar7240/ap120/flash.c
--- u-boot//board/ar7240/ap120/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap120/flash.c	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap120/Makefile u-boot_1.1//board/ar7240/ap120/Makefile
--- u-boot//board/ar7240/ap120/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap120/Makefile	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,90 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap120/u-boot-bootstrap.lds u-boot_1.1//board/ar7240/ap120/u-boot-bootstrap.lds
--- u-boot//board/ar7240/ap120/u-boot-bootstrap.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap120/u-boot-bootstrap.lds	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap120/u-boot.lds u-boot_1.1//board/ar7240/ap120/u-boot.lds
--- u-boot//board/ar7240/ap120/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap120/u-boot.lds	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap121/ap121.c u-boot_1.1//board/ar7240/ap121/ap121.c
--- u-boot//board/ar7240/ap121/ap121.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap121/ap121.c	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,142 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef CONFIG_HORNET_EMU
+extern void ar7240_ddr_initial_config_for_fpga(void);
+#endif
+
+void
+ar7240_usb_initial_config(void)
+{
+#ifndef CONFIG_HORNET_EMU
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+#endif
+}
+
+void
+ar7240_usb_otp_config(void)
+{
+    unsigned int addr, reg_val, reg_usb;
+    int time_out, status, usb_valid;
+    
+    for (addr = 0xb8114014; ;addr -= 0x10) {
+        status = 0;
+        time_out = 20;
+        
+        reg_val = ar7240_reg_rd(addr);
+
+        while ((time_out > 0) && (~status)) {
+            if ((( ar7240_reg_rd(0xb8115f18)) & 0x7) == 0x4) {
+                status = 1;
+            } else {
+                status = 0;
+            }
+            time_out--;
+        }
+
+        reg_val = ar7240_reg_rd(0xb8115f1c);
+        if ((reg_val & 0x80) == 0x80){
+            usb_valid = 1;
+            reg_usb = reg_val & 0x000000ff;
+        }
+
+        if (addr == 0xb8114004) {
+            break;
+        }
+    }
+
+    if (usb_valid) {
+        reg_val = ar7240_reg_rd(0xb8116c88);
+        reg_val &= ~0x03f00000;
+        reg_val |= (reg_usb & 0xf) << 22;
+        ar7240_reg_wr(0xb8116c88, reg_val);
+    }
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs 
+     * clk_obs1(gpio13/bit8),  clk_obs2(gpio14/bit9), clk_obs3(gpio15/bit10),
+     * clk_obs4(gpio16/bit11), clk_obs5(gpio17/bit12)
+     * clk_obs0(gpio1/bit19), 6(gpio11/bit20)
+     */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, 
+        (ar7240_reg_rd(AR7240_GPIO_FUNC) & ~((0x1f<<8)|(0x3<<19))));
+
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | (0x1f<<3)));
+	
+    /* Clear AR7240_GPIO_FUNC BIT2 to ensure that software can control LED5(GPIO16) and LED6(GPIO17)  */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & ~(0x1<<2)));
+	
+    /* Set HORNET_BOOTSTRAP_STATUS BIT18 to ensure that software can control GPIO26 and GPIO27 */
+    //ar7240_reg_wr (HORNET_BOOTSTRAP_STATUS, (ar7240_reg_rd(HORNET_BOOTSTRAP_STATUS) | (0x1<<18)));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+#ifdef CONFIG_HORNET_EMU
+    ar7240_ddr_initial_config_for_fpga();
+#else
+    //ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+#endif
+
+/* Default tap values for starting the tap_init*/
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, CFG_DDR_TAP0_VAL);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, CFG_DDR_TAP1_VAL);
+
+    ar7240_gpio_config();
+
+#ifndef COMPRESSED_UBOOT
+#ifndef CONFIG_HORNET_EMU
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+#endif
+
+    //ar7240_usb_initial_config();
+    ar7240_usb_otp_config();
+    
+    hornet_ddr_tap_init();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+#if (BOARD_STRING == WAPI)
+    strcpy(board_string, "AP121 (ar9331) U-boot");
+#else
+    strcpy(board_string, "AP121-2MB (ar9330) U-boot");
+#endif
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("AP121 (ar9330) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap121/config.mk u-boot_1.1//board/ar7240/ap121/config.mk
--- u-boot//board/ar7240/ap121/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap121/config.mk	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap121/flash.c u-boot_1.1//board/ar7240/ap121/flash.c
--- u-boot//board/ar7240/ap121/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap121/flash.c	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap121/hornet_pll_init.S u-boot_1.1//board/ar7240/ap121/hornet_pll_init.S
--- u-boot//board/ar7240/ap121/hornet_pll_init.S	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap121/hornet_pll_init.S	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,375 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7240_soc.h>
+
+    .globl hornet_pll_init
+	.text
+	.align 4
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */ 
+/*     or  t8, t8, t9;                                 \ */
+#define set_reg(_reg, _val)                         \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, _val;                                   \
+    sw  t9, 0(t7);
+
+hornet_pll_init:
+
+#if 1
+/* These three wlan reset will avoid original issue, 
+so full chip reset isn't needed here. */
+    set_reg(0xb806001c, 0x00c06b30)
+    nop
+    set_reg(0xb806001c, 0x00c06330)
+    nop    
+    set_reg(0xb806001c, 0x00c06b30)
+    nop    
+    set_reg(0xb806001c, 0x00c06330)  
+    nop  
+reset_wlan:
+    set_reg(0xb806001c, 0x00c06b30) 
+    nop    
+    set_reg(0xb806001c, 0x00c06330)
+    nop
+
+    li  t5, 0x20
+check_val:
+    beq zero, t5, reset_wlan
+    addi t5, t5, -1    
+    li  t6, 0xb80600ac
+    lw  t7, 0(t6)
+    li  t8, 0x10
+    and t7, t7, t8
+    bne zero, t7, check_val 
+    
+    set_reg(HORNET_BOOTSTRAP_STATUS, 0x0002110e)
+    nop
+#else
+/* clear wlan reset bit in RESET_Register 0x1c */
+    set_reg(AR7240_RESET, 0x00c06b30)
+    nop
+    set_reg(AR7240_RESET, 0x00c06330)
+    nop
+
+/* cleck bootstrap status, wait for bit4 on, then clear bit16 */
+wait_loop0:
+    li  t6, KSEG1ADDR(HORNET_BOOTSTRAP_STATUS)
+    lw  t7, 0(t6)
+    li  t8, 0x10
+    and t7, t7, t8
+    bne zero, t7, wait_loop0
+    nop
+    set_reg(HORNET_BOOTSTRAP_STATUS, 0x0002110e)
+    nop
+#endif    
+    
+/* RTC reset */
+    set_reg(0x1810704c, 0x00000003)
+    nop
+    nop
+    set_reg(0x18107040, 0x00000000)
+    nop
+    nop
+    set_reg(0x18107040, 0x00000001)
+    nop
+wait_loop1:
+    li  t6, KSEG1ADDR(0x18107044)
+    lw  t7, 0(t6)
+    li  t8, 0x2
+    and t7, t7, t8
+    bne t8, t7, wait_loop1
+    nop
+
+    /* AHB/APH reset */    
+    set_reg(0x18104000, 0x00000003)
+    nop
+    set_reg(0x18104000, 0x00000000)
+    nop
+
+    /* MAC reset */
+    set_reg(0x18107000, 0x0000000F)
+    nop
+    set_reg(0x18107000, 0x00000000)
+    nop
+
+#if 1  /* fetch pmu1.refv and ctrl2.tx from OTP */
+    li  t1, KSEG1ADDR(0x18114014)
+    lw  t2, 0(t1)
+otp_loop0:
+    li  t3, KSEG1ADDR(0x18115f18)
+    lw  t4, 0(t3)
+    nop
+    li  t5, 0x7
+    and t4, t4, t5
+    li  t5, 0x4
+    bne t4, t5, otp_loop0
+    nop
+
+    li  t6, KSEG1ADDR(0x18115f1c)
+    lw  t7, 0(t6)
+    nop
+    li  t8, 0x80000080
+    and t9, t7, t8
+    beq t8, t9, fetch_otp
+otp_loop0_end:
+
+    li  t1, KSEG1ADDR(0x18114004)
+    lw  t2, 0(t1)
+otp_loop1:
+    li  t3, KSEG1ADDR(0x18115f18)
+    lw  t4, 0(t3)
+    nop
+    li  t5, 0x7
+    and t4, t4, t5
+    li  t5, 0x4
+    bne t4, t5, otp_loop1
+    nop
+
+    li  t6, KSEG1ADDR(0x18115f1c)
+    lw  t7, 0(t6)
+    nop
+    li  t8, 0x80000080
+    and t9, t7, t8
+default_pmu:
+    li  t5, 0x80             /* default 0x031c4386 */
+    bne t8, t9, otp_end
+otp_loop1_end:
+
+fetch_otp:
+    srl t8, t7, 0x18
+    li  t1, 0xf
+    and t2, t1 , t7         /* USB */
+    and t5, t1 , t8         /* PMU */
+
+check_pmu:
+    li t0, 0x4                         /* PMU range should be 0x4~0xa */
+    bgt t0, t5, default_pmu
+    nop
+    li t0, 0xa                         /* PMU range should be 0x4~0xa */
+    blt t0, t5, default_pmu
+    nop
+    li  t0, 0x4
+    sll t5, t5, t0
+
+otp_end:
+#endif
+
+#if 1 /* Program PMU */
+#define PMU_TEST_NO 1000
+    li  t6, KSEG1ADDR(0x18116c40)
+    li  t9, 0xbd000010
+    li  t0, 0
+    li  t1, 0
+    li  t2, 0
+    
+    li  t3, PMU_TEST_NO
+    sw  t3, 12(t9) 
+pmu_loop0:
+    beq zero, t3, pmu_loop0_end
+    nop    
+    addi t3, t3, -1
+            
+    #li  t7, 0x10000000 /* ldo_tune 0x0 */
+    #li  t7, 0x10080000 /* ldo_tune 0x1 */
+    #li  t7, 0x10100000 /* ldo_tune 0x2 */
+    li  t7, 0x10180000  /* ldo_tune 0x3 */   
+    nop
+    sw  t7, 4(t6)
+    nop   
+    lw  t8, 4(t6)
+    nop
+    beq t8, t7, pmu_loop0_end
+    nop
+   
+    addiu  t0, t0, 1
+    b   pmu_loop0
+    nop
+pmu_loop0_end:      
+
+    li  t3, PMU_TEST_NO    
+pmu_loop1:
+    beq zero, t3, pmu_loop1_end
+    nop    
+    addi t3, t3, -1
+
+    //li  t7, 0x031c4326    /* 1.100V */
+    //li  t7, 0x031c4336    /* 1.125V */
+    //li  t7, 0x031c4346    /* 1.150V */
+    //li  t7, 0x031c4356    /* 1.175V */     
+    //li  t7, 0x031c4366    /* 1.200V */
+    //li  t7, 0x031c4376    /* 1.225V */
+    li  t7, 0x031c4386    /* 1.250V */
+    //li  t7, 0x031c4396    /* 1.275V */
+    //li  t7, 0x031c43a6    /* 1.300V */    
+    nop
+#if 1 /* from OTP */
+    li  t8, 0xffffff0f
+    and t7, t7, t8
+    or  t7, t7, t5
+#endif
+    sw  t7, 0(t6)
+    nop   
+    lw  t8, 0(t6)
+    nop
+    beq t8, t7, pmu_loop1_end
+    nop  
+    
+    addiu  t1, t1, 1
+    b   pmu_loop1    
+    nop       
+pmu_loop1_end:    
+
+    li  t3, PMU_TEST_NO
+pmu_loop2: 
+    beq zero, t3, pmu_loop2_end
+    nop    
+    addi t3, t3, -1
+    
+    #li  t7, 0x10200000 /* ldo_tune 0x0 */
+    #li  t7, 0x10280000 /* ldo_tune 0x1 */
+    #li  t7, 0x10300000 /* ldo_tune 0x2 */
+    li  t7, 0x10380000  /* ldo_tune 0x3 */
+    nop
+    sw  t7, 4(t6)
+    nop   
+    lw  t8, 4(t6)
+    nop
+    beq t8, t7, pmu_loop2_end
+    nop   
+    
+    addiu  t2, t2, 1
+    b   pmu_loop2  
+    nop       
+pmu_loop2_end:    
+
+    sw  t0, 0(t9) 
+    nop  
+    sw  t1, 4(t9) 
+    nop  
+    sw  t2, 8(t9) 
+    nop
+#endif
+
+#if 1 /* Program ki, kd */
+    /* Program ki/kd */
+#if CONFIG_40MHZ_XTAL_SUPPORT
+    set_reg(0x18116244, 0x19e82f01)
+#else
+    set_reg(0x18116244, 0x18e82f01)
+#endif
+    nop
+    
+    /* Program phase shift */
+    li  t6, KSEG1ADDR(0x18116248)
+    lw  t7, 0(t6)
+    li  t8, 0xc07fffff
+    and t7, t7, t8
+    li  t8, 0x800000
+    or  t7, t7, t8
+    sw  t7, 0(t6)    
+    nop
+#endif
+
+/* set PLL bypass(Bit 2), CPU_POST_DIV, DDR_POST_DIV, AHB_POST_DIV in CPU clock control */
+    set_reg(AR7240_CPU_CLOCK_CONTROL, 0x00018004)
+    nop
+
+/* set SETTLE_TIME in CPU PLL */
+    set_reg(AR7240_USB_PLL_CONFIG, CPU_PLL_SETTLE_TIME_VAL)
+    nop
+
+pll_unlock_handler:
+
+/* set nint, frac, refdiv, outdiv, range in CPU PLL configuration resiter */
+    set_reg(AR7240_CPU_PLL_CONFIG, CPU_PLL_CONFIG_VAL1)
+    nop
+
+wait_loop2:
+    li  t6, KSEG1ADDR(AR7240_CPU_PLL_CONFIG)
+    lw  t7, 0(t6)
+    li  t8, 0x80000000
+    and t7, t7, t8
+    bne zero, t7, wait_loop2
+    nop
+    
+/* put frac bit19:10 configuration */
+    set_reg(AR7240_PCIE_PLL_CONFIG, CPU_PLL_DITHER_FRAC_VAL)
+    nop
+
+/* clear PLL power down bit in CPU PLLl configuration */
+    set_reg(AR7240_CPU_PLL_CONFIG, CPU_PLL_CONFIG_VAL2)
+    nop
+wait_loop3:
+    li  t6, KSEG1ADDR(AR7240_CPU_PLL_CONFIG)
+    lw  t7, 0(t6)
+    li  t8, 0x80000000
+    and t7, t7, t8
+    bne zero, t7, wait_loop3
+    nop
+
+/* confirm DDR PLL lock */
+    li  t3, 100
+    li  t4, 0
+start_meas0:
+    addi t4, t4, 1
+    bgt t4, t3, pll_unlock_handler
+    nop
+    li  t5, 5
+start_meas:
+    li  t6, KSEG1ADDR(0x18116248)
+    lw  t7, 0(t6) 
+    li  t8, 0xbfffffff  
+    and t7, t7, t8
+    sw  t7, 0(t6)
+    nop
+
+/* delay */
+    li t9, 10
+delayloop0:
+    subu t9, t9, 1
+    bne t9, zero, delayloop0
+    nop
+
+    li  t8, 0x40000000  
+    or  t7, t7, t8
+    sw  t7, 0(t6)
+    nop    
+
+meas_done_statue:
+    li  t6, KSEG1ADDR(0x1811624c)
+    lw  t7, 0(t6)
+    li  t8, 0x8  
+    and t7, t7, t8
+    beq zero, t7, meas_done_statue
+    nop
+   
+meas_result:
+    li  t6, KSEG1ADDR(0x18116248)
+    lw  t7, 0(t6)
+    li  t8, 0x007ffff8
+    and t7, t7, t8
+    srl t7, t7, 3
+    li  t8, 0x4000
+    bgt t7, t8, start_meas0
+    nop
+    addi t5, t5, -1
+    bne zero, t5, start_meas
+    nop
+
+/* clear PLL bypass(Bit 2), CPU_POST_DIV, DDR_POST_DIV, AHB_POST_DIV in CPU clock control */
+    set_reg(AR7240_CPU_CLOCK_CONTROL, CPU_CLK_CONTROL_VAL2)
+    nop
+
+/* Sync mode , Set Bit 8 of DDR Tap Conrtol 3 register */
+    set_reg(AR7240_DDR_TAP_CONTROL3, 0x10105);
+    nop
+
+    jr ra
+    nop
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap121/Makefile u-boot_1.1//board/ar7240/ap121/Makefile
--- u-boot//board/ar7240/ap121/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap121/Makefile	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,22 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+ifeq ($(BOARD), ap121)
+SOBJS	+= hornet_pll_init.o
+endif
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap121/u-boot-bootstrap.lds u-boot_1.1//board/ar7240/ap121/u-boot-bootstrap.lds
--- u-boot//board/ar7240/ap121/u-boot-bootstrap.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap121/u-boot-bootstrap.lds	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap121/u-boot.lds u-boot_1.1//board/ar7240/ap121/u-boot.lds
--- u-boot//board/ar7240/ap121/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap121/u-boot.lds	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap123/ap123.c u-boot_1.1//board/ar7240/ap123/ap123.c
--- u-boot//board/ar7240/ap123/ap123.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap123/ap123.c	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,193 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+
+int
+wasp_mem_config(void)
+{
+#ifdef CONFIG_AP123
+	extern void ath_ddr_tap_cal(void);
+#endif
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+#ifdef CONFIG_AP123
+	ath_ddr_tap_cal();
+
+#ifndef COMPRESSED_UBOOT
+	printf("Tap value selected = 0x%x [0x%x - 0x%x]\n",
+		ar7240_reg_rd(AR7240_DDR_TAP_CONTROL0),
+		ar7240_reg_rd(0xbd007f10), ar7240_reg_rd(0xbd007f14));
+#endif
+#endif
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap123/config.mk u-boot_1.1//board/ar7240/ap123/config.mk
--- u-boot//board/ar7240/ap123/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap123/config.mk	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,41 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap123/flash.c u-boot_1.1//board/ar7240/ap123/flash.c
--- u-boot//board/ar7240/ap123/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap123/flash.c	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap123/Makefile u-boot_1.1//board/ar7240/ap123/Makefile
--- u-boot//board/ar7240/ap123/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap123/Makefile	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,90 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap123/u-boot-bootstrap.lds u-boot_1.1//board/ar7240/ap123/u-boot-bootstrap.lds
--- u-boot//board/ar7240/ap123/u-boot-bootstrap.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap123/u-boot-bootstrap.lds	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,60 @@
+/* 
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/ap123/u-boot.lds u-boot_1.1//board/ar7240/ap123/u-boot.lds
--- u-boot//board/ar7240/ap123/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/ap123/u-boot.lds	2014-02-18 01:46:24.771050902 -0800
@@ -0,0 +1,64 @@
+/* 
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/aph126/aph126.c u-boot_1.1//board/ar7240/aph126/aph126.c
--- u-boot//board/ar7240/aph126/aph126.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/aph126/aph126.c	2014-02-18 01:46:24.791050901 -0800
@@ -0,0 +1,185 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/*  Enable xLNBIAS signal on GPIO (19, 20) */
+	ar7240_reg_wr (AR7240_GPIO_FUNC4, ((ar7240_reg_rd(AR7240_GPIO_FUNC4) & 0x00ffffff)) | 0x2f000000);
+	ar7240_reg_wr (AR7240_GPIO_FUNC5, ((ar7240_reg_rd(AR7240_GPIO_FUNC5) & 0xffffff00)) | 0x2e);
+	ar7240_reg_wr (AR7240_GPIO_OE, (ar7240_reg_rd(AR7240_GPIO_OE) & 0xffe7ffff));
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */ 
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/aph126/config.mk u-boot_1.1//board/ar7240/aph126/config.mk
--- u-boot//board/ar7240/aph126/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/aph126/config.mk	2014-02-18 01:46:24.791050901 -0800
@@ -0,0 +1,41 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/aph126/flash.c u-boot_1.1//board/ar7240/aph126/flash.c
--- u-boot//board/ar7240/aph126/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/aph126/flash.c	2014-02-18 01:46:24.791050901 -0800
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/aph126/Makefile u-boot_1.1//board/ar7240/aph126/Makefile
--- u-boot//board/ar7240/aph126/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/aph126/Makefile	2014-02-18 01:46:24.791050901 -0800
@@ -0,0 +1,84 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o 
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif 
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/aph126/u-boot-bootstrap.lds u-boot_1.1//board/ar7240/aph126/u-boot-bootstrap.lds
--- u-boot//board/ar7240/aph126/u-boot-bootstrap.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/aph126/u-boot-bootstrap.lds	2014-02-18 01:46:24.791050900 -0800
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/aph126/u-boot.lds u-boot_1.1//board/ar7240/aph126/u-boot.lds
--- u-boot//board/ar7240/aph126/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/aph126/u-boot.lds	2014-02-18 01:46:24.791050900 -0800
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/aph128/aph128.c u-boot_1.1//board/ar7240/aph128/aph128.c
--- u-boot//board/ar7240/aph128/aph128.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/aph128/aph128.c	2014-02-18 01:46:24.791050900 -0800
@@ -0,0 +1,197 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/*  Enable xLNBIAS signal on GPIO (19, 20) */
+	ar7240_reg_wr (AR7240_GPIO_FUNC4, ((ar7240_reg_rd(AR7240_GPIO_FUNC4) & 0x00ffffff)) | 0x2f000000);
+	ar7240_reg_wr (AR7240_GPIO_FUNC5, ((ar7240_reg_rd(AR7240_GPIO_FUNC5) & 0xffffff00)) | 0x2e);
+	ar7240_reg_wr (AR7240_GPIO_OE, (ar7240_reg_rd(AR7240_GPIO_OE) & 0xffe7ffff));
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_BR)
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ar7240_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */ 
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/aph128/config.mk u-boot_1.1//board/ar7240/aph128/config.mk
--- u-boot//board/ar7240/aph128/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/aph128/config.mk	2014-02-18 01:46:24.795050910 -0800
@@ -0,0 +1,41 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/aph128/flash.c u-boot_1.1//board/ar7240/aph128/flash.c
--- u-boot//board/ar7240/aph128/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/aph128/flash.c	2014-02-18 01:46:24.795050910 -0800
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/aph128/Makefile u-boot_1.1//board/ar7240/aph128/Makefile
--- u-boot//board/ar7240/aph128/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/aph128/Makefile	2014-02-18 01:46:24.791050900 -0800
@@ -0,0 +1,84 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o 
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif 
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/aph128/u-boot-bootstrap.lds u-boot_1.1//board/ar7240/aph128/u-boot-bootstrap.lds
--- u-boot//board/ar7240/aph128/u-boot-bootstrap.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/aph128/u-boot-bootstrap.lds	2014-02-18 01:46:24.795050910 -0800
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/aph128/u-boot.lds u-boot_1.1//board/ar7240/aph128/u-boot.lds
--- u-boot//board/ar7240/aph128/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/aph128/u-boot.lds	2014-02-18 01:46:24.795050910 -0800
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/ar7240_flash.c u-boot_1.1//board/ar7240/common/ar7240_flash.c
--- u-boot//board/ar7240/common/ar7240_flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/ar7240_flash.c	2014-02-18 01:46:24.795050910 -0800
@@ -0,0 +1,271 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <jffs2/jffs2.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7240_soc.h"
+#include "ar7240_flash.h"
+
+/*
+ * globals
+ */
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+#undef display
+#define display(x)  ;
+
+/*
+ * statics
+ */
+static void ar7240_spi_write_enable(void);
+static void ar7240_spi_poll(void);
+#if !defined(ATH_SST_FLASH)
+static void ar7240_spi_write_page(uint32_t addr, uint8_t * data, int len);
+#endif
+static void ar7240_spi_sector_erase(uint32_t addr);
+
+static void
+ath_spi_read_id(void)
+{
+	u32 rd = 0x777777;
+
+	ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CS_DIS);
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_RDID);
+	ar7240_spi_delay_8();
+	ar7240_spi_delay_8();
+	ar7240_spi_delay_8();
+	ar7240_spi_go();
+
+	rd = ar7240_reg_rd(AR7240_SPI_RD_STATUS);
+
+	printf("Flash Manuf Id 0x%x, DeviceId0 0x%x, DeviceId1 0x%x\n",
+		(rd >> 16) & 0xff, (rd >> 8) & 0xff, (rd >> 0) & 0xff);
+}
+
+
+#ifdef ATH_SST_FLASH
+void ar7240_spi_flash_unblock(void)
+{
+	ar7240_spi_write_enable();
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_WRITE_SR);
+	ar7240_spi_bit_banger(0x0);
+	ar7240_spi_go();
+	ar7240_spi_poll();
+}
+#endif
+
+unsigned long flash_init(void)
+{
+#ifndef CONFIG_WASP
+#ifdef ATH_SST_FLASH
+	ar7240_reg_wr_nf(AR7240_SPI_CLOCK, 0x3);
+	ar7240_spi_flash_unblock();
+	ar7240_reg_wr(AR7240_SPI_FS, 0);
+#else
+	ar7240_reg_wr_nf(AR7240_SPI_CLOCK, 0x43);
+#endif
+#endif
+	ar7240_reg_rmw_set(AR7240_SPI_FS, 1);
+	ath_spi_read_id();
+	ar7240_reg_rmw_clear(AR7240_SPI_FS, 1);
+
+	/*
+	 * hook into board specific code to fill flash_info
+	 */
+	return (flash_get_geom(&flash_info[0]));
+}
+
+void
+flash_print_info(flash_info_t *info)
+{
+	printf("The hell do you want flinfo for??\n");
+}
+
+int
+flash_erase(flash_info_t *info, int s_first, int s_last)
+{
+	int i, sector_size = info->size / info->sector_count;
+
+#ifdef FLASH_DEBUG
+	printf("\nFirst %#x last %#x sector size %#x\n",
+	       s_first, s_last, sector_size);
+#endif
+
+	for (i = s_first; i <= s_last; i++) {
+#ifdef FLASH_DEBUG
+		printf("\b\b\b\b%4d", i);
+#else
+		puts(".");
+#endif
+		ar7240_spi_sector_erase(i * sector_size);
+	}
+	ar7240_spi_done();
+	printf("\n");
+
+	return 0;
+}
+
+/*
+ * Write a buffer from memory to flash:
+ * 0. Assumption: Caller has already erased the appropriate sectors.
+ * 1. call page programming for every 256 bytes
+ */
+#ifdef ATH_SST_FLASH
+void
+ar7240_spi_flash_chip_erase(void)
+{
+	ar7240_spi_write_enable();
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_CHIP_ERASE);
+	ar7240_spi_go();
+	ar7240_spi_poll();
+}
+
+int
+write_buff(flash_info_t *info, uchar *src, ulong dst, ulong len)
+{
+	uint32_t val;
+
+	dst = dst - CFG_FLASH_BASE;
+	printf("write len: %lu dst: 0x%x src: %p\n", len, dst, src);
+
+	for (; len; len--, dst++, src++) {
+		ar7240_spi_write_enable();	// dont move this above 'for'
+		ar7240_spi_bit_banger(AR7240_SPI_CMD_PAGE_PROG);
+		ar7240_spi_send_addr(dst);
+
+		val = *src & 0xff;
+		ar7240_spi_bit_banger(val);
+
+		ar7240_spi_go();
+		ar7240_spi_poll();
+	}
+	/*
+	 * Disable the Function Select
+	 * Without this we can't read from the chip again
+	 */
+	ar7240_reg_wr(AR7240_SPI_FS, 0);
+
+	if (len) {
+		// how to differentiate errors ??
+		return ERR_PROG_ERROR;
+	} else {
+		return ERR_OK;
+	}
+}
+#else
+int
+write_buff(flash_info_t *info, uchar *source, ulong addr, ulong len)
+{
+	int total = 0, len_this_lp, bytes_this_page, counter = 0;
+	ulong dst;
+	uchar *src;
+
+#ifdef FLASH_DEBUG
+	printf("write addr: %x\n", addr);
+#endif
+	addr = addr - CFG_FLASH_BASE;
+
+	while (total < len) {
+		src = source + total;
+		dst = addr + total;
+		bytes_this_page =
+		    AR7240_SPI_PAGE_SIZE - (addr & AR7240_SPI_PAGE_SIZE-1);
+		len_this_lp =
+		    ((len - total) >
+		     bytes_this_page) ? bytes_this_page : (len - total);
+		ar7240_spi_write_page(dst, src, len_this_lp);
+		total += len_this_lp;
+		if(counter>=255)
+		{
+			puts(".");
+			counter = 0;
+		}
+		else
+		{
+			counter++;
+		}
+	}
+
+	ar7240_spi_done();
+
+	return 0;
+}
+#endif
+
+static void
+ar7240_spi_write_enable()
+{
+	ar7240_reg_wr_nf(AR7240_SPI_FS, 1);
+	ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CS_DIS);
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_WREN);
+	ar7240_spi_go();
+}
+
+static void
+ar7240_spi_poll()
+{
+	int rd;
+
+	do {
+		ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CS_DIS);
+		ar7240_spi_bit_banger(AR7240_SPI_CMD_RD_STATUS);
+		ar7240_spi_delay_8();
+		rd = (ar7240_reg_rd(AR7240_SPI_RD_STATUS) & 1);
+	} while (rd);
+}
+
+#if !defined(ATH_SST_FLASH)
+static void
+ar7240_spi_write_page(uint32_t addr, uint8_t *data, int len)
+{
+	int i;
+	uint8_t ch;
+
+	display(0x77);
+	ar7240_spi_write_enable();
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_PAGE_PROG);
+	ar7240_spi_send_addr(addr);
+
+	for (i = 0; i < len; i++) {
+		ch = *(data + i);
+		ar7240_spi_bit_banger(ch);
+	}
+
+	ar7240_spi_go();
+	display(0x66);
+	ar7240_spi_poll();
+	display(0x6d);
+}
+#endif
+
+static void
+ar7240_spi_sector_erase(uint32_t addr)
+{
+	ar7240_spi_write_enable();
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_SECTOR_ERASE);
+	ar7240_spi_send_addr(addr);
+	ar7240_spi_go();
+	display(0x7d);
+	ar7240_spi_poll();
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/ar7240_flash.h u-boot_1.1//board/ar7240/common/ar7240_flash.h
--- u-boot//board/ar7240/common/ar7240_flash.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/ar7240_flash.h	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _FLASH_H
+#define _FLASH_H
+
+#include "ar7240_soc.h"
+
+#define AR7240_SPI_FS           0x1f000000
+#define AR7240_SPI_CLOCK        0x1f000004
+#define AR7240_SPI_WRITE        0x1f000008
+#define AR7240_SPI_READ         0x1f000000
+#define AR7240_SPI_RD_STATUS    0x1f00000c
+
+#define AR7240_SPI_CS_DIS       0x70000
+#define AR7240_SPI_CE_LOW       0x60000
+#define AR7240_SPI_CE_HIGH      0x60100
+
+#define AR7240_SPI_CMD_WRITE_SR     0x01
+#define AR7240_SPI_CMD_WREN         0x06
+#define AR7240_SPI_CMD_RD_STATUS    0x05
+#define AR7240_SPI_CMD_FAST_READ    0x0b
+#define AR7240_SPI_CMD_PAGE_PROG    0x02
+#define AR7240_SPI_CMD_SECTOR_ERASE 0xd8
+#define AR7240_SPI_CMD_CHIP_ERASE   0xc7
+#define AR7240_SPI_CMD_RDID         0x9f
+
+#define AR7240_SPI_SECTOR_SIZE      (1024*64)
+#define AR7240_SPI_PAGE_SIZE        256
+
+
+#define display(_x)     ar7240_reg_wr_nf(0x18040008, (_x))
+
+/*
+ * primitives
+ */
+
+#define ar7240_be_msb(_val, _i) (((_val) & (1 << (7 - _i))) >> (7 - _i))
+
+#define ar7240_spi_bit_banger(_byte)  do {        \
+    int i;                                      \
+    for(i = 0; i < 8; i++) {                    \
+        ar7240_reg_wr_nf(AR7240_SPI_WRITE,      \
+                        AR7240_SPI_CE_LOW | ar7240_be_msb(_byte, i));  \
+        ar7240_reg_wr_nf(AR7240_SPI_WRITE,      \
+                        AR7240_SPI_CE_HIGH | ar7240_be_msb(_byte, i)); \
+    }       \
+}while(0);
+
+#define ar7240_spi_go() do {        \
+    ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CE_LOW); \
+    ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CS_DIS); \
+}while(0);
+
+
+#define ar7240_spi_send_addr(__a) do {			\
+    ar7240_spi_bit_banger(((__a & 0xff0000) >> 16));	\
+    ar7240_spi_bit_banger(((__a & 0x00ff00) >> 8));	\
+    ar7240_spi_bit_banger(__a & 0x0000ff);		\
+} while (0)
+
+#define ar7240_spi_delay_8()    ar7240_spi_bit_banger(0)
+#define ar7240_spi_done()       ar7240_reg_wr_nf(AR7240_SPI_FS, 0)
+
+extern unsigned long flash_get_geom (flash_info_t *flash_info);
+
+#endif /*_FLASH_H*/
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/ar7240_pci.c u-boot_1.1//board/ar7240/common/ar7240_pci.c
--- u-boot//board/ar7240/common/ar7240_pci.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/ar7240_pci.c	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,574 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <pci.h>
+#include "ar7240_soc.h"
+
+/*
+** PCI controller "hose" value
+*/
+
+static struct pci_controller hose;
+
+static int  ar7240_local_read_config(int where, int size, uint32_t *value);
+static int  ar7240_local_write_config(int where, int size, uint32_t value);
+
+static int
+ar7240_local_read_config(int where, int size, uint32_t *value)
+{
+    *value = ar7240_reg_rd(AR7240_PCI_CRP + where);
+    return 0;
+}
+
+static int
+ar7240_local_write_config(int where, int size, uint32_t value)
+{
+    ar7240_reg_wr((AR7240_PCI_CRP + where),value);
+    return 0;
+}
+
+static int
+ar7240_pci_read_config(struct pci_controller *hose,
+                           pci_dev_t dev, int where, uint32_t *value)
+{
+        *value = ar7240_reg_rd(AR7240_PCI_DEV_CFGBASE + where);
+        return 0;
+}
+
+static int
+ar7240_pci_write_config(struct pci_controller *hose,
+                           pci_dev_t dev, int where,  uint32_t value)
+{
+        ar7240_reg_wr((AR7240_PCI_DEV_CFGBASE + where),value);
+        return 0;
+}
+
+/*
+** We will use the ART configuration information stored in flash to initialize
+** these devices as required.
+*/
+
+void plat_dev_init(void)
+{
+    u32     val;
+    u32     addr;
+    u32     BaseAddr = 0x10000000;
+    u32     CalAddr = WLANCAL;
+    volatile u16     *calData;
+
+    /*
+     * Copy the device ID from Flash to device config space.
+     */
+
+    calData = (u16 *)CalAddr;
+
+#ifndef CONFIG_PCI_CONFIG_DATA_IN_OTP
+    if(calData[0] != 0xa55a && calData[0] != 0x5aa5  )
+    {
+        /*
+        ** Board is not calibrated.
+        */
+#ifndef COMPRESSED_UBOOT
+        printf("BOARD IS NOT CALIBRATED!!!\n");
+#endif
+        return;
+    }
+#else
+    return;
+#endif
+    /*
+    ** Need to setup the PCI device to access the internal registers
+    */
+    if ((is_ar7241() || is_ar7242()))
+        ar7240_pci_write_config(&hose, NULL, 0x10, 0x1000ffff);
+    else
+        ar7240_pci_write_config(&hose, NULL, 0x10, 0xffff);
+
+    ar7240_pci_write_config(&hose, NULL, 0x04, 0x6);
+
+    /*
+    ** Set pointer to first reg address
+    */
+
+    calData += AR7240_ART_PCICFG_OFFSET;
+
+    while(*calData != 0xffff)
+    {
+        u16 cd;
+
+        cd = *calData++;
+        addr = BaseAddr + cd;
+        val  = *calData++;
+        val |= (*calData++) << 16;
+
+        ar7240_reg_wr_nf(addr,val);
+        udelay(100);
+    }
+
+    return;
+}
+
+
+/******************************************************************************/
+/*!
+**  \brief pci host initialization
+**
+**  Sets up the PCI controller on the host.  For AR7240 this may not be necessary,
+**  but this function is required for board support.
+**
+** We want a 1:1 mapping between PCI and DDR for inbound and outbound.
+** The PCI<---AHB decoding works as follows:
+**
+** 8 registers in the DDR unit provide software configurable 32 bit offsets
+** for each of the eight 16MB PCI windows in the 128MB. The offsets will be
+** added to any address in the 16MB segment before being sent to the PCI unit.
+**
+** Essentially  for any AHB address generated by the CPU,
+** 1. the MSB  four bits are stripped off, [31:28],
+** 2. Bit 27 is used to decide between the lower 128Mb (PCI) or the rest of
+**    the AHB space
+** 3. Bits 26:24 are used to access one of the 8 window registers and are
+**    masked off.
+** 4. If it is a PCI address, then the WINDOW offset in the WINDOW register
+**    corresponding to the next 3 bits (bit 26:24) is ADDED to the address,
+**    to generate the address to PCI unit.
+**
+**     eg. CPU address = 0x100000ff
+**         window 0 offset = 0x10000000
+**         This points to lowermost 16MB window in PCI space.
+**         So the resulting address would be 0x000000ff+0x10000000
+**         = 0x100000ff
+**
+**         eg2. CPU address = 0x120000ff
+**         WINDOW 2 offset = 0x12000000
+**         resulting address would be 0x000000ff+0x12000000
+**                         = 0x120000ff
+**
+** There is no translation for inbound access (PCI device as a master)
+**
+**  \return N/A
+*/
+
+#ifdef CONFIG_WASP_SUPPORT
+static int ar7240_pcibios_init(void)
+{
+        if (is_ar9341()) {
+                return 0;
+        }
+
+	if (((ar7240_reg_rd(AR7240_PCI_LCL_RESET)) & 0x1) == 0x0) {
+		printf("***** Warning *****: PCIe WLAN H/W not found !!!\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+#define pci_udelay(n)	do { uint32_t i; /* printf("--- %s[%d] udelay(%u)\n", __func__, __LINE__, n); */ for (i = 0; i < ((n)/10); i++) udelay(10); } while (0)
+
+char *
+__print_llx(unsigned long long u, char *num)
+{
+	char dec[] = "0123456789";
+	int i;
+
+	if (u == 0)	return "0";
+
+	memset(num, 0, 32);
+
+	for (i = 24; u; i--) {
+		num[i] = dec[u % 10];
+		u = u / 10;
+	}
+
+	return &num[i+1];
+}
+
+#define print_llx(n)	__print_llx(n, str_##n)
+
+#ifdef COMPRESSED_UBOOT
+int pci_init_board (void)
+#else
+void pci_init_board (void)
+#endif /* #ifdef COMPRESSED_UBOOT */
+{
+#ifdef CONFIG_AP123
+	return;
+#else
+	uint32_t cmd = 0, reg_val;
+
+
+	//printf("%s: PCIe PLL 0x%x\n", __func__, mips3_cp0_count_read());
+	//printf("%s: PCIe PLL 0x%x  0xb8000008 =  0x%08x\n", __func__, mips3_cp0_count_read(), ar7240_reg_rd(0xb8040008));
+
+	pci_udelay(100000);
+	//count ++;
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_DITHER_DIV_MAX,
+			PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_SET(0) |
+			PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(1) |
+			PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(0x20) |
+			PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(0));
+	} else {
+#ifndef COMPRESSED_UBOOT
+		printf("%s: PCIe PLL not set for 40MHz refclk\n", __func__);
+#endif
+	}
+
+	ar7240_reg_rmw_set(AR7240_RESET, AR7240_RESET_PCIE);	// core in reset
+	pci_udelay(10000);
+	ar7240_reg_rmw_set(AR7240_RESET, AR7240_RESET_PCIE_PHY);// phy in reset
+	pci_udelay(10000);
+	ar7240_reg_rmw_clear(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1)); // pci phy analog in reset
+	pci_udelay(10000);
+	ar7240_reg_wr(0x180f0000, 0x1ffc0);			// ltssm is disabled
+	pci_udelay(100);
+	ar7240_reg_wr_nf(AR7240_PCI_LCL_RESET, 0);	// End point in reset
+	pci_udelay(100000);
+
+
+	//ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE_PHY);
+
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG,
+			PCIE_PLL_CONFIG_REFDIV_SET(1) |
+			PCIE_PLL_CONFIG_BYPASS_SET(1) |
+			PCIE_PLL_CONFIG_PLLPWD_SET(1));
+		pci_udelay(10000);
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG,
+			PCIE_PLL_CONFIG_REFDIV_SET(1) |
+			PCIE_PLL_CONFIG_BYPASS_SET(1) |
+			PCIE_PLL_CONFIG_PLLPWD_SET(0));
+		pci_udelay(1000);
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG,
+			ar7240_reg_rd(AR934X_PCIE_PLL_CONFIG) &
+			(~PCIE_PLL_CONFIG_BYPASS_SET(1)));
+		pci_udelay(1000);
+	} else {
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG,
+			PCIE_PLL_CONFIG_REFDIV_SET(2) |
+			PCIE_PLL_CONFIG_BYPASS_SET(1) |
+			PCIE_PLL_CONFIG_PLLPWD_SET(1));
+		pci_udelay(10000);
+
+		if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+			ar7240_reg_wr_nf(0xb8116c00, (0x5 << 27) | (160 << 18) | 0);
+		} else {
+			ar7240_reg_wr_nf(0xb8116c00, (0x2 << 27) | (0x28 << 18) | 0);
+		}
+		do {
+			ar7240_reg_wr_nf(0xb8116c04, (0x1 << 30) | (0x4 << 26) | (0x32 << 19) | (1 << 16) | (3 << 13) | (0x1e << 7));
+			ar7240_reg_wr_nf(0xb8116c08, (6 << 23));
+			pci_udelay(10000);
+			ar7240_reg_wr_nf(0xb8116c04, (0x1 << 30) | (0x4 << 26) | (0x32 << 19) | (3 << 13) | (0x1e << 7));
+
+			ar7240_reg_rmw_clear(KSEG1ADDR(PCIe_DPLL3_ADDRESS), PCIe_DPLL3_DO_MEAS_SET(1));
+			ar7240_reg_rmw_set(KSEG1ADDR(PCIe_DPLL3_ADDRESS), PCIe_DPLL3_DO_MEAS_SET(1));
+
+			ar7240_reg_wr(0xb804000c, 1 << 2);
+
+			pci_udelay(1000);
+
+			while (((cmd = ar7240_reg_rd(PCIe_DPLL4_ADDRESS)) & PCIe_DPLL4_MEAS_DONE_SET(1)) == 0) {
+				printf("0x%x 0x%x 0x%x\n", KSEG1ADDR(PCIe_DPLL4_ADDRESS), cmd);
+				pci_udelay(10);
+			}
+
+			{ int i; for (i = 0; i < 100; i++) udelay(10); }
+#if 0
+			msdvc = PCIe_DPLL4_MEAN_DVC_GET(cmd);
+			cmd = PCIe_DPLL3_SQSUM_DVC_GET(ar7240_reg_rd(PCIe_DPLL3_ADDRESS));
+
+			if (msdvc & 0x400) msdvc = ((~msdvc & 0x7FF) + 1); /* 11 bit signed number , but not intentioanlly multiply by (-1), ASK VIPUL*/
+			msdvc =  cmd - (msdvc *msdvc);
+			msdvc_sq = msdvc * msdvc;
+
+			if (cmd >= 0x40000) {
+				err_count++;
+				if (sqsum_min_fail == 0)
+					sqsum_min_fail = cmd;
+				if (cmd > sqsum_max_fail)
+					sqsum_max_fail = cmd;
+				if (cmd < sqsum_min_fail)
+					sqsum_min_fail = cmd;
+				sqsum_avg_fail = (sqsum_avg_fail - (sqsum_avg_fail / err_count)) + (cmd / err_count);
+
+				if (num_pll_loops == 0)
+					err_pll1++;
+				if (num_pll_loops == 1)
+					err_pll2++;
+				if (num_pll_loops == 2)
+					err_pll3++;
+				if (num_pll_loops == 3)
+					err_pll4++;
+				if (num_pll_loops == 4) {
+					err_pll5++;
+					break;
+				}
+			} else {
+				if (sqsum_min == 0)
+					sqsum_min = cmd;
+				if (cmd < sqsum_min)
+					sqsum_min = cmd;
+				if (cmd > sqsum_max)
+					sqsum_max = cmd;
+				//sqsum_avg = (sqsum_avg - (sqsum_avg / count)) + (cmd / count);
+				sqsum_avg += cmd;
+
+				/*msdvc calc*/
+				if (msdvc_min == 0) msdvc_min = msdvc;
+				if (msdvc < msdvc_min) msdvc_min =msdvc;
+				if (msdvc > msdvc_max) msdvc_max =msdvc;
+				msdvc_avg += msdvc;
+				msdvc_sq_avg += msdvc_sq;
+
+			}
+			num_pll_loops++;
+#endif
+
+		} while ((cmd = PCIe_DPLL3_SQSUM_DVC_GET(ar7240_reg_rd(PCIe_DPLL3_ADDRESS))) >= 0x40000);
+
+		ar7240_reg_rmw_clear(AR934X_PCIE_PLL_CONFIG, PCIE_PLL_CONFIG_PLLPWD_SET(1));
+		pci_udelay(10000);
+		ar7240_reg_rmw_clear(AR934X_PCIE_PLL_CONFIG, PCIE_PLL_CONFIG_BYPASS_SET(1));
+		pci_udelay(10000);
+
+		/*
+		 * PCIe Dithering configuration
+		 */
+		if (is_ar934x_12_or_later()) {
+			ar7240_reg_wr_nf(PCIe_DPLL2_ADDRESS,
+					PCIe_DPLL2_LOCAL_PLL_SET(0) | 
+					PCIe_DPLL2_KI_SET(0x4)| 
+					PCIe_DPLL2_KD_SET(0x40));
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG, 0x40010800);
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_DITHER_DIV_MAX, 0xc013fffe);
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_DITHER_DIV_MIN, 0x0013e666);
+
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG, 0x00010800);  
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG, 0x00000800);  
+		}
+
+		//run_command("md 0xb8116c00 4", 0);
+	}
+	ar7240_reg_rmw_set(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1)); // pci phy analog out of reset
+	pci_udelay(10000);
+
+	ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE_PHY);	// phy out of reset
+	pci_udelay(10000);
+
+	ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE);	// core out of reset
+	pci_udelay(1000);
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+	      PCI_COMMAND_PARITY|PCI_COMMAND_SERR|PCI_COMMAND_FAST_BACK;
+
+	ar7240_local_write_config(PCI_COMMAND, 4, cmd);		// pci cmd reg init
+	ar7240_local_write_config(0x20, 4, 0x1ff01000);		// membase setting
+	ar7240_local_write_config(0x24, 4, 0x1ff01000);		// prefetch membase setting
+
+
+	if ((is_ar7241() || is_ar7242() || is_wasp())) {
+		ar7240_reg_wr(0x180f0000, 0x1ffc1);		// ltssm enable
+	} else {
+		ar7240_reg_wr(0x180f0000, 0x1);
+	}
+	pci_udelay(100000);
+
+	ar7240_reg_wr_nf(AR7240_PCI_LCL_RESET, 4);		// EP out of reset
+	pci_udelay(100000);
+
+
+#ifdef COMPRESSED_UBOOT
+	pci_udelay(100);
+#else
+	/*
+	 *  Delay increased from 100 to 1000, so as to
+	 *  get the correct status from PCI LCL RESET register
+	 */
+	pci_udelay(100000);
+
+	/*
+	 * Check if the WLAN PCI-E H/W is present, If the
+	 * WLAN H/W is not present, skip the PCI platform
+	 * initialization code and return
+	 */
+
+	if (((ar7240_reg_rd(AR7240_PCI_LCL_RESET)) & 0x1) == 0x0) {
+		printf("*** Warning *** : PCIe WLAN Module not found !!!\n");
+		return;
+	}
+#endif
+
+#ifndef COMPRESSED_UBOOT
+	/*
+	 * Now, configure for u-boot tools
+	 */
+
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region(	&hose.regions[0],
+			0x80000000,
+			0x00000000,
+			32 * 1024 * 1024,
+			PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region(	&hose.regions[1],
+			0x10000000,
+			0x10000000,
+			128 * 1024 * 1024,
+			PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(	&hose,
+			pci_hose_read_config_byte_via_dword,
+			pci_hose_read_config_word_via_dword,
+			ar7240_pci_read_config,
+			pci_hose_write_config_byte_via_dword,
+			pci_hose_write_config_word_via_dword,
+			ar7240_pci_write_config);
+#endif
+	plat_dev_init();
+#endif	// CONFIG_AP123
+#ifdef COMPRESSED_UBOOT
+	return 0;
+#endif
+}
+#else
+// For non - wasp
+#ifdef COMPRESSED_UBOOT
+int pci_init_board (void)
+#else
+void pci_init_board (void)
+#endif /* #ifdef COMPRESSED_UBOOT */
+{
+	uint32_t cmd;
+
+
+	ar7240_reg_rmw_clear(AR7240_RESET,AR7240_RESET_PCIE_PHY_SERIAL);
+	udelay(100);
+
+	ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE_PHY);
+
+
+	ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE);
+
+	ar7240_reg_wr_nf(AR7240_PCI_LCL_RESET, 0);
+	udelay(100000);
+
+	/*
+	 * Initialize PCIE PLL and get it out of RESET
+	 */
+	ar7240_reg_wr(AR7240_PCIE_PLL_CONFIG,0x02050800);
+
+	ar7240_reg_wr(AR7240_PCIE_PLL_CONFIG,0x00050800);
+	udelay(100);
+
+	ar7240_reg_wr(AR7240_PCIE_PLL_CONFIG,0x00040800);
+	udelay(100000);
+
+	ar7240_reg_wr_nf(AR7240_PCI_LCL_RESET, 4);
+	udelay(100000);
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+	      PCI_COMMAND_PARITY|PCI_COMMAND_SERR|PCI_COMMAND_FAST_BACK;
+
+	ar7240_local_write_config(PCI_COMMAND, 4, cmd);
+	ar7240_local_write_config(0x20, 4, 0x1ff01000);
+	ar7240_local_write_config(0x24, 4, 0x1ff01000);
+
+	if ((is_ar7241() || is_ar7242() || is_wasp())) {
+		ar7240_reg_wr(0x180f0000, 0x1ffc1);
+	} else {
+		ar7240_reg_wr(0x180f0000, 0x1);
+	}
+
+#ifdef COMPRESSED_UBOOT
+	udelay(100);
+#else
+	udelay(1000);
+
+	/*
+	 * Check if the WLAN PCI-E H/W is present, If the
+	 * WLAN H/W is not present, skip the PCI platform
+	 * initialization code and return
+	 */
+
+	if (((ar7240_reg_rd(AR7240_PCI_LCL_RESET)) & 0x1) == 0x0) {
+		printf("*** Warning *** : PCIe WLAN Module not found !!!\n");
+		return;
+	}
+#endif
+
+#ifndef COMPRESSED_UBOOT
+	/*
+	 * Now, configure for u-boot tools
+	 */
+
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region(	&hose.regions[0],
+			0x80000000,
+			0x00000000,
+			32 * 1024 * 1024,
+			PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region(	&hose.regions[1],
+			0x10000000,
+			0x10000000,
+			128 * 1024 * 1024,
+			PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(	&hose,
+			pci_hose_read_config_byte_via_dword,
+			pci_hose_read_config_word_via_dword,
+			ar7240_pci_read_config,
+			pci_hose_write_config_byte_via_dword,
+			pci_hose_write_config_word_via_dword,
+			ar7240_pci_write_config);
+#endif
+	plat_dev_init();
+#ifdef COMPRESSED_UBOOT
+	return 0;
+#endif
+}
+#endif /* CONFIG_WASP_SUPPORT */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/ar7240_s26_phy.c u-boot_1.1//board/ar7240/common/ar7240_s26_phy.c
--- u-boot//board/ar7240/common/ar7240_s26_phy.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/ar7240_s26_phy.c	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,930 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "ar7240_s26_phy.h"
+
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO, 
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG, 
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define MODULE_NAME "ATHRS26"
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,     
+     0,
+     ATHR_PHY3_ADDR, 
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+    
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR, 
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+static uint8_t athr26_init_flag = 0,athr26_init_flag1 = 0;
+
+
+#define ATHR_GLOBALREGBASE    0
+
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+            
+/* Forward references */
+BOOL athrs26_phy_is_link_alive(int phyUnit);
+uint32_t athrs26_reg_read(uint32_t reg_addr);
+void athrs26_reg_write(uint32_t reg_addr, uint32_t reg_val);
+unsigned int s26_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+void s26_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+
+
+void athrs26_powersave_off(int phy_addr)
+{
+    s26_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0x29);
+    s26_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x36c0);
+
+}
+void athrs26_sleep_off(int phy_addr)
+{
+    s26_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0xb);
+    s26_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x3c00);
+}
+
+void athrs26_reg_init(void)
+{
+
+#if S26_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+    uint32_t ar7240_revid;
+    /* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+
+    if (athr26_init_flag)
+        return;
+
+    ar7240_revid = ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK;
+    if(ar7240_revid == AR7240_REV_1_0) {
+#ifdef S26_FORCE_100M
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_FUNC_CONTROL,0x800);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0xa100);
+#endif
+
+#ifdef S26_FORCE_10M
+        athrs26_powersave_off(ATHR_PHY4_ADDR);
+        athrs26_sleep_off(ATHR_PHY4_ADDR);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_FUNC_CONTROL,0x800);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x8100);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_ADDRESS,0x0);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_DATA,0x12ee);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_ADDRESS,0x3);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_DATA,0x3bf0);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x8100);
+#endif
+    } else {
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x9000);
+    }
+
+#if S26_PHY_DEBUG
+    rd_val = s26_rd_phy(ATHR_PHY4_ADDR,ATHR_PHY_FUNC_CONTROL);
+    printf("S26 PHY FUNC CTRL  (%d) :%x\n",ATHR_PHY4_ADDR, rd_val);
+    rd_val = s26_rd_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL);
+    printf("S26 PHY CTRL  (%d) :%x\n",ATHR_PHY4_ADDR, rd_val);
+#endif
+
+    athr26_init_flag = 1;
+}
+
+void athrs26_reg_init_lan(void)
+{
+    int i = 60;
+#if S26_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+    int       phyUnit;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+    uint32_t ar7240_revid;
+    
+    /* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+    if (athr26_init_flag1)
+        return;
+    
+    /* reset switch */
+    printf(MODULE_NAME ": resetting s26\n");
+    athrs26_reg_write(0x0, athrs26_reg_read(0x0)|0x80000000);
+
+    while(i--) {
+        if(!is_ar933x())
+    	    sysMsDelay(100);
+    	if(!(athrs26_reg_read(0x0)&0x80000000))
+    		break;
+    }
+    printf(MODULE_NAME ": s26 reset done\n");
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX - 1; phyUnit++) {
+
+    foundPhy = TRUE;
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    ar7240_revid = ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK;
+    if(ar7240_revid == AR7240_REV_1_0) {
+#ifdef S26_FORCE_100M 
+        /*
+         *  Force MDI and MDX to alternate ports 
+         *  Phy 0 and 2 -- MDI
+         *  Phy 1 and 3 -- MDX
+         */
+        if(phyUnit%2) 
+            s26_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+        else 
+            s26_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+
+        s26_wr_phy(phyAddr,ATHR_PHY_CONTROL,0xa100);
+#endif
+
+#ifdef S26_FORCE_10M
+        /*
+         *  Force MDI and MDX to alternate ports 
+         *  Phy 0 and 2 -- MDI
+         *  Phy 1 and 3 -- MDX
+         */
+        if(phyUnit%2) 
+            s26_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+        else
+            s26_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+
+        athrs26_powersave_off(phyAddr);
+        athrs26_sleep_off(phyAddr);
+
+        s26_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x8100);
+        s26_wr_phy(phyAddr,ATHR_DEBUG_PORT_ADDRESS,0x0);
+        s26_wr_phy(phyAddr,ATHR_DEBUG_PORT_DATA,0x12ee);
+        s26_wr_phy(phyAddr,ATHR_DEBUG_PORT_ADDRESS,0x3);
+        s26_wr_phy(phyAddr,ATHR_DEBUG_PORT_DATA,0x3bf0);
+        s26_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x8100);
+#endif
+    } else {
+        s26_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x9000);
+    }
+
+#if S26_PHY_DEBUG
+    rd_val = s26_rd_phy(phyAddr,ATHR_PHY_ID1);
+    printf("S26 PHY ID  (%d) :%x\n",phyAddr,rd_val);
+    rd_val = s26_rd_phy(phyAddr,ATHR_PHY_CONTROL);
+    printf("S26 PHY CTRL  (%d) :%x\n",phyAddr,rd_val);
+    rd_val = s26_rd_phy(phyAddr,ATHR_PHY_STATUS);
+    printf("S26 ATHR PHY STATUS  (%d) :%x\n",phyAddr,rd_val);
+#endif
+    }
+    /* 
+     * CPU port Enable 
+     */
+    athrs26_reg_write(CPU_PORT_REGISTER,(1 << 8));
+
+    /* 
+     * status[1:0]=2'h2;   - (0x10 - 1000 Mbps , 0x0 - 10 Mbps)
+     * status[2]=1'h1;     - Tx Mac En
+     * status[3]=1'h1;     - Rx Mac En
+     * status[4]=1'h1;     - Tx Flow Ctrl En
+     * status[5]=1'h1;     - Rx Flow Ctrl En
+     * status[6]=1'h1;     - Duplex Mode
+     */
+#ifdef CONFIG_AR7240_EMU
+    athrs26_reg_write(PORT_STATUS_REGISTER0, 0x7e);  /* CPU Port */
+    athrs26_reg_write(PORT_STATUS_REGISTER1, 0x3c);
+    athrs26_reg_write(PORT_STATUS_REGISTER2, 0x3c);
+    athrs26_reg_write(PORT_STATUS_REGISTER3, 0x3c);
+    athrs26_reg_write(PORT_STATUS_REGISTER4, 0x3c);
+#else
+    athrs26_reg_write(PORT_STATUS_REGISTER1, 0x200);  /* LAN - 1 */
+    athrs26_reg_write(PORT_STATUS_REGISTER2, 0x200);  /* LAN - 2 */
+    athrs26_reg_write(PORT_STATUS_REGISTER3, 0x200);  /* LAN - 3 */
+    athrs26_reg_write(PORT_STATUS_REGISTER4, 0x200);  /* LAN - 4 */
+#endif
+
+    /* QM Control */
+    athrs26_reg_write(0x38, 0xc000050e);
+  
+    /*
+     * status[11]=1'h0;    - CPU Disable
+     * status[7] = 1'b1;   - Learn One Lock
+     * status[14] = 1'b0;  - Learn Enable
+     */
+#ifdef CONFIG_AR7240_EMU
+    athrs26_reg_write(PORT_CONTROL_REGISTER0, 0x04);
+    athrs26_reg_write(PORT_CONTROL_REGISTER1, 0x4004);
+#else
+   /* Atheros Header Disable */
+    athrs26_reg_write(PORT_CONTROL_REGISTER0, 0x4004);
+#endif
+
+   /* Tag Priority Mapping */
+    athrs26_reg_write(0x70, 0xfa50);
+
+   /* Enable ARP packets to CPU port */
+    athrs26_reg_write(S26_ARL_TBL_CTRL_REG,(athrs26_reg_read(S26_ARL_TBL_CTRL_REG) | 0x100000));
+
+#if S26_PHY_DEBUG
+    rd_val = athrs26_reg_read ( CPU_PORT_REGISTER );
+    printf("S26 CPU_PORT_REGISTER :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER0 );
+    printf("S26 PORT_STATUS_REGISTER0  :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER1 );
+    printf("S26 PORT_STATUS_REGISTER1  :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER2 );
+    printf("S26 PORT_STATUS_REGISTER2  :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER3 );
+    printf("S26 PORT_STATUS_REGISTER3  :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER4 );
+    printf("S26 PORT_STATUS_REGISTER4  :%x\n",rd_val);
+
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER0 );
+    printf("S26 PORT_CONTROL_REGISTER0 :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER1 );
+    printf("S26 PORT_CONTROL_REGISTER1 :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER2 );
+    printf("S26 PORT_CONTROL_REGISTER2 :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER3 );
+    printf("S26 PORT_CONTROL_REGISTER3 :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER4 );
+    printf("S26 PORT_CONTROL_REGISTER4 :%x\n",rd_val);
+#endif
+
+    athr26_init_flag1 = 1;
+}
+static unsigned int phy_val_saved = 0;
+/******************************************************************************
+*
+* athrs26_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs26_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phyHwStatus = s26_rd_phy( phyAddr, ATHR_PHY_SPEC_STATUS);
+    
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs26_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs26_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+#if S26_PHY_DEBUG
+    uint32_t  rd_val = 0;
+#endif
+    uint32_t  ar7240_revid;
+    
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+       
+	s26_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+#if S26_PHY_DEBUG
+        rd_val = s26_rd_phy(phyAddr,ATHR_AUTONEG_ADVERT  );
+        printf("%s ATHR_AUTONEG_ADVERT %d :%x\n",__func__,phyAddr, rd_val);
+#endif
+
+    ar7240_revid = ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK;
+    if(ar7240_revid != AR7240_REV_1_0) {
+        s26_wr_phy( phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                      | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+#if S26_PHY_DEBUG
+        rd_val = s26_rd_phy(phyAddr,ATHR_AUTONEG_ADVERT  );
+        rd_val = s26_rd_phy(phyAddr,ATHR_PHY_CONTROL);
+        printf("%s ATHR_PHY_CONTROL %d :%x\n",__func__,phyAddr, rd_val);
+#endif
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+    
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    if(!is_ar933x()) {
+        if (ethUnit == ENET_UNIT_LAN)
+            sysMsDelay(1000);
+        else
+            sysMsDelay(3000);
+    }
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus =  s26_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            if(!is_ar933x())
+                sysMsDelay(150);
+        }
+
+
+#ifdef S26_VER_1_0
+        //turn off power saving
+       s26_wr_phy(phyUnit, 29, 41);
+       s26_wr_phy(phyUnit, 30, 0);
+       printf("def_ S26_VER_1_0\n");
+#endif
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit, 
+            s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS)));
+    }
+
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs26_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs26_phy_is_fdx(int ethUnit)
+{
+    int       phyUnit;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+                sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+            
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+
+/******************************************************************************
+*
+* athrs26_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               _10BASET, _100BASET;
+*               _1000BASET;
+*/
+
+int
+athrs26_phy_speed(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return _1000BASET;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+            do {
+	        phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+                sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+            
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return _10BASET;
+            case 1:
+#ifdef CONFIG_MACH_HORNET
+                /* For IEEE 100M voltage test */
+                s26_wr_phy(phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x4);
+                s26_wr_phy(phyAddr, ATHR_DEBUG_PORT_DATA, 0xebbb);
+                s26_wr_phy(phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                s26_wr_phy(phyAddr, ATHR_DEBUG_PORT_DATA, 0x2c47);     
+#endif /* CONFIG_MACH_HORNET */
+                return _100BASET;
+            case 2:
+                return _1000BASET;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+    }
+
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs26_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+
+            phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) { /* check realtime link */
+                linkCount++;
+            } else {
+                phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+            /* If realtime failed check link in latch register before
+             * asserting link down.
+             */
+                if (phyHwStatus & ATHR_LATCH_LINK_PASS)
+                   linkCount++;
+                else {
+                    lostLinks++;
+		}
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+
+            /* Check for reset complete */
+
+                phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+                phyHwControl = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_CONTROL);
+
+            /* Check for AutoNegotiation complete */ 
+           
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                    phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+                    if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                        gainedLinks++;
+                        linkCount++;
+                        DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                        lastStatus->isPhyAlive = TRUE;
+                   }  
+            }
+        }
+    }
+
+    return (linkCount);
+
+#if S26_PHY_DEBUG
+    if (linkCount == 0) {
+        if (lostLinks) {
+            /* We just lost the last link for this MAC */
+            phyLinkLost(ethUnit);
+        }
+    } else {
+        if (gainedLinks == linkCount) {
+            /* We just gained our first link(s) for this MAC */
+            phyLinkGained(ethUnit);
+        }
+    }
+#endif
+}
+
+uint32_t
+athrs26_reg_read(unsigned int s26_addr)
+{
+        unsigned int addr_temp;
+        unsigned int s26_rd_csr_low, s26_rd_csr_high, s26_rd_csr;
+        unsigned int data, unit = 0;
+        unsigned int phy_address, reg_address;
+
+        addr_temp = (s26_addr & 0xfffffffc) >>2;
+        data = addr_temp >> 7;
+
+        phy_address = 0x1f;
+        reg_address = 0x10;
+
+        if (is_ar7240()) {
+           unit = 0;
+        }
+        else if (is_ar7241() || is_ar7242() || is_ar933x()) {
+            unit = 1;
+        }
+
+        phy_reg_write(unit,phy_address, reg_address, data);
+
+        phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+        reg_address = ((addr_temp << 1) & 0x1e);
+        s26_rd_csr_low = (uint32_t) phy_reg_read(unit, phy_address, reg_address);
+
+        reg_address = reg_address | 0x1;
+        s26_rd_csr_high = (uint32_t) phy_reg_read(unit, phy_address, reg_address);
+        s26_rd_csr = (s26_rd_csr_high << 16) | s26_rd_csr_low ;
+
+        return(s26_rd_csr);
+}
+
+void
+athrs26_reg_write(unsigned int s26_addr, unsigned int s26_write_data)
+{
+        unsigned int addr_temp;
+        unsigned int data, unit = 0;
+        unsigned int phy_address, reg_address;
+
+
+        addr_temp = (s26_addr &  0xfffffffc) >>2;
+        data = addr_temp >> 7;
+
+        phy_address = 0x1f;
+        reg_address = 0x10;
+
+        if (is_ar7240()) {
+           unit = 0;
+        }
+        else if (is_ar7241() || is_ar7242()|| is_ar933x()) {
+            unit = 1;
+        }
+
+#ifdef CONFIG_MACH_HORNET
+        //The write sequence , 0x98: L->H, 0x40 H->L, 0x50 H->L , others should not care.
+        if(s26_addr!=0x98)
+        {
+            //printf("[%s:%d] unit=%d\n",__FUNCTION__,__LINE__,unit);
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+            phy_address = 0x17 & ((addr_temp >> 4) | 0x10);
+            reg_address = ((addr_temp << 1) & 0x1e) | 0x1;
+            data =  s26_write_data >> 16;
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+            reg_address = reg_address & 0x1e;
+            data = s26_write_data  & 0xffff;
+            phy_reg_write(unit, phy_address, reg_address, data);
+        }
+        else
+        {
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+            phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+            reg_address = ((addr_temp << 1) & 0x1e);
+
+            data = s26_write_data  & 0xffff;
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+            reg_address = (((addr_temp << 1) & 0x1e) | 0x1);
+            data = s26_write_data >> 16;
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+        }
+#else
+        phy_reg_write(unit, phy_address, reg_address, data);
+
+        phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+        reg_address = ((addr_temp << 1) & 0x1e);
+        data = s26_write_data  & 0xffff;
+        phy_reg_write(unit, phy_address, reg_address, data);
+
+        reg_address = (((addr_temp << 1) & 0x1e) | 0x1);
+        data = s26_write_data >> 16;
+        phy_reg_write(unit, phy_address, reg_address, data);
+#endif
+}
+
+
+unsigned int s26_rd_phy(unsigned int phy_addr, unsigned int reg_addr)
+{
+
+         unsigned int rddata;
+
+        // MDIO_CMD is set for read
+
+        rddata = athrs26_reg_read(0x98);
+        rddata = (rddata & 0x0) | (reg_addr<<16) | (phy_addr<<21) | (1<<27) | (1<<30) | (1<<31) ;
+        athrs26_reg_write(0x98, rddata);
+
+        rddata = athrs26_reg_read(0x98);
+        rddata = rddata & (1<<31);
+
+        // Check MDIO_BUSY status
+        while(rddata){
+        rddata = athrs26_reg_read(0x98);
+        rddata = rddata & (1<<31);
+        }
+
+
+        // Read the data from phy
+
+        rddata = athrs26_reg_read(0x98) & 0xffff;
+
+        return(rddata);
+}
+
+void s26_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data)
+{
+         unsigned int rddata;
+
+        // MDIO_CMD is set for read
+
+      rddata = athrs26_reg_read(0x98);
+      rddata = (rddata & 0x0) | (write_data & 0xffff) | (reg_addr<<16) | (phy_addr<<21) | (0<<27) | (1<<30) | (1<<31) ;
+      athrs26_reg_write(0x98, rddata);
+
+      rddata = athrs26_reg_read(0x98);
+      rddata = rddata & (1<<31);
+
+        // Check MDIO_BUSY status
+      while(rddata){
+      rddata = athrs26_reg_read(0x98);
+      rddata = rddata & (1<<31);
+      }
+
+}
+
+int
+athrs26_mdc_check()
+{
+    int i;
+
+    for (i=0; i<4000; i++) {
+        if(athrs26_reg_read(0x10c) != 0x18007fff)
+            return -1;
+    }
+    return 0;
+}
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/ar7240_s26_phy.h u-boot_1.1//board/ar7240/common/ar7240_s26_phy.h
--- u-boot//board/ar7240/common/ar7240_s26_phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/ar7240_s26_phy.h	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _ATHRS26_PHY_H
+#define _ATHRS26_PHY_H
+
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_FUNC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_LATCH_LINK_PASS                  0x0004 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+/* S26 CSR Registers */
+
+#define PORT_STATUS_REGISTER0                0x0100 
+#define PORT_STATUS_REGISTER1                0x0200
+#define PORT_STATUS_REGISTER2                0x0300
+#define PORT_STATUS_REGISTER3                0x0400
+#define PORT_STATUS_REGISTER4                0x0500
+#define PORT_STATUS_REGISTER5                0x0600
+
+#define RATE_LIMIT_REGISTER0                 0x010C
+#define RATE_LIMIT_REGISTER1                 0x020C
+#define RATE_LIMIT_REGISTER2                 0x030C
+#define RATE_LIMIT_REGISTER3                 0x040C
+#define RATE_LIMIT_REGISTER4                 0x050C
+#define RATE_LIMIT_REGISTER5                 0x060C
+
+#define PORT_CONTROL_REGISTER0               0x0104
+#define PORT_CONTROL_REGISTER1               0x0204
+#define PORT_CONTROL_REGISTER2               0x0204
+#define PORT_CONTROL_REGISTER3               0x0204
+#define PORT_CONTROL_REGISTER4               0x0204
+#define PORT_CONTROL_REGISTER5               0x0204
+
+#define CPU_PORT_REGISTER                    0x0078
+#define MDIO_CTRL_REGISTER                   0x0098
+
+#define S26_ARL_TBL_FUNC_REG0                0x0050
+#define S26_ARL_TBL_FUNC_REG1                0x0054
+#define S26_ARL_TBL_FUNC_REG2                0x0058
+#define S26_ARL_TBL_CTRL_REG                 0x005c
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+#define mdelay(_x)      sysMsDelay(_x)
+
+#define S26_FORCE_100M 1
+
+#endif
+
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/ath_nand.c u-boot_1.1//board/ar7240/common/ath_nand.c
--- u-boot//board/ar7240/common/ath_nand.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/ath_nand.c	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,1619 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * linux/drivers/mtd/nand/ath_nand.c
+ * vim: tabstop=8 : noexpandtab
+ * Derived from alauda.c
+ */
+#include <common.h>
+#include <command.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <ar7240_soc.h>
+#include <malloc.h>
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/bitops.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+
+#define ENOMEM		12
+#define EINVAL		22
+
+#define writesize		oobblock
+#define ath_reg_rd		ar7240_reg_rd
+#define ath_reg_wr		ar7240_reg_wr
+#define ath_reg_rmw_set		ar7240_reg_rmw_set
+#define ath_reg_rmw_clear	ar7240_reg_rmw_clear
+
+#define DRV_NAME	"ath-nand"
+#define DRV_VERSION	"0.1"
+#define DRV_AUTHOR	"Atheros"
+#define DRV_DESC	"Atheros on-chip NAND FLash Controller Driver"
+
+#define ATH_NF_COMMAND		(ATH_NAND_FLASH_BASE + 0x200u)
+#define ATH_NF_CTRL		(ATH_NAND_FLASH_BASE + 0x204u)
+#define ATH_NF_STATUS		(ATH_NAND_FLASH_BASE + 0x208u)
+#define ATH_NF_INT_MASK		(ATH_NAND_FLASH_BASE + 0x20cu)
+#define ATH_NF_INT_STATUS	(ATH_NAND_FLASH_BASE + 0x210u)
+#define ATH_NF_ECC_CTRL		(ATH_NAND_FLASH_BASE + 0x214u)
+#define ATH_NF_ECC_OFFSET	(ATH_NAND_FLASH_BASE + 0x218u)
+#define ATH_NF_ADDR0_0		(ATH_NAND_FLASH_BASE + 0x21cu)
+#define ATH_NF_ADDR1_0		(ATH_NAND_FLASH_BASE + 0x220u)
+#define ATH_NF_ADDR0_1		(ATH_NAND_FLASH_BASE + 0x224u)
+#define ATH_NF_ADDR1_1		(ATH_NAND_FLASH_BASE + 0x228u)
+#define ATH_NF_SPARE_SIZE	(ATH_NAND_FLASH_BASE + 0x230u)
+#define ATH_NF_PROTECT		(ATH_NAND_FLASH_BASE + 0x238u)
+#define ATH_NF_LOOKUP_EN	(ATH_NAND_FLASH_BASE + 0x240u)
+#define ATH_NF_LOOKUP0		(ATH_NAND_FLASH_BASE + 0x244u)
+#define ATH_NF_LOOKUP1		(ATH_NAND_FLASH_BASE + 0x248u)
+#define ATH_NF_LOOKUP2		(ATH_NAND_FLASH_BASE + 0x24cu)
+#define ATH_NF_LOOKUP3		(ATH_NAND_FLASH_BASE + 0x250u)
+#define ATH_NF_LOOKUP4		(ATH_NAND_FLASH_BASE + 0x254u)
+#define ATH_NF_LOOKUP5		(ATH_NAND_FLASH_BASE + 0x258u)
+#define ATH_NF_LOOKUP6		(ATH_NAND_FLASH_BASE + 0x25cu)
+#define ATH_NF_LOOKUP7		(ATH_NAND_FLASH_BASE + 0x260u)
+#define ATH_NF_DMA_ADDR		(ATH_NAND_FLASH_BASE + 0x264u)
+#define ATH_NF_DMA_COUNT	(ATH_NAND_FLASH_BASE + 0x268u)
+#define ATH_NF_DMA_CTRL		(ATH_NAND_FLASH_BASE + 0x26cu)
+#define ATH_NF_MEM_CTRL		(ATH_NAND_FLASH_BASE + 0x280u)
+#define ATH_NF_PG_SIZE		(ATH_NAND_FLASH_BASE + 0x284u)
+#define ATH_NF_RD_STATUS	(ATH_NAND_FLASH_BASE + 0x288u)
+#define ATH_NF_TIME_SEQ		(ATH_NAND_FLASH_BASE + 0x28cu)
+#define ATH_NF_TIMINGS_ASYN	(ATH_NAND_FLASH_BASE + 0x290u)
+#define ATH_NF_TIMINGS_SYN	(ATH_NAND_FLASH_BASE + 0x294u)
+#define ATH_NF_FIFO_DATA	(ATH_NAND_FLASH_BASE + 0x298u)
+#define ATH_NF_TIME_MODE	(ATH_NAND_FLASH_BASE + 0x29cu)
+#define ATH_NF_DMA_ADDR_OFFSET	(ATH_NAND_FLASH_BASE + 0x2a0u)
+#define ATH_NF_FIFO_INIT	(ATH_NAND_FLASH_BASE + 0x2b0u)
+#define ATH_NF_GENERIC_SEQ_CTRL	(ATH_NAND_FLASH_BASE + 0x2b4u)
+
+#define ATH_NF_TIMING_ASYN	0x11
+#define ATH_NF_STATUS_OK	0x40	//0xc0
+#define ATH_NF_RD_STATUS_MASK	0x47	//0xc7
+
+#define ATH_NF_COMMAND_CMD_2(x)		(((x) & 0xff) << 24)	// A code of the third command in a sequence.
+#define ATH_NF_COMMAND_CMD_1(x)		(((x) & 0xff) << 16)	// A code of the second command in a sequence.
+#define ATH_NF_COMMAND_CMD_0(x)		(((x) & 0xff) <<  8)	// A code of the first command in a sequence.
+#define ATH_NF_COMMAND_ADDR_SEL		(1 << 7)		// Address register select flag:
+								// 0  the address register 0 selected
+								// 1  the address register 1 selected
+#define ATH_NF_COMMAND_INPUT_SEL_DMA	(1 << 6) 		// Input module select flag:
+								// 0  select the SIU module as input
+								// 1  select the DMA module as input
+#define ATH_NF_COMMAND_CMD_SEQ_0	0x00
+#define ATH_NF_COMMAND_CMD_SEQ_1	0x21
+#define ATH_NF_COMMAND_CMD_SEQ_2	0x22
+#define ATH_NF_COMMAND_CMD_SEQ_3	0x03
+#define ATH_NF_COMMAND_CMD_SEQ_4	0x24
+#define ATH_NF_COMMAND_CMD_SEQ_5	0x25
+#define ATH_NF_COMMAND_CMD_SEQ_6	0x26
+#define ATH_NF_COMMAND_CMD_SEQ_7	0x27
+#define ATH_NF_COMMAND_CMD_SEQ_8	0x08
+#define ATH_NF_COMMAND_CMD_SEQ_9	0x29
+#define ATH_NF_COMMAND_CMD_SEQ_10	0x2A
+#define ATH_NF_COMMAND_CMD_SEQ_11	0x2B
+#define ATH_NF_COMMAND_CMD_SEQ_12	0x0C
+#define ATH_NF_COMMAND_CMD_SEQ_13	0x0D
+#define ATH_NF_COMMAND_CMD_SEQ_14	0x0E
+#define ATH_NF_COMMAND_CMD_SEQ_15	0x2F
+#define ATH_NF_COMMAND_CMD_SEQ_16	0x30
+#define ATH_NF_COMMAND_CMD_SEQ_17	0x11
+#define ATH_NF_COMMAND_CMD_SEQ_18	0x32
+#define ATH_NF_COMMAND_CMD_SEQ_19	0x13
+
+
+#define ATH_NF_CTRL_SMALL_BLOCK_EN	(1 << 21)
+
+#define ATH_NF_CTRL_ADDR_CYCLE1_0	(0 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_1	(1 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_2	(2 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_3	(3 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_4	(4 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_5	(5 << 18)
+
+#define ATH_NF_CTRL_ADDR1_AUTO_INC_EN	(1 << 17)
+#define ATH_NF_CTRL_ADDR0_AUTO_INC_EN	(1 << 16)
+#define ATH_NF_CTRL_WORK_MODE_SYNC	(1 << 15)
+#define ATH_NF_CTRL_PROT_EN		(1 << 14)
+#define ATH_NF_CTRL_LOOKUP_EN		(1 << 13)
+#define ATH_NF_CTRL_IO_WIDTH_16BIT	(1 << 12)
+#define ATH_NF_CTRL_CUSTOM_SIZE_EN	(1 << 11)
+
+#define ATH_NF_CTRL_PAGE_SIZE_256	(0 <<  8)	/* bytes */
+#define ATH_NF_CTRL_PAGE_SIZE_512	(1 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_1024	(2 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_2048	(3 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_4096	(4 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_8192	(5 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_16384	(6 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_0		(7 <<  8)
+
+#define ATH_NF_CTRL_BLOCK_SIZE_32	(0 <<  6)	/* pages */
+#define ATH_NF_CTRL_BLOCK_SIZE_64	(1 <<  6)
+#define ATH_NF_CTRL_BLOCK_SIZE_128	(2 <<  6)
+#define ATH_NF_CTRL_BLOCK_SIZE_256	(3 <<  6)
+
+#define ATH_NF_CTRL_ECC_EN		(1 <<  5)
+#define ATH_NF_CTRL_INT_EN		(1 <<  4)
+#define ATH_NF_CTRL_SPARE_EN		(1 <<  3)
+
+#define ATH_NF_CTRL_ADDR_CYCLE0_0	(0 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_1	(1 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_2	(2 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_3	(3 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_4	(4 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_5	(5 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0(c)	((c) << 0)
+
+
+#define ATH_NF_DMA_CTRL_DMA_START	(1 << 7)
+#define ATH_NF_DMA_CTRL_DMA_DIR_WRITE	(0 << 6)
+#define ATH_NF_DMA_CTRL_DMA_DIR_READ	(1 << 6)
+#define ATH_NF_DMA_CTRL_DMA_MODE_SG	(1 << 5)
+/*
+ * 000 - incrementing precise burst of precisely four transfers
+ * 001 - stream burst (address const)
+ * 010 - single transfer (address increment)
+ * 011 - burst of unspecified length (address increment)
+ * 100 - incrementing precise burst of precisely eight transfers
+ * 101 - incrementing precise burst of precisely sixteen transfers
+ */
+#define ATH_NF_DMA_CTRL_DMA_BURST_0	(0 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_1	(1 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_2	(2 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_3	(3 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_4	(4 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_5	(5 << 2)
+#define ATH_NF_DMA_CTRL_ERR_FLAG	(1 << 1)
+#define ATH_NF_DMA_CTRL_DMA_READY	(1 << 0)
+
+#define ATH_NF_ECC_CTRL_ERR_THRESH(x)	((x << 8) & (0x1fu << 8))
+#define ATH_NF_ECC_CTRL_ECC_CAP(x)	((x << 5) & (0x07u << 5))
+#define ATH_NF_ECC_CTRL_ECC_2_BITS	ATH_NF_ECC_CTRL_ECC_CAP(0)
+#define ATH_NF_ECC_CTRL_ECC_4_BITS	ATH_NF_ECC_CTRL_ECC_CAP(1)
+#define ATH_NF_ECC_CTRL_ECC_6_BITS	ATH_NF_ECC_CTRL_ECC_CAP(2)
+#define ATH_NF_ECC_CTRL_ECC_8_BITS	ATH_NF_ECC_CTRL_ECC_CAP(3)
+#define ATH_NF_ECC_CTRL_ECC_10_BITS	ATH_NF_ECC_CTRL_ECC_CAP(4)
+#define ATH_NF_ECC_CTRL_ECC_12_BITS	ATH_NF_ECC_CTRL_ECC_CAP(5)
+#define ATH_NF_ECC_CTRL_ECC_14_BITS	ATH_NF_ECC_CTRL_ECC_CAP(6)
+#define ATH_NF_ECC_CTRL_ECC_16_BITS	ATH_NF_ECC_CTRL_ECC_CAP(7)
+
+#define ATH_NF_ECC_CTRL_ERR_OVER	(1 << 2)
+#define ATH_NF_ECC_CTRL_ERR_UNCORR	(1 << 1)
+#define ATH_NF_ECC_CTRL_ERR_CORR	(1 << 0)
+#	define ATH_NF_ECC_ERROR		(ATH_NF_ECC_CTRL_ERR_UNCORR | \
+					 ATH_NF_ECC_CTRL_ERR_OVER)
+
+#define ATH_NF_CMD_END_INT		(1 << 1)
+
+#define ATH_NF_HW_ECC		1
+#define ATH_NF_STATUS_RETRY	1000
+
+#define ath_nand_get_cmd_end_status(void)	\
+	(ath_reg_rd(ATH_NF_INT_STATUS) & ATH_NF_CMD_END_INT)
+
+#define ath_nand_clear_int_status()	ath_reg_wr(ATH_NF_INT_STATUS, 0)
+
+#define ATH_NAND_BLK_DONT_KNOW	0x0
+#define ATH_NAND_BLK_GOOD	0x1
+#define ATH_NAND_BLK_BAD	0x2
+#define ATH_NAND_BLK_ERASED	0x3
+
+#define ATH_NF_GENERIC_SEQ_CTRL_COL_ADDR	(1 << 17)
+#define ATH_NF_GENERIC_SEQ_CTRL_DATA_EN		(1 << 16)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD3_CODE(x)	(((x) & 0xff) << 8)
+#define ATH_NF_GENERIC_SEQ_CTRL_DEL_EN(x)	(((x) & 3) << 6)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD3_EN		(1 << 5)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD2_EN		(1 << 4)
+#define ATH_NF_GENERIC_SEQ_CTRL_ADDR1_EN	(1 << 3)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD1_EN		(1 << 2)
+#define ATH_NF_GENERIC_SEQ_CTRL_ADDR0_EN	(1 << 1)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD0_EN		(1 << 0)
+
+#define ATH_NAND_JFFS2_ECC_OFF	0x04	// Give 4 bytes for Factory Bad Block Marker
+#define ATH_NAND_JFFS2_ECC_LEN	0x10	// Space for JFFS2 Clean Marker
+
+/*
+ * Note: The byte positions might not match the spec.
+ * It is to handle the endianness issues.
+ */
+#define ONFI_NUM_ADDR_CYCLES	102	/* see note */
+#define ONFI_DEV_DESC		32
+#define ONFI_DEV_DESC_SZ	32
+#define ONFI_PAGE_SIZE		80
+#define ONFI_SPARE_SIZE		86	/* see note */
+#define ONFI_PAGES_PER_BLOCK	92
+#define ONFI_BLOCKS_PER_LUN	96
+#define ONFI_NUM_LUNS		103	/* see note */
+#define ONFI_RD_PARAM_PAGE_SZ	128
+#define READ_PARAM_STATUS_OK	0x40
+#define READ_PARAM_STATUS_MASK	0x41
+
+#define ATH_NAND_IO_DBG		0
+#define ATH_NAND_OOB_DBG	0
+#define ATH_NAND_IN_DBG		0
+
+#if ATH_NAND_IO_DBG
+#	define iodbg	printk
+#else
+#	define iodbg(...)
+#endif
+
+#if ATH_NAND_OOB_DBG
+#	define oobdbg	printk
+#else
+#	define oobdbg(...)
+#endif
+
+#if ATH_NAND_IN_DBG
+#	define indbg(a, ...)					\
+	do {							\
+		printk("--- %s(%d):" a "\n",			\
+			__func__, __LINE__, ## __VA_ARGS__);	\
+	} while (0)
+#else
+#	define indbg(...)
+#	define indbg1(a, ...)					\
+	do {							\
+		printk("--- %s(%d):" a "\n",			\
+			__func__, __LINE__, ## __VA_ARGS__);	\
+	} while (0)
+#endif
+
+/*
+ * Data structures for ath nand flash controller driver
+ */
+
+typedef union {
+	uint8_t			byte_id[8];
+
+	struct {
+		uint8_t		sa1	: 1,	// Serial access time (bit 1)
+				org	: 1,	// Organisation
+				bs	: 2,	// Block size
+				sa0	: 1,	// Serial access time (bit 0)
+				ss	: 1,	// Spare size per 512 bytes
+				ps	: 2,	// Page Size
+
+				wc	: 1,	// Write Cache
+				ilp	: 1, 	// Interleaved Programming
+				nsp	: 2, 	// No. of simult prog pages
+				ct	: 2,	// Cell type
+				dp	: 2,	// Die/Package
+
+				did,		// Device id
+				vid,		// Vendor id
+
+				res1	: 2,	// Reserved
+				pls	: 2,	// Plane size
+				pn	: 2,	// Plane number
+				res2	: 2;	// Reserved
+	} __details;
+} ath_nand_id_t;
+
+uint64_t ath_plane_size[] = {
+	64 << 20,
+	 1 << 30,
+	 2 << 30,
+	 4 << 30,
+	 8 << 30
+};
+
+typedef struct {
+	uint8_t		vid,
+			did,
+			b3,
+			addrcyc,
+			small,
+			spare;	// for small block;
+	uint16_t	pgsz;	// for small block
+	uint32_t	blk;	// for small block
+} ath_nand_vend_data_t;
+
+#define is_small_block_device(x)	((x)->entry && (x)->entry->small)
+
+ath_nand_vend_data_t ath_nand_arr[] = {
+	{ 0x20, 0xda, 0x10, 5, },	// NU2g3B2D
+	{ 0x20, 0xf1, 0x00, 4, },	// NU1g3B2C
+	{ 0x20, 0xdc, 0x10, 5, },	// NU4g3B2D
+	{ 0x20, 0xd3, 0x10, 5, },	// NU8g3F2A
+	{ 0x20, 0xd3, 0x14, 5, },	// NU8g3C2B
+	{ 0xad, 0xf1, 0x00, 4, },	// HY1g2b
+	{ 0xad, 0xda, 0x10, 5, },	// HY2g2b
+	{ 0xec, 0xf1, 0x00, 4, },	// Samsung 3,3V 8-bit [128MB]
+	{ 0x98, 0xd1, 0x90, 4, },	// Toshiba
+	{ 0xad, 0x76, 0xad, 5, 1, 16, 512, 16 << 10 },	// Hynix 64MB NAND Flash
+	{ 0xad, 0x36, 0xad, 5, 1, 16, 512, 16 << 10 },	// Hynix 64MB NAND Flash
+	{ 0x20, 0x76, 0x20, 5, 1, 16, 512, 16 << 10 },	// ST Micro 64MB NAND Flash
+};
+
+#define NUM_ARRAY_ENTRIES(a)	(sizeof((a)) / sizeof((a)[0]))
+#define NUM_ATH_NAND		NUM_ARRAY_ENTRIES(ath_nand_arr)
+
+/* ath nand info */
+typedef struct {
+	/* mtd info */
+	struct mtd_info		*mtd;
+
+	/* platform info */
+	unsigned short		page_size,
+				data_width;
+
+	/* NAND MTD partition information */
+	int			nr_partitions;
+	struct mtd_partition	*partitions;
+
+	unsigned		*bbt;
+
+	ath_nand_vend_data_t	*entry;
+
+	unsigned		ba0,
+				ba1,
+				cmd;	// Current command
+	ath_nand_id_t		__id;	// for readid
+	uint8_t			onfi[ONFI_RD_PARAM_PAGE_SZ];
+#if ATH_NF_HW_ECC
+	uint32_t		ecc_offset;
+#endif
+	uint32_t		nf_ctrl;
+} ath_nand_sc_t;
+
+ath_nand_sc_t ath_nand_sc;
+static int ath_nand_hw_init(ath_nand_sc_t *, void *);
+
+struct mtd_info nand_info[CFG_MAX_NAND_DEVICE];
+int nand_curr_device = 0;
+
+#define	nid	__id.__details
+#define	bid	__id.byte_id
+
+static int ath_nand_block_isbad(struct mtd_info *mtd, loff_t ofs);
+void ath_nand_dump_buf(loff_t addr, void *v, unsigned count);
+
+/* max page size (16k) + oob buf size */
+uint8_t	ath_nand_io_buf[24 << 10] __attribute__((aligned(4096)));
+#define get_ath_nand_io_buf()	ath_nand_io_buf
+
+#define	bbt_index	(sizeof(*sc->bbt) * 8 / 2)
+
+/*
+ * MTD layer assumes the NAND device as a linear array of bytes.
+ * However, the NAND devices are organised into blocks, pages,
+ * spare area etc. Hence, the address provided by Linux has to
+ * converted to format expected by the devices.
+ *
+ * [in] mtd: MTD info pointer
+ * [in] addr: Linear Address as provided by MTD layer
+ * [out] addr0: Value to be set into ADDR0_0 register
+ * [out] addr1: Value to be set into ADDR0_1 register
+ * [in] small_block_erase: Address conversion for small block
+ *	is different. Hence, special case it.
+ */
+inline void
+ath_nand_conv_addr(struct mtd_info *mtd, loff_t addr, uint32_t *addr0,
+			uint32_t *addr1, int small_block_erase)
+{
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (is_small_block_device(sc) && small_block_erase) {
+		/*
+		 * The block address loading is accomplished three
+		 * cycles. Erase is a SEQ_14 type command. Hence, the
+		 * controller starts shifting from ADDR_0[16:32] &
+		 * ADDR_1 based on the number of address cycles in our
+		 * case... The device data sheet assumes to have 3
+		 * address cycles for having page address + block
+		 * address for erase. Ideally, SMALL_BLOCK_EN in the
+		 * NF_CTRL register should help but, that doesn't seem
+		 * to work as expected. Hence, the following
+		 * conversion.
+		 */
+
+		// Get the block no.
+		uint32_t b = (addr >> mtd->erasesize_shift);
+
+		*addr0 = (b & 0xfff) << 21;
+		*addr1 = (b >> 11) & 0x1;
+	} else if (is_small_block_device(sc)) {
+		/* +-----+----+----+----+----+----+----+----+----+
+		 * |cycle|I/O7|I/O6|I/O5|I/O4|I/O3|I/O2|I/O1|I/O0|
+		 * +-----+----+----+----+----+----+----+----+----+
+		 * | 1st | A7 | A6 | A5 | A4 | A3 | A2 | A1 | A0 |
+		 * | 2nd |A16 |A15 |A14 |A13 |A12 |A11 |A10 | A9 |
+		 * | 3rd |A24 |A23 |A22 |A21 |A20 |A19 |A18 |A17 |
+		 * | 4th | x  | x  | x  | x  | x  | x  | x  |A25 |
+		 * +-----+----+----+----+----+----+----+----+----+
+		 */
+		addr &= ~(mtd->writesize_mask);
+		*addr0 = ((addr & 0xff) |
+			  ((addr >> 1) & (~0xffu))) & ((1 << 25) - 1);
+		*addr1 = 0;
+	} else {
+		/* +-----+---+---+---+---+---+---+---+---+
+		 * |Cycle|IO0|IO1|IO2|IO3|IO4|IO5|IO6|IO7|
+		 * +-----+---+---+---+---+---+---+---+---+
+		 * | 1st | A0| A1| A2| A3| A4| A5| A6| A7|
+		 * | 2nd | A8| A9|A10|A11| x | x | x | x |
+		 * | 3rd |A12|A13|A14|A15|A16|A17|A18|A19|
+		 * | 4th |A20|A21|A22|A23|A24|A25|A26|A27|
+		 * +-----+---+---+---+---+---+---+---+---+
+		 */
+		*addr0 = ((addr >> mtd->writesize_shift) << 16);
+		*addr1 = ((addr >> (mtd->writesize_shift + 16)) & 0xf);
+	}
+}
+
+inline unsigned
+ath_nand_get_blk_state(struct mtd_info *mtd, loff_t b)
+{
+	unsigned		x, y;
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (!sc->bbt)	return ATH_NAND_BLK_DONT_KNOW;
+
+	b = b >> mtd->erasesize_shift;
+
+	x = b / bbt_index;
+	y = b % bbt_index;
+
+	return (sc->bbt[x] >> (y * 2)) & 0x3;
+}
+
+inline void
+ath_nand_set_blk_state(struct mtd_info *mtd, loff_t b, unsigned state)
+{
+	unsigned		x, y;
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (!sc->bbt)	return;
+
+	b = b >> mtd->erasesize_shift;
+
+	x = b / bbt_index;
+	y = b % bbt_index;
+
+	sc->bbt[x] = (sc->bbt[x] & ~(3 << (y * 2))) | (state << (y * 2));
+}
+
+static unsigned
+ath_nand_status(ath_nand_sc_t *sc, unsigned *ecc)
+{
+	unsigned	rddata, i, j, dmastatus;
+
+	rddata = ath_reg_rd(ATH_NF_STATUS);
+	for (i = 0; i < ATH_NF_STATUS_RETRY && rddata != 0xff; i++) {
+		udelay(5);
+		rddata = ath_reg_rd(ATH_NF_STATUS);
+	}
+
+	dmastatus = ath_reg_rd(ATH_NF_DMA_CTRL);
+	for (j = 0; j < ATH_NF_STATUS_RETRY && !(dmastatus & 1); j++) {
+		udelay(5);
+		dmastatus = ath_reg_rd(ATH_NF_DMA_CTRL);
+	}
+
+	if ((i == ATH_NF_STATUS_RETRY) || (j == ATH_NF_STATUS_RETRY)) {
+		//printk("ath_nand_status: i = %u j = %u\n", i, j);
+		ath_nand_hw_init(sc, NULL);
+		return -1;
+	}
+	if (ecc) {
+		*ecc = ath_reg_rd(ATH_NF_ECC_CTRL);
+	}
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_GENERIC_SEQ_CTRL, 0);
+	ath_reg_wr(ATH_NF_COMMAND, 0x07024);	// READ STATUS
+	while (ath_nand_get_cmd_end_status() == 0);
+	rddata = ath_reg_rd(ATH_NF_RD_STATUS);
+
+	return rddata;
+}
+
+static unsigned
+ath_check_all_0xff(ath_nand_sc_t *sc, unsigned addr0, unsigned addr1, unsigned *all_0xff)
+{
+	uint8_t		*pa, *buf = ath_nand_io_buf, *end;
+	struct mtd_info	*mtd = sc->mtd;
+	unsigned	i, count = mtd->writesize + mtd->oobsize;
+
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_DMA_COUNT, count);
+	ath_reg_wr(ATH_NF_DMA_CTRL, ATH_NF_DMA_CTRL_DMA_START |
+				ATH_NF_DMA_CTRL_DMA_DIR_READ |
+				ATH_NF_DMA_CTRL_DMA_BURST_3);
+	ath_reg_wr(ATH_NF_ECC_OFFSET, 0);
+	ath_reg_wr(ATH_NF_ECC_CTRL, 0);
+	ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_CUSTOM_SIZE_EN);
+	ath_reg_wr(ATH_NF_PG_SIZE, count);
+	pa = (void *)virt_to_phys(buf);
+	ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+	ath_reg_wr(ATH_NF_COMMAND, 0x30006a);	// Read page
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	i = ath_nand_status(sc, NULL) & ATH_NF_RD_STATUS_MASK;
+	memcpy(buf, pa, count);	// cache sync equivalent
+	if (i != ATH_NF_STATUS_OK) {
+		return 0;
+	}
+	end = buf + count;
+	for (buf += sc->ecc_offset; (*buf == 0xff) && buf != end; buf ++);
+
+	*all_0xff = 1;
+
+	if (buf == end) {
+		/* This page was read without ECC. From the spare area
+		 * content we see that it a blank page (i.e. full 0xff).
+		 * To take care of bit flips if any, force 0xff on it.
+		 */
+		memset(ath_nand_io_buf, 0xff, mtd->writesize);
+	} else {
+		ath_nand_dump_buf(addr0, ath_nand_io_buf, mtd->writesize + mtd->oobsize);
+	}
+	return (buf == end);
+}
+
+static unsigned
+ath_nand_rw_page(ath_nand_sc_t *sc, int rd, unsigned addr0, unsigned addr1, unsigned count, unsigned char *buf, unsigned ecc_needed)
+{
+	unsigned	ecc, i = 0, tmp, rddata, all_0xff = 0;
+#if ATH_NF_HW_ECC
+	unsigned	mlc_retry = 0;
+#endif
+	char		*err[] = { "Write", "Read" };
+#define ATH_MAX_RETRY	25
+#define ATH_MLC_RETRY	3
+retry:
+	ecc = 0;
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)buf);
+	ath_reg_wr(ATH_NF_DMA_COUNT, count);
+
+#if ATH_NF_HW_ECC
+	if (ecc_needed && sc->ecc_offset && (count & sc->mtd->writesize_mask) == 0) {
+		/*
+		 * ECC can operate only on the device's pages.
+		 * Cannot be used for non-page-sized read/write
+		 */
+		ath_reg_wr(ATH_NF_ECC_OFFSET, sc->ecc_offset);
+		ath_reg_wr(ATH_NF_ECC_CTRL, ATH_NF_ECC_CTRL_ERR_THRESH(4) |
+						ATH_NF_ECC_CTRL_ECC_4_BITS);
+		ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_ECC_EN);
+		ath_reg_wr(ATH_NF_SPARE_SIZE, sc->mtd->oobsize);
+	} else
+#endif
+	{
+		ath_reg_wr(ATH_NF_ECC_OFFSET, 0);
+		ath_reg_wr(ATH_NF_ECC_CTRL, 0);
+		ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_CUSTOM_SIZE_EN);
+		ath_reg_wr(ATH_NF_PG_SIZE, count);
+	}
+
+	if (rd) {	// Read Page
+		if (is_small_block_device(sc)) {
+			ath_reg_wr(ATH_NF_DMA_CTRL,
+						ATH_NF_DMA_CTRL_DMA_START |
+						ATH_NF_DMA_CTRL_DMA_DIR_READ |
+						ATH_NF_DMA_CTRL_DMA_BURST_3);
+			ath_reg_wr(ATH_NF_GENERIC_SEQ_CTRL,
+						ATH_NF_GENERIC_SEQ_CTRL_COL_ADDR |
+						ATH_NF_GENERIC_SEQ_CTRL_DATA_EN |
+						ATH_NF_GENERIC_SEQ_CTRL_DEL_EN(1) |
+						ATH_NF_GENERIC_SEQ_CTRL_ADDR0_EN |
+						ATH_NF_GENERIC_SEQ_CTRL_CMD0_EN);
+			ath_reg_wr(ATH_NF_COMMAND,
+						ATH_NF_COMMAND_CMD_SEQ_18 |
+						ATH_NF_COMMAND_INPUT_SEL_DMA |
+						ATH_NF_COMMAND_CMD_0(0));
+		} else {
+			ath_reg_wr(ATH_NF_DMA_CTRL,
+						ATH_NF_DMA_CTRL_DMA_START |
+						ATH_NF_DMA_CTRL_DMA_DIR_READ |
+						ATH_NF_DMA_CTRL_DMA_BURST_3);
+			ath_reg_wr(ATH_NF_COMMAND, 0x30006a);
+		}
+	} else {	// Write Page
+		ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);	// Remove write protect
+		ath_reg_wr(ATH_NF_DMA_CTRL,
+					ATH_NF_DMA_CTRL_DMA_START |
+					ATH_NF_DMA_CTRL_DMA_DIR_WRITE |
+					ATH_NF_DMA_CTRL_DMA_BURST_3);
+		ath_reg_wr(ATH_NF_COMMAND, 0x10804c);
+	}
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	//printk(KERN_DEBUG "%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+	//	rd ? 'r' : 'w', addr0, addr1, count, buf);
+
+	rddata = (tmp = ath_nand_status(sc, &ecc)) & ATH_NF_RD_STATUS_MASK;
+	if ((rddata != ATH_NF_STATUS_OK) && (i < ATH_MAX_RETRY)) {
+		i++;
+		goto retry;
+	}
+
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0x0000);	// Enable write protect
+	ath_reg_wr(ATH_NF_FIFO_INIT, 1);
+	ath_reg_wr(ATH_NF_FIFO_INIT, 0);
+
+	if (rddata != ATH_NF_STATUS_OK) {
+		printk("%s: %s Failed. tmp = 0x%x, status = 0x%x 0x%x retries = %d\n", __func__,
+			err[rd], tmp, rddata, ath_reg_rd(ATH_NF_DMA_CTRL), i);
+	}
+#if ATH_NF_HW_ECC
+	else {
+#define DDR_WB_FLUSH_USB_ADDRESS		0x180000a4
+
+		ath_reg_wr(DDR_WB_FLUSH_USB_ADDRESS, 1);
+		while (ath_reg_rd(DDR_WB_FLUSH_USB_ADDRESS) & 1);
+		udelay(2);
+
+		if (ecc_needed && (ecc & ATH_NF_ECC_ERROR)) {
+			if (rd && all_0xff == 0) {
+				if (ath_check_all_0xff(sc, addr0, addr1, &all_0xff)) {
+					return ATH_NF_STATUS_OK;
+				}
+			}
+
+			if (mlc_retry < ATH_MLC_RETRY) {
+				mlc_retry ++;
+				i = 0;
+				goto retry;
+			} else {
+				printk("%s: %s uncorrectable errors. ecc = 0x%x\n",
+					__func__, err[rd], ecc);
+				return -1;
+			}
+		}
+	}
+#endif
+	return rddata;
+}
+
+void
+ath_nand_dump_buf(loff_t addr, void *v, unsigned count)
+{
+	unsigned	*buf = v,
+			*end = buf + (count / sizeof(*buf));
+
+	iodbg("____ Dumping %d bytes at 0x%p 0x%lx_____\n", count, buf, (ulong)addr);
+
+	for (; buf && buf < end; buf += 4, addr += 16) {
+		printk("%08lx: %08x %08x %08x %08x\n",
+			(unsigned)addr, buf[0], buf[1], buf[2], buf[3]);
+	}
+	iodbg("___________________________________\n");
+	//while(1);
+}
+
+static int
+ath_nand_rw_buff(struct mtd_info *mtd, int rd, uint8_t *buf,
+		loff_t addr, size_t len, size_t *iodone)
+{
+	unsigned	iolen, ret = ATH_NF_STATUS_OK, ecc_needed;
+	unsigned char	*pa;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	*iodone = 0;
+
+	while (len) {
+		uint32_t c, ba0, ba1;
+
+		if (ath_nand_block_isbad(mtd, addr)) {
+			printk("Skipping bad block[0x%x]\n", (unsigned)addr);
+			addr += mtd->erasesize;
+			continue;
+		}
+
+		c = (addr & mtd->writesize_mask);
+
+		ath_nand_conv_addr(mtd, addr, &ba0, &ba1, 0);
+
+		if (c) {
+			iolen = mtd->writesize - c;
+		} else {
+			iolen = mtd->writesize;
+		}
+
+		if (len < iolen) {
+			iolen = len;
+		}
+
+		if (rd) {
+			ecc_needed = (ath_nand_get_blk_state(mtd, addr) != ATH_NAND_BLK_ERASED);
+		} else {
+			int i;
+
+			for (i = 0; (i < mtd->writesize) && (buf[i] == 0xff); i++);
+			if (i == mtd->writesize) {
+				ret = ATH_NF_STATUS_OK;
+				//printk("Skipping write for 0x%x\n", (ulong)addr);
+				goto skip_write_for_all_0xff;
+			}
+
+			/* FIXME for writes FIXME */
+			memcpy(ath_nand_io_buf, buf, iolen);
+			ecc_needed = 1;
+		}
+
+		pa = (void *)virt_to_phys(ath_nand_io_buf);
+
+		flush_cache((unsigned)ath_nand_io_buf, mtd->writesize);
+
+		//printk("%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+		//	rd ? 'r' : 'w', ba0, ba1, iolen, pa);
+
+		ret = ath_nand_rw_page(sc, rd, ba0, ba1, mtd->writesize, pa, ecc_needed);
+
+		flush_cache((unsigned)ath_nand_io_buf, mtd->writesize);
+
+		if (rd) {
+			memcpy(buf, ath_nand_io_buf + c, iolen);
+		}
+skip_write_for_all_0xff:
+		//ath_nand_dump_buf(addr, buf, iolen);
+
+		if (ret != ATH_NF_STATUS_OK) {
+			return 1;
+		}
+
+		len -= iolen;
+		buf += iolen;
+		addr += iolen;
+		*iodone += iolen;
+	}
+
+	return 0;
+}
+
+#define ath_nand_write_verify	0
+
+#if ath_nand_write_verify
+uint8_t	ath_nand_rd_buf[4096 + 256] __attribute__((aligned(4096)));
+#endif
+
+static int
+ath_nand_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, const u_char *buf)
+{
+	int	ret;
+#if ath_nand_write_verify
+	int	r, rl;
+#endif
+
+	if (!len || !retlen) return (0);
+
+	indbg("0x%llx	%u", to, len);
+
+	ret = ath_nand_rw_buff(mtd, 0 /* write */, (u_char *)buf, to, len, retlen);
+#if ath_nand_write_verify
+	//printk("Verifying 0x%llx 0x%x\n", to, len);
+	r = ath_nand_rw_buff(mtd, 1 /* read */, ath_nand_rd_buf, to, len, &rl);
+	if (r || memcmp(ath_nand_rd_buf, buf, len)) {
+		printk("write failed at 0x%llx 0x%x\n", to, len);
+		while (1);
+	}
+#endif
+	return ret;
+}
+
+static int
+ath_nand_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	int	ret;
+
+	if (!len || !retlen) return (0);
+
+	ret = ath_nand_rw_buff(mtd, 1 /* read */, buf, from, len, retlen);
+
+	return ret;
+}
+
+static inline int
+ath_nand_block_erase(ath_nand_sc_t *sc, unsigned addr0, unsigned addr1)
+{
+	unsigned	rddata;
+
+	indbg("0x%x 0x%x", addr1, addr0);
+
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);	// Remove write protect
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_COMMAND, 0xd0600e);	// BLOCK ERASE
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	rddata = ath_nand_status(sc, NULL) & ATH_NF_RD_STATUS_MASK;
+
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0x0000);	// Enable write protect
+
+	if (rddata != ATH_NF_STATUS_OK) {
+		printk("Erase Failed. status = 0x%x\n", rddata);
+		return 1;
+	}
+	return 0;
+}
+
+
+static int
+ath_nand_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	ulong		s_first, i;
+	unsigned	n, j;
+	int		ret, bad = 0;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	if (instr->addr + instr->len > mtd->size) {
+		return (-EINVAL);
+	}
+
+	s_first = instr->addr;
+	n = instr->len >> mtd->erasesize_shift;
+
+	if (instr->len & mtd->erasesize_mask) n ++;
+
+	indbg("0x%llx 0x%x 0x%x", instr->addr, n, mtd->erasesize);
+
+	printk("%s: 0x%x %u\n", __func__, s_first, n);
+
+	for (j = 0, i = s_first; j < n; j++, i += mtd->erasesize) {
+		uint32_t ba0, ba1;
+
+		if (ath_nand_block_isbad(mtd, i)) {
+			bad ++;
+			continue;
+		}
+
+		ath_nand_conv_addr(mtd, i, &ba0, &ba1, 1);
+
+		printk("\b\b\b\b%4d", j);
+
+		if ((ret = ath_nand_block_erase(sc, ba0, ba1)) != 0) {
+			printf("%s: erase failed 0x%x 0x%x 0x%x %x "
+				"%lx %lx\n", __func__, instr->addr, n,
+				mtd->erasesize, i, ba1, ba0);
+			break;
+		}
+		ath_nand_set_blk_state(mtd, i, ATH_NAND_BLK_ERASED);
+	}
+
+	if (instr->callback) {
+		if (j < n) {
+			instr->state = MTD_ERASE_FAILED;
+		} else {
+			instr->state = MTD_ERASE_DONE;
+		}
+		mtd_erase_callback(instr);
+	}
+
+	printk("Skipped %d bad blocks\n", bad);
+
+	return ret;
+}
+
+/* lifted from linux */
+typedef enum {
+	MTD_OOB_PLACE,
+	MTD_OOB_AUTO,
+	MTD_OOB_RAW,
+} mtd_oob_mode_t;
+
+struct mtd_oob_ops {
+	mtd_oob_mode_t  mode;
+	size_t          len;
+	size_t          retlen;
+	size_t          ooblen;
+	size_t          oobretlen;
+	uint32_t        ooboffs;
+	uint8_t         *datbuf;
+	uint8_t         *oobbuf;
+};
+
+static int
+ath_nand_rw_oob(struct mtd_info *mtd, int rd, loff_t addr,
+		struct mtd_oob_ops *ops)
+{
+	unsigned	ret = ATH_NF_STATUS_OK;
+	unsigned char	*pa;
+	uint32_t	ba0, ba1;
+	uint8_t		*oob = ath_nand_io_buf + mtd->writesize;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	ath_nand_conv_addr(mtd, addr, &ba0, &ba1, 0);
+
+	if (!rd) {
+		if (ops->datbuf) {
+			/*
+			 * XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX
+			 * We assume that the caller gives us a full
+			 * page to write. We don't read the page and
+			 * update the changed portions alone.
+			 *
+			 * Hence, not checking for len < or > pgsz etc...
+			 * XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX
+			 */
+			memcpy(ath_nand_io_buf, ops->datbuf, ops->len);
+		}
+		if (ops->mode == MTD_OOB_PLACE) {
+			oob += ops->ooboffs;
+		} else if (ops->mode == MTD_OOB_AUTO) {
+			// clean markers
+			oob[0] = oob[1] = 0xff;
+			oob += 2;
+		}
+		memcpy(oob, ops->oobbuf, ops->ooblen);
+	}
+
+	pa = (void *)virt_to_phys(ath_nand_io_buf);
+	if (!rd) flush_cache(ath_nand_io_buf, mtd->writesize + mtd->oobsize);	// for writes...
+
+	//printk("%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+	//	rd ? 'r' : 'w', ba0, ba1, mtd->writesize + mtd->oobsize, pa);
+
+	ret = ath_nand_rw_page(sc, rd, ba0, ba1, mtd->writesize + mtd->oobsize, pa, 0);
+
+	if (ret != ATH_NF_STATUS_OK) {
+		return 1;
+	}
+
+	if (rd) {
+		memcpy(ath_nand_io_buf, KSEG1ADDR(pa), mtd->writesize + mtd->oobsize);	// for reads...
+
+		if (ops->datbuf) {
+			memcpy(ops->datbuf, ath_nand_io_buf, ops->len);
+		}
+		if (ops->mode == MTD_OOB_PLACE) {
+			oob += ops->ooboffs;
+		} else if (ops->mode == MTD_OOB_AUTO) {
+			// copy after clean marker
+			oob += 2;
+		}
+		memcpy(ops->oobbuf, oob, ops->ooblen);
+	}
+
+	//if (rd) {
+	//	ath_nand_dump_buf(addr, ops->datbuf, ops->len);
+	//	ath_nand_dump_buf(addr, ops->oobbuf, ops->ooblen);
+	//}
+
+	if (ops->datbuf) {
+		ops->retlen = ops->len;
+	}
+	ops->oobretlen = ops->ooblen;
+
+	return 0;
+}
+
+//static int
+//ath_nand_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
+int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen)
+{
+	struct mtd_oob_ops ops = { MTD_OOB_RAW, len, 0, ooblen, 0,
+					0, buf, buf + mtd->writesize };
+
+	oobdbg(	"%s: from: 0x%lx mode: 0x%x len: 0x%x retlen: 0x%x\n"
+		"ooblen: 0x%x oobretlen: 0x%x ooboffs: 0x%x datbuf: %p "
+		"oobbuf: %p\n", __func__, (uint32_t)from,
+		ops.mode, ops.len, ops.retlen, ops.ooblen,
+		ops.oobretlen, ops.ooboffs, ops.datbuf,
+		ops.oobbuf);
+
+	oobdbg("0x%lx %p %p %u\n", (uint32_t)from, ops.oobbuf, ops.datbuf, ops.len);
+
+	if (len == 0) {
+		ops.datbuf = 0;
+		ops.oobbuf = buf;
+	}
+	if (ooblen == 0) {
+		ops.oobbuf = NULL;
+	}
+
+	return ath_nand_rw_oob(mtd, 1 /* read */, from, &ops);
+}
+
+#if 0
+static int
+ath_nand_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops)
+{
+	int ret;
+	unsigned char oob[128];
+	struct mtd_oob_ops	rops = {
+		.mode	= MTD_OOB_RAW,
+		.ooblen	= mtd->oobsize,
+		.oobbuf	= oob,
+	};
+
+	if (ops->mode == MTD_OOB_AUTO) {
+		/* read existing oob */
+		if (ath_nand_read_oob(mtd, to, &rops) ||
+			rops.oobretlen != rops.ooblen) {
+			printk("%s: oob read failed at 0x%llx\n", __func__, to);
+			return 1;
+		}
+		memcpy(oob + 2, ops->oobbuf, ops->ooblen);
+		rops = *ops;
+		ops->oobbuf = oob;
+		ops->ooblen = mtd->oobsize;
+		ops->mode = MTD_OOB_RAW;
+	}
+
+	oobdbg(	"%s: from: 0x%llx mode: 0x%x len: 0x%x retlen: 0x%x\n"
+		"ooblen: 0x%x oobretlen: 0x%x ooboffs: 0x%x datbuf: %p "
+		"oobbuf: %p\n", __func__, to,
+		ops->mode, ops->len, ops->retlen, ops->ooblen,
+		ops->oobretlen, ops->ooboffs, ops->datbuf,
+		ops->oobbuf);
+
+	indbg("0x%llx", to);
+
+	ret = ath_nand_rw_oob(mtd, 0 /* write */, to, ops);
+
+	if (rops.mode == MTD_OOB_AUTO) {
+		if (ret == 0) { // rw oob success
+			rops.oobretlen = rops.ooblen;
+			rops.retlen = rops.len;
+		}
+		*ops = rops;
+	}
+
+	return ret;
+}
+#endif
+
+static int
+ath_nand_block_isbad(struct mtd_info *mtd, loff_t ofs)
+{
+	unsigned char		oob[256];
+	unsigned		bs, i;
+	unsigned		*force = (unsigned *)0xbd000000;
+
+	if (*force == 0x12345678) {
+		return 0;
+	}
+
+	bs = ath_nand_get_blk_state(mtd, ofs);
+
+	if ((bs == ATH_NAND_BLK_ERASED) || (bs == ATH_NAND_BLK_GOOD)) {
+		return 0;
+	}
+
+	if (bs == ATH_NAND_BLK_BAD) {
+		return 1;
+	}
+
+	/*
+	 * H27U1G8F2B Series [1 Gbit (128 M x 8 bit) NAND Flash]
+	 *
+	 * The Bad Block Information is written prior to shipping. Any
+	 * block where the 1st Byte in the spare area of the 1st or
+	 * 2nd th page (if the 1st page is Bad) does not contain FFh
+	 * is a Bad Block. The Bad Block Information must be read
+	 * before any erase is attempted as the Bad Block Information
+	 * may be erased. For the system to be able to recognize the
+	 * Bad Blocks based on the original information it is
+	 * recommended to create a Bad Block table following the
+	 * flowchart shown in Figure 24. The 1st block, which is
+	 *                               ^^^^^^^^^^^^^
+	 * placed on 00h block address is guaranteed to be a valid
+	 * block.                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
+	 */
+
+	for (i = 0; i < 2; i++, ofs += mtd->writesize) {
+		if (nand_read_raw(mtd, oob, ofs, 0, mtd->oobsize)) {
+			printk("%s: oob read failed at 0x%lx\n", __func__, (unsigned)ofs);
+			ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_DONT_KNOW);
+			return 1;
+		}
+
+		/* First two bytes of oob data are clean markers */
+		if (oob[0] != 0xff || oob[1] != 0xff) {
+			oobdbg("%s: block is bad at 0x%lx\n", __func__, (unsigned)ofs);
+			oobdbg(	"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				0xff & oob[ 0], 0xff & oob[ 1], 0xff & oob[ 2],
+				0xff & oob[ 3], 0xff & oob[ 4], 0xff & oob[ 5],
+				0xff & oob[ 6], 0xff & oob[ 7], 0xff & oob[ 8],
+				0xff & oob[ 9], 0xff & oob[10], 0xff & oob[11],
+				0xff & oob[12], 0xff & oob[13], 0xff & oob[14],
+				0xff & oob[15], 0xff & oob[16], 0xff & oob[17],
+				0xff & oob[18], 0xff & oob[19], 0xff & oob[20],
+				0xff & oob[21], 0xff & oob[22], 0xff & oob[23],
+				0xff & oob[24], 0xff & oob[25], 0xff & oob[26],
+				0xff & oob[27], 0xff & oob[28], 0xff & oob[29],
+				0xff & oob[30], 0xff & oob[31], 0xff & oob[32],
+				0xff & oob[33], 0xff & oob[34], 0xff & oob[35],
+				0xff & oob[36], 0xff & oob[37], 0xff & oob[38],
+				0xff & oob[39], 0xff & oob[40], 0xff & oob[41],
+				0xff & oob[42], 0xff & oob[43], 0xff & oob[44],
+				0xff & oob[45], 0xff & oob[46], 0xff & oob[47],
+				0xff & oob[48], 0xff & oob[49], 0xff & oob[50],
+				0xff & oob[51], 0xff & oob[52], 0xff & oob[53],
+				0xff & oob[54], 0xff & oob[55], 0xff & oob[56],
+				0xff & oob[57], 0xff & oob[58], 0xff & oob[59],
+				0xff & oob[60], 0xff & oob[61], 0xff & oob[62],
+				0xff & oob[63]);
+			ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_BAD);
+			return 1;
+		}
+	}
+
+	for (i = 0; (i < mtd->oobsize) && (oob[i] == 0xff); i++);
+
+	if (i == mtd->oobsize) {
+		ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_ERASED);
+	} else {
+	      ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_GOOD);
+	}
+
+	return 0;
+}
+
+static int
+ath_nand_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	indbg("unimplemented 0x%llx", ofs);
+	return 0;
+}
+
+static unsigned long
+ath_parse_read_id(ath_nand_sc_t *sc)
+{
+	int	i;
+
+	extern struct nand_manufacturers nand_manuf_ids[];
+	extern struct nand_flash_dev nand_flash_ids[];
+
+	iodbg(	"____ %s _____\n"
+		"  vid did wc  ilp nsp ct  dp  sa1 org bs  sa0 ss  "
+		"ps  res1 pls pn  res2\n"
+		"0x%3x %3x %3x %3x %3x %3x %3x %3x %3x %3x %3x %3x "
+		"%3x %3x  %3x %3x %3x\n-------------\n", __func__,
+			sc->nid.vid, sc->nid.did, sc->nid.wc, sc->nid.ilp,
+			sc->nid.nsp, sc->nid.ct, sc->nid.dp, sc->nid.sa1,
+			sc->nid.org, sc->nid.bs, sc->nid.sa0, sc->nid.ss,
+			sc->nid.ps, sc->nid.res1, sc->nid.pls, sc->nid.pn,
+			sc->nid.res2);
+
+	for (i = 0; i < nand_manuf_ids[i].id; i++) {
+		if (nand_manuf_ids[i].id == sc->nid.vid) {
+			printk(nand_manuf_ids[i].name);
+			break;
+		}
+	}
+
+	for (i = 0; i < nand_flash_ids[i].id; i++) {
+		if (nand_flash_ids[i].id == sc->nid.did) {
+			printk(" %s [%uMB]\n", nand_flash_ids[i].name,
+				nand_flash_ids[i].chipsize);
+			return nand_flash_ids[i].chipsize;
+		}
+	}
+
+	return 0;
+}
+
+ath_nand_vend_data_t *
+nand_get_entry(ath_nand_id_t *nand_id, ath_nand_vend_data_t *tbl, int count)
+{
+	int     i;
+
+	for (i = 0; i < count; i++, tbl ++) {
+		if ((nand_id->__details.vid == tbl->vid) &&
+		    (nand_id->__details.did == tbl->did) &&
+		    (nand_id->byte_id[1] == tbl->b3)) {
+			return tbl;
+		}
+	}
+
+	return NULL;
+}
+
+static inline void
+ath_nand_onfi_endian_convert(uint8_t *buf)
+{
+	uint32_t	i, *u = (uint32_t *)(buf + ONFI_DEV_DESC);
+
+	for (i = 0; i < (ONFI_DEV_DESC_SZ / sizeof(*u)); i++) {
+		u[i] = __le32_to_cpu(u[i]);
+	}
+
+	// Hope nobody has a 20 character device description
+	buf[ONFI_DEV_DESC + ONFI_DEV_DESC_SZ - 1] = 0;
+}
+
+int
+nand_param_page(ath_nand_sc_t *sc, uint8_t *buf, unsigned count)
+{
+	unsigned int	tries, rddata;
+	uint8_t		*pa;
+
+	pa = virt_to_phys(buf);
+
+	for (tries = 3; tries; tries --) {
+		// ADDR0_0 Reg Settings
+		ath_reg_wr(ATH_NF_ADDR0_0, 0x0);
+
+		// ADDR0_1 Reg Settings
+		ath_reg_wr(ATH_NF_ADDR0_1, 0x0);
+
+		// DMA Start Addr
+		ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+
+		// DMA count
+		ath_reg_wr(ATH_NF_DMA_COUNT, count);
+
+		// Custom Page Size
+		ath_reg_wr(ATH_NF_PG_SIZE, count);
+
+		// DMA Control Reg
+		ath_reg_wr(ATH_NF_DMA_CTRL, 0xcc);
+
+		ath_nand_clear_int_status();
+		// READ PARAMETER PAGE
+		ath_reg_wr(ATH_NF_COMMAND, 0xec62);
+		while (ath_nand_get_cmd_end_status() == 0);
+
+		rddata = ath_nand_status(sc, NULL) & READ_PARAM_STATUS_MASK;
+		if (rddata == READ_PARAM_STATUS_OK) {
+			break;
+		} else {
+			printk("\nParam Page Failure: 0x%x", rddata);
+			ath_nand_hw_init(sc, NULL);
+		}
+	}
+
+	memcpy(buf, KSEG1ADDR(buf), count);	// get into the cache
+
+	//ath_nand_dump_buf(buf, buf, count);
+
+	if ((rddata == READ_PARAM_STATUS_OK) &&
+	    (buf[3] == 'O' && buf[2] == 'N' && buf[1] == 'F' && buf[0] == 'I')) {
+		ath_nand_onfi_endian_convert(buf);
+		printf("ONFI %s\n", buf + ONFI_DEV_DESC);
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * System initialization functions
+ */
+static int
+ath_nand_hw_init(ath_nand_sc_t *sc, void *p)
+{
+	uint8_t		id[8];
+	unsigned char	*pa;
+	unsigned	rddata, i;
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_NANDF_RESET_MASK);
+	udelay(250);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_NANDF_RESET_MASK);
+	udelay(100);
+
+	ath_reg_wr(ATH_NF_INT_MASK, ATH_NF_CMD_END_INT);
+	ath_nand_clear_int_status();
+
+	// TIMINGS_ASYN Reg Settings
+	ath_reg_wr(ATH_NF_TIMINGS_ASYN, ATH_NF_TIMING_ASYN);
+
+	// NAND Mem Control Reg
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);
+
+	// Reset Command
+	ath_reg_wr(ATH_NF_COMMAND, 0xff00);
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	udelay(1000);
+
+	rddata = ath_reg_rd(ATH_NF_STATUS);
+	for (i = 0; i < ATH_NF_STATUS_RETRY && rddata != 0xff; i++) {
+		udelay(25);
+		rddata = ath_reg_rd(ATH_NF_STATUS);
+	}
+
+	if (i == ATH_NF_STATUS_RETRY) {
+		printf("device reset failed\n");
+		while(1);
+	}
+
+	if (p) {
+		ath_nand_vend_data_t *entry;
+
+		ath_nand_clear_int_status();
+		pa = (void *)virt_to_phys(p ? p : id);
+		ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+		ath_reg_wr(ATH_NF_ADDR0_0, 0x0);
+		ath_reg_wr(ATH_NF_ADDR0_1, 0x0);
+		ath_reg_wr(ATH_NF_DMA_COUNT, 0x8);
+		ath_reg_wr(ATH_NF_PG_SIZE, 0x8);
+		ath_reg_wr(ATH_NF_DMA_CTRL, 0xcc);
+		ath_reg_wr(ATH_NF_COMMAND, 0x9061);	// READ ID
+		while (ath_nand_get_cmd_end_status() == 0);
+
+		rddata = ath_nand_status(sc, NULL);
+		if ((rddata & ATH_NF_RD_STATUS_MASK) != ATH_NF_STATUS_OK) {
+			printf("%s: ath nand status = 0x%x\n", __func__, rddata);
+		}
+
+		pa = p;
+		printk("Ath Nand ID[%p]: %02x:%02x:%02x:%02x:%02x\n",
+				pa, pa[3], pa[2], pa[1], pa[0], pa[7]);
+
+		sc->onfi[0] = 0;
+
+		entry = nand_get_entry((ath_nand_id_t *)p, ath_nand_arr, NUM_ATH_NAND);
+		if (entry) {
+			//sc->entry = entry;
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(entry->addrcyc);
+		} else if (nand_param_page(sc, sc->onfi, sizeof(sc->onfi)) == 0) {
+			rddata = sc->onfi[ONFI_NUM_ADDR_CYCLES];
+			rddata = ((rddata >> 4) & 0xf) + (rddata & 0xf);
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(rddata);
+		} else {
+			printk("Attempting to use unknown device\n");
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(5);
+		}
+
+		iodbg("******* %s done ******\n", __func__);
+	}
+
+	return 0;
+}
+
+/*
+ * Copied from drivers/mtd/nand/nand_base.c
+ * http://ptgmedia.pearsoncmg.com/images/chap17_9780132396554/elementLinks/17fig04.gif
+ *
+ * +---...---+--+----------+---------+
+ * |  2048   |  |          |         |
+ * | File    |cm| FS spare | ecc data|
+ * | data    |  |          |         |
+ * +---...---+--+----------+---------+
+ * cm -> clean marker (2 bytes)
+ * FS Spare -> bytes available for jffs2
+ */
+
+static void
+ath_nand_ecc_init(struct mtd_info *mtd)
+{
+#if ATH_NF_HW_ECC
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (is_small_block_device(sc)) {
+		// ECC cannot be supported...
+		sc->ecc_offset = 0;
+	} else {
+		sc->ecc_offset = mtd->writesize + ATH_NAND_JFFS2_ECC_OFF +
+						ATH_NAND_JFFS2_ECC_LEN;
+	}
+#else
+	sc->ecc_offset = 0;
+#endif
+}
+
+void
+ath_nand_set_ns(struct mtd_info *mtd)
+{
+#define ATH_DEF_PAGE_SIZE	(2u << 10)
+#define ATH_DEF_BLK_SIZE	(128u << 10)
+#define ATH_NAND_SPEC		"ns"
+
+	char ns[64], *p;
+
+	if ((p = getenv(ATH_NAND_SPEC))) {
+		/* don't override user setting */
+		return;
+	}
+
+	if (mtd->writesize == ATH_DEF_PAGE_SIZE &&
+	    mtd->erasesize == ATH_DEF_BLK_SIZE) {
+		return;
+	}
+
+	sprintf(ns, "-0x%x-0x%x", mtd->erasesize, mtd->writesize);
+	setenv(ATH_NAND_SPEC, ns);
+	printf("set " ATH_NAND_SPEC " %s\n", ns);
+}
+
+/*
+ * ath_nand_probe
+ *
+ * called by device layer when it finds a device matching
+ * one our driver can handled. This code checks to see if
+ * it can allocate all necessary resources then calls the
+ * nand layer to look for devices
+ */
+static ulong ath_nand_probe(void)
+{
+	ath_nand_sc_t	*sc = NULL;
+	struct mtd_info	*mtd = NULL;
+	int		i, err = 0, bbt_size;
+	unsigned	nf_ctrl_pg[][2] = {
+		/* page size in bytes, register val */
+		{   256, ATH_NF_CTRL_PAGE_SIZE_256	},
+		{   512, ATH_NF_CTRL_PAGE_SIZE_512	},
+		{  1024, ATH_NF_CTRL_PAGE_SIZE_1024	},
+		{  2048, ATH_NF_CTRL_PAGE_SIZE_2048	},
+		{  4096, ATH_NF_CTRL_PAGE_SIZE_4096	},
+		{  8192, ATH_NF_CTRL_PAGE_SIZE_8192	},
+		{ 16384, ATH_NF_CTRL_PAGE_SIZE_16384	},
+		{     0, ATH_NF_CTRL_PAGE_SIZE_0	},
+		};
+	unsigned	nf_ctrl_blk[][2] = {
+		/* no. of pages, register val */
+		{  32, ATH_NF_CTRL_BLOCK_SIZE_32	},
+		{  64, ATH_NF_CTRL_BLOCK_SIZE_64	},
+		{ 128, ATH_NF_CTRL_BLOCK_SIZE_128	},
+		{ 256, ATH_NF_CTRL_BLOCK_SIZE_256	},
+		{   0, 0				},
+		};
+
+	sc = &ath_nand_sc;
+	sc->mtd = &nand_info[nand_curr_device];
+
+	/* initialise the hardware */
+	err = ath_nand_hw_init(sc, &sc->nid);
+	if (err) {
+		goto out_err_hw_init;
+	}
+
+	/* initialise mtd sc data struct */
+	mtd = sc->mtd;
+	mtd->size = ath_parse_read_id(sc) << 20;
+
+	mtd->name		= DRV_NAME;
+	if (mtd->size == 0) {
+		mtd->size	= ath_plane_size[sc->nid.pls] << sc->nid.pn;
+	}
+
+	if (is_small_block_device(sc)) {
+		mtd->writesize		= sc->entry->pgsz;
+		mtd->writesize_shift	= ffs(mtd->writesize) - 1;
+		mtd->writesize_mask	= mtd->writesize - 1;
+
+		mtd->erasesize		= sc->entry->blk;
+		mtd->erasesize_shift	= ffs(mtd->erasesize) - 1;
+		mtd->erasesize_mask	= mtd->erasesize - 1;
+
+		mtd->oobsize		= sc->entry->spare;
+		mtd->oobavail		= mtd->oobsize;
+	} else if (!sc->onfi[0]) {
+		mtd->writesize_shift	= 10 + sc->nid.ps;
+		mtd->writesize		= (1 << mtd->writesize_shift);
+		mtd->writesize_mask	= (mtd->writesize - 1);
+
+		mtd->erasesize_shift	= 16 + sc->nid.bs;
+		mtd->erasesize		= (1 << mtd->erasesize_shift);
+		mtd->erasesize_mask	= (mtd->erasesize - 1);
+
+		mtd->oobsize		= (mtd->writesize / 512) * (8 << sc->nid.ss);
+		mtd->oobavail		= mtd->oobsize;
+	} else {
+		mtd->writesize		= *(uint32_t *)(&sc->onfi[ONFI_PAGE_SIZE]);
+		mtd->writesize_shift	= ffs(mtd->writesize) - 1;
+		mtd->writesize_mask	= (mtd->writesize - 1);
+
+		mtd->erasesize		= *(uint32_t *)(&sc->onfi[ONFI_PAGES_PER_BLOCK]) *
+					  mtd->writesize;
+		mtd->erasesize_shift	= ffs(mtd->erasesize) - 1;
+		mtd->erasesize_mask	= (mtd->erasesize - 1);
+
+		mtd->oobsize		= *(uint16_t *)(&sc->onfi[ONFI_SPARE_SIZE]);
+		mtd->oobavail		= mtd->oobsize;
+
+		mtd->size		= mtd->erasesize *
+					  (*(uint32_t *)(&sc->onfi[ONFI_BLOCKS_PER_LUN])) *
+					  sc->onfi[ONFI_NUM_LUNS];
+	}
+
+	for (i = 0; nf_ctrl_pg[i][0]; i++) {
+		if (nf_ctrl_pg[i][0] == mtd->writesize) {
+			sc->nf_ctrl |= nf_ctrl_pg[i][1];
+			break;
+		}
+	}
+
+	for (i = 0; nf_ctrl_blk[i][0]; i++) {
+		if (nf_ctrl_blk[i][0] == (mtd->erasesize / mtd->writesize)) {
+			sc->nf_ctrl |= nf_ctrl_blk[i][1];
+			break;
+		}
+	}
+
+	ath_nand_set_ns(mtd);
+
+	mtd->type		= MTD_NANDFLASH;
+	mtd->flags		= MTD_CAP_NANDFLASH;
+
+	mtd->read		= ath_nand_read;
+	mtd->write		= ath_nand_write;
+	mtd->erase		= ath_nand_erase;
+
+	//mtd->read_oob		= ath_nand_read_oob;
+	//mtd->write_oob		= ath_nand_write_oob;
+
+	mtd->block_isbad	= ath_nand_block_isbad;
+	mtd->block_markbad	= ath_nand_block_markbad;
+
+	mtd->priv		= sc;
+
+	ath_nand_ecc_init(mtd);
+
+	// bbt has 2 bits per block
+	bbt_size = ((mtd->size >> mtd->erasesize_shift) * 2) / 8;
+	sc->bbt = malloc(bbt_size);
+
+	if (sc->bbt) {
+		memset(sc->bbt, 0, bbt_size);
+	}
+
+	printf(	"====== NAND Parameters ======\n"
+		"sc = 0x%p bbt = 0x%p bbt_size = 0x%x nf_ctrl = 0x%x\n"
+		"page = 0x%x block = 0x%x oob = 0x%x\nsize = %uMB\n", sc, sc->bbt, bbt_size,
+		sc->nf_ctrl, mtd->writesize, mtd->erasesize, mtd->oobsize, mtd->size >> 20);
+
+	return mtd->size;
+
+out_err_hw_init:
+	return 0;
+}
+
+#if 0
+static struct platform_driver ath_nand_driver = {
+	//.probe		= ath_nand_probe,
+	.remove		= __exit_p(ath_nand_remove),
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+#endif
+
+ulong ath_nand_init(void)
+{
+	printk(DRV_DESC ", Version " DRV_VERSION
+		" (c) 2010 Atheros Communications, Ltd.\n");
+
+	//return platform_driver_register(&ath_nand_driver);
+	//return platform_driver_probe(&ath_nand_driver, ath_nand_probe);
+	return ath_nand_probe();
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/athrs16_phy.c u-boot_1.1//board/ar7240/common/athrs16_phy.c
--- u-boot//board/ar7240/common/athrs16_phy.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/athrs16_phy.c	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,701 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrs16_phy.h"
+
+/* PHY selections and access functions */
+typedef enum {
+    PHY_SRCPORT_INFO, 
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG, 
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+
+/*depend on connection between cpu mac and s16 mac*/
+#if defined (CONFIG_PORT0_AS_SWITCH)
+#define ENET_UNIT_LAN 0  
+#define ENET_UNIT_WAN 1
+#define CFG_BOARD_AP96 1
+
+#elif defined (CONFIG_AG7240_GE0_IS_CONNECTED)
+#define ENET_UNIT_LAN 0  
+#define CFG_BOARD_PB45 0
+#define CFG_BOARD_AP96 1
+#else
+#define ENET_UNIT_LAN 1  
+#define ENET_UNIT_WAN 0
+#define CFG_BOARD_PB45 1
+#endif
+
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_IND_PHY 4
+
+#define MODULE_NAME "ATHRS16"
+#define S16_PHY_DEBUG 1
+extern int xmii_val;
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,//ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR, 
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+    
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00, 
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+static uint8_t athr16_init_flag = 0;
+
+//#define ATHR_PHY_MAX (sizeof(ipPhyInfo) / sizeof(ipPhyInfo[0]))
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+            
+/* Forward references */
+BOOL athrs16_phy_is_link_alive(int phyUnit);
+uint32_t athrs16_reg_read(uint32_t reg_addr);
+void athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val);
+static void phy_mode_setup(void);
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+
+static void phy_mode_setup(void) 
+{
+#ifdef ATHRS16_VER_1_0
+    /*work around for phy4 rgmii mode*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);    
+
+    /*rx delay*/ 
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);  
+
+    /*tx delay*/ 
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);    
+#endif
+}
+
+void athrs16_reg_init()
+{
+    /* if using header for register configuration, we have to     */
+    /* configure s16 register after frame transmission is enabled */
+    if (athr16_init_flag)
+        return;
+
+    /*Power on strip mode setup*/
+#if CFG_BOARD_PB45
+    athrs16_reg_write(0x208, 0x2fd0001);  /*tx delay*/   
+    athrs16_reg_write(0x108, 0x2be0001);  /*mac0 rgmii mode*/ 
+#elif CFG_BOARD_AP96
+    //athrs16_reg_write(0x8, 0x012e1bea);
+    athrs16_reg_write(0x8, 0x01261be2);
+#endif
+    
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER0, 0x7e);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER1, 0x200);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER2, 0x200);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER3, 0x200);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER4, 0x200);
+#if CFG_BOARD_PB45
+    athrs16_reg_write(0x600, 0x200);
+#elif CFG_BOARD_AP96
+    //athrs16_reg_write(0x600, 0x0);
+    athrs16_reg_write(0x600, 0x200);
+#endif
+
+//    athrs16_reg_write(S16_FLD_MASK_REG, 0x003f003f);
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)        
+#ifdef HEADER_EN        
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x6804);
+#else
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x6004);
+#endif
+
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER1, 0x6004);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER2, 0x6004);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER3, 0x6004);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER4, 0x6004);    
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER5, 0x6004);    
+#else
+#ifdef HEADER_EN        
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x4804);
+#else
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x4004);
+#endif
+#endif
+
+#ifdef FULL_FEATURE
+	hsl_dev_init(0, 2);
+#endif
+
+   /* Enable ARP packets to CPU port */
+    athrs16_reg_write(S16_ARL_TBL_CTRL_REG,(athrs16_reg_read(S16_ARL_TBL_CTRL_REG) | 0x100000));
+
+   /* Enable Broadcast packets to CPU port */
+    athrs16_reg_write(S16_FLD_MASK_REG,(athrs16_reg_read(S16_FLD_MASK_REG) | S16_ENABLE_CPU_BROADCAST ));
+
+    athrs16_reg_write(0x80,0x40000000);
+
+    athr16_init_flag = 1;
+#ifdef S16_PHY_DEBUG
+    printf("S16 CPU_PORT_REGISTER :%x\n", athrs16_reg_read ( S16_CPU_PORT_REGISTER ));
+    printf("S16 PORT_STATUS_REGISTER0  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER0 ));
+    printf("S16 PORT_STATUS_REGISTER1  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER1 ));
+    printf("S16 PORT_STATUS_REGISTER2  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER2 ));
+    printf("S16 PORT_STATUS_REGISTER3  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER3 ));
+    printf("S16 PORT_STATUS_REGISTER4  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER4 ));
+
+    printf("S16 PORT_CONTROL_REGISTER0 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER0 ));
+    printf("S16 PORT_CONTROL_REGISTER1 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER1 ));
+    printf("S16 PORT_CONTROL_REGISTER2 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER2 ));
+    printf("S16 PORT_CONTROL_REGISTER3 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER3 ));
+    printf("S16 PORT_CONTROL_REGISTER4 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER4 ));
+#endif
+
+    printf("%s: complete\n",__func__);
+}
+
+/******************************************************************************
+*
+* athrs16_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs16_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs16_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs16_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+    
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        
+        phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,
+                      ATHR_ADVERTISE_ALL);
+
+        phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,
+                      ATHR_ADVERTISE_1000FULL);
+
+        /* Reset PHYs*/
+        phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      ATHR_CTRL_AUTONEGOTIATION_ENABLE 
+                      | ATHR_CTRL_SOFTWARE_RESET);
+
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    sysMsDelay(1000);
+
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+#if 0
+	/* Enable RGMII */
+	phy_reg_write(0,phyUnit,0x1d,0x12);
+	phy_reg_write(0,phyUnit,0x1e,0x8);
+	/* Tx delay on PHY */
+	phy_reg_write(0,phyUnit,0x1d,0x5);
+	phy_reg_write(0,phyUnit,0x1e,0x100);
+        
+	/* Rx delay on PHY */
+	phy_reg_write(0,phyUnit,0x1d,0x0);
+	phy_reg_write(0,phyUnit,0x1e,0x8000);
+#endif
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+        ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit, 
+            phy_reg_read(ATHR_PHYBASE(phyUnit),
+                         ATHR_PHYADDR(phyUnit),
+                         ATHR_PHY_SPEC_STATUS)));
+    }
+    phy_mode_setup();    
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs16_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs16_phy_is_fdx(int ethUnit)
+{
+    int       phyUnit;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read (phyBase, phyAddr, 
+                                               ATHR_PHY_SPEC_STATUS);
+		if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			break;
+                sysMsDelay(10);
+            } while(--ii);
+            
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs16_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100TX;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athrs16_phy_speed(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return _1000BASET;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                              ATHR_PHY_SPEC_STATUS);
+		        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			        break;
+                sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+            
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return _10BASET;
+            case 1:
+                return _100BASET;
+                break;
+            case 2:
+                return _1000BASET;
+                break;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        } 
+
+    }
+
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs16_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS);
+            if (!ATHR_RESET_DONE(phyHwStatus)) {
+                continue;
+            }
+
+            phyHwControl = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+            /* Check for AutoNegotiation complete */            
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+
+    return (linkCount);
+
+}
+
+uint32_t
+athrs16_reg_read(uint32_t reg_addr)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr, tmp_val, reg_val;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as MIBs, since it is read/clear, we should */
+    /* read the lower 16-bit register then the higher one */
+
+    /* read register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    reg_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    tmp_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+    reg_val |= (tmp_val << 16);
+
+    return reg_val;   
+}
+
+void
+athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as ARL and VLAN, since they include BUSY bit */
+    /* in lower address, we should write the higher 16-bit register then the */
+    /* lower one */
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* write register in lower address */
+    reg_word_addr--;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) (reg_val & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val); 
+}
+
+
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/athrs16_phy.h u-boot_1.1//board/ar7240/common/athrs16_phy.h
--- u-boot//board/ar7240/common/athrs16_phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/athrs16_phy.h	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,165 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _ATHRS16_PHY_H
+#define _ATHRS16_PHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+/* S16 CSR Registers */
+
+#define S16_PORT_STATUS_REGISTER0                0x0100 
+#define S16_PORT_STATUS_REGISTER1                0x0200
+#define S16_PORT_STATUS_REGISTER2                0x0300
+#define S16_PORT_STATUS_REGISTER3                0x0400
+#define S16_PORT_STATUS_REGISTER4                0x0500
+#define S16_PORT_STATUS_REGISTER5                0x0600
+
+#define S16_RATE_LIMIT_REGISTER0                 0x010C
+#define S16_RATE_LIMIT_REGISTER1                 0x020C
+#define S16_RATE_LIMIT_REGISTER2                 0x030C
+#define S16_RATE_LIMIT_REGISTER3                 0x040C
+#define S16_RATE_LIMIT_REGISTER4                 0x050C
+#define S16_RATE_LIMIT_REGISTER5                 0x060C
+
+#define S16_PORT_CONTROL_REGISTER0               0x0104
+#define S16_PORT_CONTROL_REGISTER1               0x0204
+#define S16_PORT_CONTROL_REGISTER2               0x0304
+#define S16_PORT_CONTROL_REGISTER3               0x0404
+#define S16_PORT_CONTROL_REGISTER4               0x0504
+#define S16_PORT_CONTROL_REGISTER5               0x0604
+
+#define S16_CPU_PORT_REGISTER                    0x0078
+#define S16_MDIO_CTRL_REGISTER                   0x0098
+
+#define S16_ARL_TBL_FUNC_REG0                0x0050
+#define S16_ARL_TBL_FUNC_REG1                0x0054
+#define S16_ARL_TBL_FUNC_REG2                0x0058
+#define S16_FLD_MASK_REG                     0x002c
+#define S16_ARL_TBL_CTRL_REG                 0x005c
+#define S16_GLOBAL_INTR_REG                  0x10
+#define S16_GLOBAL_INTR_MASK_REG             0x14
+#define S16_PWR_ON_STRAP_REG                 0x8
+
+
+#define S16_ENABLE_CPU_BROADCAST             (1 << 26)
+
+#define S16_PHY_LINK_CHANGE_REG 		     0x4
+#define S16_PHY_LINK_UP 		             0x400
+#define S16_PHY_LINK_DOWN 		             0x800
+#define S16_PHY_LINK_DUPLEX_CHANGE 		     0x2000
+#define S16_PHY_LINK_SPEED_CHANGE		     0x4000
+#define S16_PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+/*add feature define here*/
+//#define FULL_FEATURE
+
+#ifdef CONFIG_AR7242_S16_PHY
+#undef HEADER_REG_CONF
+#undef HEADER_EN
+#endif
+
+void athrs16_reg_init(void);
+int athrs16_phy_is_up(int unit);
+int athrs16_phy_is_fdx(int unit);
+int athrs16_phy_speed(int unit);
+BOOL athrs16_phy_setup(int unit);
+
+#endif
+
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/athrs17_phy.c u-boot_1.1//board/ar7240/common/athrs17_phy.c
--- u-boot//board/ar7240/common/athrs17_phy.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/athrs17_phy.c	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,649 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrs17_phy.h"
+
+/* PHY selections and access functions */
+typedef enum {
+    PHY_SRCPORT_INFO, 
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG, 
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+#define ENET_UNIT_GE0 0
+#define ENET_UNIT_GE1 1
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_IND_PHY 4
+
+#define MODULE_NAME "ATHRS17"
+#define S17_PHY_DEBUG 1
+extern int xmii_val;
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     ATHR_PHY2_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     ATHR_PHY3_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     ENET_UNIT_GE0,//ENET_UNIT_GE1,
+     0,
+     ATHR_PHY4_ADDR, 
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+    
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_GE0,
+     0,
+     0x00, 
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+static uint8_t athr17_init_flag = 0;
+
+//#define ATHR_PHY_MAX (sizeof(ipPhyInfo) / sizeof(ipPhyInfo[0]))
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_GE0))
+            
+/* Forward references */
+BOOL athrs17_phy_is_link_alive(int phyUnit);
+uint32_t athrs17_reg_read(uint32_t reg_addr);
+void athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val);
+static void phy_mode_setup(void);
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+
+static void phy_mode_setup(void) 
+{
+#ifdef ATHRS17_VER_1_0
+    /*work around for phy4 rgmii mode*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);    
+
+    /*rx delay*/ 
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);  
+
+    /*tx delay*/ 
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);    
+#endif
+}
+
+void athrs17_reg_init()
+{
+
+    int phy_addr = 0;
+
+    /* if using header for register configuration, we have to     */
+    /* configure s17 register after frame transmission is enabled */
+    
+    if (athr17_init_flag)
+        return;
+
+    athrs17_reg_write(0x624 , 0x7f7f7f7f);
+    athrs17_reg_write(0x10  , 0x40000000);
+    athrs17_reg_write(0x4   , 0x07600000);
+    athrs17_reg_write(0xc   , 0x01000000);
+    athrs17_reg_write(0x7c  , 0x0000007e);
+
+    /* AR8327/AR8328 v1.0 fixup */
+    if ((athrs17_reg_read(0x0) & 0xffff) == 0x1201)
+    {
+        for (phy_addr = 0x0; phy_addr <= ATHR_PHY_MAX; phy_addr++)
+        {
+            /* For 100M waveform */
+            phy_reg_write(0, phy_addr, 0x1d, 0x0);
+            phy_reg_write(0, phy_addr, 0x1e, 0x02ea);
+            /* Turn On Gigabit Clock */
+            phy_reg_write(0, phy_addr, 0x1d, 0x3d);
+            phy_reg_write(0, phy_addr, 0x1e, 0x68a0);
+        }
+    }
+ 
+
+    athr17_init_flag = 1;
+    printf("%s: complete\n",__func__);
+}
+
+/******************************************************************************
+*
+* athrs17_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs17_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs17_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs17_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+    
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        
+        phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,
+                      ATHR_ADVERTISE_ALL);
+
+        phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,
+                      ATHR_ADVERTISE_1000FULL);
+
+        /* Reset PHYs*/
+        phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      ATHR_CTRL_AUTONEGOTIATION_ENABLE 
+                      | ATHR_CTRL_SOFTWARE_RESET);
+
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    sysMsDelay(1000);
+
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+#if 0
+	/* Enable RGMII */
+	phy_reg_write(0,phyUnit,0x1d,0x12);
+	phy_reg_write(0,phyUnit,0x1e,0x8);
+	/* Tx delay on PHY */
+	phy_reg_write(0,phyUnit,0x1d,0x5);
+	phy_reg_write(0,phyUnit,0x1e,0x100);
+        
+	/* Rx delay on PHY */
+	phy_reg_write(0,phyUnit,0x1d,0x0);
+	phy_reg_write(0,phyUnit,0x1e,0x8000);
+#endif
+        if (athrs17_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+        ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit, 
+            phy_reg_read(ATHR_PHYBASE(phyUnit),
+                         ATHR_PHYADDR(phyUnit),
+                         ATHR_PHY_SPEC_STATUS)));
+    }
+    phy_mode_setup();    
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs17_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs17_phy_is_fdx(int ethUnit)
+{
+    int       phyUnit;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+
+    if (ethUnit == ENET_UNIT_GE0)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs17_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read (phyBase, phyAddr, 
+                                               ATHR_PHY_SPEC_STATUS);
+		if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			break;
+                sysMsDelay(10);
+            } while(--ii);
+            
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs17_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100TX;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athrs17_phy_speed(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_GE0)
+        return _1000BASET;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs17_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                              ATHR_PHY_SPEC_STATUS);
+		        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			        break;
+                sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+            
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return _10BASET;
+            case 1:
+                return _100BASET;
+                break;
+            case 2:
+                return _1000BASET;
+                break;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        } 
+
+    }
+
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs17_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS);
+            if (!ATHR_RESET_DONE(phyHwStatus)) {
+                continue;
+            }
+
+            phyHwControl = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+            /* Check for AutoNegotiation complete */            
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+
+    return (linkCount);
+
+}
+
+uint32_t
+athrs17_reg_read(uint32_t reg_addr)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr, tmp_val, reg_val;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as MIBs, since it is read/clear, we should */
+    /* read the lower 16-bit register then the higher one */
+
+    /* read register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    reg_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    tmp_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+    reg_val |= (tmp_val << 16);
+
+    return reg_val;   
+}
+
+void
+athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as ARL and VLAN, since they include BUSY bit */
+    /* in lower address, we should write the higher 16-bit register then the */
+    /* lower one */
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* write register in lower address */
+    reg_word_addr--;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) (reg_val & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val); 
+}
+
+unsigned int s17_rd_phy(unsigned int phy_addr, unsigned int reg_addr)
+{
+    return ((uint32_t) phy_reg_read(0, phy_addr, reg_addr));
+}
+
+void s17_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data)
+{
+    phy_reg_write(0, phy_addr, reg_addr, write_data);
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/athrs17_phy.h u-boot_1.1//board/ar7240/common/athrs17_phy.h
--- u-boot//board/ar7240/common/athrs17_phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/athrs17_phy.h	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _ATHRS17_PHY_H
+#define _ATHRS17_PHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+/* S17 CSR Registers */
+
+#define S17_ENABLE_CPU_BROADCAST             (1 << 26)
+
+#define S17_PHY_LINK_CHANGE_REG 		     0x4
+#define S17_PHY_LINK_UP 		             0x400
+#define S17_PHY_LINK_DOWN 		             0x800
+#define S17_PHY_LINK_DUPLEX_CHANGE 		     0x2000
+#define S17_PHY_LINK_SPEED_CHANGE		     0x4000
+#define S17_PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+/*add feature define here*/
+//#define FULL_FEATURE
+
+#ifdef CONFIG_AR7242_S17_PHY
+#undef HEADER_REG_CONF
+#undef HEADER_EN
+#endif
+
+void athrs17_reg_init(void);
+int athrs17_phy_is_up(int unit);
+int athrs17_phy_is_fdx(int unit);
+int athrs17_phy_speed(int unit);
+BOOL athrs17_phy_setup(int unit);
+
+#endif
+
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/athr_s27_phy.c u-boot_1.1//board/ar7240/common/athr_s27_phy.c
--- u-boot//board/ar7240/common/athr_s27_phy.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/athr_s27_phy.c	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,891 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athr_s27_phy.h"
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO,
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG,
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define MODULE_NAME "ATHRS27"
+
+/*
+ * Track per-PHY port information.
+ */
+
+
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+
+   {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+
+#define ATHR_GLOBALREGBASE    0
+
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+
+/* Forward references */
+BOOL athrs27_phy_is_link_alive(int phyUnit);
+uint32_t athrs27_reg_read(uint32_t reg_addr);
+void athrs27_reg_write(uint32_t reg_addr, uint32_t reg_val);
+unsigned int s27_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+void s27_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+
+
+void athrs27_powersave_off(int phy_addr)
+{
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0x29);
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x36c0);
+
+}
+void athrs27_sleep_off(int phy_addr)
+{
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0xb);
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x3c00);
+}
+
+void athrs27_force_100M(int phyAddr,int duplex)
+{
+   /*
+    *  Force MDI and MDX to alternate ports 
+    *  Phy 0,2 and 4 -- MDI
+    *  Phy 1 and 3 -- MDX
+    */
+
+    if(phyAddr%2) {
+        s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+    }
+    else {
+        s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+    }
+
+    s27_wr_phy(phyAddr,0x1d,0x29);
+    s27_wr_phy(phyAddr,0x1e,0x0);
+    s27_wr_phy(phyAddr,0x10,0xc60);
+    s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,(0xa000|(duplex << 8)));
+}
+
+void athrs27_force_10M(int phyAddr,int duplex)
+{
+
+    athrs27_powersave_off(phyAddr);
+    athrs27_sleep_off(phyAddr);
+
+    s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,(0x8000 |(duplex << 8)));
+}
+
+int athrs27_reg_init(void)
+{
+#if S27_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+
+    /* if using header for register configuration, we have to     */
+    /* configure s27 register after frame transmission is enabled */
+    athrs27_reg_rmw(0x8,(1<<28));  /* Set WAN port is connected to GE0 */
+
+#if defined(S27_FORCE_100M)
+    athrs27_force_100M(ATHR_PHY4_ADDR,1);
+#elif  defined(S27_FORCE_10M)
+    athrs27_force_10M(ATHR_PHY4_ADDR,1);
+#else
+    s27_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x9000);
+
+#endif
+#ifdef S27_PHY_DEBUG
+    printf(MODULE_NAME":OPERATIONAL_MODE_REG0:%x\n",athrs27_reg_read(OPERATIONAL_MODE_REG0));
+    printf(MODULE_NAME":REG 0x4-->:%x\n",athrs27_reg_read(0x4));
+    printf(MODULE_NAME":REG 0x2c-->:%x\n",athrs27_reg_read(0x2c));
+    printf(MODULE_NAME":REG 0x8-->:%x\n",athrs27_reg_read(0x8));
+#endif
+
+    return 0;
+}
+ 
+int athrs27_reg_init_lan(void)
+{
+    int i = 60;
+#if S26_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+    int       phyUnit;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+
+
+    /* reset switch */
+    printf(MODULE_NAME ": resetting s27\n");
+    athrs27_reg_write(0x0, athrs27_reg_read(0x0)|0x80000000);
+
+    while(i--) {
+        sysMsDelay(100);
+        if(!(athrs27_reg_read(0x0)&0x80000000))
+            break;
+    }
+    printf(MODULE_NAME ": s27 reset done\n");
+    athrs27_reg_write(PORT_STATUS_REGISTER0,0x4e);
+
+    athrs27_reg_rmw(OPERATIONAL_MODE_REG0,(1<<6));  /* Set GMII mode */
+
+    if (is_emu() || is_wasp()) {
+       athrs27_reg_rmw(0x2c,((1<<26)| (1<<16) | 0x1)); /* FiX ME: EBU debug */
+    }
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+#if defined(S27_FORCE_100M)
+        athrs27_force_100M(phyAddr,1);
+#elif defined(S27_FORCE_10M)
+        athrs27_force_10M(phyAddr,1);
+#else
+        s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x9000);
+#endif
+
+#if S27_PHY_DEBUG
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_FUNC_CONTROL);
+        printf("S27 ATHR_PHY_FUNC_CONTROL (%d):%x\n",phyAddr,rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_ID1);
+        printf("S27 PHY ID  (%d) :%x\n",phyAddr, rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_SPEC_STATUS);
+        printf("S27 PHY CTRL  (%d) :%x\n",phyAddr, rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_STATUS);
+        printf("S27 ATHR PHY STATUS  (%d) :%x\n",phyAddr, rd_val);
+#endif
+    }
+
+    /* 
+     * status[1:0]=2'h2;   - (0x10 - 1000 Mbps , 0x01 - 100Mbps, 0x0 - 10 Mbps)
+     * status[2]=1'h1;     - Tx Mac En
+     * status[3]=1'h1;     - Rx Mac En
+     * status[4]=1'h1;     - Tx Flow Ctrl En
+     * status[5]=1'h1;     - Rx Flow Ctrl En
+     * status[6]=1'h1;     - Duplex Mode
+     */
+    athrs27_reg_write(PORT_STATUS_REGISTER1, 0x200);  /* LAN - 1 */
+    athrs27_reg_write(PORT_STATUS_REGISTER2, 0x200);  /* LAN - 2 */
+    athrs27_reg_write(PORT_STATUS_REGISTER3, 0x200);  /* LAN - 3 */
+    athrs27_reg_write(PORT_STATUS_REGISTER4, 0x200);  /* LAN - 4 */
+
+    if (is_emu()) {
+        athrs27_reg_write(PORT_STATUS_REGISTER1, 0x4C);  /* LAN - 1 */
+        athrs27_reg_write(PORT_STATUS_REGISTER2, 0x4c);  /* LAN - 2 */
+        athrs27_reg_write(PORT_STATUS_REGISTER3, 0x4c);  /* LAN - 3 */
+        athrs27_reg_write(PORT_STATUS_REGISTER4, 0x4c);  /* LAN - 4 */
+    }
+
+    /* QM Control */
+    athrs27_reg_write(0x38, 0xc000050e);
+
+    /*
+     * status[11]=1'h0;    - CPU Disable
+     * status[7] = 1'b1;   - Learn One Lock
+     * status[14] = 1'b0;  - Learn Enable
+     */
+#ifdef ATHEROS_HEADER_EN
+    athrs27_reg_write(PORT_CONTROL_REGISTER0, 0x4804);
+#else
+   /* Atheros Header Disable */
+    athrs27_reg_write(PORT_CONTROL_REGISTER0, 0x4004);
+#endif
+
+    /* Tag Priority Mapping */
+    athrs27_reg_write(0x70, 0xfa50);
+
+    /* Enable ARP packets to CPU port */
+    athrs27_reg_write(S27_ARL_TBL_CTRL_REG,(athrs27_reg_read(S27_ARL_TBL_CTRL_REG) | 0x100000));
+
+   /* Enable Broadcast packets to CPU port */
+    athrs27_reg_write(S27_FLD_MASK_REG,(athrs27_reg_read(S27_FLD_MASK_REG) |
+                           S27_ENABLE_CPU_BROADCAST | S27_ENABLE_CPU_BCAST_FWD ));
+
+    return 0;
+}
+
+/******************************************************************************
+*
+* athrs27_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs27_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+    phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs27_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*   
+* Resets the associated PHY port.
+*   
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+BOOL
+athrs27_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+//#if S27_PHY_DEBUG
+    uint32_t  rd_val = 0;
+//#endif
+    uint32_t  ar7240_revid;
+
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+        if (!is_emu()) {
+           s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+
+           s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+        }
+        else  {
+		printf("############ is emulation ############\n");
+
+           if(ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN) {
+               s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+               s27_wr_phy(phyAddr,0x9, 0x0); //donot advertise 1000Mbps mode
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,0x0);
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+           }
+           else { 
+
+               s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,(ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE |
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL));
+               s27_wr_phy(phyAddr,0x9, 0x0); //donot advertise 1000Mbps mode
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,0x0);
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+           }
+       }
+       rd_val = s27_rd_phy(phyAddr,ATHR_PHY_CONTROL);
+       printf("%s ATHR_PHY_CONTROL %d :%x\n",__func__,phyAddr,rd_val);
+       rd_val = s27_rd_phy(phyAddr,ATHR_PHY_SPEC_STATUS);
+       printf("%s ATHR_PHY_SPEC_STAUS %d :%x\n",__func__,phyAddr,rd_val);
+    }
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    if (ethUnit == ENET_UNIT_LAN)
+        sysMsDelay(1000);
+    else
+        sysMsDelay(3000);
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN)
+            continue;
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus =  s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+        /* extend the cable length */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x14);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xf52);
+
+       /* Force Class A setting phys */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 4);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xebbb);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 5);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0x2c47);
+
+        /* fine-tune PHYs */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x3c);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0x1c1);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x37);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xd600);
+
+
+#ifdef S27_VER_1_0
+        /* turn off power saving */
+        s27_wr_phy(phyUnit, 29, 41);
+        s27_wr_phy(phyUnit, 30, 0);
+        printf("def_ S27_VER_1_0\n");
+#endif
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit,
+            s27_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS)));
+    }
+
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs27_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs27_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = s27_rd_phy (phyAddr, ATHR_PHY_SPEC_STATUS);
+                        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+                                break;
+                sysMsDelay(10);
+            } while(--ii);
+            if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+            }
+        }
+    }
+
+    return FALSE;
+}
+/******************************************************************************
+*
+* athrs27_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               ATHR_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               ATHR_PHY_SPEED_1000T;
+*/
+
+int
+athrs27_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+    int       phySpeed;
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        phySpeed = _10BASET;
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+
+            do {
+                phyHwStatus = s27_rd_phy(phyAddr,
+                                              ATHR_PHY_SPEC_STATUS);
+                        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+                                break;
+                sysMsDelay(10);
+            }while(--ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                phySpeed = _10BASET;
+		break;
+            case 1:
+                phySpeed = _100BASET;
+		break;
+            case 2:
+                phySpeed = _1000BASET;
+		break;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+
+        phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x18);
+
+        if(phySpeed == _100BASET) {
+            phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_DATA, 0xba8);
+        } else {
+            phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_DATA, 0x2ea);
+        }
+    }
+
+    if (ethUnit == ENET_UNIT_LAN)
+         phySpeed = _1000BASET;
+
+    return phySpeed;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs27_phy_is_up(int ethUnit)
+{
+
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+    int           phyUnit;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                printf("enet%d port%d down\n",ethUnit, phyUnit);
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            if(is_emu())
+            {
+                phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_STATUS);
+                if(phyAddr%2) {
+                    s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+                }
+                else {
+                    s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+                }
+
+                if((phyHwStatus & 0x4)==0)
+                {
+                   s27_wr_phy(phyAddr,0x9,0x0);
+                   if(phyAddr !=0x4)
+                       s27_wr_phy(phyAddr,0x4,0x41);
+                   s27_wr_phy(phyAddr,0x0,0x9000);
+                }
+            }
+
+            phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+             phyHwControl = s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+             phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_STATUS);
+
+            /* Check for AutoNegotiation complete */
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = s27_rd_phy(phyAddr,
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                printf("enet%d port%d up\n",ethUnit, phyUnit);
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+    return (linkCount);
+}
+
+unsigned int athrs27_reg_read(unsigned int s27_addr)
+{
+    unsigned int addr_temp;
+    unsigned int s27_rd_csr_low, s27_rd_csr_high, s27_rd_csr;
+    unsigned int data,unit = 0;
+    unsigned int phy_address, reg_address;
+
+    addr_temp = s27_addr >>2;
+    data = addr_temp >> 7;
+
+    phy_address = 0x1f;
+    reg_address = 0x10;
+
+    if (is_ar7240()) {
+        unit = 0;
+    }
+    else if(is_ar7241() || is_ar7242() || is_wasp()) {
+        unit = 1;
+    }
+
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+    reg_address = ((addr_temp << 1) & 0x1e);
+    s27_rd_csr_low = (uint32_t) phy_reg_read(unit,phy_address, reg_address);
+
+    reg_address = reg_address | 0x1;
+    s27_rd_csr_high = (uint32_t) phy_reg_read(unit,phy_address, reg_address);
+    s27_rd_csr = (s27_rd_csr_high << 16) | s27_rd_csr_low ;
+	
+    return(s27_rd_csr);
+}
+
+void athrs27_reg_write(unsigned int s27_addr, unsigned int s27_write_data)
+{
+    unsigned int addr_temp;
+    unsigned int data;
+    unsigned int phy_address, reg_address,unit = 0;
+
+    addr_temp = (s27_addr ) >>2;
+    data = addr_temp >> 7;
+
+    phy_address = 0x1f;
+    reg_address = 0x10;
+
+    if (is_ar7240()) {
+        unit = 0;
+    }
+    else if(is_ar7241() || is_ar7242() || is_wasp()) {
+        unit = 1;
+    }
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+
+    reg_address = (((addr_temp << 1) & 0x1e) | 0x1);
+    data = (s27_write_data >> 16) & 0xffff;
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    reg_address = ((addr_temp << 1) & 0x1e);
+    data = s27_write_data  & 0xffff;
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+}
+
+void athrs27_reg_rmw(unsigned int s27_addr, unsigned int s27_write_data)
+{
+    int val = athrs27_reg_read(s27_addr);
+    athrs27_reg_write(s27_addr,(val | s27_write_data));
+}
+
+unsigned int s27_rd_phy(unsigned int phy_addr, unsigned int reg_addr)
+{
+
+     unsigned int rddata, i = 100;
+
+
+    /* MDIO_CMD is set for read */
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = (rddata & 0x0) | (reg_addr<<16)
+              | (phy_addr<<21) | (1<<27)
+              | (1<<30) | (1<<31) ;
+
+    athrs27_reg_write(0x98, rddata);
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & (1<<31);
+
+    /* Check MDIO_BUSY status */
+    while(rddata && --i){
+        rddata = athrs27_reg_read(0x98);
+        rddata = rddata & (1<<31);
+    }
+
+    if(i <= 0)
+      printf("ERROR:%s failed:phy:%d reg:%X rddata:%X\n",
+                __func__,phy_addr,reg_addr,rddata);
+    /* Read the data from phy */
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & 0xffff;
+    return(rddata);
+}
+void s27_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data)
+{
+    unsigned int rddata,i = 100;
+
+    /* MDIO_CMD is set for read */
+
+    rddata = athrs27_reg_read(0x98);
+
+    rddata = (rddata & 0x0) | (write_data & 0xffff)
+               | (reg_addr<<16) | (phy_addr<<21)
+               | (0<<27) | (1<<30) | (1<<31) ;
+
+    athrs27_reg_write(0x98, rddata);
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & (1<<31);
+
+    /* Check MDIO_BUSY status */
+    while(rddata && --i){
+        rddata = athrs27_reg_read(0x98);
+        rddata = rddata & (1<<31);
+    }
+    if(i <= 0)
+      printf("ERROR:%s failed:phy:%d reg%X\n",__func__,phy_addr,reg_addr);
+
+}
+
+int athrs27_mdc_check()
+{
+    int i;
+
+    for (i=0; i<4000; i++) {
+        if(athrs27_reg_read(0x10c) != 0x18007fff)
+            return -1;
+    }
+    return 0;
+}
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/athr_s27_phy.h u-boot_1.1//board/ar7240/common/athr_s27_phy.h
--- u-boot//board/ar7240/common/athr_s27_phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/athr_s27_phy.h	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,208 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS27_PHY_H
+#define _ATHRS27_PHY_H
+
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_FUNC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+#define ATHR_PHY_INTR_ENABLE             0x12
+#define ATHR_PHY_INTR_STATUS             0x13
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+#define ATHR_ADVERTISE_1000HALF		      0x0100
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DUPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_LATCH_LINK_PASS                  0x0004 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+#define OPERATIONAL_MODE_REG0                0x4
+
+/* S27 CSR Registers */
+
+#define PORT_STATUS_REGISTER0                0x0100 
+#define PORT_STATUS_REGISTER1                0x0200
+#define PORT_STATUS_REGISTER2                0x0300
+#define PORT_STATUS_REGISTER3                0x0400
+#define PORT_STATUS_REGISTER4                0x0500
+#define PORT_STATUS_REGISTER5                0x0600
+
+#define RATE_LIMIT_REGISTER0                 0x010C
+#define RATE_LIMIT_REGISTER1                 0x020C
+#define RATE_LIMIT_REGISTER2                 0x030C
+#define RATE_LIMIT_REGISTER3                 0x040C
+#define RATE_LIMIT_REGISTER4                 0x050C
+#define RATE_LIMIT_REGISTER5                 0x060C
+
+#define PORT_CONTROL_REGISTER0               0x0104
+#define PORT_CONTROL_REGISTER1               0x0204
+#define PORT_CONTROL_REGISTER2               0x0304
+#define PORT_CONTROL_REGISTER3               0x0404
+#define PORT_CONTROL_REGISTER4               0x0504
+#define PORT_CONTROL_REGISTER5               0x0604
+
+#define CPU_PORT_REGISTER                    0x0078
+#define MDIO_CTRL_REGISTER                   0x0098
+
+#define S27_ARL_TBL_FUNC_REG0                0x0050
+#define S27_ARL_TBL_FUNC_REG1                0x0054
+#define S27_ARL_TBL_FUNC_REG2                0x0058
+#define S27_FLD_MASK_REG                     0x002c
+#define S27_ARL_TBL_CTRL_REG                 0x005c
+#define S27_GLOBAL_INTR_REG                  0x10
+#define S27_GLOBAL_INTR_MASK_REG             0x14
+
+
+#define S27_ENABLE_CPU_BROADCAST             (1 << 26)
+#define S27_ENABLE_CPU_BCAST_FWD             (1 << 25)
+
+#define PHY_LINK_CHANGE_REG 		     0x4
+#define PHY_LINK_UP 		             0x400
+#define PHY_LINK_DOWN 		             0x800
+#define PHY_LINK_DUPLEX_CHANGE 		     0x2000
+#define PHY_LINK_SPEED_CHANGE		     0x4000
+#define PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+/* SWITCH QOS REGISTERS */
+
+#define ATHR_QOS_PORT_0			0x110 /* CPU PORT */
+#define ATHR_QOS_PORT_1			0x210
+#define ATHR_QOS_PORT_2			0x310
+#define ATHR_QOS_PORT_3			0x410
+#define ATHR_QOS_PORT_4			0x510
+
+#define ATHR_ENABLE_TOS                 (1 << 16)
+
+#define ATHR_QOS_MODE_REGISTER          0x030
+#define ATHR_QOS_FIXED_PRIORITY        ((0 << 31) | (0 << 28))
+#define ATHR_QOS_WEIGHTED              ((1 << 31) | (0 << 28)) /* Fixed weight 8,4,2,1 */
+#define ATHR_QOS_MIXED                 ((1 << 31) | (1 << 28)) /* Q3 for managment; Q2,Q1,Q0 - 4,2,1 */
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+#define mdelay(_x)      sysMsDelay(_x)
+
+#undef S27_VER_1_0
+
+/*
+ *  Atheros header defines
+ */
+#ifndef _ATH_HEADER_CONF
+#define _ATH_HEADER_CONF
+
+typedef enum {
+    NORMAL_PACKET,
+    RESERVED0,
+    MIB_1ST,
+    RESERVED1,
+    RESERVED2,
+    READ_WRITE_REG,
+    READ_WRITE_REG_ACK,
+    RESERVED3
+} AT_HEADER_TYPE;
+
+typedef struct {
+    uint16_t    reserved0  :2;
+    uint16_t    priority   :2;
+    uint16_t    type       :4;
+    uint16_t    broadcast  :1;
+    uint16_t    from_cpu   :1;
+    uint16_t    reserved1  :2;
+    uint16_t    port_num   :4;
+}at_header_t;
+
+#define ATHR_HEADER_LEN 2
+
+#endif // _ATH_HEADER_CONF
+
+typedef enum {
+    PORT_EG_UNMODIFIED = 0,  /**<  egress transmit packets unmodified */
+    PORT_EG_UNTAGGED,        /**<  egress transmit packets without vlan tag */
+    PORT_EG_TAGGED,          /**<  egress transmit packets with vlan tag */
+} port_1q_egmode_t;
+
+extern void set_packet_inspection_flag(int flag);
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/athrsf1_phy.c u-boot_1.1//board/ar7240/common/athrsf1_phy.c
--- u-boot//board/ar7240/common/athrsf1_phy.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/athrsf1_phy.c	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,434 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrsf1_phy.h"
+
+#define MODULE_NAME "ATHRSF1_PHY"
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY_MAX 5
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+ 
+/* Forward references */
+BOOL athr_phy_is_link_alive(int phyUnit);
+unsigned int last_phy_speed;
+
+void athr_enable_linkIntrs(int ethUnit) 
+{
+    return;
+}
+
+void athr_disable_linkIntrs(int ethUnit) 
+{
+	return;
+}
+void athr_auto_neg(int ethUnit,int phyUnit) 
+{ 
+    int timeout = 0;
+    uint16_t phyHwStatus;
+    
+    if(!is_emu()) {
+#if 0
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+       phy_reg_write(ethUnit, phyUnit , ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       phy_reg_write(ethUnit, phyUnit , ATHR_1000BASET_CONTROL, ATHR_ADVERTISE_1000FULL);
+#endif
+
+       printf("ATHR_AUTONEG_ADVERT:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_AUTONEG_ADVERT));
+       printf("ATHR_1000BASET_CONTROL:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_1000BASET_CONTROL));
+       printf("ATHR_PHY_CONTROL:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_PHY_CONTROL));
+    }
+    else {
+       phy_reg_write(ethUnit, phyUnit , ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       /* Do not advertise 1000 */
+       phy_reg_write(ethUnit, phyUnit , ATHR_1000BASET_CONTROL,0x0);
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+   /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    timeout=20;
+    for (;;) {
+        phyHwStatus = phy_reg_read(ethUnit, phyUnit, ATHR_PHY_CONTROL);
+
+        if (ATHR_RESET_DONE(phyHwStatus)) {
+            printf(MODULE_NAME": Port %d, Neg Success\n", phyUnit);
+            break;
+        }
+        if (timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+        if (--timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+
+        mdelay(150);
+    }
+
+    printf(MODULE_NAME": unit %d phy addr %x ", ethUnit, phyUnit);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_phy_is_link_alive(int phyUnit)
+{
+	uint16_t phyHwStatus;
+	uint32_t phyBase;
+	uint32_t phyAddr;
+
+	phyBase = ATHR_PHYBASE(phyUnit);
+	phyAddr = ATHR_PHYADDR(phyUnit);
+	phyHwStatus = phy_reg_read(0, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+	if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_phy_setup(int ethUnit)
+{
+	int       phyUnit = 0;
+	int       liveLinks = 0;
+
+	athr_auto_neg(ethUnit,phyUnit);
+
+	if (athr_phy_is_link_alive(phyUnit)) {
+		liveLinks++;
+		ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+	} else {
+		ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+	}
+	return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+         phyBase = ATHR_PHYBASE(phyUnit);
+         phyAddr = ATHR_PHYADDR(phyUnit);
+
+         do {
+                phyHwStatus = phy_reg_read(ethUnit, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+                mdelay(10);
+          } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+          
+          if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+          }
+    }
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        do {
+            phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+            mdelay(10);
+        } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+        phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                       ATHER_STATUS_LINK_SHIFT);
+
+        switch(phyHwStatus) {
+        case 0:
+            if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x147);
+                last_phy_speed = phyHwStatus;
+            }
+            return _10BASET;
+        case 1:
+            if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x147);
+                last_phy_speed = phyHwStatus;
+            }
+            return _100BASET;
+        case 2:
+            if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x0);
+                last_phy_speed = phyHwStatus;
+            }
+            return _1000BASET;
+        default:
+            printf("Unkown speed read!\n");
+        }
+    }
+
+    if (last_phy_speed != phyHwStatus)
+    {
+        phy_reg_write(0, ATHR_PHYADDR(phyUnit), ATHR_DEBUG_PORT_ADDRESS, 0x0);
+        phy_reg_write(0, ATHR_PHYADDR(phyUnit), ATHR_DEBUG_PORT_DATA, 0x14e);
+        last_phy_speed = phyHwStatus;
+    }
+
+
+    //printf("athr_phy_speed: link down, returning 10t\n");
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < 1; phyUnit++) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+
+             phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) { /* check realtime link */
+                linkCount++;
+            } else {
+                phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+            /* If realtime failed check link in latch register before
+	     * asserting link down.
+             */
+                if (phyHwStatus & ATHR_LATCH_LINK_PASS)     
+                   linkCount++;
+		else
+                    lostLinks++;
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+
+            /* Check for reset complete */
+
+                phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+                phyHwControl = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_CONTROL);
+
+            /* Check for AutoNegotiation complete */ 
+           
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                    phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+                    if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                        gainedLinks++;
+                        linkCount++;
+                        lastStatus->isPhyAlive = TRUE;
+                   }  
+            }
+        }
+    }
+    return (linkCount);
+
+}
+/* Place holders */
+
+int 
+athr_reg_init(void *arg)
+{
+   return 0;
+}
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/athrsf1_phy.h u-boot_1.1//board/ar7240/common/athrsf1_phy.h
--- u-boot//board/ar7240/common/athrsf1_phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/athrsf1_phy.h	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS26_RGMII_H
+#define _ATHRS26_RGMII_H
+#define BOOL int
+#include "athr_s27_phy.h"
+int athr_phy_is_up(int unit);
+int athr_phy_is_fdx(int unit,int phyUnit);
+int athr_phy_speed(int unit,int phyUnit);
+BOOL athr_phy_setup(int unit);
+BOOL athr_phy_is_link_alive(int phyUnit);
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/athrsf2_phy.c u-boot_1.1//board/ar7240/common/athrsf2_phy.c
--- u-boot//board/ar7240/common/athrsf2_phy.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/athrsf2_phy.c	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,377 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrsf1_phy.h"
+
+#define MODULE_NAME "ATHRSF2_PHY"
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY_MAX 5
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_PHY5_ADDR   0x5
+
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,                /* phy Base */
+     ATHR_PHY5_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+ 
+/* Forward references */
+BOOL athr_phy_is_link_alive(int phyUnit);
+
+void athr_enable_linkIntrs(int ethUnit) 
+{
+    return;
+}
+
+void athr_disable_linkIntrs(int ethUnit) 
+{
+	return;
+}
+void athr_auto_neg(int ethUnit,int phyUnit) 
+{ 
+    int timeout = 0;
+    uint16_t phyHwStatus;
+    int phyBase = 0,phyAddr =0;
+    
+    phyUnit = 0;
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    if(!is_emu()) {
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+
+       printf("ATHR_AUTONEG_ADVERT:%X\n",phy_reg_read(phyBase, phyAddr,ATHR_AUTONEG_ADVERT));
+       printf("ATHR_1000BASET_CONTROL:%X\n",phy_reg_read(phyBase, phyAddr,ATHR_1000BASET_CONTROL));
+       printf("ATHR_PHY_CONTROL:%X\n",phy_reg_read(phyBase, phyAddr,ATHR_PHY_CONTROL));
+    }
+    else {
+       phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       /* Do not advertise 1000 */
+       phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,0x0);
+       phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+   /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    timeout=20;
+    for (;;) {
+        phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+        if (ATHR_RESET_DONE(phyHwStatus)) {
+            printf(MODULE_NAME": Port %d, Neg Success\n", phyUnit);
+            break;
+        }
+        if (timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+        if (--timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+
+        mdelay(150);
+    }
+
+    printf(MODULE_NAME": unit %d phy addr %x ", phyBase, phyAddr);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_phy_is_link_alive(int phyUnit)
+{
+	uint16_t phyHwStatus;
+	uint32_t phyBase;
+	uint32_t phyAddr;
+
+	phyBase = ATHR_PHYBASE(phyUnit);
+	phyAddr = ATHR_PHYADDR(phyUnit);
+
+	phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+	if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_phy_setup(int ethUnit)
+{
+	int       phyUnit = 0;
+	int       liveLinks = 0;
+
+	athr_auto_neg(ethUnit,phyUnit);
+
+	if (athr_phy_is_link_alive(phyUnit)) {
+		liveLinks++;
+		ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+	} else {
+		ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+	}
+	return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    phyUnit = 0;
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+         phyBase = ATHR_PHYBASE(phyUnit);
+         phyAddr = ATHR_PHYADDR(phyUnit);
+
+         do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr,ATHR_PHY_SPEC_STATUS);
+                mdelay(10);
+          } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+          
+          if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+          }
+    }
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+
+    phyUnit = 0;
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        do {
+            phyHwStatus = phy_reg_read(phyBase, phyAddr,ATHR_PHY_SPEC_STATUS);
+            mdelay(10);
+        } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+        phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                       ATHER_STATUS_LINK_SHIFT);
+
+        switch(phyHwStatus) {
+        case 0:
+            return _10BASET;
+        case 1:
+            return _100BASET;
+        case 2:
+            return _1000BASET;
+        default:
+            printf("Unkown speed read!!!!\n");
+        }
+    }
+
+    //printf("athr_phy_speed: link down, returning 10t\n");
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit= 0; phyUnit < 1; phyUnit++) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+
+             phyHwStatus = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) { /* check realtime link */
+                linkCount++;
+            } else {
+                phyHwStatus = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+            /* If realtime failed check link in latch register before
+	     * asserting link down.
+             */
+                if (phyHwStatus & ATHR_LATCH_LINK_PASS)     
+                   linkCount++;
+		else
+                    lostLinks++;
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+
+            /* Check for reset complete */
+
+                phyHwStatus = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+                phyHwControl = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_CONTROL);
+
+            /* Check for AutoNegotiation complete */ 
+           
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                    phyHwStatus = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+                    if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                        gainedLinks++;
+                        linkCount++;
+                        lastStatus->isPhyAlive = TRUE;
+                   }  
+            }
+        }
+    }
+    return (linkCount);
+
+}
+/* Place holders */
+
+int 
+athr_reg_init(void *arg)
+{
+   /* Feed 50 Mhz internal clk */
+   ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0);
+   printf("F2 phy:%s\n",__func__);
+   return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/athrs_vir_phy.c u-boot_1.1//board/ar7240/common/athrs_vir_phy.c
--- u-boot//board/ar7240/common/athrs_vir_phy.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/athrs_vir_phy.c	2014-02-18 01:46:24.799050917 -0800
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+
+#define MODULE_NAME "ATHRS_VIR_PHY"
+
+#define TRUE    1
+#define FALSE   0
+#define BOOL	int
+
+/* Forward references */
+BOOL athr_vir_phy_is_link_alive(int phyUnit);
+
+
+/******************************************************************************
+*
+* athr_vir_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_vir_phy_is_link_alive(int phyUnit)
+{
+    return TRUE;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_vir_phy_setup(int ethUnit)
+{
+    return 0;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_vir_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    return TRUE;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_vir_phy_speed(int ethUnit,int phyUnit)
+{
+    return _1000BASET;
+}
+
+/*****************************************************************************
+*
+* athr_vir_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_vir_phy_is_up(int ethUnit)
+{
+    return 1;
+
+}
+/* Place holders */
+
+int 
+athr_vir_reg_init(void *arg)
+{
+   return 0;
+}
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/lowlevel_init_934x-1.1.S u-boot_1.1//board/ar7240/common/lowlevel_init_934x-1.1.S
--- u-boot//board/ar7240/common/lowlevel_init_934x-1.1.S	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/lowlevel_init_934x-1.1.S	2014-02-18 01:46:24.827050929 -0800
@@ -0,0 +1,427 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7240_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define set_val(_reg, _mask, _val)		\
+	li	t7,	KSEG1ADDR(_reg);	\
+	lw	t8,	0(t7);			\
+	li	t9,	~_mask;			\
+	and	t8,	t8,	t9;		\
+	li	t9,	_val;			\
+	or	t8,	t8,	t9;		\
+	sw	t8,	0(t7)
+
+#define cpu_pll_set(_mask, _val)	\
+	set_val(AR934X_CPU_PLL_CONFIG, _mask, _val)
+
+#define ddr_pll_set(_mask, _val)	\
+	set_val(AR934X_DDR_PLL_CONFIG, _mask, _val)
+
+#define cpu_ddr_control_set(_mask, _val)	\
+	set_val(AR934X_CPU_DDR_CLOCK_CONTROL, _mask, _val)
+
+#define set_bb_pll(reg, val)		\
+	li	t7,	KSEG1ADDR(reg);	\
+	li	t8,	val;		\
+	sw	t8,	0(t7);
+
+#define set_srif_pll(reg, val)		\
+	li	t7,	KSEG1ADDR(reg);	\
+	li	t8,	val;		\
+	sw	t8,	0(t7);
+
+#define set_srif_pll_reg(reg, _r)	\
+	li	t7,	KSEG1ADDR(reg);	\
+	sw	_r,	0(t7);
+
+#define inc_loop_count(loc)		\
+	li	t9,	loc;		\
+	lw	t7,	0(t9);		\
+	addi	t7,	t7,	1;	\
+	sw	t7,	0(t9);
+
+#define clear_loop_count(loc)	\
+	li	t9,	loc;	\
+	sw	zero,	0(t9);
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl ar934x_1_dot_1_lowlevel_init
+	.type	ar934x_1_dot_1_lowlevel_init, @function
+	.text
+	.align 4
+ar934x_1_dot_1_lowlevel_init:
+
+	set_bb_pll(DPLL2_ADDRESS_c4, 0x13210f00);
+	set_bb_pll(DPLL3_ADDRESS_c8, 0x03000000);
+	set_bb_pll(DPLL2_ADDRESS_44, 0x13210f00);
+	set_bb_pll(DPLL3_ADDRESS_48, 0x03000000);
+	set_bb_pll(DPLL3_ADDRESS_88, 0x03000000);
+
+	li	t5,	KSEG1ADDR(WASP_BOOTSTRAP_REG);
+	li	t6,	WASP_REF_CLK_25
+	lw	t7,	0(t5);
+	and	t6,	t7,	t6
+	beq	zero,	t6,	setup_ref25_val
+	nop
+setup_ref40_val:
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL_40
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL_40
+	li	t7,	CPU_PLL_NFRAC_40
+	li	t9,	DDR_PLL_NFRAC_40
+	b	1f
+	nop
+
+setup_ref25_val:
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL_25
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL_25
+	li	t7,	CPU_PLL_NFRAC_25
+	li	t9,	DDR_PLL_NFRAC_25
+
+1:
+	li	t4,	(CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+			CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+	or	t4,	t4,	t7
+
+	li	t8,	(CPU_PLL_CONFIG_REF_DIV_VAL | \
+			CPU_PLL_CONFIG_RANGE_VAL | \
+			CPU_PLL_CONFIG_OUT_DIV_VAL2);
+	or	t5,	t5,	t8
+
+	li	t8,	(DDR_PLL_CONFIG_REF_DIV_VAL | \
+			DDR_PLL_CONFIG_RANGE_VAL | \
+			DDR_PLL_CONFIG_OUT_DIV_VAL2);
+	or	t6,	t6,	t8
+
+#if 0 /* !defined(CONFIG_AP123) && !defined(CONFIG_MI124) */
+	/*
+	 * From: Ravi Subramanian
+	 * Subject: Workaround for 5G RX reset-reset variation
+	 * Date: Mon, 30 Aug 2010 12:53:49 +0530
+	 *
+	 * We are observing a reset to reset issue related to 5G RX
+	 * performance (and EVM). As a workaround, pushing the DDR
+	 * frequency from 400 MHz to 406 MHz, fixes this issue.
+	 * Could you please give us a new u-boot with the following
+	 * change?
+	 */
+	li	t3,	(DDR_PLL_DITHER_DITHER_EN_SET(1) | \
+			DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#else
+	li	t3,	(DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+			DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#endif
+
+	or	t3,	t3,	t9
+
+	li	t7,	PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	PLL_MAGIC
+	beq	t7,	t8,	read_from_flash
+	nop
+	j	pll_bypass_set
+	nop
+read_from_flash:
+	li	t7,	PLL_CONFIG_VAL_F + 4
+	lw	t5,	0(t7)
+	lw	t4,	4(t7)
+	lw	t6,	8(t7)
+	lw	t3,	12(t7)
+
+
+pll_bypass_set:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+init_cpu_pll:
+	li	t7,	KSEG1ADDR(AR934X_CPU_PLL_CONFIG);
+	li	t8,	CPU_PLL_CONFIG_PLLPWD_SET(1)
+	or	t8,	t8,	t5
+	sw	t8,	0(t7);
+
+init_ddr_pll:
+	li	t7,	KSEG1ADDR(AR934X_DDR_PLL_CONFIG);
+	li	t8,	DDR_PLL_CONFIG_PLLPWD_SET(1)
+	or	t8,	t8,	t6
+	sw	t8,	0(t7);
+
+init_ahb_pll:
+	li	t7,	KSEG1ADDR(AR934X_CPU_DDR_CLOCK_CONTROL);
+	li	t8,	(CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL | \
+			CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR | \
+			CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR | \
+			CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU | \
+			CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV | \
+			CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV | \
+			CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1) | \
+			CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1) | \
+			CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+	sw	t8,	0(t7);
+#define cpu_from_srif	1
+#define ddr_from_srif	1
+
+pll_pwd_unset:
+#if !cpu_from_srif
+	cpu_pll_set(CPU_PLL_CONFIG_PLLPWD_MASK, CPU_PLL_CONFIG_PLLPWD_SET(0));
+#endif
+#if !ddr_from_srif
+	ddr_pll_set(DDR_PLL_CONFIG_PLLPWD_MASK, DDR_PLL_CONFIG_PLLPWD_SET(0));
+#endif
+
+srif_set:
+	/* See if we have to read the pll values from flash */
+	li	t7,	SRIF_PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	SRIF_PLL_MAGIC
+	beq	t7,	t8,	read_srif_from_flash
+	nop
+
+	/* Use built in values, based on ref clock */
+	li	t5,	KSEG1ADDR(WASP_BOOTSTRAP_REG);
+	li	t6,	WASP_REF_CLK_25
+	lw	t7,	0(t5);
+	and	t6,	t7,	t6
+	beq	zero,	t6,	1f
+	nop
+#if !defined(CONFIG_AP123)
+	/*		refdiv		nint		nfrac */
+#if cpu_from_srif
+	li	t4,	((0x8 << 27) | (112 << 18) | 0);// cpu freq = (40 MHz refclk/refdiv 8) * Nint
+#endif
+#if ddr_from_srif
+#ifdef CONFIG_ATH_NAND_SUPPORT
+	li	t5,	((0x8 << 27) | (160 << 18) | 0);// ddr freq = (40 MHz refclk/refdiv 8) * Nint
+#else
+	li	t5,	((0x8 << 27) | (90 << 18) | 0);	// ddr freq = (40 MHz refclk/refdiv 8) * Nint
+#endif /* CONFIG_ATH_NAND_SUPPORT */
+#endif
+	j	2f
+	nop
+1:
+#if cpu_from_srif
+	li	t4,	((0x5 << 27) | (112 << 18) | 0);// cpu freq = (25 MHz refclk/refdiv 5) * Nint
+#endif
+#if ddr_from_srif
+#ifdef CONFIG_ATH_NAND_SUPPORT
+	li	t5,	((0x5 << 27) | (160 << 18) | 0);// ddr freq = (25 MHz refclk/refdiv 5) * Nint
+#else
+	li	t5,	((0x5 << 27) | (90 << 18) | 0);	// ddr freq = (25 MHz refclk/refdiv 5) * Nint
+#endif /* CONFIG_ATH_NAND_SUPPORT */
+#endif
+	j	2f
+	nop
+#else	/* defined(CONFIG_AP123) */
+	/*		refdiv		nint		nfrac */
+#if cpu_from_srif
+	li	t4,	((0x8 << 27) | (107 << 18) | 0);// cpu freq = (40 MHz refclk/refdiv 8) * Nint
+#endif
+#if ddr_from_srif
+	li	t5,	((0x8 << 27) | (160 << 18) | 0);// ddr freq = (40 MHz refclk/refdiv 8) * Nint
+#endif
+	j	2f
+	nop
+1:
+#if cpu_from_srif
+	li	t4,	((0x5 << 27) | (107 << 18) | 0);// cpu freq = (25 MHz refclk/refdiv 5) * Nint
+#endif
+#if ddr_from_srif
+	li	t5,	((0x5 << 27) | (160 << 18) | 0);// ddr freq = (25 MHz refclk/refdiv 5) * Nint
+#endif
+	j	2f
+	nop
+#endif	/* !defined(CONFIG_AP123) */
+
+read_srif_from_flash:
+	li	t7,	SRIF_PLL_CONFIG_VAL_F + 4
+#if cpu_from_srif
+	lw	t4,	0(t7);	// CPU PLL
+#endif
+#if ddr_from_srif
+	lw	t5,	4(t7);	// DDR PLL
+#endif
+	/* CPU */
+2:
+
+	clear_loop_count(ATH_CPU_COUNT_LOC);
+
+cpu_pll_is_not_locked:
+
+	inc_loop_count(ATH_CPU_COUNT_LOC);
+
+#if cpu_from_srif
+	set_srif_pll(0xb81161c4, (0x4 << 26) | (0x10 << 19) | (0x1e << 7) | (1 << 16));
+	set_srif_pll_reg(0xb81161c0, t4);
+	set_srif_pll(0xb81161c4, (0x3 << 30) | (0x4 << 26) | (0x10 << 19) | (0x1e << 7) | (1 << 16));
+	set_srif_pll(0xb81161c8, (6 << 23));
+	set_srif_pll(0xb81161c4, (0x3 << 30) | (0x4 << 26) | (0x10 << 19) | (0x1e << 7));
+
+cpu_clear_do_meas1:
+	li	t7,	KSEG1ADDR(CPU_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	~CPU_DPLL3_DO_MEAS_SET(1)
+	and	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+cpu_set_do_meas:
+	li	t7,	KSEG1ADDR(CPU_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	CPU_DPLL3_DO_MEAS_SET(1)
+	or	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+	li	t7,	KSEG1ADDR(CPU_DPLL4_ADDRESS)
+cpu_wait_for_meas_done:
+	lw	t8,	0(t7)
+	andi	t8,	t8,	CPU_DPLL4_MEAS_DONE_SET(1)
+	beqz	t8,	cpu_wait_for_meas_done
+	nop
+
+cpu_clear_do_meas2:
+	li	t7,	KSEG1ADDR(CPU_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	~CPU_DPLL3_DO_MEAS_SET(1)
+	and	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+cpu_read_sqsum_dvc:
+	li	t7,	KSEG1ADDR(CPU_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	CPU_DPLL3_SQSUM_DVC_MASK
+	and	t8,	t8,	t9
+	sra	t8,	t8,	CPU_DPLL3_SQSUM_DVC_LSB
+	li	t9,	0x40000
+	subu	t8,	t8,	t9
+	bgez	t8,	cpu_pll_is_not_locked
+	nop
+
+#endif
+
+	/* DDR */
+#if ddr_from_srif
+
+	clear_loop_count(ATH_DDR_COUNT_LOC)
+
+ddr_pll_is_not_locked:
+
+	inc_loop_count(ATH_DDR_COUNT_LOC)
+
+#if defined(CONFIG_ATH_NAND_SUPPORT)
+	set_srif_pll(0xb8116244, (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7) | (1 << 16));
+	set_srif_pll_reg(0xb8116240, t5);
+	set_srif_pll(0xb8116244, (0x1 << 30) | (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7) | (1 << 16));
+	set_srif_pll(0xb8116248, (6 << 23));
+	set_srif_pll(0xb8116244, (0x1 << 30) | (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7));
+#elif !defined(CONFIG_AP123)
+	set_srif_pll(0xb8116244, (0x4 << 26) | (0x10 << 19) | (0x1e << 7) | (1 << 16));
+	set_srif_pll_reg(0xb8116240, t5);
+	set_srif_pll(0xb8116244, (0x3 << 30) | (0x4 << 26) | (0x10 << 19) | (0x1e << 7) | (1 << 16));
+	set_srif_pll(0xb8116248, (6 << 23));
+	set_srif_pll(0xb8116244, (0x3 << 30) | (0x4 << 26) | (0x10 << 19) | (0x1e << 7));
+#else /* defined(CONFIG_AP123) */
+	/* AP123 uses outdiv = 1 for ddr pll */
+	set_srif_pll(0xb8116244, (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7) | (1 << 16));
+	set_srif_pll_reg(0xb8116240, t5);
+	set_srif_pll(0xb8116244, (0x1 << 30) | (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7) | (1 << 16));
+	set_srif_pll(0xb8116248, (6 << 23));
+	set_srif_pll(0xb8116244, (0x1 << 30) | (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7));
+#endif /* !defined(CONFIG_AP123) */
+
+ddr_clear_do_meas1:
+	li	t7,	KSEG1ADDR(DDR_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	~DDR_DPLL3_DO_MEAS_SET(1)
+	and	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+
+ddr_set_do_meas:
+	li	t7,	KSEG1ADDR(DDR_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	DDR_DPLL3_DO_MEAS_SET(1)
+	or	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+	li	t7,	KSEG1ADDR(DDR_DPLL4_ADDRESS)
+ddr_wait_for_meas_done:
+	lw	t8,	0(t7)
+	andi	t8,	t8,	DDR_DPLL4_MEAS_DONE_SET(1)
+	beqz	t8,	ddr_wait_for_meas_done
+	nop
+
+ddr_clear_do_meas2:
+	li	t7,	KSEG1ADDR(DDR_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	~DDR_DPLL3_DO_MEAS_SET(1)
+	and	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+ddr_read_sqsum_dvc:
+	li	t7,	KSEG1ADDR(DDR_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	DDR_DPLL3_SQSUM_DVC_MASK
+	and	t8,	t8,	t9
+	sra	t8,	t8,	DDR_DPLL3_SQSUM_DVC_LSB
+	li	t9,	0x40000
+	subu	t8,	t8,	t9
+	bgez	t8,	ddr_pll_is_not_locked
+	nop
+#endif
+
+pll_bypass_unset:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(0));
+
+ddr_pll_dither_unset:
+	li	t7,	KSEG1ADDR(AR934X_DDR_PLL_DITHER);
+	sw	t3,	0(t7);
+
+cpu_pll_dither_unset:
+	li	t7,	KSEG1ADDR(AR934X_CPU_PLL_DITHER);
+	sw	t4,	0(t7);
+
+	jr ra
+	nop
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/lowlevel_init_934x.S u-boot_1.1//board/ar7240/common/lowlevel_init_934x.S
--- u-boot//board/ar7240/common/lowlevel_init_934x.S	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/lowlevel_init_934x.S	2014-02-18 01:46:24.827050929 -0800
@@ -0,0 +1,202 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7240_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define set_val(_reg, _mask, _val)		\
+	li	t7,	KSEG1ADDR(_reg);	\
+	lw	t8,	0(t7);			\
+	li	t9,	~_mask;			\
+	and	t8,	t8,	t9;		\
+	li	t9,	_val;			\
+	or	t8,	t8,	t9;		\
+	sw	t8,	0(t7)
+
+#define cpu_pll_set(_mask, _val)	\
+	set_val(AR934X_CPU_PLL_CONFIG, _mask, _val)
+
+#define ddr_pll_set(_mask, _val)	\
+	set_val(AR934X_DDR_PLL_CONFIG, _mask, _val)
+
+#define cpu_ddr_control_set(_mask, _val)	\
+	set_val(AR934X_CPU_DDR_CLOCK_CONTROL, _mask, _val)
+
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl ar934x_lowlevel_init
+	.type	ar934x_lowlevel_init, @function
+.globl lowlevel_init
+	.type	lowlevel_init, @function
+	.text
+	.align 4
+
+ar934x_lowlevel_init:
+lowlevel_init:
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	li	t7,	AR7240_REV_ID
+	lw	t7,	0(t7)
+	andi	t9,	t7,	0xf
+	bne	zero,	t9,	ar934x_1_dot_1_lowlevel_init
+	nop
+
+	li	t5,	KSEG1ADDR(WASP_BOOTSTRAP_REG);
+	li	t6,	WASP_REF_CLK_25
+	lw	t7,	0(t5);
+	and	t6,	t7,	t6
+	beq	zero,	t6,	setup_ref25_val
+	nop
+setup_ref40_val:
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL_40
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL_40
+	b	1f
+	nop
+
+setup_ref25_val:
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL_25
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL_25
+
+1:
+	li	t4,	(CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+			CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+			CPU_PLL_NFRAC_MIN_SET | \
+			CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#if 0
+	/*
+	 * From: Ravi Subramanian
+	 * Subject: Workaround for 5G RX reset-reset variation
+	 * Date: Mon, 30 Aug 2010 12:53:49 +0530
+	 *
+	 * We are observing a reset to reset issue related to 5G RX
+	 * performance (and EVM). As a workaround, pushing the DDR
+	 * frequency from 400 MHz to 406 MHz, fixes this issue.
+	 * Could you please give us a new u-boot with the following
+	 * change?
+	 */
+	li	t3,	(DDR_PLL_DITHER_DITHER_EN_SET(1) | \
+			DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+			DDR_PLL_DITHER_NFRAC_MIN_SET(0x200) | \
+			DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#else
+	li	t3,	(DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+			DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+			DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#endif
+
+	li	t7,	PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	PLL_MAGIC
+	beq	t7,	t8,	read_from_flash
+	nop
+	j	pll_bypass_set
+	nop
+read_from_flash:
+	li	t7,	PLL_CONFIG_VAL_F + 4
+	lw	t5,	0(t7)
+	lw	t4,	4(t7)
+	lw	t6,	8(t7)
+	lw	t3,	12(t7)
+
+
+pll_bypass_set:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+init_cpu_pll:
+	li	t7,	KSEG1ADDR(AR934X_CPU_PLL_CONFIG);
+	li	t8,	(CPU_PLL_CONFIG_PLLPWD_SET(1) | \
+			CPU_PLL_CONFIG_REF_DIV_VAL | \
+			CPU_PLL_CONFIG_RANGE_VAL | \
+			CPU_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t5
+	sw	t8,	0(t7);
+
+init_ddr_pll:
+	li	t7,	KSEG1ADDR(AR934X_DDR_PLL_CONFIG);
+	li	t8,	(DDR_PLL_CONFIG_PLLPWD_SET(1) | \
+			DDR_PLL_CONFIG_REF_DIV_VAL | \
+			DDR_PLL_CONFIG_RANGE_VAL | \
+			DDR_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t6
+	sw	t8,	0(t7);
+
+init_ahb_pll:
+	li	t7,	KSEG1ADDR(AR934X_CPU_DDR_CLOCK_CONTROL);
+	li	t8,	(CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL | \
+			CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR | \
+			CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR | \
+			CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU | \
+			CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV | \
+			CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV | \
+			CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1) | \
+			CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1) | \
+			CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+	sw	t8,	0(t7);
+
+pll_pwd_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_PLLPWD_MASK, CPU_PLL_CONFIG_PLLPWD_SET(0));
+	ddr_pll_set(DDR_PLL_CONFIG_PLLPWD_MASK, DDR_PLL_CONFIG_PLLPWD_SET(0));
+
+outdiv_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_OUTDIV_MASK, CPU_PLL_CONFIG_OUT_DIV_VAL2);
+	ddr_pll_set(DDR_PLL_CONFIG_OUTDIV_MASK, DDR_PLL_CONFIG_OUT_DIV_VAL2);
+
+pll_bypass_unset:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(0));
+
+ddr_pll_dither_unset:
+	li	t7,	KSEG1ADDR(AR934X_DDR_PLL_DITHER);
+	sw	t3,	0(t7);
+
+cpu_pll_dither_unset:
+	li	t7,	KSEG1ADDR(AR934X_CPU_PLL_DITHER);
+	sw	t4,	0(t7);
+
+#endif
+	jr ra
+	nop
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/lowlevel_init.S u-boot_1.1//board/ar7240/common/lowlevel_init.S
--- u-boot//board/ar7240/common/lowlevel_init.S	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/lowlevel_init.S	2014-02-18 01:46:24.803050920 -0800
@@ -0,0 +1,234 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7240_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define clear_mask(_reg, _mask)                     \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+#define set_val(_reg, _mask, _val)                  \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t9, _val;                                   \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+#define set_val_f(_reg, _mask, _val)                \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t6, KSEG1ADDR(_val);                        \
+    lw  t9, 0(t6);                                  \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+
+#define get_val(_reg, _mask, _shift, _res_reg)      \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, _mask;                                  \
+    and t8, t8, t9;                                 \
+    srl _res_reg, t8, _shift                        \
+
+#define pll_clr(_mask)                              \
+    clear_mask(AR7240_CPU_PLL_CONFIG, _mask)
+
+#define pll_set(_mask, _val)                        \
+    set_val(AR7240_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_set_f(_mask, _val)                      \
+    set_val_f(AR7240_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_get(_mask, _shift, _res_reg)            \
+    get_val(AR7240_CPU_PLL_CONFIG, _mask, _shift, _res_reg)
+
+#define clk_clr(_mask)                              \
+    clear_mask(AR7240_CPU_CLOCK_CONTROL, _mask)
+
+#define clk_set(_mask, _val)                        \
+    set_val(AR7240_CPU_CLOCK_CONTROL,  _mask, _val)
+
+#define clk_get(_mask, _shift, _res_reg)            \
+    get_val(AR7240_CPU_CLOCK_CONTROL, _mask, _shift, _res_reg)
+
+
+/******************************************************************************
+ * first level initialization:
+ * 
+ * 0) If clock cntrl reset switch is already set, we're recovering from 
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ * 
+ *****************************************************************************/
+
+.globl lowlevel_init
+
+lowlevel_init:
+
+    /*
+     * The code below is for the real chip. Wont work on FPGA
+     */
+    /* jr ra  */
+
+#if !defined(CONFIG_AR7240_EMU) && defined(CONFIG_WASP_SUPPORT)
+#if !defined(CONFIG_ATH_NAND_BR)
+	b ar934x_lowlevel_init
+#endif
+#else
+
+#ifndef CONFIG_HORNET_EMU
+#if defined(CONFIG_MACH_HORNET)
+    b hornet_pll_init
+#else
+wdt_reset:
+#ifndef CONFIG_AR7240_EMU
+	li	$3, -1207566336		# 0xffffffffb8060000
+	ori	$4, $3, 0x8
+	lw	$2, 0($4)
+	bltz	$2, $L6
+	nop
+	ori	$5, $3, 0xc
+
+	li	$3, 300			# 0x4
+	sw	$3, 0($5)
+	li	$3, 3			# 0x3
+	sw	$3, 0($4)
+$L3:
+	b	$L3
+	nop
+#endif
+$L6:
+	nop
+	nop
+#ifndef CONFIG_AR7240_EMU
+#ifndef COMPRESSED_UBOOT
+
+    /* 
+     * WAR for the bug#55574: Set the CKE (bit 7 in DDR_CONFIG2 register) 
+     * to low initially 
+     */
+    li  t7, KSEG1ADDR(AR7240_DDR_CONFIG2);
+    lw  t8, 0(t7);
+    li  t9, 0xffffff7f;
+    and t8, t8, t9;
+    sw  t8, 0(t7);
+#endif
+
+    /*
+     * Check if the PLL is already set and CPU is Reset
+     */
+    clk_get(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CONTROL_RST_SWITCH_SHIFT, t6)
+    bne zero, t6, initialize_pll
+    nop
+
+init_pll_values:
+    li  a2,PLL_CONFIG_VAL_F                 # 0xffffffffbf040000
+    lw  a0,0(a2)
+    li  v1,PLL_MAGIC                        # 0xffffffffaabb0000
+    beq a0,v1,read_pll_from_flash
+    nop
+
+#ifdef CONFIG_SUPPORT_AR7241
+    li  t7, KSEG1ADDR(AR7240_REV_ID)
+    lw  t8, 0(t7)
+    li  t9, AR7240_REV_ID_MASK
+    and t8, t8, t9
+    li  v1, AR7241_REV_1_0
+    beq t8,v1,init_7241_pll
+    nop
+    li  v1, AR7242_REV_1_0
+    beq t8,v1,init_7241_pll
+    nop
+    bne t8,v1,init_default
+
+init_7241_pll:
+    pll_clr(PLL_CONFIG_PLL_RESET_MASK)
+    pll_set( (PLL_CONFIG_DDR_DIV_MASK | PLL_CONFIG_AHB_DIV_MASK | PLL_CONFIG_PLL_NOPWD_MASK | PLL_CONFIG_PLL_REF_DIV_MASK | PLL_CONFIG_PLL_DIV_MASK) ,( PLL_7241_CONFIG_PLL_REF_DIV_VAL|PLL_7241_CONFIG_PLL_DIV_VAL|PLL_7241_CONFIG_AHB_DIV_VAL|PLL_7241_CONFIG_DDR_DIV_VAL|PLL_CONFIG_PLL_NOPWD_VAL))
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK) 
+    b wait_for_pll_update
+    nop
+
+init_default:
+#endif
+
+    pll_clr(PLL_CONFIG_PLL_RESET_MASK)
+    pll_set( (PLL_CONFIG_DDR_DIV_MASK | PLL_CONFIG_AHB_DIV_MASK | PLL_CONFIG_PLL_NOPWD_MASK | PLL_CONFIG_PLL_REF_DIV_MASK | PLL_CONFIG_PLL_DIV_MASK) ,( PLL_CONFIG_PLL_REF_DIV_VAL|PLL_CONFIG_PLL_DIV_VAL|PLL_CONFIG_AHB_DIV_VAL|PLL_CONFIG_DDR_DIV_VAL|PLL_CONFIG_PLL_NOPWD_VAL))
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK) 
+    b wait_for_pll_update
+    nop
+
+read_pll_from_flash:
+    pll_clr(PLL_CONFIG_PLL_RESET_MASK)
+    pll_set_f((PLL_CONFIG_DDR_DIV_MASK | PLL_CONFIG_AHB_DIV_MASK | PLL_CONFIG_PLL_NOPWD_MASK | PLL_CONFIG_PLL_REF_DIV_MASK | PLL_CONFIG_PLL_DIV_MASK) ,((PLL_CONFIG_VAL_F + 4) | PLL_CONFIG_PLL_NOPWD_VAL))
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK) 
+    b wait_for_pll_update
+    nop
+
+
+wait_for_pll_update:
+    pll_get(PLL_CONFIG_PLL_UPDATE_MASK, PLL_CONFIG_PLL_UPDATE_SHIFT, t6)
+    bne zero, t6, wait_for_pll_update
+    nop
+
+    /*
+     * Will cause a reset
+     * The RESET_SWITCH need to be set first and then 
+     * set the CLOCK_SWITCH for the CPU to boot properly
+     * after RESET.
+     */
+pll_locked:
+    clk_set(CLOCK_CONTROL_RST_SWITCH_MASK, 0x2)
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 0x1)
+    nop
+
+    /*
+     * When the PLL is already set and CPU is RESET
+     * The code will jump here
+     */
+initialize_pll:
+    clk_clr(CLOCK_CONTROL_RST_SWITCH_MASK)
+    clk_clr(CLOCK_CONTROL_CLOCK_SWITCH_MASK)
+#endif
+#endif /* CONFIG_MACH_HORNET */
+#endif /* CONFIG_HORNET_EMU */
+#endif /* CONFIG_MAC_WASP */
+    jr ra
+    nop
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/common/phy.h u-boot_1.1//board/ar7240/common/phy.h
--- u-boot//board/ar7240/common/phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/common/phy.h	2014-02-18 01:46:24.827050929 -0800
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _PHY_H
+#define _PHY_H
+
+#include <config.h>
+/*
+ * This file defines the interface between MAC and various phy switches.
+ */
+#define ag7240_unit2name(_unit) _unit ?  "eth1" : "eth0"
+extern int  ag7240_miiphy_read(char *devname, uint32_t phaddr,
+		uint8_t reg, uint16_t *data);
+extern int  ag7240_miiphy_write(char *devname, uint32_t phaddr,
+		uint8_t reg, uint16_t data);
+
+#define phy_reg_read(base, addr, reg)                    \
+    ag7240_miiphy_read(ag7240_unit2name(base), addr, reg, NULL)
+#define phy_reg_write(base, addr, reg, data)                   \
+        ag7240_miiphy_write(ag7240_unit2name(base), addr, reg, data)
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x/config.mk u-boot_1.1//board/ar7240/db12x/config.mk
--- u-boot//board/ar7240/db12x/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x/config.mk	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,57 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+ifdef BOOT_FROM_NAND #{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0xa0100000
+else #}{
+TEXT_BASE = 0xa0100000
+endif #}
+else #}{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else #}{
+TEXT_BASE = 0x9f000000
+endif #}
+endif #}
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
+
+export BOARD_EXTRA_OBJS_tmp =
+
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(BOARDDIR)/extra.o
+ifeq ($(BOOT_FROM_NAND),1)
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(VENDOR)/common/ath_nand.o $(TOPDIR)/drivers/nand/nand_ids.o
+endif
+
+ifeq ($(COMPRESSED_UBOOT),1) #{
+BOARD_EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x/db12x.c u-boot_1.1//board/ar7240/db12x/db12x.c
--- u-boot//board/ar7240/db12x/db12x.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x/db12x.c	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,151 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#	define args		char *s
+#	define board_str(a)	do {			\
+	char ver[] = "0";				\
+	strcpy(s, "U-Boot " a "Wasp 1.");		\
+	ver[0] += ar7240_reg_rd(AR7240_REV_ID) & 0xf;	\
+	strcat(s, ver);					\
+} while (0)
+#else
+#	define prmsg		printf
+#	define args		void
+#	define board_str(a)	printf(a)
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ar7240_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ar7240_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ar7240_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ar7240_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+}
+
+int
+wasp_mem_config(void)
+{
+	extern void ath_ddr_tap_cal(void);
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	ath_ddr_tap_cal();
+
+	prmsg("Tap value selected = 0x%x [0x%x - 0x%x]\n",
+		ar7240_reg_rd(AR7240_DDR_TAP_CONTROL0),
+		ar7240_reg_rd(0xbd007f10), ar7240_reg_rd(0xbd007f14));
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+
+	wasp_gpio_config();
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+int	checkboard(args)
+{
+#if CONFIG_AP123
+	board_str("AP123\n");
+#elif CONFIG_MI124
+	board_str("MI124\n");
+#else
+	board_str("DB120\n");
+#endif
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x/extra.c u-boot_1.1//board/ar7240/db12x/extra.c
--- u-boot//board/ar7240/db12x/extra.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x/extra.c	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+void *
+ath_get_nand_cal_data(void)
+{
+        ulong           off,size;
+        int             ret;
+        static u_char   nand_cal_data[256 * 1024];
+        nand_info_t *nand;
+
+         /*
+          * caldata partition is of 128k
+          *
+          */
+        nand = &nand_info[nand_curr_device];
+        size = nand->erasesize;
+
+        /*
+         * Get the Offset of Caldata partition
+         */
+        off = ath_nand_get_cal_offset(getenv("bootargs"));
+        if(off == ATH_CAL_OFF_INVAL) {
+                printf("Invalid CAL offset \n");
+                return 1;
+        }
+
+        /*
+         * Get the values from flash, and program into the MAC address
+         * registers
+         */
+        ret = nand_read(nand, (loff_t)off, &size, nand_cal_data);
+        printf(" %d bytes %s: %s\n", size,
+                        "read", ret ? "ERROR" : "OK");
+        if(ret != 0 ) {
+                return NULL;
+        }
+
+        return nand_cal_data;
+}
+#endif
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep;
+	uint32_t	val;
+
+#ifdef CONFIG_ATH_NAND_BR
+        eep = (ar9300_eeprom_t *)ath_get_nand_cal_data();
+#else
+        eep = (ar9300_eeprom_t *)WLANCAL;
+#endif /* CONFIG_ATH_NAND_BR */
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	printf("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x/flash.c u-boot_1.1//board/ar7240/db12x/flash.c
--- u-boot//board/ar7240/db12x/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x/flash.c	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x/Makefile u-boot_1.1//board/ar7240/db12x/Makefile
--- u-boot//board/ar7240/db12x/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x/Makefile	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,100 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+#
+# The files included in EXTRA_OBJS use some functions that are not
+# available in the `bootstrap' portion of tuboot.bin resulting in
+# compile/link errors. Hence have them separate (i.e. don't include
+# into lib$(BOARD).a and include them only in `u-boot' portion of
+# tuboot.bin.
+#
+
+ifeq ($(strip $(COMPRESSED_UBOOT)),0) #{
+OBJS	+= $(BOARD_EXTRA_OBJS_tmp)
+else
+EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif #}
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS) $(EXTRA_OBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x/u-boot-bootstrap.lds u-boot_1.1//board/ar7240/db12x/u-boot-bootstrap.lds
--- u-boot//board/ar7240/db12x/u-boot-bootstrap.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x/u-boot-bootstrap.lds	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x/u-boot.lds u-boot_1.1//board/ar7240/db12x/u-boot.lds
--- u-boot//board/ar7240/db12x/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x/u-boot.lds	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x-extender/config.mk u-boot_1.1//board/ar7240/db12x-extender/config.mk
--- u-boot//board/ar7240/db12x-extender/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x-extender/config.mk	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,41 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x-extender/db12x-extender.c u-boot_1.1//board/ar7240/db12x-extender/db12x-extender.c
--- u-boot//board/ar7240/db12x-extender/db12x-extender.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x-extender/db12x-extender.c	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,158 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_BR)
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ar7240_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x-extender/flash.c u-boot_1.1//board/ar7240/db12x-extender/flash.c
--- u-boot//board/ar7240/db12x-extender/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x-extender/flash.c	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x-extender/Makefile u-boot_1.1//board/ar7240/db12x-extender/Makefile
--- u-boot//board/ar7240/db12x-extender/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x-extender/Makefile	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,84 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o 
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif 
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x-extender/u-boot-bootstrap.lds u-boot_1.1//board/ar7240/db12x-extender/u-boot-bootstrap.lds
--- u-boot//board/ar7240/db12x-extender/u-boot-bootstrap.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x-extender/u-boot-bootstrap.lds	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x-extender/u-boot.lds u-boot_1.1//board/ar7240/db12x-extender/u-boot.lds
--- u-boot//board/ar7240/db12x-extender/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x-extender/u-boot.lds	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x-hybrid/config.mk u-boot_1.1//board/ar7240/db12x-hybrid/config.mk
--- u-boot//board/ar7240/db12x-hybrid/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x-hybrid/config.mk	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,41 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x-hybrid/db12x-hybrid.c u-boot_1.1//board/ar7240/db12x-hybrid/db12x-hybrid.c
--- u-boot//board/ar7240/db12x-hybrid/db12x-hybrid.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x-hybrid/db12x-hybrid.c	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,192 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ar7240_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ar7240_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ar7240_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ar7240_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+#ifdef CONFIG_AP123
+	extern void ath_ddr_tap_cal(void);
+#endif
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+#ifdef CONFIG_AP123
+	ath_ddr_tap_cal();
+
+#ifndef COMPRESSED_UBOOT
+	printf("Tap value selected = 0x%x [0x%x - 0x%x]\n",
+		ar7240_reg_rd(AR7240_DDR_TAP_CONTROL0),
+		ar7240_reg_rd(0xbd007f10), ar7240_reg_rd(0xbd007f14));
+#endif
+#endif
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */ 
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x-hybrid/flash.c u-boot_1.1//board/ar7240/db12x-hybrid/flash.c
--- u-boot//board/ar7240/db12x-hybrid/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x-hybrid/flash.c	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x-hybrid/Makefile u-boot_1.1//board/ar7240/db12x-hybrid/Makefile
--- u-boot//board/ar7240/db12x-hybrid/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x-hybrid/Makefile	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,90 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif 
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x-hybrid/u-boot-bootstrap.lds u-boot_1.1//board/ar7240/db12x-hybrid/u-boot-bootstrap.lds
--- u-boot//board/ar7240/db12x-hybrid/u-boot-bootstrap.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x-hybrid/u-boot-bootstrap.lds	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/db12x-hybrid/u-boot.lds u-boot_1.1//board/ar7240/db12x-hybrid/u-boot.lds
--- u-boot//board/ar7240/db12x-hybrid/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/db12x-hybrid/u-boot.lds	2014-02-18 01:46:24.827050930 -0800
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/dhp1565/config.mk u-boot_1.1//board/ar7240/dhp1565/config.mk
--- u-boot//board/ar7240/dhp1565/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/dhp1565/config.mk	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,41 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/dhp1565/dhp1565.c u-boot_1.1//board/ar7240/dhp1565/dhp1565.c
--- u-boot//board/ar7240/dhp1565/dhp1565.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/dhp1565/dhp1565.c	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,193 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_BR)
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ar7240_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */ 
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/dhp1565/flash.c u-boot_1.1//board/ar7240/dhp1565/flash.c
--- u-boot//board/ar7240/dhp1565/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/dhp1565/flash.c	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/dhp1565/Makefile u-boot_1.1//board/ar7240/dhp1565/Makefile
--- u-boot//board/ar7240/dhp1565/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/dhp1565/Makefile	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,84 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o 
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif 
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/dhp1565/u-boot-bootstrap.lds u-boot_1.1//board/ar7240/dhp1565/u-boot-bootstrap.lds
--- u-boot//board/ar7240/dhp1565/u-boot-bootstrap.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/dhp1565/u-boot-bootstrap.lds	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/dhp1565/u-boot.lds u-boot_1.1//board/ar7240/dhp1565/u-boot.lds
--- u-boot//board/ar7240/dhp1565/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/dhp1565/u-boot.lds	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/reh132/config.mk u-boot_1.1//board/ar7240/reh132/config.mk
--- u-boot//board/ar7240/reh132/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/reh132/config.mk	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,41 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/reh132/flash.c u-boot_1.1//board/ar7240/reh132/flash.c
--- u-boot//board/ar7240/reh132/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/reh132/flash.c	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/reh132/Makefile u-boot_1.1//board/ar7240/reh132/Makefile
--- u-boot//board/ar7240/reh132/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/reh132/Makefile	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,84 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o 
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif 
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/reh132/reh132.c u-boot_1.1//board/ar7240/reh132/reh132.c
--- u-boot//board/ar7240/reh132/reh132.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/reh132/reh132.c	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,198 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+        /*  Enable xLNBIAS signal on GPIO (19, 20) */
+        ar7240_reg_wr (AR7240_GPIO_FUNC4, ((ar7240_reg_rd(AR7240_GPIO_FUNC4) & 0x00ffffff)) | 0x2f000000);
+        ar7240_reg_wr (AR7240_GPIO_FUNC5, ((ar7240_reg_rd(AR7240_GPIO_FUNC5) & 0xffffff00)) | 0x2e);
+        ar7240_reg_wr (AR7240_GPIO_OE, (ar7240_reg_rd(AR7240_GPIO_OE) & 0xffe7ffff));
+
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_FL)
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ar7240_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */ 
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot REH132\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot REH132\n");
+#endif
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/reh132/u-boot-bootstrap.lds u-boot_1.1//board/ar7240/reh132/u-boot-bootstrap.lds
--- u-boot//board/ar7240/reh132/u-boot-bootstrap.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/reh132/u-boot-bootstrap.lds	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/reh132/u-boot.lds u-boot_1.1//board/ar7240/reh132/u-boot.lds
--- u-boot//board/ar7240/reh132/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/reh132/u-boot.lds	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/wasp_emu/config.mk u-boot_1.1//board/ar7240/wasp_emu/config.mk
--- u-boot//board/ar7240/wasp_emu/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/wasp_emu/config.mk	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,31 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+# TEXT_BASE = 0x9f000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+#TEXT_BASE = 0x83fc0000
+TEXT_BASE = 0x80100000
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/wasp_emu/flash.c u-boot_1.1//board/ar7240/wasp_emu/flash.c
--- u-boot//board/ar7240/wasp_emu/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/wasp_emu/flash.c	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/wasp_emu/Makefile u-boot_1.1//board/ar7240/wasp_emu/Makefile
--- u-boot//board/ar7240/wasp_emu/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/wasp_emu/Makefile	2014-02-18 01:46:24.847050957 -0800
@@ -0,0 +1,40 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/athr_s27_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/wasp_emu/u-boot.lds u-boot_1.1//board/ar7240/wasp_emu/u-boot.lds
--- u-boot//board/ar7240/wasp_emu/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/wasp_emu/u-boot.lds	2014-02-18 01:46:24.851050956 -0800
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/ar7240/wasp_emu/wasp_emu.c u-boot_1.1//board/ar7240/wasp_emu/wasp_emu.c
--- u-boot//board/ar7240/wasp_emu/wasp_emu.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/ar7240/wasp_emu/wasp_emu.c	2014-02-18 01:46:24.851050956 -0800
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+#if !defined(CONFIG_WASP_EMU)
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004); 
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+#endif 
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+	printf("Wasp Emulation U-boot\n");
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board953x/board953x.c u-boot_1.1//board/atheros/board953x/board953x.c
--- u-boot//board/atheros/board953x/board953x.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board953x/board953x.c	2014-02-18 01:46:24.871050964 -0800
@@ -0,0 +1,151 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#	define args		char *s
+#	define board_str(a)	do {			\
+	char ver[] = "0";				\
+	strcpy(s, a " - Honey Bee 1.");			\
+	ver[0] += ath_reg_rd(RST_REVISION_ID_ADDRESS)	\
+						& 0xf;	\
+	strcat(s, ver);					\
+} while (0)
+#else
+#	define prmsg	printf
+#	define args		void
+#	define board_str(a)				\
+	printf(a " - Honey Bee 1.%d", ath_reg_rd	\
+			(RST_REVISION_ID_ADDRESS) & 0xf)
+#endif
+
+void
+ath_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if (ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_TESTROM_ENABLE_MASK) {
+
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+		udelay(1000);
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+		udelay(1000);
+
+		ath_reg_wr(PHY_CTRL5_ADDRESS, PHY_CTRL5_RESET_1);
+		udelay(1000);
+
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+		udelay(1000);
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+		udelay(1000);
+
+		ath_reg_rmw_clear(RST_CLKGAT_EN_ADDRESS, RST_CLKGAT_EN_USB1_SET(1));
+
+		return;
+	}
+
+	ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+		ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+		SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	udelay(1000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS,
+				RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+	udelay(10);
+}
+
+void ath_gpio_config(void)
+{
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+	/* Set GPIO 13 as input for LED functionality to be OFF during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 13));
+	/* Turn off JUMPST_LED and 5Gz LED during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 15));
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 12));
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32, *tap;
+	extern uint32_t *ath_ddr_tap_cal(void);
+
+#if !defined(CONFIG_ATH_EMULATION)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	tap = ath_ddr_tap_cal();
+	prmsg("tap = 0x%p\n", tap);
+
+	tap = (uint32_t *)0xbd001f10;
+	prmsg("Tap (low, high) = (0x%x, 0x%x)\n", tap[0], tap[1]);
+
+	tap = (uint32_t *)TAP_CONTROL_0_ADDRESS;
+	prmsg("Tap values = (0x%x, 0x%x, 0x%x, 0x%x)\n",
+		tap[0], tap[2], tap[2], tap[3]);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 & ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+
+	ath_usb_initial_config();
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	return ath_ddr_find_size();
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(args)
+{
+	board_str(CONFIG_BOARD_NAME);
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board953x/config.mk u-boot_1.1//board/atheros/board953x/config.mk
--- u-boot//board/atheros/board953x/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board953x/config.mk	2014-02-18 01:46:24.871050964 -0800
@@ -0,0 +1,45 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else #}{
+TEXT_BASE = 0x9f000000
+endif #}
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
+
+export BOARD_EXTRA_OBJS_tmp =
+
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(BOARDDIR)/extra.o
+
+ifeq ($(COMPRESSED_UBOOT),1) #{
+BOARD_EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board953x/extra.c u-boot_1.1//board/atheros/board953x/extra.c
--- u-boot//board/atheros/board953x/extra.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board953x/extra.c	2014-02-18 01:46:24.871050964 -0800
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep;
+	uint32_t	val;
+
+        eep = (ar9300_eeprom_t *)WLANCAL;
+
+	val =	XTAL_TCXODET_SET(0x0) |
+		XTAL_XTAL_CAPINDAC_SET(0x4b) |
+		XTAL_XTAL_CAPOUTDAC_SET(0x4b) |
+		XTAL_XTAL_DRVSTR_SET(0x3) |
+		XTAL_XTAL_SHORTXIN_SET(0x0) |
+		XTAL_XTAL_LOCALBIAS_SET(0x1) |
+		XTAL_XTAL_PWDCLKD_SET(0x0) |
+		XTAL_XTAL_BIAS2X_SET(0x0) |
+		XTAL_XTAL_LBIAS2X_SET(0x0) |
+		XTAL_XTAL_OSCON_SET(0x1) |
+		XTAL_XTAL_PWDCLKIN_SET(0x0) |
+		XTAL_LOCAL_XTAL_SET(0x0) |
+		XTAL_PWD_SWREGCLK_SET(0x0) |
+		XTAL_SPARE_SET(0x0);
+
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		val &= ~(XTAL_XTAL_CAPINDAC_MASK | XTAL_XTAL_CAPOUTDAC_MASK);
+		val |=	XTAL_XTAL_CAPINDAC_SET(eep->params_for_tuning_caps[0]) |
+			XTAL_XTAL_CAPOUTDAC_SET(eep->params_for_tuning_caps[0]);
+	}
+
+	ath_reg_wr(XTAL_ADDRESS, val);
+	ath_reg_wr(XTAL2_ADDRESS, XTAL2_DCA_BYPASS_SET(0x1) |
+					XTAL2_FSM_START_L_SET(0x1));
+	ath_reg_wr(XTAL3_ADDRESS, XTAL3_EVAL_LENGTH_SET(0x400) |
+					XTAL3_HARMONIC_NUMBER_SET(0x51));
+
+#define __str(x)	# x
+#define str(x)		__str(x)
+
+	printf("Setting " str(XTAL_ADDRESS) " to 0x%x\n", val);
+	return;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board953x/flash.c u-boot_1.1//board/atheros/board953x/flash.c
--- u-boot//board/atheros/board953x/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board953x/flash.c	2014-02-18 01:46:24.871050964 -0800
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board953x/Makefile u-boot_1.1//board/atheros/board953x/Makefile
--- u-boot//board/atheros/board953x/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board953x/Makefile	2014-02-18 01:46:24.871050964 -0800
@@ -0,0 +1,90 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-953x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-953x.o
+
+#
+# The files included in EXTRA_OBJS use some functions that are not
+# available in the `bootstrap' portion of tuboot.bin resulting in
+# compile/link errors. Hence have them separate (i.e. don't include
+# into lib$(BOARD).a and include them only in `u-boot' portion of
+# tuboot.bin.
+#
+
+ifeq ($(strip $(COMPRESSED_UBOOT)),0) #{
+OBJS	+= $(BOARD_EXTRA_OBJS_tmp)
+else
+EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif #}
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ATH_RGMII_CAL),1)
+OBJS	+= ../common/rgmii-cal-953x.o	
+OBJS	+= ../common/athrs17_lpbk.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/953x.o ../common/tap-953x.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS) $(EXTRA_OBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board953x/u-boot-bootstrap.lds u-boot_1.1//board/atheros/board953x/u-boot-bootstrap.lds
--- u-boot//board/atheros/board953x/u-boot-bootstrap.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board953x/u-boot-bootstrap.lds	2014-02-18 01:46:24.871050964 -0800
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board953x/u-boot.lds u-boot_1.1//board/atheros/board953x/u-boot.lds
--- u-boot//board/atheros/board953x/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board953x/u-boot.lds	2014-02-18 01:46:24.871050964 -0800
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board955x/board955x.c u-boot_1.1//board/atheros/board955x/board955x.c
--- u-boot//board/atheros/board955x/board955x.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board955x/board955x.c	2014-02-18 01:46:24.871050964 -0800
@@ -0,0 +1,165 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#	define args		char *s
+#	define board_str(a)	do {			\
+	char ver[] = "0";				\
+	strcpy(s, a " - Scorpion 1.");			\
+	ver[0] += ath_reg_rd(RST_REVISION_ID_ADDRESS)	\
+						& 0xf;	\
+	strcat(s, ver);					\
+} while (0)
+#else
+#	define prmsg	printf
+#	define args		void
+#	define board_str(a)				\
+	printf(a " - Scorpion 1.%d", ath_reg_rd		\
+			(RST_REVISION_ID_ADDRESS) & 0xf)
+#endif
+
+void
+ath_usb1_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+		ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+		SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	udelay(1000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS,
+				RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB1_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+void
+ath_usb2_initial_config(void)
+{
+	if (is_drqfn()) {
+		return;
+	}
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_MODE_SET(1));
+	udelay(10);
+	ath_reg_rmw_set(RST_RESET2_ADDRESS,
+				RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_HOST2_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+
+void ath_gpio_config(void)
+{
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+	/* Set GPIO 13 as input for LED functionality to be OFF during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 13));
+	/* Turn off JUMPST_LED and 5Gz LED during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 15));
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 12));
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32, *tap;
+	extern uint32_t *ath_ddr_tap_cal(void);
+
+#if !defined(CONFIG_ATH_EMULATION)
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	tap = ath_ddr_tap_cal();
+	prmsg("tap = 0x%p\n", tap);
+
+	tap = (uint32_t *)0xbd007f10;
+	prmsg("Tap (low, high) = (0x%x, 0x%x)\n", tap[0], tap[1]);
+
+	tap = (uint32_t *)TAP_CONTROL_0_ADDRESS;
+	prmsg("Tap values = (0x%x, 0x%x, 0x%x, 0x%x)\n",
+		tap[0], tap[2], tap[2], tap[3]);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 & ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+#endif
+
+	ath_usb1_initial_config();
+	ath_usb2_initial_config();
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	return ath_ddr_find_size();
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(args)
+{
+	board_str(CONFIG_BOARD_NAME);
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board955x/config.mk u-boot_1.1//board/atheros/board955x/config.mk
--- u-boot//board/atheros/board955x/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board955x/config.mk	2014-02-18 01:46:24.871050964 -0800
@@ -0,0 +1,57 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+ifdef BOOT_FROM_NAND #{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0xa0100000
+else #}{
+TEXT_BASE = 0xa0100000
+endif #}
+else #}{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else #}{
+TEXT_BASE = 0x9f000000
+endif #}
+endif #}
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
+
+export BOARD_EXTRA_OBJS_tmp =
+
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(BOARDDIR)/extra.o
+ifeq ($(BOOT_FROM_NAND),1)
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(VENDOR)/common/ath_nand.o $(TOPDIR)/drivers/nand/nand_ids.o
+endif
+
+ifeq ($(COMPRESSED_UBOOT),1) #{
+BOARD_EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board955x/extra.c u-boot_1.1//board/atheros/board955x/extra.c
--- u-boot//board/atheros/board955x/extra.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board955x/extra.c	2014-02-18 01:46:24.875050968 -0800
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+void *
+ath_get_nand_cal_data(void)
+{
+	extern unsigned long long ath_nand_get_cal_offset(const char *ba);
+
+        ulong           off,size;
+        int             ret;
+        static u_char   nand_cal_data[256 * 1024];
+        nand_info_t *nand;
+
+         /*
+          * caldata partition is of 128k
+          *
+          */
+        nand = &nand_info[nand_curr_device];
+        size = nand->erasesize;
+
+        /*
+         * Get the Offset of Caldata partition
+         */
+        off = ath_nand_get_cal_offset(getenv("bootargs"));
+        if(off == ATH_CAL_OFF_INVAL) {
+                printf("Invalid CAL offset \n");
+                return 1;
+        }
+
+        /*
+         * Get the values from flash, and program into the MAC address
+         * registers
+         */
+        ret = nand_read(nand, (loff_t)off, &size, nand_cal_data);
+        printf(" %d bytes %s: %s\n", size,
+                        "read", ret ? "ERROR" : "OK");
+        if(ret != 0 ) {
+                return NULL;
+        }
+
+        return nand_cal_data;
+}
+#endif
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep;
+	uint32_t	val;
+
+#ifdef CONFIG_ATH_NAND_BR
+        eep = (ar9300_eeprom_t *)ath_get_nand_cal_data();
+#else
+        eep = (ar9300_eeprom_t *)WLANCAL;
+#endif /* CONFIG_ATH_NAND_BR */
+
+	val =	XTAL_TCXODET_SET(0x0) |
+		XTAL_XTAL_CAPINDAC_SET(0x45) |
+		XTAL_XTAL_CAPOUTDAC_SET(0x45) |
+		XTAL_XTAL_SHORTXIN_SET(0x0) |
+		XTAL_XTAL_LOCALBIAS_SET(0x1) |
+		XTAL_XTAL_PWDCLKD_SET(0x0) |
+		XTAL_XTAL_BIAS2X_SET(0x0) |
+		XTAL_XTAL_LBIAS2X_SET(0x0) |
+		XTAL_XTAL_ATBVREG_SET(0x0) |
+		XTAL_XTAL_OSCON_SET(0x1) |
+		XTAL_XTAL_PWDCLKIN_SET(0x0) |
+		XTAL_LOCAL_XTAL_SET(0x1) |
+		XTAL_PWD_SWREGCLK_SET(0x0) |
+		XTAL_SWREGCLK_EDGE_SEL_SET(0x0) |
+		XTAL_SPARE_SET(0xf);
+
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		val &= ~(XTAL_XTAL_CAPINDAC_MASK | XTAL_XTAL_CAPOUTDAC_MASK);
+		val |=	XTAL_XTAL_CAPINDAC_SET(eep->params_for_tuning_caps[0]) |
+			XTAL_XTAL_CAPOUTDAC_SET(eep->params_for_tuning_caps[0]);
+
+  			/* DRVSTR value should be set 3 only for 5G */ 
+        		if((eep->pad[33] & 0x01))    
+            			val |= XTAL_XTAL_DRVSTR_SET(0x3) ;
+	}
+
+	ath_reg_wr(XTAL_ADDRESS, val);
+
+#define __str(x)	# x
+#define str(x)		__str(x)
+
+	printf("Setting " str(XTAL_ADDRESS) " to 0x%x\n", val);
+	return;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board955x/flash.c u-boot_1.1//board/atheros/board955x/flash.c
--- u-boot//board/atheros/board955x/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board955x/flash.c	2014-02-18 01:46:24.875050968 -0800
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+#ifndef CONFIG_ATH_NAND_BR
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
+#endif /* CONFIG_ATH_NAND_BR */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board955x/Makefile u-boot_1.1//board/atheros/board955x/Makefile
--- u-boot//board/atheros/board955x/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board955x/Makefile	2014-02-18 01:46:24.871050964 -0800
@@ -0,0 +1,120 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-955x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-955x.o
+
+#
+# The files included in EXTRA_OBJS use some functions that are not
+# available in the `bootstrap' portion of tuboot.bin resulting in
+# compile/link errors. Hence have them separate (i.e. don't include
+# into lib$(BOARD).a and include them only in `u-boot' portion of
+# tuboot.bin.
+#
+
+ifeq ($(strip $(COMPRESSED_UBOOT)),0) #{
+OBJS	+= $(BOARD_EXTRA_OBJS_tmp)
+else
+EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif #}
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ATH_RGMII_CAL),1)
+OBJS	+= ../common/rgmii-cal-955x.o	
+OBJS	+= ../common/athrs17_lpbk.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _ar8033)
+OBJS	+= ../common/athr_ar8033_phy.o
+endif
+
+
+SOBJS	= ../common/955x.o ../common/tap-955x.o
+
+
+$(LIB):	.depend $(OBJS) $(SOBJS) $(EXTRA_OBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board955x/u-boot-bootstrap.lds u-boot_1.1//board/atheros/board955x/u-boot-bootstrap.lds
--- u-boot//board/atheros/board955x/u-boot-bootstrap.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board955x/u-boot-bootstrap.lds	2014-02-18 01:46:24.875050968 -0800
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board955x/u-boot.lds u-boot_1.1//board/atheros/board955x/u-boot.lds
--- u-boot//board/atheros/board955x/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board955x/u-boot.lds	2014-02-18 01:46:24.875050968 -0800
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board956x/board956x.c u-boot_1.1//board/atheros/board956x/board956x.c
--- u-boot//board/atheros/board956x/board956x.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board956x/board956x.c	2014-02-18 01:46:24.879050972 -0800
@@ -0,0 +1,178 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#	define args		char *s
+#	define board_str(a)	do {			\
+	char ver[] = "0";				\
+	strcpy(s, a " - Dragonfly 1.");			\
+	ver[0] += ath_reg_rd(RST_REVISION_ID_ADDRESS)	\
+						& 0xf;	\
+	strcat(s, ver);					\
+} while (0)
+#else
+#	define prmsg	printf
+#	define args		void
+#	define board_str(a)				\
+	printf(a " - Dragonfly 1.%d", ath_reg_rd		\
+			(RST_REVISION_ID_ADDRESS) & 0xf)
+#endif
+
+void
+ath_usb1_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+		ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+		SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	udelay(1000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS,
+				RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB1_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+void
+ath_usb2_initial_config(void)
+{
+	if (is_drqfn()) {
+		return;
+	}
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_MODE_SET(1));
+	udelay(10);
+	ath_reg_rmw_set(RST_RESET2_ADDRESS,
+				RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_HOST2_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+
+void ath_gpio_config(void)
+{
+#if defined(CONFIG_CUS249)
+    /* Turn on System LED GPIO18 for CUS249 */
+    ath_reg_rmw_clear(GPIO_OUT_ADDRESS, (1 << 18));
+#endif
+	/* Turn off JUMPST_LED and 5Gz LED during bootup */
+//	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 15));
+//	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 12));
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32, *tap;
+	extern uint32_t *ath_ddr_tap_cal(void);
+
+#if !defined(CONFIG_ATH_EMULATION)
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+	tap = ath_ddr_tap_cal();
+//	tap = (uint32_t *)0xbd001f10;
+//	prmsg("Tap (low, high) = (0x%x, 0x%x)\n", tap[0], tap[1]);
+
+	tap = (uint32_t *)TAP_CONTROL_0_ADDRESS;
+	prmsg("Tap values = (0x%x, 0x%x, 0x%x, 0x%x)\n",
+		tap[0], tap[1], tap[2], tap[3]);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 & ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+#endif
+
+#if defined(CONFIG_USB)
+	ath_usb1_initial_config();
+	ath_usb2_initial_config();
+#else
+    //turn off not support interface register
+    reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+    reg32 = reg32 | RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1);
+    ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+    reg32 = ath_reg_rd(RST_CLKGAT_EN_ADDRESS);
+    reg32 = reg32 & ~(RST_CLKGAT_EN_PCIE_EP_SET(1) | RST_CLKGAT_EN_PCIE_RC_SET(1) |
+            RST_CLKGAT_EN_PCIE_RC2_SET(1) | RST_CLKGAT_EN_CLK100_PCIERC_SET(1) | 
+            RST_CLKGAT_EN_CLK100_PCIERC2_SET(1) | RST_CLKGAT_EN_USB1_SET(1) |
+            RST_CLKGAT_EN_USB2_SET(1));
+    ath_reg_wr_nf(RST_CLKGAT_EN_ADDRESS, reg32);
+    reg32 = ath_reg_rd(RST_RESET2_ADDRESS);
+    reg32 = reg32 | RST_RESET2_USB_PHY2_PLL_PWD_EXT_SET(1);
+    ath_reg_wr_nf(RST_RESET2_ADDRESS, reg32);
+
+    ath_reg_wr_nf(BIAS4_ADDRESS, 0x6df6ffe0);
+    ath_reg_wr_nf(BIAS5_ADDRESS, 0x7ffffffe);
+#endif
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	return ath_ddr_find_size();
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(args)
+{
+	board_str(CONFIG_BOARD_NAME);
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board956x/config.mk u-boot_1.1//board/atheros/board956x/config.mk
--- u-boot//board/atheros/board956x/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board956x/config.mk	2014-02-18 01:46:24.879050972 -0800
@@ -0,0 +1,57 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+ifdef BOOT_FROM_NAND #{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0xa0100000
+else #}{
+TEXT_BASE = 0xa0100000
+endif #}
+else #}{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else #}{
+TEXT_BASE = 0x9f000000
+endif #}
+endif #}
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
+
+export BOARD_EXTRA_OBJS_tmp =
+
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(BOARDDIR)/extra.o
+ifeq ($(BOOT_FROM_NAND),1)
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(VENDOR)/common/ath_nand.o $(TOPDIR)/drivers/nand/nand_ids.o
+endif
+
+ifeq ($(COMPRESSED_UBOOT),1) #{
+BOARD_EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board956x/extra.c u-boot_1.1//board/atheros/board956x/extra.c
--- u-boot//board/atheros/board956x/extra.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board956x/extra.c	2014-02-18 01:46:24.879050972 -0800
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+void *
+ath_get_nand_cal_data(void)
+{
+	extern unsigned long long ath_nand_get_cal_offset(const char *ba);
+
+        ulong           off,size;
+        int             ret;
+        static u_char   nand_cal_data[256 * 1024];
+        nand_info_t *nand;
+
+         /*
+          * caldata partition is of 128k
+          *
+          */
+        nand = &nand_info[nand_curr_device];
+        size = nand->erasesize;
+
+        /*
+         * Get the Offset of Caldata partition
+         */
+        off = ath_nand_get_cal_offset(getenv("bootargs"));
+        if(off == ATH_CAL_OFF_INVAL) {
+                printf("Invalid CAL offset \n");
+                return 1;
+        }
+
+        /*
+         * Get the values from flash, and program into the MAC address
+         * registers
+         */
+        ret = nand_read(nand, (loff_t)off, &size, nand_cal_data);
+        printf(" %d bytes %s: %s\n", size,
+                        "read", ret ? "ERROR" : "OK");
+        if(ret != 0 ) {
+                return NULL;
+        }
+
+        return nand_cal_data;
+}
+#endif
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep;
+	uint32_t	val;
+
+#ifdef CONFIG_ATH_NAND_BR
+        eep = (ar9300_eeprom_t *)ath_get_nand_cal_data();
+#else
+        eep = (ar9300_eeprom_t *)WLANCAL;
+#endif /* CONFIG_ATH_NAND_BR */
+	val =	XTAL_TCXODET_SET(0x0) |
+		XTAL_XTAL_CAPINDAC_SET(0x4b) |
+		XTAL_XTAL_CAPOUTDAC_SET(0x4b) |
+		XTAL_XTAL_DRVSTR_SET(0x0) |
+		XTAL_XTAL_SHORTXIN_SET(0x0) |
+		XTAL_XTAL_LOCALBIAS_SET(0x1) |
+		XTAL_XTAL_PWDCLKD_SET(0x0) |
+		XTAL_XTAL_BIAS2X_SET(0x0) |
+		XTAL_XTAL_LBIAS2X_SET(0x0) |
+		XTAL_XTAL_SELVREG_SET(0X0) |
+		XTAL_XTAL_OSCON_SET(0x1) |
+		XTAL_XTAL_PWDCLKIN_SET(0x0) |
+		XTAL_LOCAL_XTAL_SET(0x0) |
+		XTAL_PWD_SWREGCLK_SET(0x0) |
+		XTAL_LOCAL_EXT_CLK_OUT_EN_SET(0X0) |
+		XTAL_EXT_CLK_OUT_EN_SET(0X0) |
+		XTAL_XTAL_SVREG_SET(0X0) |
+		XTAL_RBK_UDSEL_SET(0X0) |
+		XTAL_SPARE_SET(0x0);
+
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		val &= ~(XTAL_XTAL_CAPINDAC_MASK | XTAL_XTAL_CAPOUTDAC_MASK);
+		val |=	XTAL_XTAL_CAPINDAC_SET(eep->params_for_tuning_caps[0]) |
+			XTAL_XTAL_CAPOUTDAC_SET(eep->params_for_tuning_caps[0]);
+	}
+
+	ath_reg_wr(XTAL_ADDRESS, val);
+	ath_reg_wr(XTAL2_ADDRESS, XTAL2_DCA_BYPASS_SET(0x1) |
+					XTAL2_FSM_START_L_SET(0x1));
+	ath_reg_wr(XTAL3_ADDRESS, XTAL3_EVAL_LENGTH_SET(0x400) |
+					XTAL3_HARMONIC_NUMBER_SET(0xa2));
+
+#define __str(x)	# x
+#define str(x)		__str(x)
+#if defined(CONFIG_AP151)
+    val = ath_reg_rd(GPIO_FUNCTION_ADDRESS);
+	ath_reg_wr(GPIO_FUNCTION_ADDRESS, val | 0x2);
+#endif
+	printf("Setting " str(XTAL_ADDRESS) " to 0x%x\n", val);
+	return;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board956x/flash.c u-boot_1.1//board/atheros/board956x/flash.c
--- u-boot//board/atheros/board956x/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board956x/flash.c	2014-02-18 01:46:24.879050972 -0800
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+#ifndef CONFIG_ATH_NAND_BR
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
+#endif /* CONFIG_ATH_NAND_BR */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board956x/Makefile u-boot_1.1//board/atheros/board956x/Makefile
--- u-boot//board/atheros/board956x/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board956x/Makefile	2014-02-18 01:46:24.879050972 -0800
@@ -0,0 +1,120 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-956x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-956x.o
+
+#
+# The files included in EXTRA_OBJS use some functions that are not
+# available in the `bootstrap' portion of tuboot.bin resulting in
+# compile/link errors. Hence have them separate (i.e. don't include
+# into lib$(BOARD).a and include them only in `u-boot' portion of
+# tuboot.bin.
+#
+
+ifeq ($(strip $(COMPRESSED_UBOOT)),0) #{
+OBJS	+= $(BOARD_EXTRA_OBJS_tmp)
+else
+EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif #}
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ATH_RGMII_CAL),1)
+OBJS	+= ../common/rgmii-cal-956x.o	
+OBJS	+= ../common/athrs17_lpbk.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _ar8033)
+OBJS	+= ../common/athr_ar8033_phy.o
+endif
+
+
+SOBJS	= ../common/956x.o ../common/tap-956x.o
+
+
+$(LIB):	.depend $(OBJS) $(SOBJS) $(EXTRA_OBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board956x/u-boot-bootstrap.lds u-boot_1.1//board/atheros/board956x/u-boot-bootstrap.lds
--- u-boot//board/atheros/board956x/u-boot-bootstrap.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board956x/u-boot-bootstrap.lds	2014-02-18 01:46:24.879050972 -0800
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/board956x/u-boot.lds u-boot_1.1//board/atheros/board956x/u-boot.lds
--- u-boot//board/atheros/board956x/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/board956x/u-boot.lds	2014-02-18 01:46:24.879050972 -0800
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/953x.S u-boot_1.1//board/atheros/common/953x.S
--- u-boot//board/atheros/common/953x.S	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/953x.S	2014-02-18 01:46:24.879050972 -0800
@@ -0,0 +1,173 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define reg_write(_reg, _val)			\
+	li	t7,	KSEG1ADDR(_reg);	\
+	li	t8,	_val;			\
+	sw	t8,	0(t7);
+
+#define reg_rmw_set(_reg, _mask, _val)		\
+	li	t7,	KSEG1ADDR(_reg);	\
+	lw	t8,	0(t7);			\
+	li	t9,	~(_mask);		\
+	and	t8,	t8,	t9;		\
+	li	t9,	_val;			\
+	or	t8,	t8,	t9;		\
+	sw	t8,	0(t7)
+
+#define cpu_pll_set(_mask, _val)	\
+	reg_rmw_set(CPU_PLL_CONFIG_ADDRESS, _mask, _val)
+
+#define ddr_pll_set(_mask, _val)	\
+	reg_rmw_set(DDR_PLL_CONFIG_ADDRESS, _mask, _val)
+
+#define cpu_ddr_control_set(_mask, _val)	\
+	reg_rmw_set(CPU_DDR_CLOCK_CONTROL_ADDRESS, _mask, _val)
+
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl lowlevel_init
+	.type	lowlevel_init, @function
+	.text
+	.align 4
+
+lowlevel_init:
+
+#if !defined(CONFIG_ATH_EMULATION)
+
+	reg_write(BB_DPLL2_ADDRESS, BB_DPLL2_KI_SET(2) | \
+				BB_DPLL2_KD_SET(0x10) | \
+				BB_DPLL2_PLL_PWD_SET(1));
+	reg_write(PCIe_DPLL2_ADDRESS, PCIe_DPLL2_KI_SET(2) | \
+				PCIe_DPLL2_KD_SET(0x10) | \
+				PCIe_DPLL2_PLL_PWD_SET(1));
+	reg_write(DDR_DPLL2_ADDRESS, DDR_DPLL2_KI_SET(2) | \
+				DDR_DPLL2_KD_SET(0x10) | \
+				DDR_DPLL2_PLL_PWD_SET(1));
+	reg_write(CPU_DPLL2_ADDRESS, CPU_DPLL2_KI_SET(2) | \
+				CPU_DPLL2_KD_SET(0x10) | \
+				CPU_DPLL2_PLL_PWD_SET(1));
+
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL
+	li	t4,	CPU_PLL_DITHER_VAL
+	li	t3,	DDR_PLL_DITHER_VAL
+
+	li	t7,	PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	PLL_MAGIC
+	beq	t7,	t8,	read_from_flash
+	nop
+	j	pll_bypass_set
+	nop
+read_from_flash:
+	li	t7,	PLL_CONFIG_VAL_F + 4
+	lw	t5,	0(t7)
+	lw	t4,	4(t7)
+	lw	t6,	8(t7)
+	lw	t3,	12(t7)
+
+
+pll_bypass_set:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+init_cpu_pll:
+	li	t7,	KSEG1ADDR(CPU_PLL_CONFIG_ADDRESS);
+	li	t8,	(CPU_PLL_CONFIG_PLLPWD_SET(1) | \
+			CPU_PLL_CONFIG_REF_DIV_VAL | \
+			CPU_PLL_CONFIG_RANGE_VAL | \
+			CPU_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t5
+	sw	t8,	0(t7);
+
+init_ddr_pll:
+	li	t7,	KSEG1ADDR(DDR_PLL_CONFIG_ADDRESS);
+	li	t8,	(DDR_PLL_CONFIG_PLLPWD_SET(1) | \
+			DDR_PLL_CONFIG_REF_DIV_VAL | \
+			DDR_PLL_CONFIG_RANGE_VAL | \
+			DDR_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t6
+	sw	t8,	0(t7);
+
+init_ahb_pll:
+	reg_write(CPU_DDR_CLOCK_CONTROL_ADDRESS,
+			CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL |
+			AHB_CLK_FROM_DDR |
+			CLK_SRC_CONTROL |
+			CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV |
+			CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV |
+			CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1) |
+			CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1) |
+			CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+pll_pwd_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_PLLPWD_MASK, CPU_PLL_CONFIG_PLLPWD_SET(0));
+	ddr_pll_set(DDR_PLL_CONFIG_PLLPWD_MASK, DDR_PLL_CONFIG_PLLPWD_SET(0));
+
+outdiv_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_OUTDIV_MASK, CPU_PLL_CONFIG_OUT_DIV_VAL2);
+	ddr_pll_set(DDR_PLL_CONFIG_OUTDIV_MASK, DDR_PLL_CONFIG_OUT_DIV_VAL2);
+
+pll_bypass_unset:
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(0));
+
+ddr_pll_dither_unset:
+	li	t7,	KSEG1ADDR(DDR_PLL_DITHER_ADDRESS);
+	sw	t3,	0(t7);
+
+cpu_pll_dither_unset:
+	li	t7,	KSEG1ADDR(CPU_PLL_DITHER_ADDRESS);
+	sw	t4,	0(t7);
+
+	lui	t7,	47110;
+	lui	t8,	1020;
+	sw	t8,	0xb4(t7);
+
+
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+	jr ra
+	nop
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/955x.S u-boot_1.1//board/atheros/common/955x.S
--- u-boot//board/atheros/common/955x.S	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/955x.S	2014-02-18 01:46:24.879050972 -0800
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define reg_write(_reg, _val)			\
+	li	t7,	KSEG1ADDR(_reg);	\
+	li	t8,	_val;			\
+	sw	t8,	0(t7);
+
+#define reg_rmw_set(_reg, _mask, _val)		\
+	li	t7,	KSEG1ADDR(_reg);	\
+	lw	t8,	0(t7);			\
+	li	t9,	~(_mask);		\
+	and	t8,	t8,	t9;		\
+	li	t9,	_val;			\
+	or	t8,	t8,	t9;		\
+	sw	t8,	0(t7)
+
+#define cpu_pll_set(_mask, _val)	\
+	reg_rmw_set(CPU_PLL_CONFIG_ADDRESS, _mask, _val)
+
+#define ddr_pll_set(_mask, _val)	\
+	reg_rmw_set(DDR_PLL_CONFIG_ADDRESS, _mask, _val)
+
+#define cpu_ddr_control_set(_mask, _val)	\
+	reg_rmw_set(CPU_DDR_CLOCK_CONTROL_ADDRESS, _mask, _val)
+
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl lowlevel_init
+	.type	lowlevel_init, @function
+	.text
+	.align 4
+
+lowlevel_init:
+
+#if !defined(CONFIG_ATH_EMULATION)
+#if !defined(CONFIG_ATH_NAND_BR)
+
+	reg_write(BB_DPLL2_ADDRESS, BB_DPLL2_KI_SET(4) | \
+				BB_DPLL2_KD_SET(0x60) | \
+				BB_DPLL2_PLL_PWD_SET(1) | \
+				BB_DPLL2_DELTA_SET(0x1e));
+	reg_write(PCIe_DPLL2_ADDRESS, PCIe_DPLL2_KI_SET(4) | \
+				PCIe_DPLL2_KD_SET(0x60) | \
+				PCIe_DPLL2_PLL_PWD_SET(1) | \
+				PCIe_DPLL2_DELTA_SET(0x1e));
+	reg_write(DDR_DPLL2_ADDRESS, DDR_DPLL2_KI_SET(4) | \
+				DDR_DPLL2_KD_SET(0x60) | \
+				DDR_DPLL2_PLL_PWD_SET(1) | \
+				DDR_DPLL2_DELTA_SET(0x1e));
+	reg_write(CPU_DPLL2_ADDRESS, CPU_DPLL2_KI_SET(4) | \
+				CPU_DPLL2_KD_SET(0x60) | \
+				CPU_DPLL2_PLL_PWD_SET(1) | \
+				CPU_DPLL2_DELTA_SET(0x1e));
+
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL
+	li	t4,	CPU_PLL_DITHER_VAL
+	li	t3,	DDR_PLL_DITHER_VAL
+
+	li	t7,	PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	PLL_MAGIC
+	beq	t7,	t8,	read_from_flash
+	nop
+	j	pll_bypass_set
+	nop
+read_from_flash:
+	li	t7,	PLL_CONFIG_VAL_F + 4
+	lw	t5,	0(t7)
+	lw	t4,	4(t7)
+	lw	t6,	8(t7)
+	lw	t3,	12(t7)
+
+
+pll_bypass_set:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+init_cpu_pll:
+	li	t7,	KSEG1ADDR(CPU_PLL_CONFIG_ADDRESS);
+	li	t8,	(CPU_PLL_CONFIG_PLLPWD_SET(1) | \
+			CPU_PLL_CONFIG_REF_DIV_VAL | \
+			CPU_PLL_CONFIG_RANGE_VAL | \
+			CPU_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t5
+	sw	t8,	0(t7);
+
+init_ddr_pll:
+	li	t7,	KSEG1ADDR(DDR_PLL_CONFIG_ADDRESS);
+	li	t8,	(DDR_PLL_CONFIG_PLLPWD_SET(1) | \
+			DDR_PLL_CONFIG_REF_DIV_VAL | \
+			DDR_PLL_CONFIG_RANGE_VAL | \
+			DDR_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t6
+	sw	t8,	0(t7);
+
+init_ahb_pll:
+	reg_write(CPU_DDR_CLOCK_CONTROL_ADDRESS,
+			CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL |
+			AHB_CLK_FROM_DDR |
+			CPU_AND_DDR_CLK_FROM_DDR |
+			CPU_AND_DDR_CLK_FROM_CPU |
+			CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV |
+			CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV |
+			CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1) |
+			CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1) |
+			CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+pll_pwd_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_PLLPWD_MASK, CPU_PLL_CONFIG_PLLPWD_SET(0));
+	ddr_pll_set(DDR_PLL_CONFIG_PLLPWD_MASK, DDR_PLL_CONFIG_PLLPWD_SET(0));
+
+outdiv_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_OUTDIV_MASK, CPU_PLL_CONFIG_OUT_DIV_VAL2);
+	ddr_pll_set(DDR_PLL_CONFIG_OUTDIV_MASK, DDR_PLL_CONFIG_OUT_DIV_VAL2);
+
+pll_bypass_unset:
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(0));
+
+ddr_pll_dither_unset:
+	li	t7,	KSEG1ADDR(DDR_PLL_DITHER_ADDRESS);
+	sw	t3,	0(t7);
+
+cpu_pll_dither_unset:
+	li	t7,	KSEG1ADDR(CPU_PLL_DITHER_ADDRESS);
+	sw	t4,	0(t7);
+
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+	jr ra
+	nop
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/956x.S u-boot_1.1//board/atheros/common/956x.S
--- u-boot//board/atheros/common/956x.S	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/956x.S	2014-02-18 01:46:24.879050972 -0800
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define reg_write(_reg, _val)			\
+	li	t7,	KSEG1ADDR(_reg);	\
+	li	t8,	_val;			\
+	sw	t8,	0(t7);
+
+#define reg_rmw_set(_reg, _mask, _val)		\
+	li	t7,	KSEG1ADDR(_reg);	\
+	lw	t8,	0(t7);			\
+	li	t9,	~(_mask);		\
+	and	t8,	t8,	t9;		\
+	li	t9,	_val;			\
+	or	t8,	t8,	t9;		\
+	sw	t8,	0(t7)
+
+#define cpu_pll_set(_mask, _val)	\
+	reg_rmw_set(CPU_PLL_CONFIG_ADDRESS, _mask, _val)
+
+#define ddr_pll_set(_mask, _val)	\
+	reg_rmw_set(DDR_PLL_CONFIG_ADDRESS, _mask, _val)
+
+#define cpu_ddr_control_set(_mask, _val)	\
+	reg_rmw_set(CPU_DDR_CLOCK_CONTROL_ADDRESS, _mask, _val)
+
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl lowlevel_init
+	.type	lowlevel_init, @function
+	.text
+	.align 4
+
+lowlevel_init:
+
+#if !defined(CONFIG_ATH_EMULATION)
+#if !defined(CONFIG_ATH_NAND_BR)
+
+	reg_write(BB_DPLL2_ADDRESS, BB_DPLL2_KI_SET(2) | \
+				BB_DPLL2_KD_SET(0xa) | \
+				BB_DPLL2_OUTDIV_SET(1) | \
+				BB_DPLL2_PLL_PWD_SET(1) | \
+				BB_DPLL2_PHASE_SHIFT_SET(0x6));
+	reg_write(PCIe_DPLL2_ADDRESS, PCIe_DPLL2_KI_SET(2) | \
+                PCIe_DPLL2_KD_SET(0xa) | \
+				PCIe_DPLL2_PLL_PWD_SET(1) | \
+				PCIe_DPLL2_OUTDIV_SET(0x3) | \
+				PCIe_DPLL2_PHASE_SHIFT_SET(0x6));
+	reg_write(DDR_DPLL2_ADDRESS, DDR_DPLL2_KI_SET(2) | \
+				DDR_DPLL2_KD_SET(0xa) | \
+				DDR_DPLL2_PLL_PWD_SET(1) | \
+				DDR_DPLL2_PHASE_SHIFT_SET(0x6));
+	reg_write(CPU_DPLL2_ADDRESS, CPU_DPLL2_KI_SET(1) | \
+				CPU_DPLL2_KD_SET(0x7)  | \
+				CPU_DPLL2_PLL_PWD_SET(1) | \
+				CPU_DPLL2_PHASE_SHIFT_SET(0x6));
+
+	li	t5,	CPU_PLL_CONFIG1_NINT_VAL
+	li	t6,	DDR_PLL_CONFIG1_NINT_VAL
+	li	t4,	CPU_PLL_DITHER1_VAL
+	li	t3,	DDR_PLL_DITHER1_VAL
+
+	li	t7,	PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	PLL_MAGIC
+	beq	t7,	t8,	read_from_flash
+	nop
+	j	pll_bypass_set
+	nop
+read_from_flash:
+	li	t7,	PLL_CONFIG_VAL_F + 4
+	lw	t5,	0(t7)
+	lw	t4,	4(t7)
+	lw	t6,	8(t7)
+	lw	t3,	12(t7)
+
+
+pll_bypass_set:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+init_cpu_pll:
+	li	t7,	KSEG1ADDR(CPU_PLL_CONFIG_ADDRESS);
+	li	t8,	(CPU_PLL_CONFIG_PLLPWD_SET(1) | \
+			CPU_PLL_CONFIG_REF_DIV_VAL | \
+			CPU_PLL_CONFIG_RANGE_VAL | \
+			CPU_PLL_CONFIG_OUT_DIV_VAL1);
+	sw	t8,	0(t7);
+	li	t7,	KSEG1ADDR(CPU_PLL_CONFIG1_ADDRESS);
+	sw  t5, 0(t7);
+
+init_ddr_pll:
+	li	t7,	KSEG1ADDR(DDR_PLL_CONFIG_ADDRESS);
+	li	t8,	(DDR_PLL_CONFIG_PLLPWD_SET(1) | \
+			DDR_PLL_CONFIG_REF_DIV_VAL | \
+			DDR_PLL_CONFIG_RANGE_VAL | \
+			DDR_PLL_CONFIG_OUT_DIV_VAL1);
+	sw	t8,	0(t7);
+	li	t7,	KSEG1ADDR(DDR_PLL_CONFIG1_ADDRESS);	
+	sw  t6, 0(t7);
+
+init_ahb_pll:
+	reg_write(CPU_DDR_CLOCK_CONTROL_ADDRESS,
+			CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL |
+			AHB_CLK_FROM_DDR |
+			CPU_AND_DDR_CLK_FROM_DDR |
+			CPU_AND_DDR_CLK_FROM_CPU |
+			CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV |
+			CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV |
+			CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1) |
+			CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1) |
+			CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+ddr_pll_dither_unset:
+	li	t7,	KSEG1ADDR(DDR_PLL_DITHER1_ADDRESS);
+	sw	t3,	0(t7);
+	li	t7,	KSEG1ADDR(DDR_PLL_DITHER2_ADDRESS);
+	li	t8,	DDR_PLL_DITHER2_VAL
+	sw	t8,	0(t7);
+
+cpu_pll_dither_unset:
+	li	t7,	KSEG1ADDR(CPU_PLL_DITHER1_ADDRESS);
+	sw	t4,	0(t7);
+	li	t7,	KSEG1ADDR(CPU_PLL_DITHER2_ADDRESS);
+	li	t8,	CPU_PLL_DITHER2_VAL
+	sw	t8,	0(t7);
+
+pll_pwd_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_PLLPWD_MASK, CPU_PLL_CONFIG_PLLPWD_SET(0));
+	ddr_pll_set(DDR_PLL_CONFIG_PLLPWD_MASK, DDR_PLL_CONFIG_PLLPWD_SET(0));
+
+outdiv_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_OUTDIV_MASK, CPU_PLL_CONFIG_OUT_DIV_VAL2);
+	ddr_pll_set(DDR_PLL_CONFIG_OUTDIV_MASK, DDR_PLL_CONFIG_OUT_DIV_VAL2);
+
+pll_bypass_unset:
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(0));
+
+check_cpu_pll_locked:
+    li  t7, KSEG1ADDR(CPU_PLL_CONFIG_ADDRESS);
+    lw  t8, 0(t7);
+    li  t9, 0x8000000;
+    and t8, t8, t9;
+    bne zero, t8, check_cpu_pll_locked;
+
+check_ddr_pll_locked:
+    li  t7, KSEG1ADDR(DDR_PLL_CONFIG_ADDRESS);
+    lw  t8, 0(t7);
+    li  t9, 0x8000000;
+    and t8, t8, t9;
+    bne zero, t8, check_ddr_pll_locked;
+
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+	jr ra
+	nop
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/ath_flash.c u-boot_1.1//board/atheros/common/ath_flash.c
--- u-boot//board/atheros/common/ath_flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/ath_flash.c	2014-02-18 01:46:24.879050972 -0800
@@ -0,0 +1,263 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <jffs2/jffs2.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <atheros.h>
+#include "ath_flash.h"
+
+#if !defined(ATH_DUAL_FLASH)
+#	define	ath_spi_flash_print_info	flash_print_info
+#endif
+
+/*
+ * globals
+ */
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+/*
+ * statics
+ */
+static void ath_spi_write_enable(void);
+static void ath_spi_poll(void);
+#if !defined(ATH_SST_FLASH)
+static void ath_spi_write_page(uint32_t addr, uint8_t * data, int len);
+#endif
+static void ath_spi_sector_erase(uint32_t addr);
+
+static void
+ath_spi_read_id(void)
+{
+	u32 rd;
+
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_DIS);
+	ath_spi_bit_banger(ATH_SPI_CMD_RDID);
+	ath_spi_delay_8();
+	ath_spi_delay_8();
+	ath_spi_delay_8();
+	ath_spi_go();
+
+	rd = ath_reg_rd(ATH_SPI_RD_STATUS);
+
+	printf("Flash Manuf Id 0x%x, DeviceId0 0x%x, DeviceId1 0x%x\n",
+		(rd >> 16) & 0xff, (rd >> 8) & 0xff, (rd >> 0) & 0xff);
+}
+
+
+#ifdef ATH_SST_FLASH
+void ath_spi_flash_unblock(void)
+{
+	ath_spi_write_enable();
+	ath_spi_bit_banger(ATH_SPI_CMD_WRITE_SR);
+	ath_spi_bit_banger(0x0);
+	ath_spi_go();
+	ath_spi_poll();
+}
+#endif
+
+unsigned long flash_init(void)
+{
+#if !(defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x) || defined(CONFIG_MACH_QCA956x))
+#ifdef ATH_SST_FLASH
+	ath_reg_wr_nf(ATH_SPI_CLOCK, 0x3);
+	ath_spi_flash_unblock();
+	ath_reg_wr(ATH_SPI_FS, 0);
+#else
+	ath_reg_wr_nf(ATH_SPI_CLOCK, 0x43);
+#endif
+#endif
+	ath_reg_rmw_set(ATH_SPI_FS, 1);
+	ath_spi_read_id();
+	ath_reg_rmw_clear(ATH_SPI_FS, 1);
+
+	/*
+	 * hook into board specific code to fill flash_info
+	 */
+	return (flash_get_geom(&flash_info[0]));
+}
+
+void
+ath_spi_flash_print_info(flash_info_t *info)
+{
+	printf("The hell do you want flinfo for??\n");
+}
+
+int
+flash_erase(flash_info_t *info, int s_first, int s_last)
+{
+	int i, sector_size = info->size / info->sector_count;
+
+	printf("\nFirst %#x last %#x sector size %#x\n",
+		s_first, s_last, sector_size);
+
+	for (i = s_first; i <= s_last; i++) {
+		printf("\b\b\b\b%4d", i);
+		ath_spi_sector_erase(i * sector_size);
+	}
+	ath_spi_done();
+	printf("\n");
+
+	return 0;
+}
+
+/*
+ * Write a buffer from memory to flash:
+ * 0. Assumption: Caller has already erased the appropriate sectors.
+ * 1. call page programming for every 256 bytes
+ */
+#ifdef ATH_SST_FLASH
+void
+ath_spi_flash_chip_erase(void)
+{
+	ath_spi_write_enable();
+	ath_spi_bit_banger(ATH_SPI_CMD_CHIP_ERASE);
+	ath_spi_go();
+	ath_spi_poll();
+}
+
+int
+write_buff(flash_info_t *info, uchar *src, ulong dst, ulong len)
+{
+	uint32_t val;
+
+	dst = dst - CFG_FLASH_BASE;
+	printf("write len: %lu dst: 0x%x src: %p\n", len, dst, src);
+
+	for (; len; len--, dst++, src++) {
+		ath_spi_write_enable();	// dont move this above 'for'
+		ath_spi_bit_banger(ATH_SPI_CMD_PAGE_PROG);
+		ath_spi_send_addr(dst);
+
+		val = *src & 0xff;
+		ath_spi_bit_banger(val);
+
+		ath_spi_go();
+		ath_spi_poll();
+	}
+	/*
+	 * Disable the Function Select
+	 * Without this we can't read from the chip again
+	 */
+	ath_reg_wr(ATH_SPI_FS, 0);
+
+	if (len) {
+		// how to differentiate errors ??
+		return ERR_PROG_ERROR;
+	} else {
+		return ERR_OK;
+	}
+}
+#else
+int
+write_buff(flash_info_t *info, uchar *source, ulong addr, ulong len)
+{
+	int total = 0, len_this_lp, bytes_this_page;
+	ulong dst;
+	uchar *src;
+
+	printf("write addr: %x\n", addr);
+	addr = addr - CFG_FLASH_BASE;
+
+	while (total < len) {
+		src = source + total;
+		dst = addr + total;
+		bytes_this_page =
+			ATH_SPI_PAGE_SIZE - (addr % ATH_SPI_PAGE_SIZE);
+		len_this_lp =
+			((len - total) >
+			bytes_this_page) ? bytes_this_page : (len - total);
+		ath_spi_write_page(dst, src, len_this_lp);
+		total += len_this_lp;
+	}
+
+	ath_spi_done();
+
+	return 0;
+}
+#endif
+
+static void
+ath_spi_write_enable()
+{
+	ath_reg_wr_nf(ATH_SPI_FS, 1);
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_DIS);
+	ath_spi_bit_banger(ATH_SPI_CMD_WREN);
+	ath_spi_go();
+}
+
+static void
+ath_spi_poll()
+{
+	int rd;
+
+	do {
+		ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_DIS);
+		ath_spi_bit_banger(ATH_SPI_CMD_RD_STATUS);
+		ath_spi_delay_8();
+		rd = (ath_reg_rd(ATH_SPI_RD_STATUS) & 1);
+	} while (rd);
+}
+
+#if !defined(ATH_SST_FLASH)
+static void
+ath_spi_write_page(uint32_t addr, uint8_t *data, int len)
+{
+	int i;
+	uint8_t ch;
+
+	display(0x77);
+	ath_spi_write_enable();
+	ath_spi_bit_banger(ATH_SPI_CMD_PAGE_PROG);
+	ath_spi_send_addr(addr);
+
+	for (i = 0; i < len; i++) {
+		ch = *(data + i);
+		ath_spi_bit_banger(ch);
+	}
+
+	ath_spi_go();
+	display(0x66);
+	ath_spi_poll();
+	display(0x6d);
+}
+#endif
+
+static void
+ath_spi_sector_erase(uint32_t addr)
+{
+	ath_spi_write_enable();
+	ath_spi_bit_banger(ATH_SPI_CMD_SECTOR_ERASE);
+	ath_spi_send_addr(addr);
+	ath_spi_go();
+	display(0x7d);
+	ath_spi_poll();
+}
+
+#ifdef ATH_DUAL_FLASH
+void flash_print_info(flash_info_t *info)
+{
+	ath_spi_flash_print_info(NULL);
+	ath_nand_flash_print_info(NULL);
+}
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/ath_flash.h u-boot_1.1//board/atheros/common/ath_flash.h
--- u-boot//board/atheros/common/ath_flash.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/ath_flash.h	2014-02-18 01:46:24.879050972 -0800
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _ATH_FLASH_H
+#define _ATH_FLASH_H
+
+#define display(_x)
+
+/*
+ * primitives
+ */
+
+#define ath_be_msb(_val, _i) (((_val) & (1 << (7 - _i))) >> (7 - _i))
+
+#define ath_spi_bit_banger(_byte)	do {				\
+	int i;								\
+	for(i = 0; i < 8; i++) {					\
+		ath_reg_wr_nf(ATH_SPI_WRITE,				\
+			ATH_SPI_CE_LOW | ath_be_msb(_byte, i));		\
+		ath_reg_wr_nf(ATH_SPI_WRITE,				\
+			ATH_SPI_CE_HIGH | ath_be_msb(_byte, i));	\
+	}								\
+} while (0)
+
+#define ath_spi_go()	do {				\
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CE_LOW);	\
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_DIS);	\
+} while (0)
+
+
+#define ath_spi_send_addr(__a) do {			\
+	ath_spi_bit_banger(((__a & 0xff0000) >> 16));	\
+	ath_spi_bit_banger(((__a & 0x00ff00) >> 8));	\
+	ath_spi_bit_banger(__a & 0x0000ff);		\
+} while (0)
+
+#define ath_spi_delay_8()	ath_spi_bit_banger(0)
+#define ath_spi_done()		ath_reg_wr_nf(ATH_SPI_FS, 0)
+
+extern unsigned long flash_get_geom (flash_info_t *flash_info);
+
+#endif /* _ATH_FLASH_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/ath_nand.c u-boot_1.1//board/atheros/common/ath_nand.c
--- u-boot//board/atheros/common/ath_nand.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/ath_nand.c	2014-02-18 01:46:24.883050975 -0800
@@ -0,0 +1,1615 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * linux/drivers/mtd/nand/ath_nand.c
+ * vim: tabstop=8 : noexpandtab
+ * Derived from alauda.c
+ */
+#include <common.h>
+#include <command.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <config.h>
+#include <atheros.h>
+#include <malloc.h>
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/bitops.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+
+#define ENOMEM		12
+#define EINVAL		22
+
+#define writesize		oobblock
+
+#define DRV_NAME	"ath-nand"
+#define DRV_VERSION	"0.1"
+#define DRV_AUTHOR	"Atheros"
+#define DRV_DESC	"Atheros on-chip NAND FLash Controller Driver"
+
+#define ATH_NF_COMMAND		(ATH_NAND_FLASH_BASE + 0x200u)
+#define ATH_NF_CTRL		(ATH_NAND_FLASH_BASE + 0x204u)
+#define ATH_NF_STATUS		(ATH_NAND_FLASH_BASE + 0x208u)
+#define ATH_NF_INT_MASK		(ATH_NAND_FLASH_BASE + 0x20cu)
+#define ATH_NF_INT_STATUS	(ATH_NAND_FLASH_BASE + 0x210u)
+#define ATH_NF_ECC_CTRL		(ATH_NAND_FLASH_BASE + 0x214u)
+#define ATH_NF_ECC_OFFSET	(ATH_NAND_FLASH_BASE + 0x218u)
+#define ATH_NF_ADDR0_0		(ATH_NAND_FLASH_BASE + 0x21cu)
+#define ATH_NF_ADDR1_0		(ATH_NAND_FLASH_BASE + 0x220u)
+#define ATH_NF_ADDR0_1		(ATH_NAND_FLASH_BASE + 0x224u)
+#define ATH_NF_ADDR1_1		(ATH_NAND_FLASH_BASE + 0x228u)
+#define ATH_NF_SPARE_SIZE	(ATH_NAND_FLASH_BASE + 0x230u)
+#define ATH_NF_PROTECT		(ATH_NAND_FLASH_BASE + 0x238u)
+#define ATH_NF_LOOKUP_EN	(ATH_NAND_FLASH_BASE + 0x240u)
+#define ATH_NF_LOOKUP0		(ATH_NAND_FLASH_BASE + 0x244u)
+#define ATH_NF_LOOKUP1		(ATH_NAND_FLASH_BASE + 0x248u)
+#define ATH_NF_LOOKUP2		(ATH_NAND_FLASH_BASE + 0x24cu)
+#define ATH_NF_LOOKUP3		(ATH_NAND_FLASH_BASE + 0x250u)
+#define ATH_NF_LOOKUP4		(ATH_NAND_FLASH_BASE + 0x254u)
+#define ATH_NF_LOOKUP5		(ATH_NAND_FLASH_BASE + 0x258u)
+#define ATH_NF_LOOKUP6		(ATH_NAND_FLASH_BASE + 0x25cu)
+#define ATH_NF_LOOKUP7		(ATH_NAND_FLASH_BASE + 0x260u)
+#define ATH_NF_DMA_ADDR		(ATH_NAND_FLASH_BASE + 0x264u)
+#define ATH_NF_DMA_COUNT	(ATH_NAND_FLASH_BASE + 0x268u)
+#define ATH_NF_DMA_CTRL		(ATH_NAND_FLASH_BASE + 0x26cu)
+#define ATH_NF_MEM_CTRL		(ATH_NAND_FLASH_BASE + 0x280u)
+#define ATH_NF_PG_SIZE		(ATH_NAND_FLASH_BASE + 0x284u)
+#define ATH_NF_RD_STATUS	(ATH_NAND_FLASH_BASE + 0x288u)
+#define ATH_NF_TIME_SEQ		(ATH_NAND_FLASH_BASE + 0x28cu)
+#define ATH_NF_TIMINGS_ASYN	(ATH_NAND_FLASH_BASE + 0x290u)
+#define ATH_NF_TIMINGS_SYN	(ATH_NAND_FLASH_BASE + 0x294u)
+#define ATH_NF_FIFO_DATA	(ATH_NAND_FLASH_BASE + 0x298u)
+#define ATH_NF_TIME_MODE	(ATH_NAND_FLASH_BASE + 0x29cu)
+#define ATH_NF_DMA_ADDR_OFFSET	(ATH_NAND_FLASH_BASE + 0x2a0u)
+#define ATH_NF_FIFO_INIT	(ATH_NAND_FLASH_BASE + 0x2b0u)
+#define ATH_NF_GENERIC_SEQ_CTRL	(ATH_NAND_FLASH_BASE + 0x2b4u)
+
+#define ATH_NF_TIMING_ASYN	0x11
+#define ATH_NF_STATUS_OK	0x40	//0xc0
+#define ATH_NF_RD_STATUS_MASK	0x47	//0xc7
+
+#define ATH_NF_COMMAND_CMD_2(x)		(((x) & 0xff) << 24)	// A code of the third command in a sequence.
+#define ATH_NF_COMMAND_CMD_1(x)		(((x) & 0xff) << 16)	// A code of the second command in a sequence.
+#define ATH_NF_COMMAND_CMD_0(x)		(((x) & 0xff) <<  8)	// A code of the first command in a sequence.
+#define ATH_NF_COMMAND_ADDR_SEL		(1 << 7)		// Address register select flag:
+								// 0  the address register 0 selected
+								// 1  the address register 1 selected
+#define ATH_NF_COMMAND_INPUT_SEL_DMA	(1 << 6) 		// Input module select flag:
+								// 0  select the SIU module as input
+								// 1  select the DMA module as input
+#define ATH_NF_COMMAND_CMD_SEQ_0	0x00
+#define ATH_NF_COMMAND_CMD_SEQ_1	0x21
+#define ATH_NF_COMMAND_CMD_SEQ_2	0x22
+#define ATH_NF_COMMAND_CMD_SEQ_3	0x03
+#define ATH_NF_COMMAND_CMD_SEQ_4	0x24
+#define ATH_NF_COMMAND_CMD_SEQ_5	0x25
+#define ATH_NF_COMMAND_CMD_SEQ_6	0x26
+#define ATH_NF_COMMAND_CMD_SEQ_7	0x27
+#define ATH_NF_COMMAND_CMD_SEQ_8	0x08
+#define ATH_NF_COMMAND_CMD_SEQ_9	0x29
+#define ATH_NF_COMMAND_CMD_SEQ_10	0x2A
+#define ATH_NF_COMMAND_CMD_SEQ_11	0x2B
+#define ATH_NF_COMMAND_CMD_SEQ_12	0x0C
+#define ATH_NF_COMMAND_CMD_SEQ_13	0x0D
+#define ATH_NF_COMMAND_CMD_SEQ_14	0x0E
+#define ATH_NF_COMMAND_CMD_SEQ_15	0x2F
+#define ATH_NF_COMMAND_CMD_SEQ_16	0x30
+#define ATH_NF_COMMAND_CMD_SEQ_17	0x11
+#define ATH_NF_COMMAND_CMD_SEQ_18	0x32
+#define ATH_NF_COMMAND_CMD_SEQ_19	0x13
+
+
+#define ATH_NF_CTRL_SMALL_BLOCK_EN	(1 << 21)
+
+#define ATH_NF_CTRL_ADDR_CYCLE1_0	(0 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_1	(1 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_2	(2 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_3	(3 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_4	(4 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_5	(5 << 18)
+
+#define ATH_NF_CTRL_ADDR1_AUTO_INC_EN	(1 << 17)
+#define ATH_NF_CTRL_ADDR0_AUTO_INC_EN	(1 << 16)
+#define ATH_NF_CTRL_WORK_MODE_SYNC	(1 << 15)
+#define ATH_NF_CTRL_PROT_EN		(1 << 14)
+#define ATH_NF_CTRL_LOOKUP_EN		(1 << 13)
+#define ATH_NF_CTRL_IO_WIDTH_16BIT	(1 << 12)
+#define ATH_NF_CTRL_CUSTOM_SIZE_EN	(1 << 11)
+
+#define ATH_NF_CTRL_PAGE_SIZE_256	(0 <<  8)	/* bytes */
+#define ATH_NF_CTRL_PAGE_SIZE_512	(1 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_1024	(2 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_2048	(3 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_4096	(4 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_8192	(5 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_16384	(6 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_0		(7 <<  8)
+
+#define ATH_NF_CTRL_BLOCK_SIZE_32	(0 <<  6)	/* pages */
+#define ATH_NF_CTRL_BLOCK_SIZE_64	(1 <<  6)
+#define ATH_NF_CTRL_BLOCK_SIZE_128	(2 <<  6)
+#define ATH_NF_CTRL_BLOCK_SIZE_256	(3 <<  6)
+
+#define ATH_NF_CTRL_ECC_EN		(1 <<  5)
+#define ATH_NF_CTRL_INT_EN		(1 <<  4)
+#define ATH_NF_CTRL_SPARE_EN		(1 <<  3)
+
+#define ATH_NF_CTRL_ADDR_CYCLE0_0	(0 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_1	(1 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_2	(2 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_3	(3 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_4	(4 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_5	(5 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0(c)	((c) << 0)
+
+
+#define ATH_NF_DMA_CTRL_DMA_START	(1 << 7)
+#define ATH_NF_DMA_CTRL_DMA_DIR_WRITE	(0 << 6)
+#define ATH_NF_DMA_CTRL_DMA_DIR_READ	(1 << 6)
+#define ATH_NF_DMA_CTRL_DMA_MODE_SG	(1 << 5)
+/*
+ * 000  incrementing precise burst of precisely four transfers
+ * 001  stream burst (address const)
+ * 010  single transfer (address increment)
+ * 011  burst of unspecified length (address increment)
+ * 100  incrementing precise burst of precisely eight transfers
+ * 101  incrementing precise burst of precisely sixteen transfers
+ */
+#define ATH_NF_DMA_CTRL_DMA_BURST_0	(0 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_1	(1 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_2	(2 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_3	(3 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_4	(4 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_5	(5 << 2)
+#define ATH_NF_DMA_CTRL_ERR_FLAG	(1 << 1)
+#define ATH_NF_DMA_CTRL_DMA_READY	(1 << 0)
+
+#define ATH_NF_ECC_CTRL_ERR_THRESH(x)	((x << 8) & (0x1fu << 8))
+#define ATH_NF_ECC_CTRL_ECC_CAP(x)	((x << 5) & (0x07u << 5))
+#define ATH_NF_ECC_CTRL_ECC_2_BITS	ATH_NF_ECC_CTRL_ECC_CAP(0)
+#define ATH_NF_ECC_CTRL_ECC_4_BITS	ATH_NF_ECC_CTRL_ECC_CAP(1)
+#define ATH_NF_ECC_CTRL_ECC_6_BITS	ATH_NF_ECC_CTRL_ECC_CAP(2)
+#define ATH_NF_ECC_CTRL_ECC_8_BITS	ATH_NF_ECC_CTRL_ECC_CAP(3)
+#define ATH_NF_ECC_CTRL_ECC_10_BITS	ATH_NF_ECC_CTRL_ECC_CAP(4)
+#define ATH_NF_ECC_CTRL_ECC_12_BITS	ATH_NF_ECC_CTRL_ECC_CAP(5)
+#define ATH_NF_ECC_CTRL_ECC_14_BITS	ATH_NF_ECC_CTRL_ECC_CAP(6)
+#define ATH_NF_ECC_CTRL_ECC_16_BITS	ATH_NF_ECC_CTRL_ECC_CAP(7)
+
+#define ATH_NF_ECC_CTRL_ERR_OVER	(1 << 2)
+#define ATH_NF_ECC_CTRL_ERR_UNCORR	(1 << 1)
+#define ATH_NF_ECC_CTRL_ERR_CORR	(1 << 0)
+#	define ATH_NF_ECC_ERROR		(ATH_NF_ECC_CTRL_ERR_UNCORR | \
+					 ATH_NF_ECC_CTRL_ERR_OVER)
+
+#define ATH_NF_CMD_END_INT		(1 << 1)
+
+#define ATH_NF_HW_ECC		1
+#define ATH_NF_STATUS_RETRY	1000
+
+#define ath_nand_get_cmd_end_status(void)	\
+	(ath_reg_rd(ATH_NF_INT_STATUS) & ATH_NF_CMD_END_INT)
+
+#define ath_nand_clear_int_status()	ath_reg_wr(ATH_NF_INT_STATUS, 0)
+
+#define ATH_NAND_BLK_DONT_KNOW	0x0
+#define ATH_NAND_BLK_GOOD	0x1
+#define ATH_NAND_BLK_BAD	0x2
+#define ATH_NAND_BLK_ERASED	0x3
+
+#define ATH_NF_GENERIC_SEQ_CTRL_COL_ADDR	(1 << 17)
+#define ATH_NF_GENERIC_SEQ_CTRL_DATA_EN		(1 << 16)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD3_CODE(x)	(((x) & 0xff) << 8)
+#define ATH_NF_GENERIC_SEQ_CTRL_DEL_EN(x)	(((x) & 3) << 6)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD3_EN		(1 << 5)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD2_EN		(1 << 4)
+#define ATH_NF_GENERIC_SEQ_CTRL_ADDR1_EN	(1 << 3)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD1_EN		(1 << 2)
+#define ATH_NF_GENERIC_SEQ_CTRL_ADDR0_EN	(1 << 1)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD0_EN		(1 << 0)
+
+#define ATH_NAND_JFFS2_ECC_OFF	0x04	// Give 4 bytes for Factory Bad Block Marker
+#define ATH_NAND_JFFS2_ECC_LEN	0x10	// Space for JFFS2 Clean Marker
+
+/*
+ * Note: The byte positions might not match the spec.
+ * It is to handle the endianness issues.
+ */
+#define ONFI_NUM_ADDR_CYCLES	102	/* see note */
+#define ONFI_DEV_DESC		32
+#define ONFI_DEV_DESC_SZ	32
+#define ONFI_PAGE_SIZE		80
+#define ONFI_SPARE_SIZE		86	/* see note */
+#define ONFI_PAGES_PER_BLOCK	92
+#define ONFI_BLOCKS_PER_LUN	96
+#define ONFI_NUM_LUNS		103	/* see note */
+#define ONFI_RD_PARAM_PAGE_SZ	128
+#define READ_PARAM_STATUS_OK	0x40
+#define READ_PARAM_STATUS_MASK	0x41
+
+#define ATH_NAND_IO_DBG		0
+#define ATH_NAND_OOB_DBG	0
+#define ATH_NAND_IN_DBG		0
+
+#if ATH_NAND_IO_DBG
+#	define iodbg	printk
+#else
+#	define iodbg(...)
+#endif
+
+#if ATH_NAND_OOB_DBG
+#	define oobdbg	printk
+#else
+#	define oobdbg(...)
+#endif
+
+#if ATH_NAND_IN_DBG
+#	define indbg(a, ...)					\
+	do {							\
+		printk("--- %s(%d):" a "\n",			\
+			__func__, __LINE__, ## __VA_ARGS__);	\
+	} while (0)
+#else
+#	define indbg(...)
+#	define indbg1(a, ...)					\
+	do {							\
+		printk("--- %s(%d):" a "\n",			\
+			__func__, __LINE__, ## __VA_ARGS__);	\
+	} while (0)
+#endif
+
+/*
+ * Data structures for ath nand flash controller driver
+ */
+
+typedef union {
+	uint8_t			byte_id[8];
+
+	struct {
+		uint8_t		sa1	: 1,	// Serial access time (bit 1)
+				org	: 1,	// Organisation
+				bs	: 2,	// Block size
+				sa0	: 1,	// Serial access time (bit 0)
+				ss	: 1,	// Spare size per 512 bytes
+				ps	: 2,	// Page Size
+
+				wc	: 1,	// Write Cache
+				ilp	: 1, 	// Interleaved Programming
+				nsp	: 2, 	// No. of simult prog pages
+				ct	: 2,	// Cell type
+				dp	: 2,	// Die/Package
+
+				did,		// Device id
+				vid,		// Vendor id
+
+				res1	: 2,	// Reserved
+				pls	: 2,	// Plane size
+				pn	: 2,	// Plane number
+				res2	: 2;	// Reserved
+	} __details;
+} ath_nand_id_t;
+
+uint64_t ath_plane_size[] = {
+	64 << 20,
+	 1 << 30,
+	 2 << 30,
+	 4 << 30,
+	 8 << 30
+};
+
+typedef struct {
+	uint8_t		vid,
+			did,
+			b3,
+			addrcyc,
+			small,
+			spare;	// for small block;
+	uint16_t	pgsz;	// for small block
+	uint32_t	blk;	// for small block
+} ath_nand_vend_data_t;
+
+#define is_small_block_device(x)	((x)->entry && (x)->entry->small)
+
+ath_nand_vend_data_t ath_nand_arr[] = {
+	{ 0x20, 0xda, 0x10, 5, },	// NU2g3B2D
+	{ 0x20, 0xf1, 0x00, 4, },	// NU1g3B2C
+	{ 0x20, 0xdc, 0x10, 5, },	// NU4g3B2D
+	{ 0x20, 0xd3, 0x10, 5, },	// NU8g3F2A
+	{ 0x20, 0xd3, 0x14, 5, },	// NU8g3C2B
+	{ 0xad, 0xf1, 0x00, 4, },	// HY1g2b
+	{ 0xad, 0xda, 0x10, 5, },	// HY2g2b
+	{ 0xec, 0xf1, 0x00, 4, },	// Samsung 3,3V 8-bit [128MB]
+	{ 0x98, 0xd1, 0x90, 4, },	// Toshiba
+	{ 0xad, 0x76, 0xad, 5, 1, 16, 512, 16 << 10 },	// Hynix 64MB NAND Flash
+	{ 0xad, 0x36, 0xad, 5, 1, 16, 512, 16 << 10 },	// Hynix 64MB NAND Flash
+	{ 0x20, 0x76, 0x20, 5, 1, 16, 512, 16 << 10 },	// ST Micro 64MB NAND Flash
+};
+
+#define NUM_ARRAY_ENTRIES(a)	(sizeof((a)) / sizeof((a)[0]))
+#define NUM_ATH_NAND		NUM_ARRAY_ENTRIES(ath_nand_arr)
+
+/* ath nand info */
+typedef struct {
+	/* mtd info */
+	struct mtd_info		*mtd;
+
+	/* platform info */
+	unsigned short		page_size,
+				data_width;
+
+	/* NAND MTD partition information */
+	int			nr_partitions;
+	struct mtd_partition	*partitions;
+
+	unsigned		*bbt;
+
+	ath_nand_vend_data_t	*entry;
+
+	unsigned		ba0,
+				ba1,
+				cmd;	// Current command
+	ath_nand_id_t		__id;	// for readid
+	uint8_t			onfi[ONFI_RD_PARAM_PAGE_SZ];
+#if ATH_NF_HW_ECC
+	uint32_t		ecc_offset;
+#endif
+	uint32_t		nf_ctrl;
+} ath_nand_sc_t;
+
+ath_nand_sc_t ath_nand_sc;
+static int ath_nand_hw_init(ath_nand_sc_t *, void *);
+
+struct mtd_info nand_info[CFG_MAX_NAND_DEVICE];
+int nand_curr_device = 0;
+
+#define	nid	__id.__details
+#define	bid	__id.byte_id
+
+static int ath_nand_block_isbad(struct mtd_info *mtd, loff_t ofs);
+void ath_nand_dump_buf(loff_t addr, void *v, unsigned count);
+
+/* max page size (16k) + oob buf size */
+uint8_t	ath_nand_io_buf[24 << 10] __attribute__((aligned(4096)));
+#define get_ath_nand_io_buf()	ath_nand_io_buf
+
+#define	bbt_index	(sizeof(*sc->bbt) * 8 / 2)
+
+/*
+ * MTD layer assumes the NAND device as a linear array of bytes.
+ * However, the NAND devices are organised into blocks, pages,
+ * spare area etc. Hence, the address provided by Linux has to
+ * converted to format expected by the devices.
+ *
+ * [in] mtd: MTD info pointer
+ * [in] addr: Linear Address as provided by MTD layer
+ * [out] addr0: Value to be set into ADDR0_0 register
+ * [out] addr1: Value to be set into ADDR0_1 register
+ * [in] small_block_erase: Address conversion for small block
+ *	is different. Hence, special case it.
+ */
+inline void
+ath_nand_conv_addr(struct mtd_info *mtd, loff_t addr, uint32_t *addr0,
+			uint32_t *addr1, int small_block_erase)
+{
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (is_small_block_device(sc) && small_block_erase) {
+		/*
+		 * The block address loading is accomplished three
+		 * cycles. Erase is a SEQ_14 type command. Hence, the
+		 * controller starts shifting from ADDR_0[16:32] &
+		 * ADDR_1 based on the number of address cycles in our
+		 * case... The device data sheet assumes to have 3
+		 * address cycles for having page address + block
+		 * address for erase. Ideally, SMALL_BLOCK_EN in the
+		 * NF_CTRL register should help but, that doesn't seem
+		 * to work as expected. Hence, the following
+		 * conversion.
+		 */
+
+		// Get the block no.
+		uint32_t b = (addr >> mtd->erasesize_shift);
+
+		*addr0 = (b & 0xfff) << 21;
+		*addr1 = (b >> 11) & 0x1;
+	} else if (is_small_block_device(sc)) {
+		/* +-----+----+----+----+----+----+----+----+----+
+		 * |cycle|I/O7|I/O6|I/O5|I/O4|I/O3|I/O2|I/O1|I/O0|
+		 * +-----+----+----+----+----+----+----+----+----+
+		 * | 1st | A7 | A6 | A5 | A4 | A3 | A2 | A1 | A0 |
+		 * | 2nd |A16 |A15 |A14 |A13 |A12 |A11 |A10 | A9 |
+		 * | 3rd |A24 |A23 |A22 |A21 |A20 |A19 |A18 |A17 |
+		 * | 4th | x  | x  | x  | x  | x  | x  | x  |A25 |
+		 * +-----+----+----+----+----+----+----+----+----+
+		 */
+		addr &= ~(mtd->writesize_mask);
+		*addr0 = ((addr & 0xff) |
+			  ((addr >> 1) & (~0xffu))) & ((1 << 25) - 1);
+		*addr1 = 0;
+	} else {
+		/* +-----+---+---+---+---+---+---+---+---+
+		 * |Cycle|IO0|IO1|IO2|IO3|IO4|IO5|IO6|IO7|
+		 * +-----+---+---+---+---+---+---+---+---+
+		 * | 1st | A0| A1| A2| A3| A4| A5| A6| A7|
+		 * | 2nd | A8| A9|A10|A11| x | x | x | x |
+		 * | 3rd |A12|A13|A14|A15|A16|A17|A18|A19|
+		 * | 4th |A20|A21|A22|A23|A24|A25|A26|A27|
+		 * +-----+---+---+---+---+---+---+---+---+
+		 */
+		*addr0 = ((addr >> mtd->writesize_shift) << 16);
+		*addr1 = ((addr >> (mtd->writesize_shift + 16)) & 0xf);
+	}
+}
+
+inline unsigned
+ath_nand_get_blk_state(struct mtd_info *mtd, loff_t b)
+{
+	unsigned		x, y;
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (!sc->bbt)	return ATH_NAND_BLK_DONT_KNOW;
+
+	b = b >> mtd->erasesize_shift;
+
+	x = b / bbt_index;
+	y = b % bbt_index;
+
+	return (sc->bbt[x] >> (y * 2)) & 0x3;
+}
+
+inline void
+ath_nand_set_blk_state(struct mtd_info *mtd, loff_t b, unsigned state)
+{
+	unsigned		x, y;
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (!sc->bbt)	return;
+
+	b = b >> mtd->erasesize_shift;
+
+	x = b / bbt_index;
+	y = b % bbt_index;
+
+	sc->bbt[x] = (sc->bbt[x] & ~(3 << (y * 2))) | (state << (y * 2));
+}
+
+static unsigned
+ath_nand_status(ath_nand_sc_t *sc, unsigned *ecc)
+{
+	unsigned	rddata, i, j, dmastatus;
+
+	rddata = ath_reg_rd(ATH_NF_STATUS);
+	for (i = 0; i < ATH_NF_STATUS_RETRY && rddata != 0xff; i++) {
+		udelay(5);
+		rddata = ath_reg_rd(ATH_NF_STATUS);
+	}
+
+	dmastatus = ath_reg_rd(ATH_NF_DMA_CTRL);
+	for (j = 0; j < ATH_NF_STATUS_RETRY && !(dmastatus & 1); j++) {
+		udelay(5);
+		dmastatus = ath_reg_rd(ATH_NF_DMA_CTRL);
+	}
+
+	if ((i == ATH_NF_STATUS_RETRY) || (j == ATH_NF_STATUS_RETRY)) {
+		//printk("ath_nand_status: i = %u j = %u\n", i, j);
+		ath_nand_hw_init(sc, NULL);
+		return -1;
+	}
+	if (ecc) {
+		*ecc = ath_reg_rd(ATH_NF_ECC_CTRL);
+	}
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_GENERIC_SEQ_CTRL, 0);
+	ath_reg_wr(ATH_NF_COMMAND, 0x07024);	// READ STATUS
+	while (ath_nand_get_cmd_end_status() == 0);
+	rddata = ath_reg_rd(ATH_NF_RD_STATUS);
+
+	return rddata;
+}
+
+static unsigned
+ath_check_all_0xff(ath_nand_sc_t *sc, unsigned addr0, unsigned addr1, unsigned *all_0xff)
+{
+	uint8_t		*pa, *buf = ath_nand_io_buf, *end;
+	struct mtd_info	*mtd = sc->mtd;
+	unsigned	i, count = mtd->writesize + mtd->oobsize;
+
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_DMA_COUNT, count);
+	ath_reg_wr(ATH_NF_DMA_CTRL, ATH_NF_DMA_CTRL_DMA_START |
+				ATH_NF_DMA_CTRL_DMA_DIR_READ |
+				ATH_NF_DMA_CTRL_DMA_BURST_3);
+	ath_reg_wr(ATH_NF_ECC_OFFSET, 0);
+	ath_reg_wr(ATH_NF_ECC_CTRL, 0);
+	ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_CUSTOM_SIZE_EN);
+	ath_reg_wr(ATH_NF_PG_SIZE, count);
+	pa = (void *)virt_to_phys(buf);
+	ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+	ath_reg_wr(ATH_NF_COMMAND, 0x30006a);	// Read page
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	i = ath_nand_status(sc, NULL) & ATH_NF_RD_STATUS_MASK;
+	memcpy(buf, pa, count);	// cache sync equivalent
+	if (i != ATH_NF_STATUS_OK) {
+		return 0;
+	}
+	end = buf + count;
+	for (buf += sc->ecc_offset; (*buf == 0xff) && buf != end; buf ++);
+
+	*all_0xff = 1;
+
+	if (buf == end) {
+		/* This page was read without ECC. From the spare area
+		 * content we see that it a blank page (i.e. full 0xff).
+		 * To take care of bit flips if any, force 0xff on it.
+		 */
+		memset(ath_nand_io_buf, 0xff, mtd->writesize);
+	} else {
+		ath_nand_dump_buf(addr0, ath_nand_io_buf, mtd->writesize + mtd->oobsize);
+	}
+	return (buf == end);
+}
+
+static unsigned
+ath_nand_rw_page(ath_nand_sc_t *sc, int rd, unsigned addr0, unsigned addr1, unsigned count, unsigned char *buf, unsigned ecc_needed)
+{
+	unsigned	ecc, i = 0, tmp, rddata, all_0xff = 0;
+#if ATH_NF_HW_ECC
+	unsigned	mlc_retry = 0;
+#endif
+	char		*err[] = { "Write", "Read" };
+#define ATH_MAX_RETRY	25
+#define ATH_MLC_RETRY	3
+retry:
+	ecc = 0;
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)buf);
+	ath_reg_wr(ATH_NF_DMA_COUNT, count);
+
+#if ATH_NF_HW_ECC
+	if (ecc_needed && sc->ecc_offset && (count & sc->mtd->writesize_mask) == 0) {
+		/*
+		 * ECC can operate only on the device's pages.
+		 * Cannot be used for non-page-sized read/write
+		 */
+		ath_reg_wr(ATH_NF_ECC_OFFSET, sc->ecc_offset);
+		ath_reg_wr(ATH_NF_ECC_CTRL, ATH_NF_ECC_CTRL_ERR_THRESH(4) |
+						ATH_NF_ECC_CTRL_ECC_4_BITS);
+		ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_ECC_EN);
+		ath_reg_wr(ATH_NF_SPARE_SIZE, sc->mtd->oobsize);
+	} else
+#endif
+	{
+		ath_reg_wr(ATH_NF_ECC_OFFSET, 0);
+		ath_reg_wr(ATH_NF_ECC_CTRL, 0);
+		ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_CUSTOM_SIZE_EN);
+		ath_reg_wr(ATH_NF_PG_SIZE, count);
+	}
+
+	if (rd) {	// Read Page
+		if (is_small_block_device(sc)) {
+			ath_reg_wr(ATH_NF_DMA_CTRL,
+						ATH_NF_DMA_CTRL_DMA_START |
+						ATH_NF_DMA_CTRL_DMA_DIR_READ |
+						ATH_NF_DMA_CTRL_DMA_BURST_3);
+			ath_reg_wr(ATH_NF_GENERIC_SEQ_CTRL,
+						ATH_NF_GENERIC_SEQ_CTRL_COL_ADDR |
+						ATH_NF_GENERIC_SEQ_CTRL_DATA_EN |
+						ATH_NF_GENERIC_SEQ_CTRL_DEL_EN(1) |
+						ATH_NF_GENERIC_SEQ_CTRL_ADDR0_EN |
+						ATH_NF_GENERIC_SEQ_CTRL_CMD0_EN);
+			ath_reg_wr(ATH_NF_COMMAND,
+						ATH_NF_COMMAND_CMD_SEQ_18 |
+						ATH_NF_COMMAND_INPUT_SEL_DMA |
+						ATH_NF_COMMAND_CMD_0(0));
+		} else {
+			ath_reg_wr(ATH_NF_DMA_CTRL,
+						ATH_NF_DMA_CTRL_DMA_START |
+						ATH_NF_DMA_CTRL_DMA_DIR_READ |
+						ATH_NF_DMA_CTRL_DMA_BURST_3);
+			ath_reg_wr(ATH_NF_COMMAND, 0x30006a);
+		}
+	} else {	// Write Page
+		ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);	// Remove write protect
+		ath_reg_wr(ATH_NF_DMA_CTRL,
+					ATH_NF_DMA_CTRL_DMA_START |
+					ATH_NF_DMA_CTRL_DMA_DIR_WRITE |
+					ATH_NF_DMA_CTRL_DMA_BURST_3);
+		ath_reg_wr(ATH_NF_COMMAND, 0x10804c);
+	}
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	//printk(KERN_DEBUG "%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+	//	rd ? 'r' : 'w', addr0, addr1, count, buf);
+
+	rddata = (tmp = ath_nand_status(sc, &ecc)) & ATH_NF_RD_STATUS_MASK;
+	if ((rddata != ATH_NF_STATUS_OK) && (i < ATH_MAX_RETRY)) {
+		i++;
+		goto retry;
+	}
+
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0x0000);	// Enable write protect
+	ath_reg_wr(ATH_NF_FIFO_INIT, 1);
+	ath_reg_wr(ATH_NF_FIFO_INIT, 0);
+
+	if (rddata != ATH_NF_STATUS_OK) {
+		printk("%s: %s Failed. tmp = 0x%x, status = 0x%x 0x%x retries = %d\n", __func__,
+			err[rd], tmp, rddata, ath_reg_rd(ATH_NF_DMA_CTRL), i);
+	}
+#if ATH_NF_HW_ECC
+	else {
+#define DDR_WB_FLUSH_USB_ADDRESS		0x180000a4
+
+		ath_reg_wr(DDR_WB_FLUSH_USB_ADDRESS, 1);
+		while (ath_reg_rd(DDR_WB_FLUSH_USB_ADDRESS) & 1);
+		udelay(2);
+
+		if (ecc_needed && (ecc & ATH_NF_ECC_ERROR)) {
+			if (rd && all_0xff == 0) {
+				if (ath_check_all_0xff(sc, addr0, addr1, &all_0xff)) {
+					return ATH_NF_STATUS_OK;
+				}
+			}
+
+			if (mlc_retry < ATH_MLC_RETRY) {
+				mlc_retry ++;
+				i = 0;
+				goto retry;
+			} else {
+				printk("%s: %s uncorrectable errors. ecc = 0x%x\n",
+					__func__, err[rd], ecc);
+				return -1;
+			}
+		}
+	}
+#endif
+	return rddata;
+}
+
+void
+ath_nand_dump_buf(loff_t addr, void *v, unsigned count)
+{
+	unsigned	*buf = v,
+			*end = buf + (count / sizeof(*buf));
+
+	iodbg("____ Dumping %d bytes at 0x%p 0x%lx_____\n", count, buf, (ulong)addr);
+
+	for (; buf && buf < end; buf += 4, addr += 16) {
+		printk("%08lx: %08x %08x %08x %08x\n",
+			(unsigned)addr, buf[0], buf[1], buf[2], buf[3]);
+	}
+	iodbg("___________________________________\n");
+	//while(1);
+}
+
+static int
+ath_nand_rw_buff(struct mtd_info *mtd, int rd, uint8_t *buf,
+		loff_t addr, size_t len, size_t *iodone)
+{
+	unsigned	iolen, ret = ATH_NF_STATUS_OK, ecc_needed;
+	unsigned char	*pa;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	*iodone = 0;
+
+	while (len) {
+		uint32_t c, ba0, ba1;
+
+		if (ath_nand_block_isbad(mtd, addr)) {
+			printk("Skipping bad block[0x%x]\n", (unsigned)addr);
+			addr += mtd->erasesize;
+			continue;
+		}
+
+		c = (addr & mtd->writesize_mask);
+
+		ath_nand_conv_addr(mtd, addr, &ba0, &ba1, 0);
+
+		if (c) {
+			iolen = mtd->writesize - c;
+		} else {
+			iolen = mtd->writesize;
+		}
+
+		if (len < iolen) {
+			iolen = len;
+		}
+
+		if (rd) {
+			ecc_needed = (ath_nand_get_blk_state(mtd, addr) != ATH_NAND_BLK_ERASED);
+		} else {
+			int i;
+
+			for (i = 0; (i < mtd->writesize) && (buf[i] == 0xff); i++);
+			if (i == mtd->writesize) {
+				ret = ATH_NF_STATUS_OK;
+				//printk("Skipping write for 0x%x\n", (ulong)addr);
+				goto skip_write_for_all_0xff;
+			}
+
+			/* FIXME for writes FIXME */
+			memcpy(ath_nand_io_buf, buf, iolen);
+			ecc_needed = 1;
+		}
+
+		pa = (void *)virt_to_phys(ath_nand_io_buf);
+
+		flush_cache((unsigned)ath_nand_io_buf, mtd->writesize);
+
+		//printk("%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+		//	rd ? 'r' : 'w', ba0, ba1, iolen, pa);
+
+		ret = ath_nand_rw_page(sc, rd, ba0, ba1, mtd->writesize, pa, ecc_needed);
+
+		flush_cache((unsigned)ath_nand_io_buf, mtd->writesize);
+
+		if (rd) {
+			memcpy(buf, ath_nand_io_buf + c, iolen);
+		}
+skip_write_for_all_0xff:
+		//ath_nand_dump_buf(addr, buf, iolen);
+
+		if (ret != ATH_NF_STATUS_OK) {
+			return 1;
+		}
+
+		len -= iolen;
+		buf += iolen;
+		addr += iolen;
+		*iodone += iolen;
+	}
+
+	return 0;
+}
+
+#define ath_nand_write_verify	0
+
+#if ath_nand_write_verify
+uint8_t	ath_nand_rd_buf[4096 + 256] __attribute__((aligned(4096)));
+#endif
+
+static int
+ath_nand_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, const u_char *buf)
+{
+	int	ret;
+#if ath_nand_write_verify
+	int	r, rl;
+#endif
+
+	if (!len || !retlen) return (0);
+
+	indbg("0x%llx	%u", to, len);
+
+	ret = ath_nand_rw_buff(mtd, 0 /* write */, (u_char *)buf, to, len, retlen);
+#if ath_nand_write_verify
+	//printk("Verifying 0x%llx 0x%x\n", to, len);
+	r = ath_nand_rw_buff(mtd, 1 /* read */, ath_nand_rd_buf, to, len, &rl);
+	if (r || memcmp(ath_nand_rd_buf, buf, len)) {
+		printk("write failed at 0x%llx 0x%x\n", to, len);
+		while (1);
+	}
+#endif
+	return ret;
+}
+
+static int
+ath_nand_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	int	ret;
+
+	if (!len || !retlen) return (0);
+
+	ret = ath_nand_rw_buff(mtd, 1 /* read */, buf, from, len, retlen);
+
+	return ret;
+}
+
+static inline int
+ath_nand_block_erase(ath_nand_sc_t *sc, unsigned addr0, unsigned addr1)
+{
+	unsigned	rddata;
+
+	indbg("0x%x 0x%x", addr1, addr0);
+
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);	// Remove write protect
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_COMMAND, 0xd0600e);	// BLOCK ERASE
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	rddata = ath_nand_status(sc, NULL) & ATH_NF_RD_STATUS_MASK;
+
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0x0000);	// Enable write protect
+
+	if (rddata != ATH_NF_STATUS_OK) {
+		printk("Erase Failed. status = 0x%x\n", rddata);
+		return 1;
+	}
+	return 0;
+}
+
+
+static int
+ath_nand_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	ulong		s_first, i;
+	unsigned	n, j;
+	int		ret, bad = 0;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	if (instr->addr + instr->len > mtd->size) {
+		return (-EINVAL);
+	}
+
+	s_first = instr->addr;
+	n = instr->len >> mtd->erasesize_shift;
+
+	if (instr->len & mtd->erasesize_mask) n ++;
+
+	indbg("0x%llx 0x%x 0x%x", instr->addr, n, mtd->erasesize);
+
+	printk("%s: 0x%x %u\n", __func__, s_first, n);
+
+	for (j = 0, i = s_first; j < n; j++, i += mtd->erasesize) {
+		uint32_t ba0, ba1;
+
+		if (ath_nand_block_isbad(mtd, i)) {
+			bad ++;
+			continue;
+		}
+
+		ath_nand_conv_addr(mtd, i, &ba0, &ba1, 1);
+
+		printk("\b\b\b\b%4d", j);
+
+		if ((ret = ath_nand_block_erase(sc, ba0, ba1)) != 0) {
+			printf("%s: erase failed 0x%x 0x%x 0x%x %x "
+				"%lx %lx\n", __func__, instr->addr, n,
+				mtd->erasesize, i, ba1, ba0);
+			break;
+		}
+		ath_nand_set_blk_state(mtd, i, ATH_NAND_BLK_ERASED);
+	}
+
+	if (instr->callback) {
+		if (j < n) {
+			instr->state = MTD_ERASE_FAILED;
+		} else {
+			instr->state = MTD_ERASE_DONE;
+		}
+		mtd_erase_callback(instr);
+	}
+
+	printk("Skipped %d bad blocks\n", bad);
+
+	return ret;
+}
+
+/* lifted from linux */
+typedef enum {
+	MTD_OOB_PLACE,
+	MTD_OOB_AUTO,
+	MTD_OOB_RAW,
+} mtd_oob_mode_t;
+
+struct mtd_oob_ops {
+	mtd_oob_mode_t  mode;
+	size_t          len;
+	size_t          retlen;
+	size_t          ooblen;
+	size_t          oobretlen;
+	uint32_t        ooboffs;
+	uint8_t         *datbuf;
+	uint8_t         *oobbuf;
+};
+
+static int
+ath_nand_rw_oob(struct mtd_info *mtd, int rd, loff_t addr,
+		struct mtd_oob_ops *ops)
+{
+	unsigned	ret = ATH_NF_STATUS_OK;
+	unsigned char	*pa;
+	uint32_t	ba0, ba1;
+	uint8_t		*oob = ath_nand_io_buf + mtd->writesize;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	ath_nand_conv_addr(mtd, addr, &ba0, &ba1, 0);
+
+	if (!rd) {
+		if (ops->datbuf) {
+			/*
+			 * XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX
+			 * We assume that the caller gives us a full
+			 * page to write. We don't read the page and
+			 * update the changed portions alone.
+			 *
+			 * Hence, not checking for len < or > pgsz etc...
+			 * XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX
+			 */
+			memcpy(ath_nand_io_buf, ops->datbuf, ops->len);
+		}
+		if (ops->mode == MTD_OOB_PLACE) {
+			oob += ops->ooboffs;
+		} else if (ops->mode == MTD_OOB_AUTO) {
+			// clean markers
+			oob[0] = oob[1] = 0xff;
+			oob += 2;
+		}
+		memcpy(oob, ops->oobbuf, ops->ooblen);
+	}
+
+	pa = (void *)virt_to_phys(ath_nand_io_buf);
+	if (!rd) flush_cache(ath_nand_io_buf, mtd->writesize + mtd->oobsize);	// for writes...
+
+	//printk("%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+	//	rd ? 'r' : 'w', ba0, ba1, mtd->writesize + mtd->oobsize, pa);
+
+	ret = ath_nand_rw_page(sc, rd, ba0, ba1, mtd->writesize + mtd->oobsize, pa, 0);
+
+	if (ret != ATH_NF_STATUS_OK) {
+		return 1;
+	}
+
+	if (rd) {
+		memcpy(ath_nand_io_buf, KSEG1ADDR(pa), mtd->writesize + mtd->oobsize);	// for reads...
+
+		if (ops->datbuf) {
+			memcpy(ops->datbuf, ath_nand_io_buf, ops->len);
+		}
+		if (ops->mode == MTD_OOB_PLACE) {
+			oob += ops->ooboffs;
+		} else if (ops->mode == MTD_OOB_AUTO) {
+			// copy after clean marker
+			oob += 2;
+		}
+		memcpy(ops->oobbuf, oob, ops->ooblen);
+	}
+
+	//if (rd) {
+	//	ath_nand_dump_buf(addr, ops->datbuf, ops->len);
+	//	ath_nand_dump_buf(addr, ops->oobbuf, ops->ooblen);
+	//}
+
+	if (ops->datbuf) {
+		ops->retlen = ops->len;
+	}
+	ops->oobretlen = ops->ooblen;
+
+	return 0;
+}
+
+//static int
+//ath_nand_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
+int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen)
+{
+	struct mtd_oob_ops ops = { MTD_OOB_RAW, len, 0, ooblen, 0,
+					0, buf, buf + mtd->writesize };
+
+	oobdbg(	"%s: from: 0x%lx mode: 0x%x len: 0x%x retlen: 0x%x\n"
+		"ooblen: 0x%x oobretlen: 0x%x ooboffs: 0x%x datbuf: %p "
+		"oobbuf: %p\n", __func__, (uint32_t)from,
+		ops.mode, ops.len, ops.retlen, ops.ooblen,
+		ops.oobretlen, ops.ooboffs, ops.datbuf,
+		ops.oobbuf);
+
+	oobdbg("0x%lx %p %p %u\n", (uint32_t)from, ops.oobbuf, ops.datbuf, ops.len);
+
+	if (len == 0) {
+		ops.datbuf = 0;
+		ops.oobbuf = buf;
+	}
+	if (ooblen == 0) {
+		ops.oobbuf = NULL;
+	}
+
+	return ath_nand_rw_oob(mtd, 1 /* read */, from, &ops);
+}
+
+#if 0
+static int
+ath_nand_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops)
+{
+	int ret;
+	unsigned char oob[128];
+	struct mtd_oob_ops	rops = {
+		.mode	= MTD_OOB_RAW,
+		.ooblen	= mtd->oobsize,
+		.oobbuf	= oob,
+	};
+
+	if (ops->mode == MTD_OOB_AUTO) {
+		/* read existing oob */
+		if (ath_nand_read_oob(mtd, to, &rops) ||
+			rops.oobretlen != rops.ooblen) {
+			printk("%s: oob read failed at 0x%llx\n", __func__, to);
+			return 1;
+		}
+		memcpy(oob + 2, ops->oobbuf, ops->ooblen);
+		rops = *ops;
+		ops->oobbuf = oob;
+		ops->ooblen = mtd->oobsize;
+		ops->mode = MTD_OOB_RAW;
+	}
+
+	oobdbg(	"%s: from: 0x%llx mode: 0x%x len: 0x%x retlen: 0x%x\n"
+		"ooblen: 0x%x oobretlen: 0x%x ooboffs: 0x%x datbuf: %p "
+		"oobbuf: %p\n", __func__, to,
+		ops->mode, ops->len, ops->retlen, ops->ooblen,
+		ops->oobretlen, ops->ooboffs, ops->datbuf,
+		ops->oobbuf);
+
+	indbg("0x%llx", to);
+
+	ret = ath_nand_rw_oob(mtd, 0 /* write */, to, ops);
+
+	if (rops.mode == MTD_OOB_AUTO) {
+		if (ret == 0) { // rw oob success
+			rops.oobretlen = rops.ooblen;
+			rops.retlen = rops.len;
+		}
+		*ops = rops;
+	}
+
+	return ret;
+}
+#endif
+
+static int
+ath_nand_block_isbad(struct mtd_info *mtd, loff_t ofs)
+{
+	unsigned char		oob[256];
+	unsigned		bs, i;
+	unsigned		*force = (unsigned *)0xbd000000;
+
+	if (*force == 0x12345678) {
+		return 0;
+	}
+
+	bs = ath_nand_get_blk_state(mtd, ofs);
+
+	if ((bs == ATH_NAND_BLK_ERASED) || (bs == ATH_NAND_BLK_GOOD)) {
+		return 0;
+	}
+
+	if (bs == ATH_NAND_BLK_BAD) {
+		return 1;
+	}
+
+	/*
+	 * H27U1G8F2B Series [1 Gbit (128 M x 8 bit) NAND Flash]
+	 *
+	 * The Bad Block Information is written prior to shipping. Any
+	 * block where the 1st Byte in the spare area of the 1st or
+	 * 2nd th page (if the 1st page is Bad) does not contain FFh
+	 * is a Bad Block. The Bad Block Information must be read
+	 * before any erase is attempted as the Bad Block Information
+	 * may be erased. For the system to be able to recognize the
+	 * Bad Blocks based on the original information it is
+	 * recommended to create a Bad Block table following the
+	 * flowchart shown in Figure 24. The 1st block, which is
+	 *                               ^^^^^^^^^^^^^
+	 * placed on 00h block address is guaranteed to be a valid
+	 * block.                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
+	 */
+
+	for (i = 0; i < 2; i++, ofs += mtd->writesize) {
+		if (nand_read_raw(mtd, oob, ofs, 0, mtd->oobsize)) {
+			printk("%s: oob read failed at 0x%lx\n", __func__, (unsigned)ofs);
+			ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_DONT_KNOW);
+			return 1;
+		}
+
+		/* First two bytes of oob data are clean markers */
+		if (oob[0] != 0xff || oob[1] != 0xff) {
+			oobdbg("%s: block is bad at 0x%lx\n", __func__, (unsigned)ofs);
+			oobdbg(	"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				0xff & oob[ 0], 0xff & oob[ 1], 0xff & oob[ 2],
+				0xff & oob[ 3], 0xff & oob[ 4], 0xff & oob[ 5],
+				0xff & oob[ 6], 0xff & oob[ 7], 0xff & oob[ 8],
+				0xff & oob[ 9], 0xff & oob[10], 0xff & oob[11],
+				0xff & oob[12], 0xff & oob[13], 0xff & oob[14],
+				0xff & oob[15], 0xff & oob[16], 0xff & oob[17],
+				0xff & oob[18], 0xff & oob[19], 0xff & oob[20],
+				0xff & oob[21], 0xff & oob[22], 0xff & oob[23],
+				0xff & oob[24], 0xff & oob[25], 0xff & oob[26],
+				0xff & oob[27], 0xff & oob[28], 0xff & oob[29],
+				0xff & oob[30], 0xff & oob[31], 0xff & oob[32],
+				0xff & oob[33], 0xff & oob[34], 0xff & oob[35],
+				0xff & oob[36], 0xff & oob[37], 0xff & oob[38],
+				0xff & oob[39], 0xff & oob[40], 0xff & oob[41],
+				0xff & oob[42], 0xff & oob[43], 0xff & oob[44],
+				0xff & oob[45], 0xff & oob[46], 0xff & oob[47],
+				0xff & oob[48], 0xff & oob[49], 0xff & oob[50],
+				0xff & oob[51], 0xff & oob[52], 0xff & oob[53],
+				0xff & oob[54], 0xff & oob[55], 0xff & oob[56],
+				0xff & oob[57], 0xff & oob[58], 0xff & oob[59],
+				0xff & oob[60], 0xff & oob[61], 0xff & oob[62],
+				0xff & oob[63]);
+			ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_BAD);
+			return 1;
+		}
+	}
+
+	for (i = 0; (i < mtd->oobsize) && (oob[i] == 0xff); i++);
+
+	if (i == mtd->oobsize) {
+		ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_ERASED);
+	} else {
+		ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_GOOD);
+	}
+
+	return 0;
+}
+
+static int
+ath_nand_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	indbg("unimplemented 0x%llx", ofs);
+	return 0;
+}
+
+static unsigned long
+ath_parse_read_id(ath_nand_sc_t *sc)
+{
+	int	i;
+
+	extern struct nand_manufacturers nand_manuf_ids[];
+	extern struct nand_flash_dev nand_flash_ids[];
+
+	iodbg(	"____ %s _____\n"
+		"  vid did wc  ilp nsp ct  dp  sa1 org bs  sa0 ss  "
+		"ps  res1 pls pn  res2\n"
+		"0x%3x %3x %3x %3x %3x %3x %3x %3x %3x %3x %3x %3x "
+		"%3x %3x  %3x %3x %3x\n-------------\n", __func__,
+			sc->nid.vid, sc->nid.did, sc->nid.wc, sc->nid.ilp,
+			sc->nid.nsp, sc->nid.ct, sc->nid.dp, sc->nid.sa1,
+			sc->nid.org, sc->nid.bs, sc->nid.sa0, sc->nid.ss,
+			sc->nid.ps, sc->nid.res1, sc->nid.pls, sc->nid.pn,
+			sc->nid.res2);
+
+	for (i = 0; i < nand_manuf_ids[i].id; i++) {
+		if (nand_manuf_ids[i].id == sc->nid.vid) {
+			printk(nand_manuf_ids[i].name);
+			break;
+		}
+	}
+
+	for (i = 0; i < nand_flash_ids[i].id; i++) {
+		if (nand_flash_ids[i].id == sc->nid.did) {
+			printk(" %s [%uMB]\n", nand_flash_ids[i].name,
+				nand_flash_ids[i].chipsize);
+			return nand_flash_ids[i].chipsize;
+		}
+	}
+
+	return 0;
+}
+
+ath_nand_vend_data_t *
+nand_get_entry(ath_nand_id_t *nand_id, ath_nand_vend_data_t *tbl, int count)
+{
+	int     i;
+
+	for (i = 0; i < count; i++, tbl ++) {
+		if ((nand_id->__details.vid == tbl->vid) &&
+		    (nand_id->__details.did == tbl->did) &&
+		    (nand_id->byte_id[1] == tbl->b3)) {
+			return tbl;
+		}
+	}
+
+	return NULL;
+}
+
+static inline void
+ath_nand_onfi_endian_convert(uint8_t *buf)
+{
+	uint32_t	i, *u = (uint32_t *)(buf + ONFI_DEV_DESC);
+
+	for (i = 0; i < (ONFI_DEV_DESC_SZ / sizeof(*u)); i++) {
+		u[i] = __le32_to_cpu(u[i]);
+	}
+
+	// Hope nobody has a 20 character device description
+	buf[ONFI_DEV_DESC + ONFI_DEV_DESC_SZ - 1] = 0;
+}
+
+int
+nand_param_page(ath_nand_sc_t *sc, uint8_t *buf, unsigned count)
+{
+	unsigned int	tries, rddata;
+	uint8_t		*pa;
+
+	pa = virt_to_phys(buf);
+
+	for (tries = 3; tries; tries --) {
+		// ADDR0_0 Reg Settings
+		ath_reg_wr(ATH_NF_ADDR0_0, 0x0);
+
+		// ADDR0_1 Reg Settings
+		ath_reg_wr(ATH_NF_ADDR0_1, 0x0);
+
+		// DMA Start Addr
+		ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+
+		// DMA count
+		ath_reg_wr(ATH_NF_DMA_COUNT, count);
+
+		// Custom Page Size
+		ath_reg_wr(ATH_NF_PG_SIZE, count);
+
+		// DMA Control Reg
+		ath_reg_wr(ATH_NF_DMA_CTRL, 0xcc);
+
+		ath_nand_clear_int_status();
+		// READ PARAMETER PAGE
+		ath_reg_wr(ATH_NF_COMMAND, 0xec62);
+		while (ath_nand_get_cmd_end_status() == 0);
+
+		rddata = ath_nand_status(sc, NULL) & READ_PARAM_STATUS_MASK;
+		if (rddata == READ_PARAM_STATUS_OK) {
+			break;
+		} else {
+			printk("\nParam Page Failure: 0x%x", rddata);
+			ath_nand_hw_init(sc, NULL);
+		}
+	}
+
+	memcpy(buf, KSEG1ADDR(buf), count);	// get into the cache
+
+	//ath_nand_dump_buf(buf, buf, count);
+
+	if ((rddata == READ_PARAM_STATUS_OK) &&
+	    (buf[3] == 'O' && buf[2] == 'N' && buf[1] == 'F' && buf[0] == 'I')) {
+		ath_nand_onfi_endian_convert(buf);
+		printf("ONFI %s\n", buf + ONFI_DEV_DESC);
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * System initialization functions
+ */
+static int
+ath_nand_hw_init(ath_nand_sc_t *sc, void *p)
+{
+	uint8_t		id[8];
+	unsigned char	*pa;
+	unsigned	rddata, i;
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_NANDF_RESET_MASK);
+	udelay(250);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_NANDF_RESET_MASK);
+	udelay(100);
+
+	ath_reg_wr(ATH_NF_INT_MASK, ATH_NF_CMD_END_INT);
+	ath_nand_clear_int_status();
+
+	// TIMINGS_ASYN Reg Settings
+	ath_reg_wr(ATH_NF_TIMINGS_ASYN, ATH_NF_TIMING_ASYN);
+
+	// NAND Mem Control Reg
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);
+
+	// Reset Command
+	ath_reg_wr(ATH_NF_COMMAND, 0xff00);
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	udelay(1000);
+
+	rddata = ath_reg_rd(ATH_NF_STATUS);
+	for (i = 0; i < ATH_NF_STATUS_RETRY && rddata != 0xff; i++) {
+		udelay(25);
+		rddata = ath_reg_rd(ATH_NF_STATUS);
+	}
+
+	if (i == ATH_NF_STATUS_RETRY) {
+		printf("device reset failed\n");
+		while(1);
+	}
+
+	if (p) {
+		ath_nand_vend_data_t *entry;
+
+		ath_nand_clear_int_status();
+		pa = (void *)virt_to_phys(p ? p : id);
+		ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+		ath_reg_wr(ATH_NF_ADDR0_0, 0x0);
+		ath_reg_wr(ATH_NF_ADDR0_1, 0x0);
+		ath_reg_wr(ATH_NF_DMA_COUNT, 0x8);
+		ath_reg_wr(ATH_NF_PG_SIZE, 0x8);
+		ath_reg_wr(ATH_NF_DMA_CTRL, 0xcc);
+		ath_reg_wr(ATH_NF_COMMAND, 0x9061);	// READ ID
+		while (ath_nand_get_cmd_end_status() == 0);
+
+		rddata = ath_nand_status(sc, NULL);
+		if ((rddata & ATH_NF_RD_STATUS_MASK) != ATH_NF_STATUS_OK) {
+			printf("%s: ath nand status = 0x%x\n", __func__, rddata);
+		}
+
+		pa = p;
+		printk("Ath Nand ID[%p]: %02x:%02x:%02x:%02x:%02x\n",
+				pa, pa[3], pa[2], pa[1], pa[0], pa[7]);
+
+		sc->onfi[0] = 0;
+
+		entry = nand_get_entry((ath_nand_id_t *)p, ath_nand_arr, NUM_ATH_NAND);
+		if (entry) {
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(entry->addrcyc);
+		} else if (nand_param_page(sc, sc->onfi, sizeof(sc->onfi)) == 0) {
+			rddata = sc->onfi[ONFI_NUM_ADDR_CYCLES];
+			rddata = ((rddata >> 4) & 0xf) + (rddata & 0xf);
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(rddata);
+		} else {
+			printk("Attempting to use unknown device\n");
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(5);
+		}
+
+		iodbg("******* %s done ******\n", __func__);
+	}
+
+	return 0;
+}
+
+/*
+ * Copied from drivers/mtd/nand/nand_base.c
+ * http://ptgmedia.pearsoncmg.com/images/chap17_9780132396554/elementLinks/17fig04.gif
+ *
+ * +---...---+--+----------+---------+
+ * |  2048   |  |          |         |
+ * | File    |cm| FS spare | ecc data|
+ * | data    |  |          |         |
+ * +---...---+--+----------+---------+
+ * cm -> clean marker (2 bytes)
+ * FS Spare -> bytes available for jffs2
+ */
+
+static void
+ath_nand_ecc_init(struct mtd_info *mtd)
+{
+#if ATH_NF_HW_ECC
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (is_small_block_device(sc)) {
+		// ECC cannot be supported...
+		sc->ecc_offset = 0;
+	} else {
+		sc->ecc_offset = mtd->writesize + ATH_NAND_JFFS2_ECC_OFF +
+						ATH_NAND_JFFS2_ECC_LEN;
+	}
+#else
+	sc->ecc_offset = 0;
+#endif
+}
+
+void
+ath_nand_set_ns(struct mtd_info *mtd)
+{
+#define ATH_DEF_PAGE_SIZE	(2u << 10)
+#define ATH_DEF_BLK_SIZE	(128u << 10)
+#define ATH_NAND_SPEC		"ns"
+
+	char ns[64], *p;
+
+	if ((p = getenv(ATH_NAND_SPEC))) {
+		/* don't override user setting */
+		return;
+	}
+
+	if (mtd->writesize == ATH_DEF_PAGE_SIZE &&
+	    mtd->erasesize == ATH_DEF_BLK_SIZE) {
+		return;
+	}
+
+	sprintf(ns, "-0x%x-0x%x", mtd->erasesize, mtd->writesize);
+	setenv(ATH_NAND_SPEC, ns);
+	printf("set " ATH_NAND_SPEC " %s\n", ns);
+}
+
+/*
+ * ath_nand_probe
+ *
+ * called by device layer when it finds a device matching
+ * one our driver can handled. This code checks to see if
+ * it can allocate all necessary resources then calls the
+ * nand layer to look for devices
+ */
+static ulong ath_nand_probe(void)
+{
+	ath_nand_sc_t	*sc = NULL;
+	struct mtd_info	*mtd = NULL;
+	int		i, err = 0, bbt_size;
+	unsigned	nf_ctrl_pg[][2] = {
+		/* page size in bytes, register val */
+		{   256, ATH_NF_CTRL_PAGE_SIZE_256	},
+		{   512, ATH_NF_CTRL_PAGE_SIZE_512	},
+		{  1024, ATH_NF_CTRL_PAGE_SIZE_1024	},
+		{  2048, ATH_NF_CTRL_PAGE_SIZE_2048	},
+		{  4096, ATH_NF_CTRL_PAGE_SIZE_4096	},
+		{  8192, ATH_NF_CTRL_PAGE_SIZE_8192	},
+		{ 16384, ATH_NF_CTRL_PAGE_SIZE_16384	},
+		{     0, ATH_NF_CTRL_PAGE_SIZE_0	},
+		};
+	unsigned	nf_ctrl_blk[][2] = {
+		/* no. of pages, register val */
+		{  32, ATH_NF_CTRL_BLOCK_SIZE_32	},
+		{  64, ATH_NF_CTRL_BLOCK_SIZE_64	},
+		{ 128, ATH_NF_CTRL_BLOCK_SIZE_128	},
+		{ 256, ATH_NF_CTRL_BLOCK_SIZE_256	},
+		{   0, 0				},
+		};
+
+	sc = &ath_nand_sc;
+	sc->mtd = &nand_info[nand_curr_device];
+
+	/* initialise the hardware */
+	err = ath_nand_hw_init(sc, &sc->nid);
+	if (err) {
+		goto out_err_hw_init;
+	}
+
+	/* initialise mtd sc data struct */
+	mtd = sc->mtd;
+	mtd->size = ath_parse_read_id(sc) << 20;
+
+	mtd->name		= DRV_NAME;
+	if (mtd->size == 0) {
+		mtd->size	= ath_plane_size[sc->nid.pls] << sc->nid.pn;
+	}
+
+	if (is_small_block_device(sc)) {
+		mtd->writesize		= sc->entry->pgsz;
+		mtd->writesize_shift	= ffs(mtd->writesize) - 1;
+		mtd->writesize_mask	= mtd->writesize - 1;
+
+		mtd->erasesize		= sc->entry->blk;
+		mtd->erasesize_shift	= ffs(mtd->erasesize) - 1;
+		mtd->erasesize_mask	= mtd->erasesize - 1;
+
+		mtd->oobsize		= sc->entry->spare;
+		mtd->oobavail		= mtd->oobsize;
+	} else if (!sc->onfi[0]) {
+		mtd->writesize_shift	= 10 + sc->nid.ps;
+		mtd->writesize		= (1 << mtd->writesize_shift);
+		mtd->writesize_mask	= (mtd->writesize - 1);
+
+		mtd->erasesize_shift	= 16 + sc->nid.bs;
+		mtd->erasesize		= (1 << mtd->erasesize_shift);
+		mtd->erasesize_mask	= (mtd->erasesize - 1);
+
+		mtd->oobsize		= (mtd->writesize / 512) * (8 << sc->nid.ss);
+		mtd->oobavail		= mtd->oobsize;
+	} else {
+		mtd->writesize		= *(uint32_t *)(&sc->onfi[ONFI_PAGE_SIZE]);
+		mtd->writesize_shift	= ffs(mtd->writesize) - 1;
+		mtd->writesize_mask	= (mtd->writesize - 1);
+
+		mtd->erasesize		= *(uint32_t *)(&sc->onfi[ONFI_PAGES_PER_BLOCK]) *
+					  mtd->writesize;
+		mtd->erasesize_shift	= ffs(mtd->erasesize) - 1;
+		mtd->erasesize_mask	= (mtd->erasesize - 1);
+
+		mtd->oobsize		= *(uint16_t *)(&sc->onfi[ONFI_SPARE_SIZE]);
+		mtd->oobavail		= mtd->oobsize;
+
+		mtd->size		= mtd->erasesize *
+					  (*(uint32_t *)(&sc->onfi[ONFI_BLOCKS_PER_LUN])) *
+					  sc->onfi[ONFI_NUM_LUNS];
+	}
+
+	for (i = 0; nf_ctrl_pg[i][0]; i++) {
+		if (nf_ctrl_pg[i][0] == mtd->writesize) {
+			sc->nf_ctrl |= nf_ctrl_pg[i][1];
+			break;
+		}
+	}
+
+	for (i = 0; nf_ctrl_blk[i][0]; i++) {
+		if (nf_ctrl_blk[i][0] == (mtd->erasesize / mtd->writesize)) {
+			sc->nf_ctrl |= nf_ctrl_blk[i][1];
+			break;
+		}
+	}
+
+	ath_nand_set_ns(mtd);
+
+	mtd->type		= MTD_NANDFLASH;
+	mtd->flags		= MTD_CAP_NANDFLASH;
+
+	mtd->read		= ath_nand_read;
+	mtd->write		= ath_nand_write;
+	mtd->erase		= ath_nand_erase;
+
+	//mtd->read_oob		= ath_nand_read_oob;
+	//mtd->write_oob		= ath_nand_write_oob;
+
+	mtd->block_isbad	= ath_nand_block_isbad;
+	mtd->block_markbad	= ath_nand_block_markbad;
+
+	mtd->priv		= sc;
+
+	ath_nand_ecc_init(mtd);
+
+	// bbt has 2 bits per block
+	bbt_size = ((mtd->size >> mtd->erasesize_shift) * 2) / 8;
+	sc->bbt = malloc(bbt_size);
+
+	if (sc->bbt) {
+		memset(sc->bbt, 0, bbt_size);
+	}
+
+	printf(	"====== NAND Parameters ======\n"
+		"sc = 0x%p bbt = 0x%p bbt_size = 0x%x nf_ctrl = 0x%x\n"
+		"page = 0x%x block = 0x%x oob = 0x%x\nsize = %uMB\n", sc, sc->bbt, bbt_size,
+		sc->nf_ctrl, mtd->writesize, mtd->erasesize, mtd->oobsize, mtd->size >> 20);
+
+	return mtd->size;
+
+out_err_hw_init:
+	return 0;
+}
+
+#if 0
+static struct platform_driver ath_nand_driver = {
+	//.probe		= ath_nand_probe,
+	.remove		= __exit_p(ath_nand_remove),
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+#endif
+
+ulong ath_nand_init(void)
+{
+	printk(DRV_DESC ", Version " DRV_VERSION
+		" (c) 2010 Atheros Communications, Ltd.\n");
+
+	//return platform_driver_register(&ath_nand_driver);
+	//return platform_driver_probe(&ath_nand_driver, ath_nand_probe);
+	return ath_nand_probe();
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/ath_pci.c u-boot_1.1//board/atheros/common/ath_pci.c
--- u-boot//board/atheros/common/ath_pci.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/ath_pci.c	2014-02-18 01:46:24.883050975 -0800
@@ -0,0 +1,525 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <pci.h>
+#include <atheros.h>
+
+/*
+** PCI controller "hose" value
+*/
+
+static struct pci_controller hose;
+
+static int ath_local_read_config(int where, int size, uint32_t *value);
+static int ath_local_write_config(int where, int size, uint32_t value);
+
+static int
+ath_local_read_config(int where, int size, uint32_t *value)
+{
+	*value = ath_reg_rd(ATH_PCI_CRP + where);
+	return 0;
+}
+
+static int
+ath_local_write_config(int where, int size, uint32_t value)
+{
+	ath_reg_wr((ATH_PCI_CRP + where),value);
+	return 0;
+}
+
+static int
+ath_pci_read_config(struct pci_controller *hose,
+			pci_dev_t dev, int where, uint32_t *value)
+{
+	*value = ath_reg_rd(ATH_PCI_DEV_CFGBASE + where);
+	return 0;
+}
+
+static int
+ath_pci_write_config(struct pci_controller *hose,
+			pci_dev_t dev, int where, uint32_t value)
+{
+	ath_reg_wr((ATH_PCI_DEV_CFGBASE + where), value);
+	return 0;
+}
+
+#ifdef PCIE2_APP_ADDRESS
+static int
+ath_local_read_config_rc2(int where, int size, uint32_t *value)
+{
+	*value = ath_reg_rd(0x18250000 + where);
+	return 0;
+}
+
+static int
+ath_local_write_config_rc2(int where, int size, uint32_t value)
+{
+	ath_reg_wr((0x18250000 + where),value);
+	return 0;
+}
+
+static int
+ath_pci_read_config_rc2(struct pci_controller *hose,
+			pci_dev_t dev, int where, uint32_t *value)
+{
+	*value = ath_reg_rd(0xb6000000 + where);
+	return 0;
+}
+
+static int
+ath_pci_write_config_rc2(struct pci_controller *hose,
+			pci_dev_t dev, int where, uint32_t value)
+{
+	ath_reg_wr((0xb6000000 + where), value);
+	return 0;
+}
+#endif
+
+/*
+** We will use the ART configuration information stored in flash to initialize
+** these devices as required.
+*/
+
+void plat_dev_init(void)
+{
+	u32	val;
+	u32	addr;
+	u32	BaseAddr = 0x10000000;
+	u32	CalAddr = WLANCAL;
+	volatile u16 *calData;
+
+	/*
+	 * Copy the device ID from Flash to device config space.
+	 */
+
+	calData = (u16 *)CalAddr;
+
+#ifndef CONFIG_PCI_CONFIG_DATA_IN_OTP
+	if (calData[0] != 0xa55a && calData[0] != 0x5aa5)
+	{
+#ifndef COMPRESSED_UBOOT
+		prmsg("BOARD IS NOT CALIBRATED!!!\n");
+#endif
+		return;
+	}
+#else
+	return;
+#endif
+	/*
+	** Need to setup the PCI device to access the internal registers
+	*/
+	if ((is_ar7241() || is_ar7242()))
+		ath_pci_write_config(&hose, NULL, 0x10, 0x1000ffff);
+	else
+		ath_pci_write_config(&hose, NULL, 0x10, 0xffff);
+
+	ath_pci_write_config(&hose, NULL, 0x04, 0x6);
+
+#ifdef PCIE2_APP_ADDRESS
+	ath_pci_write_config_rc2(&hose, NULL, 0x10, 0xffff);
+
+	ath_pci_write_config_rc2(&hose, NULL, 0x04, 0x6);
+#endif
+
+	/*
+	** Set pointer to first reg address
+	*/
+
+	calData += ATH_ART_PCICFG_OFFSET;
+
+	while(*calData != 0xffff)
+	{
+		u16 cd;
+
+		cd = *calData++;
+		addr = BaseAddr + cd;
+		val = *calData++;
+		val |= (*calData++) << 16;
+
+		ath_reg_wr_nf(addr,val);
+		udelay(100);
+	}
+
+	return;
+}
+
+
+/******************************************************************************/
+/*!
+** \brief pci host initialization
+**
+** Sets up the PCI controller on the host. For AR7240 this may not be necessary,
+** but this function is required for board support.
+**
+** We want a 1:1 mapping between PCI and DDR for inbound and outbound.
+** The PCI<---AHB decoding works as follows:
+**
+** 8 registers in the DDR unit provide software configurable 32 bit offsets
+** for each of the eight 16MB PCI windows in the 128MB. The offsets will be
+** added to any address in the 16MB segment before being sent to the PCI unit.
+**
+** Essentially for any AHB address generated by the CPU,
+** 1. the MSB four bits are stripped off, [31:28],
+** 2. Bit 27 is used to decide between the lower 128Mb (PCI) or the rest of
+**    the AHB space
+** 3. Bits 26:24 are used to access one of the 8 window registers and are
+**    masked off.
+** 4. If it is a PCI address, then the WINDOW offset in the WINDOW register
+**    corresponding to the next 3 bits (bit 26:24) is ADDED to the address,
+**    to generate the address to PCI unit.
+**
+**     eg. CPU address = 0x100000ff
+**         window 0 offset = 0x10000000
+**         This points to lowermost 16MB window in PCI space.
+**         So the resulting address would be 0x000000ff+0x10000000
+**         = 0x100000ff
+**
+**         eg2. CPU address = 0x120000ff
+**         WINDOW 2 offset = 0x12000000
+**         resulting address would be 0x000000ff+0x12000000
+**                         = 0x120000ff
+**
+** There is no translation for inbound access (PCI device as a master)
+**
+**  \return N/A
+*/
+
+#ifdef  COMPRESSED_UBOOT
+#	define PCI_INIT_RET_TYPE	int
+#	define PCI_INIT_RETURN		return 0
+#else
+#	define PCI_INIT_RET_TYPE	void
+#	define PCI_INIT_RETURN		return
+#endif
+
+PCI_INIT_RET_TYPE
+pci_init_board (void)
+{
+#ifdef CONFIG_ATH_EMULATION
+	prmsg("--- Skipping %s for emulation\n", __func__);
+#else
+	uint32_t cmd;
+
+	if (is_drqfn() && !is_qca953x()) {
+		/*
+		 * Dont enable PCIe in DRQFN package as it has some issues
+		 * related to PCIe
+		 */
+		PCI_INIT_RETURN;
+	}
+
+#if defined(CONFIG_MACH_QCA953x)
+	if (ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_TESTROM_ENABLE_MASK) { 
+		ath_reg_rmw_clear(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1));
+
+		ath_reg_wr(PCIE_PHY_REG_1_ADDRESS, PCIE_PHY_REG_1_RESET_1); 
+		ath_reg_wr(PCIE_PHY_REG_3_ADDRESS, PCIE_PHY_REG_3_RESET_1); 
+
+		ath_reg_rmw_set(PCIE_PWR_MGMT_ADDRESS, PCIE_PWR_MGMT_ASSERT_CLKREQN_SET(1));
+
+		ath_reg_rmw_set(PCIE_PLL_CONFIG_ADDRESS, PCIE_PLL_CONFIG_PLLPWD_SET(1));
+
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_PCIE_RESET_SET(1));
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_PCIE_PHY_RESET_SET(1));
+
+		ath_reg_rmw_clear(RST_CLKGAT_EN_ADDRESS, RST_CLKGAT_EN_PCIE_RC_SET(1));
+
+		PCI_INIT_RETURN;
+	} else { 
+	 	 /* Honeybee -The PCIe reference clock frequency is being changed 
+	  	    to vary from 99.968MHz to 99.999MHz using SS modulation */
+		ath_reg_wr_nf(PCIE_PLL_DITHER_DIV_MAX_ADDRESS,
+			PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_SET(0x1) |
+			PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(0x1) |
+			PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(0x17) |
+			PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(0x3fff));
+
+		ath_reg_wr_nf(PCIE_PLL_DITHER_DIV_MIN_ADDRESS,
+			PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_SET(0x3f84)|
+			PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_SET(0x17));
+	} 
+#else 
+
+#if defined(CONFIG_MACH_QCA956x)
+
+        ath_reg_rmw_set(PCIE_PHY_REG_1_ADDRESS, PCIE_PHY_REG_1_S_SET(PCIE_PHY_REG_1_S_RESET));
+
+        ath_reg_wr_nf(PCIE_PLL_DITHER_DIV_MAX_ADDRESS,
+                      PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(0x1) |
+                      PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(0x17) |
+                      PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(0x3fff));
+
+        ath_reg_wr_nf(PCIE_PLL_DITHER_DIV_MIN_ADDRESS,
+                      PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_SET(0x3f84) |
+                      PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_SET(0x17));
+#else
+	// common for rc1 and rc2
+	ath_reg_wr_nf(PCIE_PLL_DITHER_DIV_MAX_ADDRESS,
+		PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_SET(0x1) |
+		PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(0x1) |
+		PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(0x14) |
+		PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(0x3ff));
+
+	ath_reg_wr_nf(PCIE_PLL_DITHER_DIV_MIN_ADDRESS,
+		PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_SET(0x14));
+#endif
+
+#endif 
+
+	ath_reg_wr_nf(PCIE_PLL_CONFIG_ADDRESS,
+		PCIE_PLL_CONFIG_REFDIV_SET(1) |
+		PCIE_PLL_CONFIG_BYPASS_SET(1) |
+		PCIE_PLL_CONFIG_PLLPWD_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(PCIE_PLL_CONFIG_ADDRESS, PCIE_PLL_CONFIG_PLLPWD_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(PCIE_PLL_CONFIG_ADDRESS, PCIE_PLL_CONFIG_BYPASS_SET(1));
+	udelay(1000);
+
+#if !defined(CONFIG_MACH_QCA956x)
+
+#ifdef PCIE2_APP_ADDRESS
+	if (!(ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MASK)) {
+		pci_rc2_init_board();
+		return;
+	}
+#endif
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_PCIE_PHY_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_PCIE_RESET_SET(1));
+	udelay(10000);
+
+#ifdef PCIE2_APP_ADDRESS
+	ath_reg_rmw_clear(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1));
+	udelay(10000);
+#endif
+
+	ath_reg_wr_nf(PCIE_RESET_ADDRESS, 0);	// Put endpoint in reset
+	udelay(100000);
+
+#ifdef PCIE2_APP_ADDRESS
+	ath_reg_rmw_set(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1));
+	udelay(10000);
+#endif
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_PCIE_PHY_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_PCIE_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_wr_nf(PCIE_APP_ADDRESS, PCIE_APP_PCIE_BAR_MSN_SET(1) |
+					PCIE_APP_CFG_BE_SET(0xf) |
+					PCIE_APP_SLV_RESP_ERR_MAP_SET(0x3f) |
+					PCIE_APP_LTSSM_ENABLE_SET(1));
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+		PCI_COMMAND_PARITY | PCI_COMMAND_SERR | PCI_COMMAND_FAST_BACK;
+
+	ath_local_write_config(PCI_COMMAND, 4, cmd);
+	ath_local_write_config(0x20, 4, 0x1ff01000);
+	ath_local_write_config(0x24, 4, 0x1ff01000);
+
+	ath_reg_wr_nf(PCIE_RESET_ADDRESS, 4);	// Pull endpoint out of reset
+	udelay(100000);
+
+	/*
+	 * Check if the WLAN PCI-E H/W is present, If the
+	 * WLAN H/W is not present, skip the PCI platform
+	 * initialization code and return
+	 */
+	if (((ath_reg_rd(PCIE_RESET_ADDRESS)) & 0x1) == 0x0) {
+		prmsg("*** Warning *** : PCIe WLAN Module not found !!!\n");
+	}
+#endif
+
+#ifdef PCIE2_APP_ADDRESS
+	pci_rc2_init_board();
+#endif
+
+#ifndef COMPRESSED_UBOOT
+	/*
+	 * Now, configure for u-boot tools
+	 */
+
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region(	&hose.regions[0],
+			0x80000000,
+			0x00000000,
+			32 * 1024 * 1024,
+			PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region(	&hose.regions[1],
+			0x10000000,
+			0x10000000,
+			128 * 1024 * 1024,
+			PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(	&hose,
+			pci_hose_read_config_byte_via_dword,
+			pci_hose_read_config_word_via_dword,
+			ath_pci_read_config,
+			pci_hose_write_config_byte_via_dword,
+			pci_hose_write_config_word_via_dword,
+			ath_pci_write_config);
+#endif
+	plat_dev_init();
+#endif /* CONFIG_ATH_EMULATION */
+
+	PCI_INIT_RETURN;
+}
+
+#ifdef PCIE2_APP_ADDRESS
+void
+pci_rc2_init_board (void)
+{
+#if defined(CONFIG_MACH_QCA956x)
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, 0x1);
+        udelay(10000);
+        ath_reg_rmw_set(GPIO_OUT_FUNCTION0_ADDRESS, GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_SET(0x73));
+        udelay(10000);
+        ath_reg_rmw_set(RST_RESET_ADDRESS,RST_RESET_PCIE_PHY_RESET_SET(1) |
+                                          RST_RESET_PCIE_RESET_SET(1));
+
+        udelay(10000);
+        ath_reg_rmw_clear(RST_RESET_ADDRESS,RST_RESET_PCIE_PHY_RESET_SET(1) |
+                                            RST_RESET_PCIE_RESET_SET(1));
+
+        udelay(10000);
+        ath_reg_rmw_set(RST_RESET2_ADDRESS,RST_RESET_PCIE_PHY_RESET_SET(1) |
+                                           RST_RESET_PCIE_RESET_SET(1));
+
+        udelay(10000);
+        ath_reg_rmw_clear(RST_RESET2_ADDRESS,RST_RESET_PCIE_PHY_RESET_SET(1) |
+                                             RST_RESET_PCIE_RESET_SET(1));
+
+        udelay(10000);
+        ath_reg_wr(PCIE2_RESET_ADDRESS,PCIE2_RESET_EP_RESET_L_SET(1));
+        udelay(10000);
+        ath_reg_wr(ATH_PCI_CRP_WRDATA,0x6);
+        udelay(10000);
+        ath_reg_wr(PCIE_APP_ADDRESS,PCIE_APP_LTSSM_ENABLE_SET(1) |
+                                    PCIE_APP_SLV_RESP_ERR_MAP_SET(0x3f) |
+                                    PCIE_APP_CFG_BE_SET(0xf) |
+                                    PCIE_APP_PCIE_BAR_MSN_SET(1));
+        udelay(10000);
+        ath_reg_wr(PCIE_INT_MASK_ADDRESS,PCIE_INT_MASK_CORR_ERR_SET(1) |
+                                         PCIE_INT_MASK_NONFATAL_ERR_SET(1) |
+                                         PCIE_INT_MASK_FATAL_ERR_SET(1) |
+                                         PCIE_INT_MASK_GM_COMP_LOOKUP_ERR_SET(1) |
+                                         PCIE_INT_MASK_RADMX_COMP_LOOKUP_ERR_SET(1) |
+                                         PCIE_INT_MASK_INTA_SET(1) |
+                                         PCIE_INT_MASK_INTB_SET(1) |
+                                         PCIE_INT_MASK_INTC_SET(1) |
+                                         PCIE_INT_MASK_INTD_SET(1) |
+                                         PCIE_INT_MASK_MSI_SET(1) |
+                                         PCIE_INT_MASK_MSI_ERR_SET(1) |
+                                         PCIE_INT_MASK_AER_INT_SET(1) |
+                                         PCIE_INT_MASK_AER_MSI_SET(1) |
+                                         PCIE_INT_MASK_SYS_ERR_SET(1) |
+                                         PCIE_INT_MASK_INTAL_SET(1) |
+                                         PCIE_INT_MASK_INTBL_SET(1) |
+                                         PCIE_INT_MASK_INTCL_SET(1) |
+                                         PCIE_INT_MASK_INTDL_SET(1));
+        udelay(10000);
+        ath_local_write_config_rc2(0x70c, 4, 0x1b403200);
+        udelay(10000);
+        ath_reg_wr(PCIE_DEBUG_ADDRESS,PCIE_DEBUG_BYTESWAP_SET(1));
+        udelay(10000);
+		
+        ath_reg_rmw_set(XTAL2_SEC_ADDRESS, XTAL2_SEC_SPARE_SET(0xc));
+        udelay(10000);
+        ath_reg_rmw_clear(PCIe_DPLL2_ADDRESS, PCIe_DPLL2_KI_SET(0x3) |
+                                              PCIe_DPLL2_KD_SET(0xF));
+        udelay(10000);
+        ath_reg_rmw_set(PCIe_DPLL2_ADDRESS, PCIe_DPLL2_KD_SET(0x4));
+        udelay(10000);
+
+#else
+
+	uint32_t	cmd;
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_PCIE2_PHY_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_PCIE2_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY2_SET(1));
+	udelay(10000);
+
+	ath_reg_wr_nf(PCIE2_RESET_ADDRESS, 0);	// Put endpoint in reset
+	udelay(100000);
+
+	ath_reg_rmw_set(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY2_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET_PCIE_PHY_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET_PCIE_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_wr_nf(PCIE2_APP_ADDRESS, PCIE2_APP_PCIE2_BAR_MSN_SET(1) |
+					PCIE2_APP_CFG_BE_SET(0xf) |
+					PCIE2_APP_SLV_RESP_ERR_MAP_SET(0x3f) |
+					PCIE2_APP_LTSSM_ENABLE_SET(1));
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+		PCI_COMMAND_PARITY | PCI_COMMAND_SERR | PCI_COMMAND_FAST_BACK;
+
+	ath_local_write_config_rc2(PCI_COMMAND, 4, cmd);
+	ath_local_write_config_rc2(0x20, 4, 0x1ff01000);
+	ath_local_write_config_rc2(0x24, 4, 0x1ff01000);
+
+	ath_reg_wr_nf(PCIE2_RESET_ADDRESS, 4);	// Pull endpoint out of reset
+	udelay(100000);
+
+#endif	   
+	/*
+	 * Check if the WLAN PCI-E H/W is present, If the
+	 * WLAN H/W is not present, skip the PCI platform
+	 * initialization code and return
+	 */
+	if (((ath_reg_rd(PCIE2_RESET_ADDRESS)) & 0x1) == 0x0) {
+		prmsg("*** Warning *** : PCIe WLAN Module not found !!!\n");
+		return;
+	}
+}
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/athr_ar8033_phy.c u-boot_1.1//board/atheros/common/athr_ar8033_phy.c
--- u-boot//board/atheros/common/athr_ar8033_phy.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/athr_ar8033_phy.c	2014-02-18 01:46:24.883050975 -0800
@@ -0,0 +1,156 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include <atheros.h>
+#include "athrs_ar8033_phy.h"
+
+
+void
+athrs_ar8033_mgmt_init(void)
+{
+    uint32_t rddata;
+
+
+    rddata = ath_reg_rd(GPIO_IN_ENABLE3_ADDRESS)&
+             ~GPIO_IN_ENABLE3_MII_GE1_MDI_MASK;
+    rddata |= GPIO_IN_ENABLE3_MII_GE1_MDI_SET(19);
+    ath_reg_wr(GPIO_IN_ENABLE3_ADDRESS, rddata);
+    
+    ath_reg_rmw_clear(GPIO_OE_ADDRESS, ATH_GPIO);
+
+    ath_reg_rmw_clear(GPIO_OE_ADDRESS, ATH_GPIO17);
+
+    
+    rddata = ath_reg_rd(GPIO_OUT_FUNCTION4_ADDRESS) & 
+             ~ (GPIO_FUNCTION4_MASK);
+
+    rddata |= (GPIO_FUNCTION4_ENABLE);
+
+    ath_reg_wr(GPIO_OUT_FUNCTION4_ADDRESS, rddata);
+
+#ifdef ATH_MDC_GPIO
+    rddata = ath_reg_rd(GPIO_OUT_FUNCTION3_ADDRESS) &
+           ~ (GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK);
+
+    rddata |= GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_SET(0x21);
+
+    ath_reg_wr(GPIO_OUT_FUNCTION3_ADDRESS, rddata);
+#endif
+
+}
+
+int
+athrs_ar8033_phy_setup(void  *arg)
+{
+    
+    return 0;
+}
+
+int
+athrs_ar8033_phy_is_fdx(int ethUnit)
+{
+   int phy_hw_status = 0x0;
+
+   phy_hw_status = ath_reg_rd(SGMII_MAC_RX_CONFIG_ADDRESS);
+
+   if (SGMII_MAC_RX_CONFIG_DUPLEX_MODE_GET(phy_hw_status) == 1) {
+        return 1;
+    } else if (SGMII_MAC_RX_CONFIG_DUPLEX_MODE_GET(phy_hw_status) == 0) {
+        return 0;
+    }
+
+    return 0;
+
+}
+
+int
+athrs_ar8033_phy_is_link_alive(int phyUnit)
+{
+   int phy_hw_status = 0x0;
+
+   phy_hw_status = ath_reg_rd(SGMII_MAC_RX_CONFIG_ADDRESS);
+
+   if (SGMII_MAC_RX_CONFIG_LINK_GET(phy_hw_status))
+        return 1;
+    else
+        return 0;
+
+  }
+
+int
+athrs_ar8033_phy_is_up(int ethUnit)
+{
+   int phy_hw_status = 0x0;
+
+   phy_hw_status = ath_reg_rd(SGMII_MAC_RX_CONFIG_ADDRESS);
+    if (SGMII_MAC_RX_CONFIG_LINK_GET(phy_hw_status))
+        return 1;
+    else
+        return 0;
+
+   
+}
+int
+athrs_ar8033_phy_speed(int ethUnit)
+{
+   int phy_hw_status = 0x0,speed;
+
+   phy_hw_status = ath_reg_rd(SGMII_MAC_RX_CONFIG_ADDRESS);
+
+   speed = ((phy_hw_status & (3 << 10)) >> 10);
+
+   switch (speed) {
+        case 0:
+                return _10BASET;
+                break;
+        case 1:
+                return _100BASET;
+                break;
+        case 2:
+                return _1000BASET;
+                break;
+        default:
+                return -1;
+                break;
+   }
+
+   return -1;
+
+}
+
+
+int 
+athrs_ar8033_reg_init(void *arg)
+{
+
+
+	athrs_ar8033_mgmt_init();
+	phy_reg_write(0x1,0x5, 0x1f, 0x101);
+
+
+
+	printf("%s: Done %x \n",__func__, phy_reg_read(0x1,0x5,0x1f));
+   
+	return 0;
+}
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/athrs17_lpbk.c u-boot_1.1//board/atheros/common/athrs17_lpbk.c
--- u-boot//board/atheros/common/athrs17_lpbk.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/athrs17_lpbk.c	2014-02-18 01:46:24.883050975 -0800
@@ -0,0 +1,312 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+// ----------------------------------
+// S17 Initialization
+// author : subha@atheros.com
+// adapted: Abishek Goda <Abishek.Goda at atheros dot com>
+// ----------------------------------
+
+//#include <prototypes.h>
+//#include <gmac_defines.h>
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#include <atheros.h>
+#include "qca-eth-955x.h"
+#include "qca-eth-955x_phy.h"
+#include "phy.h"
+#include "athrs17_phy.h"
+
+uint32_t athrs17_reg_read(uint32_t reg_addr);
+void athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val);
+
+#ifdef ATH_RGMII_CAL
+
+# define ATHR_PHY_MAX 1
+
+#if 0
+void s17_phy_write( unsigned int phy_address, 
+                    unsigned int reg_address, 
+                    unsigned int write_data ) {
+
+    unsigned int rddata;
+    unsigned int address;
+
+    address = ((phy_address << 8) & 0x1f00) | (reg_address & 0x1f);
+
+    reg_write(GE0_MAC_MII_MGMT_CFG, 0x7);
+
+    rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    while(rddata){
+        rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    }
+    reg_write(GE0_MAC_MII_MGMT_CMD, 0x0);
+    reg_write(GE0_MAC_MII_MGMT_ADDR, address);
+    reg_write(GE0_MAC_MII_MGMT_CNTR, write_data);
+    while(rddata){
+        rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    }
+}
+
+unsigned int s17_phy_read(unsigned int phy_address, unsigned int reg_address) {
+
+    unsigned int rddata;
+    unsigned int address;
+    unsigned int phy_rddata;
+
+    address = ((phy_address << 8) & 0x1f00) | (reg_address & 0x1f);
+
+    reg_write(GE0_MAC_MII_MGMT_CFG, 0x7);
+
+    rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    while(rddata){
+        rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    }
+    reg_write(GE0_MAC_MII_MGMT_CMD, 0x0);
+    reg_write(GE0_MAC_MII_MGMT_ADDR, address);
+    reg_write(GE0_MAC_MII_MGMT_CMD, 0x1);
+
+    rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    while(rddata){
+        rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    }
+
+    phy_rddata = reg_read(GE0_MAC_MII_MGMT_STAT);
+    reg_write(GE0_MAC_MII_MGMT_CMD, 0x0);
+
+    return(phy_rddata);
+
+}
+
+void s17_reg_write(unsigned int reg_addr, unsigned int reg_val) {
+
+    unsigned int reg_word_addr;
+    unsigned int phy_addr;
+    unsigned int phy_val;
+    unsigned int phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    /* bit16-8 of reg address          */
+    phy_val = (unsigned int) ((reg_word_addr >> 8) & 0x3ff);  
+    s17_phy_write(phy_addr, phy_reg, phy_val);
+
+    /* For S17 registers such as ARL and VLAN, since they include BUSY bit   */
+    /* in higher address, we should write the lower 16-bit register then the */
+    /* higher one */
+
+    /* write register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);  /* bit7-5 of reg address */
+    phy_reg = (unsigned int) (reg_word_addr & 0x1f); /* bit4-0 of reg address */
+    phy_val = (unsigned int) (reg_val & 0xffff);
+    s17_phy_write( phy_addr, phy_reg, phy_val);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);  /* bit7-5 of reg address */
+    phy_reg = (unsigned int) (reg_word_addr & 0x1f); /* bit4-0 of reg address */
+    phy_val = (unsigned int) ((reg_val >> 16) & 0xffff);
+    s17_phy_write( phy_addr, phy_reg, phy_val);
+}
+
+unsigned int s17_reg_read(unsigned int reg_addr) 
+{
+    unsigned int reg_word_addr;
+    unsigned int phy_addr, tmp_val, reg_val;
+    unsigned int phy_val;
+    unsigned int phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    /* bit16-8 of reg address */
+    phy_val = (unsigned int) ((reg_word_addr >> 8) & 0x3ff); 
+    s17_phy_write( phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as MIBs, since it is read/clear, we should */
+    /* read the lower 16-bit register then the higher one */
+
+    /* read register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);  /* bit7-5 of reg address */
+    phy_reg = (unsigned int) (reg_word_addr & 0x1f); /* bit4-0 of reg address */
+    reg_val = (unsigned int) s17_phy_read( phy_addr, phy_reg);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);  /* bit7-5 of reg address */
+    phy_reg = (unsigned int) (reg_word_addr & 0x1f); /* bit4-0 of reg address */
+    tmp_val = (unsigned int) s17_phy_read( phy_addr, phy_reg);
+    reg_val |= (tmp_val << 16);
+
+    return reg_val;
+}
+#endif
+
+void s17_reg_rmw(unsigned int reg_addr, unsigned int reg_val) 
+{
+
+    reg_val |= athrs17_reg_read(reg_addr);
+    athrs17_reg_write(reg_addr,reg_val);
+}
+
+void init_s17(void) 
+{
+    int phyUnit = 0;
+    int phyBase = 0;
+    int phyAddr = 0;
+    unsigned int rddata;
+
+    athrs17_reg_write(0x624 , 0x003f3f3f);
+    athrs17_reg_write(0x10  , 0x40000000);
+    athrs17_reg_write(0x4   , 0x07500000);
+    athrs17_reg_write(0xc   , 0x01000000);
+    athrs17_reg_write(0x7c  , 0x000000fe); // 1gbps
+    //athrs17_reg_write(0x7c  , 0x0000007d); // 100 mbps
+    //athrs17_reg_write(0x7c  , 0x0000007c); // 10 mbps
+
+    for (phyUnit= 0; phyUnit <= ATHR_PHY_MAX; phyUnit++)
+    {
+        phyBase = 0;
+        phyAddr = phyUnit;
+        // To enable loopback on a phy
+        // rddata = s17_phy_read(phyAddr, 0x0);
+        // s17_phy_write(phyAddr, 0x0, (rddata | (1 << 14)));
+        /* For 100M waveform */
+        phy_reg_write(0, phyAddr, 0x1d, 0x18);
+        phy_reg_write(0, phyAddr, 0x1e, 0x02ea);
+        /* Turn On Gigabit Clock */
+        phy_reg_write(0, phyAddr, 0x1d, 0x3d);
+        phy_reg_write(0, phyAddr, 0x1e, 0x48a0);
+
+    }
+
+    /* Enable flow control */
+    s17_reg_rmw(0x80,0x30);
+    s17_reg_rmw(0x84,0x30);
+    s17_reg_rmw(0x88,0x30);
+    s17_reg_rmw(0x8c,0x30);
+    s17_reg_rmw(0x90,0x30);
+}
+
+void vlan_config(void)
+{
+    athrs17_reg_write(S17_P0LOOKUP_CTRL_REG, 0x0014001e);
+    athrs17_reg_write(S17_P0VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P1LOOKUP_CTRL_REG, 0x0014001d);
+    athrs17_reg_write(S17_P1VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P2LOOKUP_CTRL_REG, 0x0014001b);
+    athrs17_reg_write(S17_P2VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P3LOOKUP_CTRL_REG, 0x00140017);
+    athrs17_reg_write(S17_P3VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P4LOOKUP_CTRL_REG, 0x0014000f);
+    athrs17_reg_write(S17_P4VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P5LOOKUP_CTRL_REG, 0x00140040);
+    athrs17_reg_write(S17_P5VLAN_CTRL0_REG, 0x20001);
+
+    athrs17_reg_write(S17_P6LOOKUP_CTRL_REG, 0x00140020);
+    athrs17_reg_write(S17_P6VLAN_CTRL0_REG, 0x20001);
+
+}
+
+void init_s17_lpbk(void) 
+{
+    int phyUnit = 0;
+    int phyBase = 0;
+    int phyAddr = 0;
+    unsigned int rddata;
+
+#ifdef ATH_S17_MAC0_SGMII
+    athrs17_reg_write(0x4   , 0x080080);
+    athrs17_reg_write(0xc   , 0x07600000);
+    athrs17_reg_write(0x94  , 0x000000fe); // 1gbps
+    athrs17_reg_write(0x624 , 0x007f7f7f);
+    printf ("Vlan config...\n");
+    vlan_config();
+#else
+    athrs17_reg_write(0x624 , 0x003f3f3f);
+    athrs17_reg_write(0x4   , 0x07500000);
+    athrs17_reg_write(0xc   , 0x01000000);
+#endif
+    athrs17_reg_write(0x10  , 0x4000000);
+    athrs17_reg_write(0x7c  , 0x000000fe); // 1gbps
+    //athrs17_reg_write(0x7c  , 0x0000007d); // 100 mbps
+    //athrs17_reg_write(0x7c  , 0x0000007c); // 10 mbps
+
+    phyBase = 0;
+#ifdef ATH_S17_MAC0_SGMII
+    phyAddr = 4;
+#else
+    phyAddr = 0;
+#endif
+    // To enable loopback on single phy
+    phy_reg_write(0, phyAddr, 0x0, 0xc140);
+    for(rddata=0; rddata<1000; rddata++);
+    phy_reg_write(0, phyAddr, 0x0, 0x4140);
+    for(rddata=0; rddata<1000; rddata++);
+    rddata = phy_reg_read(0, phyAddr, 0x0);
+#ifdef DEBUG
+    printf("s17 phy0 register value 0x%08x\n", rddata);
+#endif
+    // power down other phys
+#ifdef ATH_S17_MAC0_SGMII
+    phy_reg_write(0, 0x0, 0x0, 0x8800);
+#else
+    phy_reg_write(0, 0x4, 0x0, 0x8800);
+#endif
+    phy_reg_write(0, 0x1, 0x0, 0x8800);
+    phy_reg_write(0, 0x2, 0x0, 0x8800);
+    phy_reg_write(0, 0x3, 0x0, 0x8800);
+    /* For 100M waveform */
+    phy_reg_write(0, phyAddr, 0x1d, 0x18);
+    phy_reg_write(0, phyAddr, 0x1e, 0x02ea);
+    /* Turn On Gigabit Clock */
+    phy_reg_write(0, phyAddr, 0x1d, 0x3d);
+    phy_reg_write(0, phyAddr, 0x1e, 0x48a0);
+
+    /* Enable flow control */
+    s17_reg_rmw(0x80,0x30);
+    s17_reg_rmw(0x84,0x30);
+    s17_reg_rmw(0x88,0x30);
+    s17_reg_rmw(0x8c,0x30);
+    s17_reg_rmw(0x90,0x30);
+}
+
+#endif /* #ifdef RGMII_CAL */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/athrs17_phy.c u-boot_1.1//board/atheros/common/athrs17_phy.c
--- u-boot//board/atheros/common/athrs17_phy.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/athrs17_phy.c	2014-02-18 01:46:24.883050975 -0800
@@ -0,0 +1,754 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include <atheros.h>
+#include "athrs17_phy.h"
+
+/* PHY selections and access functions */
+typedef enum {
+	PHY_SRCPORT_INFO,
+	PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+	PHY_SRCPORT_NONE,
+	PHY_SRCPORT_VLANTAG,
+	PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+#define ENET_UNIT_GE0 0
+#define ENET_UNIT_GE1 1
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_IND_PHY 4
+
+#define MODULE_NAME "ATHRS17"
+#define S17_PHY_DEBUG 1
+extern int xmii_val;
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+#if defined(ATH_S17_MAC0_SGMII)
+#if (CFG_ATH_GMAC_NMACS == 1) /* QCA9563 only have 1 GMAC working */
+#define ENET_UNIT            ENET_UNIT_GE0
+#define ENET_UNIT_WAN        ENET_UNIT_GE0
+#else
+#define ENET_UNIT            ENET_UNIT_GE1
+#define ENET_UNIT_WAN        ENET_UNIT_GE0
+#endif
+#else
+#define ENET_UNIT            ENET_UNIT_GE0
+#define ENET_UNIT_WAN        ENET_UNIT_GE1
+#endif
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+	{
+		TRUE,   /* phy port 0 -- LAN port 0 */
+		FALSE,
+		ENET_UNIT,
+		0,
+		ATHR_PHY0_ADDR,
+		ATHR_LAN_PORT_VLAN
+	},
+	{
+		TRUE,   /* phy port 1 -- LAN port 1 */
+		FALSE,
+		ENET_UNIT,
+		0,
+		ATHR_PHY1_ADDR,
+		ATHR_LAN_PORT_VLAN
+	},
+	{
+		TRUE,   /* phy port 2 -- LAN port 2 */
+		FALSE,
+		ENET_UNIT,
+		0,
+		ATHR_PHY2_ADDR,
+		ATHR_LAN_PORT_VLAN
+	},
+	{
+		TRUE,   /* phy port 3 -- LAN port 3 */
+		FALSE,
+		ENET_UNIT,
+		0,
+		ATHR_PHY3_ADDR,
+		ATHR_LAN_PORT_VLAN
+	},
+	{
+		TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+		FALSE,
+#if defined(CONFIG_ATH_S17_WAN) || defined (ATH_S17_MAC0_SGMII)
+		ENET_UNIT_WAN,
+#else
+		ENET_UNIT,
+#endif
+		0,
+		ATHR_PHY4_ADDR,
+		ATHR_LAN_PORT_VLAN   /* Send to all ports */
+	},
+	{
+		FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+		TRUE,
+		ENET_UNIT,
+		0,
+		0x00,
+		ATHR_LAN_PORT_VLAN    /* Send to all ports */
+	},
+};
+
+static uint8_t athr17_init_flag = 0;
+
+//#define ATHR_PHY_MAX (sizeof(ipPhyInfo) / sizeof(ipPhyInfo[0]))
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit)	\
+	(ATHR_IS_ENET_PORT(phyUnit) &&		\
+	 ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_GE0))
+
+/* Forward references */
+BOOL athrs17_phy_is_link_alive(int phyUnit);
+uint32_t athrs17_reg_read(uint32_t reg_addr);
+void athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val);
+static void phy_mode_setup(void);
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+
+static void phy_mode_setup(void)
+{
+#ifdef ATHRS17_VER_1_0
+	/*work around for phy4 rgmii mode*/
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);
+
+	/*rx delay*/
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);
+
+	/*tx delay*/
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);
+#endif
+}
+/*
+ * V-lan configuration given by Switch team
+ * Vlan 1:PHY0,1,2,3 and Mac 0 of s17
+ * Vlam 2:PHY4 and Mac 6 of s17
+ */
+
+void athrs17_vlan_config()
+{
+	athrs17_reg_write(S17_P0LOOKUP_CTRL_REG, 0x0014001e);
+	athrs17_reg_write(S17_P0VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P1LOOKUP_CTRL_REG, 0x0014001d);
+	athrs17_reg_write(S17_P1VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P2LOOKUP_CTRL_REG, 0x0014001b);
+	athrs17_reg_write(S17_P2VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P3LOOKUP_CTRL_REG, 0x00140017);
+	athrs17_reg_write(S17_P3VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P4LOOKUP_CTRL_REG, 0x0014000f);
+	athrs17_reg_write(S17_P4VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P5LOOKUP_CTRL_REG, 0x00140040);
+	athrs17_reg_write(S17_P5VLAN_CTRL0_REG, 0x20001);
+
+	athrs17_reg_write(S17_P6LOOKUP_CTRL_REG, 0x00140020);
+	athrs17_reg_write(S17_P6VLAN_CTRL0_REG, 0x20001);
+
+
+}
+
+void athrs17_reg_init_wan(void)
+{
+
+#ifdef ATH_S17_MAC0_SGMII
+	athrs17_reg_write(S17_P6PAD_MODE_REG,0x07600000);
+
+#else
+	athrs17_reg_write(S17_P6PAD_MODE_REG,
+           athrs17_reg_read(S17_P6PAD_MODE_REG)|S17_MAC6_SGMII_EN);
+#endif
+	athrs17_reg_write(S17_P6STATUS_REG, S17_PORT_STATUS_AZ_DEFAULT);
+	athrs17_reg_write(S17_SGMII_CTRL_REG , 0xc74164d0); /* SGMII control */
+         
+        athrs17_vlan_config();
+	printf("%s done\n",__func__);
+
+}
+
+void athrs17_reg_init()
+{
+	int phy_addr = 0;
+	uint32_t sgmii_ctrl_value;
+	/* if using header for register configuration, we have to     */
+	/* configure s17 register after frame transmission is enabled */
+
+	if ((athrs17_reg_read(S17_MASK_CTRL_REG) & 0xFFFF) == S17C_DEVICEID){
+		sgmii_ctrl_value = 0xc74164de;
+	}else{
+		sgmii_ctrl_value = 0xc74164d0;
+	}
+	if (athr17_init_flag){
+		return;
+	}
+
+#if (CFG_ATH_GMAC_NMACS == 1)	
+		athrs17_reg_write(S17_P0PAD_MODE_REG, S17_MAC0_SGMII_EN);
+		athrs17_reg_write(S17_SGMII_CTRL_REG , sgmii_ctrl_value); /* SGMII control  */
+		athrs17_reg_write(S17_GLOFW_CTRL1_REG,	0x7f7f7f7f);
+#else
+	if (is_drqfn()) {
+		athrs17_reg_write(S17_P0PAD_MODE_REG, S17_MAC0_SGMII_EN);
+		athrs17_reg_write(S17_SGMII_CTRL_REG , sgmii_ctrl_value); /* SGMII control  */
+    } else {
+		athrs17_reg_write(S17_GLOFW_CTRL1_REG,	0x7f7f7f7f);
+		/* 
+                 * If defined S17 Mac0 sgmii val of 0x4(S17_P0PAD_MODE_REG)
+                 * should be configured as 0x80
+                 */
+#ifdef ATH_S17_MAC0_SGMII
+		athrs17_reg_write(S17_P0PAD_MODE_REG,	0x80080);
+#else
+		athrs17_reg_write(S17_P0PAD_MODE_REG,	0x07680000);
+#endif
+		athrs17_reg_write(S17_P6PAD_MODE_REG,	0x01000000);		
+	}
+#endif	/* CFG_ATH_GMAC_NMACS == 1 */
+	
+/*
+ * Values suggested by the swich team when s17 in sgmii configuration
+ * operates in forced mode.
+ * 0x10(S17_PWS_REG)=0x602613a0
+ */
+#ifdef ATH_SGMII_FORCED_MODE
+	athrs17_reg_write(S17_PWS_REG, 0x602613a0);
+#else
+	athrs17_reg_write(S17_PWS_REG,	0x40000000);
+#endif
+	athrs17_reg_write(S17_P0STATUS_REG,	 0x0000007e);
+
+	/* AR8327/AR8328 v1.0 fixup */
+	if ((athrs17_reg_read(0x0) & 0xffff) == 0x1201) {
+		for (phy_addr = 0x0; phy_addr <= ATHR_PHY_MAX; phy_addr++) {
+			/* For 100M waveform */
+			phy_reg_write(0, phy_addr, 0x1d, 0x0);
+			phy_reg_write(0, phy_addr, 0x1e, 0x02ea);
+			/* Turn On Gigabit Clock */
+			phy_reg_write(0, phy_addr, 0x1d, 0x3d);
+			phy_reg_write(0, phy_addr, 0x1e, 0x68a0);
+		}
+	}
+#if CONFIG_S17_SWMAC6_CONNECTED
+        printf ("Configuring Mac6 of s17 to slave scorpion\n");
+	athrs17_reg_write(S17_P6PAD_MODE_REG, S17_MAC6_RGMII_EN | S17_MAC6_RGMII_TXCLK_DELAY | \
+                              S17_MAC6_RGMII_RXCLK_DELAY | (1 << S17_MAC6_RGMII_TXCLK_SHIFT) | \
+                              (2 << S17_MAC6_RGMII_RXCLK_SHIFT));
+	athrs17_reg_write(S17_P6STATUS_REG, 0x7e);	
+        athrs17_vlan_config();
+#endif
+	athr17_init_flag = 1;
+	printf("%s: complete\n",__func__);
+}
+
+/******************************************************************************
+*
+* athrs17_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs17_phy_is_link_alive(int phyUnit)
+{
+	uint16_t phyHwStatus;
+	uint32_t phyBase;
+	uint32_t phyAddr;
+
+	phyBase = ATHR_PHYBASE(phyUnit);
+	phyAddr = ATHR_PHYADDR(phyUnit);
+
+	phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+	if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+		return TRUE;
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs17_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs17_phy_setup(int ethUnit)
+{
+	int       phyUnit;
+	uint16_t  phyHwStatus;
+	uint16_t  timeout;
+	int       liveLinks = 0;
+	uint32_t  phyBase = 0;
+	BOOL      foundPhy = FALSE;
+	uint32_t  phyAddr = 0;
+
+	/* See if there's any configuration data for this enet */
+	/* start auto negogiation on each phy */
+	if (is_drqfn()) 
+		ethUnit=0;
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		foundPhy = TRUE;
+		phyBase = ATHR_PHYBASE(phyUnit);
+		phyAddr = ATHR_PHYADDR(phyUnit);
+
+		phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,
+				ATHR_ADVERTISE_ALL);
+
+		phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,
+				ATHR_ADVERTISE_1000FULL);
+
+		/* Reset PHYs*/
+		phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+				ATHR_CTRL_AUTONEGOTIATION_ENABLE
+				| ATHR_CTRL_SOFTWARE_RESET);
+
+	}
+
+	if (!foundPhy) {
+		return FALSE; /* No PHY's configured for this ethUnit */
+	}
+
+	/*
+	 * After the phy is reset, it takes a little while before
+	 * it can respond properly.
+	 */
+	sysMsDelay(1000);
+
+
+	/*
+	 * Wait up to 3 seconds for ALL associated PHYs to finish
+	 * autonegotiation.  The only way we get out of here sooner is
+	 * if ALL PHYs are connected AND finish autonegotiation.
+	 */
+	for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		timeout=20;
+		for (;;) {
+			phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+			if (ATHR_RESET_DONE(phyHwStatus)) {
+				DRV_PRINT(DRV_DEBUG_PHYSETUP,
+						("Port %d, Neg Success\n", phyUnit));
+				break;
+			}
+			if (timeout == 0) {
+				DRV_PRINT(DRV_DEBUG_PHYSETUP,
+						("Port %d, Negogiation timeout\n", phyUnit));
+				break;
+			}
+			if (--timeout == 0) {
+				DRV_PRINT(DRV_DEBUG_PHYSETUP,
+						("Port %d, Negogiation timeout\n", phyUnit));
+				break;
+			}
+
+			sysMsDelay(150);
+		}
+	}
+
+	/*
+	 * All PHYs have had adequate time to autonegotiate.
+	 * Now initialize software status.
+	 *
+	 * It's possible that some ports may take a bit longer
+	 * to autonegotiate; but we can't wait forever.  They'll
+	 * get noticed by mv_phyCheckStatusChange during regular
+	 * polling activities.
+	 */
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+#if 0
+		/* Enable RGMII */
+		phy_reg_write(0,phyUnit,0x1d,0x12);
+		phy_reg_write(0,phyUnit,0x1e,0x8);
+		/* Tx delay on PHY */
+		phy_reg_write(0,phyUnit,0x1d,0x5);
+		phy_reg_write(0,phyUnit,0x1e,0x100);
+
+		/* Rx delay on PHY */
+		phy_reg_write(0,phyUnit,0x1d,0x0);
+		phy_reg_write(0,phyUnit,0x1e,0x8000);
+#endif
+		if (athrs17_phy_is_link_alive(phyUnit)) {
+			liveLinks++;
+			ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+		} else {
+			ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+		}
+
+		DRV_PRINT(DRV_DEBUG_PHYSETUP,
+				("eth%d: Phy Specific Status=%4.4x\n",
+				 ethUnit,
+				 phy_reg_read(ATHR_PHYBASE(phyUnit),
+					 ATHR_PHYADDR(phyUnit),
+					 ATHR_PHY_SPEC_STATUS)));
+	}
+	phy_mode_setup();
+	return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs17_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs17_phy_is_fdx(int ethUnit)
+{
+	int       phyUnit;
+	uint32_t  phyBase;
+	uint32_t  phyAddr;
+	uint16_t  phyHwStatus;
+	int       ii = 200;
+
+
+	if (is_drqfn())
+		ethUnit = 0;
+
+
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		if (athrs17_phy_is_link_alive(phyUnit)) {
+
+			phyBase = ATHR_PHYBASE(phyUnit);
+			phyAddr = ATHR_PHYADDR(phyUnit);
+
+			do {
+				phyHwStatus = phy_reg_read (phyBase, phyAddr,
+						ATHR_PHY_SPEC_STATUS);
+				if(phyHwStatus & ATHR_STATUS_RESOVLED)
+					break;
+				sysMsDelay(10);
+			} while(--ii);
+
+			if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+				return TRUE;
+		}
+	}
+
+	if (ethUnit == ENET_UNIT_GE0 || ethUnit == ENET_UNIT_GE1)
+		return TRUE;
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs17_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS: _10BASET, _100BASETX, _1000BASET
+*/
+
+int
+athrs17_phy_speed(int ethUnit)
+{
+	int       phyUnit;
+	uint16_t  phyHwStatus;
+	uint32_t  phyBase;
+	uint32_t  phyAddr;
+	int       ii = 200;
+
+	if ((ethUnit == ENET_UNIT_GE0) || (ethUnit == ENET_UNIT_GE1))
+		return _1000BASET;
+
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		if (athrs17_phy_is_link_alive(phyUnit)) {
+
+			phyBase = ATHR_PHYBASE(phyUnit);
+			phyAddr = ATHR_PHYADDR(phyUnit);
+
+			do {
+				phyHwStatus = phy_reg_read(phyBase, phyAddr,
+						ATHR_PHY_SPEC_STATUS);
+				if(phyHwStatus & ATHR_STATUS_RESOVLED)
+					break;
+				sysMsDelay(10);
+			} while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+			phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+					ATHER_STATUS_LINK_SHIFT);
+
+			switch(phyHwStatus) {
+			case 0: return _10BASET;
+			case 1: return _100BASET;
+			case 2: return _1000BASET;
+			default: printf("Unkown speed read!\n");
+			}
+		}
+
+	}
+
+	return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs17_phy_is_up(int ethUnit)
+{
+	int           phyUnit;
+	uint16_t      phyHwStatus, phyHwControl;
+	athrPhyInfo_t *lastStatus;
+	int           linkCount   = 0;
+	int           lostLinks   = 0;
+	int           gainedLinks = 0;
+	uint32_t      phyBase;
+	uint32_t      phyAddr;
+
+	if (is_drqfn()) 
+		ethUnit = 0;
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		phyBase = ATHR_PHYBASE(phyUnit);
+		phyAddr = ATHR_PHYADDR(phyUnit);
+
+		lastStatus = &athrPhyInfo[phyUnit];
+
+		if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+			phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+			/* See if we've lost link */
+			if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+				linkCount++;
+			} else {
+				lostLinks++;
+				DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+							ethUnit, phyUnit));
+				lastStatus->isPhyAlive = FALSE;
+			}
+		} else { /* last known link status was DEAD */
+			/* Check for reset complete */
+			phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS);
+			if (!ATHR_RESET_DONE(phyHwStatus)) {
+				continue;
+			}
+
+			phyHwControl = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+			/* Check for AutoNegotiation complete */
+			if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+					|| ATHR_AUTONEG_DONE(phyHwStatus)) {
+				phyHwStatus = phy_reg_read(phyBase, phyAddr,
+						ATHR_PHY_SPEC_STATUS);
+
+				if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+					gainedLinks++;
+					linkCount++;
+					DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+								ethUnit, phyUnit));
+					lastStatus->isPhyAlive = TRUE;
+				}
+			}
+		}
+	}
+
+	return (linkCount);
+
+}
+
+uint32_t
+athrs17_reg_read(uint32_t reg_addr)
+{
+	uint32_t reg_word_addr;
+	uint32_t phy_addr, tmp_val, reg_val;
+	uint16_t phy_val;
+	uint8_t phy_reg;
+
+	/* change reg_addr to 16-bit word address, 32-bit aligned */
+	reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+	/* configure register high address */
+	phy_addr = 0x18;
+	phy_reg = 0x0;
+	phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+	phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+	/* For some registers such as MIBs, since it is read/clear, we should */
+	/* read the lower 16-bit register then the higher one */
+
+	/* read register in lower address */
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+	reg_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+
+	/* read register in higher address */
+	reg_word_addr++;
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+	tmp_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+	reg_val |= (tmp_val << 16);
+
+	return reg_val;
+}
+
+void
+athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val)
+{
+	uint32_t reg_word_addr;
+	uint32_t phy_addr;
+	uint16_t phy_val;
+	uint8_t phy_reg;
+
+	/* change reg_addr to 16-bit word address, 32-bit aligned */
+	reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+	/* configure register high address */
+	phy_addr = 0x18;
+	phy_reg = 0x0;
+	phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+	phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+	/* For some registers such as ARL and VLAN, since they include BUSY bit */
+	/* in lower address, we should write the higher 16-bit register then the */
+	/* lower one */
+
+	/* read register in higher address */
+	reg_word_addr++;
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+	phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+	phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+	/* write register in lower address */
+	reg_word_addr--;
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+	phy_val = (uint16_t) (reg_val & 0xffff);
+	phy_reg_write(0, phy_addr, phy_reg, phy_val);
+}
+
+unsigned int s17_rd_phy(unsigned int phy_addr, unsigned int reg_addr)
+{
+    return ((uint32_t) phy_reg_read(0, phy_addr, reg_addr));
+}
+
+void s17_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data)
+{
+    phy_reg_write(0, phy_addr, reg_addr, write_data);
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/athrs17_phy.h u-boot_1.1//board/atheros/common/athrs17_phy.h
--- u-boot//board/atheros/common/athrs17_phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/athrs17_phy.h	2014-02-18 01:46:24.895050981 -0800
@@ -0,0 +1,578 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _ATHRS17_PHY_H
+#define _ATHRS17_PHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+/* S17 CSR Registers */
+
+#define S17_ENABLE_CPU_BROADCAST             (1 << 26)
+
+#define S17_PHY_LINK_CHANGE_REG 		     0x4
+#define S17_PHY_LINK_UP 		             0x400
+#define S17_PHY_LINK_DOWN 		             0x800
+#define S17_PHY_LINK_DUPLEX_CHANGE 		     0x2000
+#define S17_PHY_LINK_SPEED_CHANGE		     0x4000
+#define S17_PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+//defines from athrs17_phy.h driver
+#define S17C_DEVICEID					0x1302
+
+#define S17_MASK_CTRL_REG               0x0000
+#define S17_P0PAD_MODE_REG              0x0004
+#define S17_P5PAD_MODE_REG              0x0008
+#define S17_P6PAD_MODE_REG              0x000c
+#define S17_PWS_REG                     0x0010
+#define S17_GLOBAL_INT0_REG             0x0020
+#define S17_GLOBAL_INT1_REG             0x0024
+#define S17_GLOBAL_INTMASK0             0x0028
+#define S17_GLOBAL_INTMASK1             0x002c
+#define S17_MODULE_EN_REG               0x0030
+#define S17_MIB_REG                     0x0034
+#define S17_INTF_HIADDR_REG             0x0038
+#define S17_MDIO_CTRL_REG               0x003c
+#define S17_BIST_CTRL_REG               0x0040
+#define S17_BIST_REC_REG                0x0044
+#define S17_SERVICE_REG                 0x0048
+#define S17_LED_CTRL0_REG               0x0050
+#define S17_LED_CTRL1_REG               0x0054
+#define S17_LED_CTRL2_REG               0x0058
+#define S17_LED_CTRL3_REG               0x005c
+#define S17_MACADDR0_REG                0x0060
+#define S17_MACADDR1_REG                0x0064
+#define S17_MAX_FRAME_SIZE_REG          0x0078
+#define S17_P0STATUS_REG                0x007c
+#define S17_P1STATUS_REG                0x0080
+#define S17_P2STATUS_REG                0x0084
+#define S17_P3STATUS_REG                0x0088
+#define S17_P4STATUS_REG                0x008c
+#define S17_P5STATUS_REG                0x0090
+#define S17_P6STATUS_REG                0x0094
+#define S17_HDRCTRL_REG                 0x0098
+#define S17_P0HDRCTRL_REG               0x009c
+#define S17_P1HDRCTRL_REG               0x00A0
+#define S17_P2HDRCTRL_REG               0x00a4
+#define S17_P3HDRCTRL_REG               0x00a8
+#define S17_P4HDRCTRL_REG               0x00ac
+#define S17_P5HDRCTRL_REG               0x00b0
+#define S17_P6HDRCTRL_REG               0x00b4
+#define S17_SGMII_CTRL_REG              0x00e0
+#define S17_EEE_CTRL_REG		0x0100
+
+/* ACL Registers */
+#define S17_ACL_FUNC0_REG               0x0400
+#define S17_ACL_FUNC1_REG               0x0404
+#define S17_ACL_FUNC2_REG               0x0408
+#define S17_ACL_FUNC3_REG               0x040c
+#define S17_ACL_FUNC4_REG               0x0410
+#define S17_ACL_FUNC5_REG               0x0414
+#define S17_PRIVATE_IP_REG              0x0418
+#define S17_P0VLAN_CTRL0_REG            0x0420
+#define S17_P0VLAN_CTRL1_REG            0x0424
+#define S17_P1VLAN_CTRL0_REG            0x0428
+#define S17_P1VLAN_CTRL1_REG            0x042c
+#define S17_P2VLAN_CTRL0_REG            0x0430
+#define S17_P2VLAN_CTRL1_REG            0x0434
+#define S17_P3VLAN_CTRL0_REG            0x0438
+#define S17_P3VLAN_CTRL1_REG            0x043c
+#define S17_P4VLAN_CTRL0_REG            0x0440
+#define S17_P4VLAN_CTRL1_REG            0x0444
+#define S17_P5VLAN_CTRL0_REG            0x0448
+#define S17_P5VLAN_CTRL1_REG            0x044c
+#define S17_P6VLAN_CTRL0_REG            0x0450
+#define S17_P6VLAN_CTRL1_REG            0x0454
+
+/* Table Lookup Registers */
+#define S17_ATU_DATA0_REG               0x0600
+#define S17_ATU_DATA1_REG               0x0604
+#define S17_ATU_DATA2_REG               0x0608
+#define S17_ATU_FUNC_REG                0x060C
+#define S17_VTU_FUNC0_REG               0x0610
+#define S17_VTU_FUNC1_REG               0x0614
+#define S17_ARL_CTRL_REG                0x0618
+#define S17_GLOFW_CTRL0_REG             0x0620
+#define S17_GLOFW_CTRL1_REG             0x0624
+#define S17_GLOLEARN_LIMIT_REG          0x0628
+#define S17_TOS_PRIMAP_REG0             0x0630
+#define S17_TOS_PRIMAP_REG1             0x0634
+#define S17_TOS_PRIMAP_REG2             0x0638
+#define S17_TOS_PRIMAP_REG3             0x063c
+#define S17_TOS_PRIMAP_REG4             0x0640
+#define S17_TOS_PRIMAP_REG5             0x0644
+#define S17_TOS_PRIMAP_REG6             0x0648
+#define S17_TOS_PRIMAP_REG7             0x064c
+#define S17_VLAN_PRIMAP_REG0            0x0650
+#define S17_LOOP_CHECK_REG              0x0654
+#define S17_P0LOOKUP_CTRL_REG           0x0660
+#define S17_P0PRI_CTRL_REG              0x0664
+#define S17_P0LEARN_LMT_REG             0x0668
+#define S17_P1LOOKUP_CTRL_REG           0x066c
+#define S17_P1PRI_CTRL_REG              0x0670
+#define S17_P1LEARN_LMT_REG             0x0674
+#define S17_P2LOOKUP_CTRL_REG           0x0678
+#define S17_P2PRI_CTRL_REG              0x067c
+#define S17_P2LEARN_LMT_REG             0x0680
+#define S17_P3LOOKUP_CTRL_REG           0x0684
+#define S17_P3PRI_CTRL_REG              0x0688
+#define S17_P3LEARN_LMT_REG             0x068c
+#define S17_P4LOOKUP_CTRL_REG           0x0690
+#define S17_P4PRI_CTRL_REG              0x0694
+#define S17_P4LEARN_LMT_REG             0x0698
+#define S17_P5LOOKUP_CTRL_REG           0x069c
+#define S17_P5PRI_CTRL_REG              0x06a0
+#define S17_P5LEARN_LMT_REG             0x06a4
+#define S17_P6LOOKUP_CTRL_REG           0x06a8
+#define S17_P6PRI_CTRL_REG              0x06ac
+#define S17_P6LEARN_LMT_REG             0x06b0
+#define S17_GLO_TRUNK_CTRL0_REG         0x0700
+#define S17_GLO_TRUNK_CTRL1_REG         0x0704
+#define S17_GLO_TRUNK_CTRL2_REG         0x0708
+
+/* Queue Management Registers */
+#define S17_PORT0_HOL_CTRL0		0x0970
+#define S17_PORT0_HOL_CTRL1		0x0974
+#define S17_PORT1_HOL_CTRL0		0x0978
+#define S17_PORT1_HOL_CTRL1		0x097c
+#define S17_PORT2_HOL_CTRL0		0x0980
+#define S17_PORT2_HOL_CTRL1		0x0984
+#define S17_PORT3_HOL_CTRL0		0x0988
+#define S17_PORT3_HOL_CTRL1		0x098c
+#define S17_PORT4_HOL_CTRL0		0x0990
+#define S17_PORT4_HOL_CTRL1		0x0994
+#define S17_PORT5_HOL_CTRL0		0x0998
+#define S17_PORT5_HOL_CTRL1		0x099c
+#define S17_PORT6_HOL_CTRL0		0x09a0
+#define S17_PORT6_HOL_CTRL1		0x09a4
+
+/* Port flow control registers */
+#define S17_P0_FLCTL_REG		0x09b0
+#define S17_P1_FLCTL_REG		0x09b4
+#define S17_P2_FLCTL_REG		0x09b8
+#define S17_P3_FLCTL_REG		0x09bc
+#define S17_P4_FLCTL_REG		0x09c0
+#define S17_P5_FLCTL_REG		0x09c4
+
+/* Packet Edit registers */
+#define S17_PKT_EDIT_CTRL		0x0c00
+#define S17_P0Q_REMAP_REG0		0x0c40
+#define S17_P0Q_REMAP_REG1		0x0c44
+#define S17_P1Q_REMAP_REG0		0x0c48
+#define S17_P2Q_REMAP_REG0		0x0c4c
+#define S17_P3Q_REMAP_REG0		0x0c50
+#define S17_P4Q_REMAP_REG0		0x0c54
+#define S17_P5Q_REMAP_REG0		0x0c58
+#define S17_P5Q_REMAP_REG1		0x0c5c
+#define S17_P6Q_REMAP_REG0		0x0c60
+#define S17_P6Q_REMAP_REG1		0x0c64
+#define S17_ROUTER_VID0			0x0c70
+#define S17_ROUTER_VID1			0x0c74
+#define S17_ROUTER_VID2			0x0c78
+#define S17_ROUTER_VID3			0x0c7c
+#define S17_ROUTER_EG_VLAN_MODE		0x0c80
+
+/* L3 Registers */
+#define S17_HROUTER_CTRL_REG            0x0e00
+#define S17_HROUTER_PBCTRL0_REG         0x0e04
+#define S17_HROUTER_PBCTRL1_REG         0x0e08
+#define S17_HROUTER_PBCTRL2_REG         0x0e0c
+#define S17_WCMP_HASH_TABLE0_REG        0x0e10
+#define S17_WCMP_HASH_TABLE1_REG        0x0e14
+#define S17_WCMP_HASH_TABLE2_REG        0x0e18
+#define S17_WCMP_HASH_TABLE3_REG        0x0e1c
+#define S17_WCMP_NHOP_TABLE0_REG        0x0e20
+#define S17_WCMP_NHOP_TABLE1_REG        0x0e24
+#define S17_WCMP_NHOP_TABLE2_REG        0x0e28
+#define S17_WCMP_NHOP_TABLE3_REG        0x0e2c
+#define S17_ARP_ENTRY_CTRL_REG          0x0e30
+#define S17_ARP_USECNT_REG              0x0e34
+#define S17_HNAT_CTRL_REG               0x0e38
+#define S17_NAPT_ENTRY_CTRL0_REG        0x0e3c
+#define S17_NAPT_ENTRY_CTRL1_REG        0x0e40
+#define S17_NAPT_USECNT_REG             0x0e44
+#define S17_ENTRY_EDIT_DATA0_REG        0x0e48
+#define S17_ENTRY_EDIT_DATA1_REG        0x0e4c
+#define S17_ENTRY_EDIT_DATA2_REG        0x0e50
+#define S17_ENTRY_EDIT_DATA3_REG        0x0e54
+#define S17_ENTRY_EDIT_CTRL_REG         0x0e58
+#define S17_HNAT_PRIVATE_IP_REG         0x0e5c
+
+/* MIB counters */
+#define S17_MIB_PORT0			0x1000
+#define S17_MIB_PORT1			0x1100
+#define S17_MIB_PORT2			0x1200
+#define S17_MIB_PORT3			0x1300
+#define S17_MIB_PORT4			0x1400
+#define S17_MIB_PORT5			0x1500
+#define S17_MIB_PORT6			0x1600
+
+#define S17_MIB_RXBROAD			0x0
+#define S17_MIB_RXPAUSE			0x4
+#define S17_MIB_RXMULTI			0x8
+#define S17_MIB_RXFCSERR		0xC
+#define S17_MIB_RXALIGNERR		0x10
+#define S17_MIB_RXUNDERSIZE		0x14
+#define S17_MIB_RXFRAG			0x18
+#define S17_MIB_RX64B			0x1C
+#define S17_MIB_RX128B			0x20
+#define S17_MIB_RX256B			0x24
+#define S17_MIB_RX512B			0x28
+#define S17_MIB_RX1024B			0x2C
+#define S17_MIB_RX1518B			0x30
+#define S17_MIB_RXMAXB			0x34
+#define S17_MIB_RXTOOLONG		0x38
+#define S17_MIB_RXBYTE1			0x3C
+#define S17_MIB_RXBYTE2			0x40
+#define S17_MIB_RXOVERFLOW		0x4C
+#define S17_MIB_FILTERED		0x50
+#define S17_MIB_TXBROAD			0x54
+#define S17_MIB_TXPAUSE			0x58
+#define S17_MIB_TXMULTI			0x5C
+#define S17_MIB_TXUNDERRUN		0x60
+#define S17_MIB_TX64B			0x64
+#define S17_MIB_TX128B			0x68
+#define S17_MIB_TX256B			0x6c
+#define S17_MIB_TX512B			0x70
+#define S17_MIB_TX1024B			0x74
+#define S17_MIB_TX1518B			0x78
+#define S17_MIB_TXMAXB			0x7C
+#define S17_MIB_TXOVERSIZE		0x80
+#define S17_MIB_TXBYTE1			0x84
+#define S17_MIB_TXBYTE2			0x88
+#define S17_MIB_TXCOL			0x8C
+#define S17_MIB_TXABORTCOL		0x90
+#define S17_MIB_TXMULTICOL		0x94
+#define S17_MIB_TXSINGLECOL		0x98
+#define S17_MIB_TXEXCDEFER		0x9C
+#define S17_MIB_TXDEFER			0xA0
+#define S17_MIB_TXLATECOL		0xA4
+
+/* Register fields */
+#define S17_CHIPID_V1_0			0x1201
+#define S17_CHIPID_V1_1			0x1202
+
+#define S17_MAC0_MAC_MII_RXCLK_SEL	(1 << 0)
+#define S17_MAC0_MAC_MII_TXCLK_SEL	(1 << 1)
+#define S17_MAC0_MAC_MII_EN		(1 << 2)
+#define S17_MAC0_MAC_GMII_RXCLK_SEL	(1 << 4)
+#define S17_MAC0_MAC_GMII_TXCLK_SEL	(1 << 5)
+#define S17_MAC0_MAC_GMII_EN		(1 << 6)
+#define S17_MAC0_SGMII_EN		(1 << 7)
+#define S17_MAC0_PHY_MII_RXCLK_SEL	(1 << 8)
+#define S17_MAC0_PHY_MII_TXCLK_SEL	(1 << 9)
+#define S17_MAC0_PHY_MII_EN		(1 << 10)
+#define S17_MAC0_PHY_MII_PIPE_SEL	(1 << 11)
+#define S17_MAC0_PHY_GMII_RXCLK_SEL	(1 << 12)
+#define S17_MAC0_PHY_GMII_TXCLK_SEL	(1 << 13)
+#define S17_MAC0_PHY_GMII_EN		(1 << 14)
+#define S17_MAC0_RGMII_RXCLK_SHIFT	20
+#define S17_MAC0_RGMII_TXCLK_SHIFT	22
+#define S17_MAC0_RGMII_RXCLK_DELAY	(1 << 24)
+#define S17_MAC0_RGMII_TXCLK_DELAY	(1 << 25)
+#define S17_MAC0_RGMII_EN		(1 << 26)
+
+#define S17_MAC5_MAC_MII_RXCLK_SEL	(1 << 0)
+#define S17_MAC5_MAC_MII_TXCLK_SEL	(1 << 1)
+#define S17_MAC5_MAC_MII_EN		(1 << 2)
+#define S17_MAC5_PHY_MII_RXCLK_SEL	(1 << 8)
+#define S17_MAC5_PHY_MII_TXCLK_SEL	(1 << 9)
+#define S17_MAC5_PHY_MII_EN		(1 << 10)
+#define S17_MAC5_PHY_MII_PIPE_SEL	(1 << 11)
+#define S17_MAC5_RGMII_RXCLK_SHIFT	20
+#define S17_MAC5_RGMII_TXCLK_SHIFT	22
+#define S17_MAC5_RGMII_RXCLK_DELAY	(1 << 24)
+#define S17_MAC5_RGMII_TXCLK_DELAY	(1 << 25)
+#define S17_MAC5_RGMII_EN		(1 << 26)
+
+#define S17_MAC6_MAC_MII_RXCLK_SEL	(1 << 0)
+#define S17_MAC6_MAC_MII_TXCLK_SEL	(1 << 1)
+#define S17_MAC6_MAC_MII_EN		(1 << 2)
+#define S17_MAC6_MAC_GMII_RXCLK_SEL	(1 << 4)
+#define S17_MAC6_MAC_GMII_TXCLK_SEL	(1 << 5)
+#define S17_MAC6_MAC_GMII_EN		(1 << 6)
+#define S17_MAC6_SGMII_EN		(1 << 7)
+#define S17_MAC6_PHY_MII_RXCLK_SEL	(1 << 8)
+#define S17_MAC6_PHY_MII_TXCLK_SEL	(1 << 9)
+#define S17_MAC6_PHY_MII_EN		(1 << 10)
+#define S17_MAC6_PHY_MII_PIPE_SEL	(1 << 11)
+#define S17_MAC6_PHY_GMII_RXCLK_SEL	(1 << 12)
+#define S17_MAC6_PHY_GMII_TXCLK_SEL	(1 << 13)
+#define S17_MAC6_PHY_GMII_EN		(1 << 14)
+#define S17_PHY4_GMII_EN		(1 << 16)
+#define S17_PHY4_RGMII_EN		(1 << 17)
+#define S17_PHY4_MII_EN			(1 << 18)
+#define S17_MAC6_RGMII_RXCLK_SHIFT	20
+#define S17_MAC6_RGMII_TXCLK_SHIFT	22
+#define S17_MAC6_RGMII_RXCLK_DELAY	(1 << 24)
+#define S17_MAC6_RGMII_TXCLK_DELAY	(1 << 25)
+#define S17_MAC6_RGMII_EN		(1 << 26)
+
+#define S17_SPEED_10M			(0 << 0)
+#define S17_SPEED_100M			(1 << 0)
+#define S17_SPEED_1000M			(2 << 0)
+#define S17_TXMAC_EN			(1 << 2)
+#define S17_RXMAC_EN			(1 << 3)
+#define S17_TX_FLOW_EN			(1 << 4)
+#define S17_RX_FLOW_EN			(1 << 5)
+#define S17_DUPLEX_FULL			(1 << 6)
+#define S17_DUPLEX_HALF			(0 << 6)
+#define S17_TX_HALF_FLOW_EN		(1 << 7)
+#define S17_LINK_EN			(1 << 9)
+#define S17_FLOW_LINK_EN		(1 << 12)
+#define S17_PORT_STATUS_DEFAULT		(S17_SPEED_1000M | S17_TXMAC_EN | \
+                                        S17_RXMAC_EN | S17_TX_FLOW_EN | \
+                                        S17_RX_FLOW_EN | S17_DUPLEX_FULL | \
+                                        S17_TX_HALF_FLOW_EN)
+
+#define S17_PORT_STATUS_AZ_DEFAULT	(S17_SPEED_1000M | S17_TXMAC_EN | \
+                                        S17_RXMAC_EN | S17_TX_FLOW_EN | \
+                                        S17_RX_FLOW_EN | S17_DUPLEX_FULL)
+
+
+#define S17_HDRLENGTH_SEL		(1 << 16)
+#define S17_HDR_VALUE			0xAAAA
+
+#define S17_TXHDR_MODE_NO		0
+#define S17_TXHDR_MODE_MGM		1
+#define S17_TXHDR_MODE_ALL		2
+#define S17_RXHDR_MODE_NO		(0 << 2)
+#define S17_RXHDR_MODE_MGM		(1 << 2)
+#define S17_RXHDR_MODE_ALL		(2 << 2)
+
+#define S17_CPU_PORT_EN			(1 << 10)
+#define S17_PPPOE_REDIR_EN		(1 << 8)
+#define S17_MIRROR_PORT_SHIFT		4
+#define S17_IGMP_COPY_EN		(1 << 3)
+#define S17_RIP_COPY_EN			(1 << 2)
+#define S17_EAPOL_REDIR_EN		(1 << 0)
+
+#define S17_IGMP_JOIN_LEAVE_DP_SHIFT	24
+#define S17_BROAD_DP_SHIFT		16
+#define S17_MULTI_FLOOD_DP_SHIFT	8
+#define S17_UNI_FLOOD_DP_SHIFT		0
+#define S17_IGMP_JOIN_LEAVE_DPALL	(0x7f << S17_IGMP_JOIN_LEAVE_DP_SHIFT)
+#define S17_BROAD_DPALL			(0x7f << S17_BROAD_DP_SHIFT)
+#define S17_MULTI_FLOOD_DPALL		(0x7f << S17_MULTI_FLOOD_DP_SHIFT)
+#define S17_UNI_FLOOD_DPALL		(0x7f << S17_UNI_FLOOD_DP_SHIFT)
+
+#define S17_PWS_CHIP_AR8327             (1 << 30)
+
+/* S17_PHY_CONTROL fields */
+#define S17_CTRL_SOFTWARE_RESET                    0x8000
+#define S17_CTRL_SPEED_LSB                         0x2000
+#define S17_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define S17_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define S17_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define S17_CTRL_SPEED_MSB                         0x0040
+
+/* For EEE_CTRL_REG */
+#define S17_LPI_DISABLE_P1		     (1 << 4)
+#define S17_LPI_DISABLE_P2		     (1 << 6)
+#define S17_LPI_DISABLE_P3		     (1 << 8)
+#define S17_LPI_DISABLE_P4		     (1 << 10)
+#define S17_LPI_DISABLE_P5		     (1 << 12)
+#define S17_LPI_DISABLE_ALL		     0x1550
+
+/* For MMD register control */
+#define S17_MMD_FUNC_ADDR			(0 << 14)
+#define S17_MMD_FUNC_DATA			(1 << 14)
+#define S17_MMD_FUNC_DATA_2			(2 << 14)
+#define S17_MMD_FUNC_DATA_3			(3 << 14)
+
+/* For phyInfo_t azFeature */
+#define S17_8023AZ_PHY_ENABLED			(1 << 0)
+#define S17_8023AZ_PHY_LINKED                   (1 << 1)
+
+/* Queue Management registe fields */
+#define S17_HOL_CTRL0_LAN		0x2a008888 /* egress priority 8, eg_portq = 0x2a */
+#define S17_HOL_CTRL0_WAN		0x2a666666 /* egress priority 6, eg_portq = 0x2a */
+#define S17_HOL_CTRL1_DEFAULT		0xc6	   /* enable HOL control */
+
+/* Packet Edit register fields */
+#define S17_ROUTER_EG_UNMOD		0x0	/* unmodified */
+#define S17_ROUTER_EG_WOVLAN		0x1	/* without VLAN */
+#define S17_ROUTER_EG_WVLAN		0x2	/* with VLAN */
+#define S17_ROUTER_EG_UNTOUCH		0x3	/* untouched */
+#define S17_ROUTER_EG_MODE_DEFAULT	0x01111111 /* all ports without VLAN */
+
+#define S17_RESET_DONE(phy_control)                   \
+    (((phy_control) & (S17_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define S17_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define S17_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (S17_STATUS_AUTO_NEG_DONE)) ==                    \
+        (S17_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define S17_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define S17_LINK_100BASETX                   0x0080
+#define S17_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define S17_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define S17_ADVERTISE_NEXT_PAGE              0x8000
+#define S17_ADVERTISE_ASYM_PAUSE             0x0800
+#define S17_ADVERTISE_PAUSE                  0x0400
+#define S17_ADVERTISE_100FULL                0x0100
+#define S17_ADVERTISE_100HALF                0x0080  
+#define S17_ADVERTISE_10FULL                 0x0040  
+#define S17_ADVERTISE_10HALF                 0x0020  
+
+#define S17_ADVERTISE_ALL (S17_ADVERTISE_ASYM_PAUSE | S17_ADVERTISE_PAUSE | \
+                            S17_ADVERTISE_10HALF | S17_ADVERTISE_10FULL | \
+                            S17_ADVERTISE_100HALF | S17_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define S17_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define S17_STATUS_LINK_MASK                0xC000
+#define S17_STATUS_LINK_SHIFT               14
+#define S17_STATUS_FULL_DEPLEX              0x2000
+#define S17_STATUS_LINK_PASS                 0x0400 
+#define S17_STATUS_RESOLVED                  0x0800
+#define S17_STATUS_LINK_10M			 0
+#define S17_STATUS_LINK_100M			 1
+#define S17_STATUS_LINK_1000M			 2
+
+#define S17_GLOBAL_INT_PHYMASK	 	     (1 << 15)
+
+#define S17_PHY_LINK_UP 		     0x400
+#define S17_PHY_LINK_DOWN 		     0x800
+#define S17_PHY_LINK_DUPLEX_CHANGE 	     0x2000
+#define S17_PHY_LINK_SPEED_CHANGE	     0x4000
+
+/* For Port flow control registers */
+#define S17_PORT_FLCTL_XON_DEFAULT		(0x3a << 16)
+#define S17_PORT_FLCTL_XOFF_DEFAULT		(0x4a)
+
+/* Module enable Register */
+#define S17_MODULE_L3_EN		(1 << 2)
+#define S17_MODULE_ACL_EN		(1 << 1)
+#define S17_MODULE_MIB_EN		(1 << 0)
+
+/* MIB Function Register 1 */
+#define S17_MIB_FUNC_ALL		(3 << 24)
+#define S17_MIB_CPU_KEEP		(1 << 20)
+#define S17_MIB_BUSY			(1 << 17)
+#define S17_MIB_AT_HALF_EN		(1 << 16)
+#define S17_MIB_TIMER_DEFAULT		0x100
+
+#define S17_MAC_MAX			7
+
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+/*add feature define here*/
+//#define FULL_FEATURE
+
+#ifdef CONFIG_AR7242_S17_PHY
+#undef HEADER_REG_CONF
+#undef HEADER_EN
+#endif
+
+void athrs17_reg_init(void);
+int athrs17_phy_is_up(int unit);
+int athrs17_phy_is_fdx(int unit);
+int athrs17_phy_speed(int unit);
+BOOL athrs17_phy_setup(int unit);
+
+#endif
+
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/athr_s27_phy.c u-boot_1.1//board/atheros/common/athr_s27_phy.c
--- u-boot//board/atheros/common/athr_s27_phy.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/athr_s27_phy.c	2014-02-18 01:46:24.883050975 -0800
@@ -0,0 +1,856 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include <atheros.h>
+#include "athr_s27_phy.h"
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO,
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG,
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define MODULE_NAME "ATHRS27"
+
+/*
+ * Track per-PHY port information.
+ */
+
+
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+
+   {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+
+#define ATHR_GLOBALREGBASE    0
+
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+
+/* Forward references */
+BOOL athrs27_phy_is_link_alive(int phyUnit);
+uint32_t athrs27_reg_read(uint32_t reg_addr);
+void athrs27_reg_write(uint32_t reg_addr, uint32_t reg_val);
+unsigned int s27_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+void s27_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+
+
+void athrs27_powersave_off(int phy_addr)
+{
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0x29);
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x36c0);
+
+}
+void athrs27_sleep_off(int phy_addr)
+{
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0xb);
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x3c00);
+}
+
+void athrs27_force_100M(int phyAddr,int duplex)
+{
+   /*
+    *  Force MDI and MDX to alternate ports 
+    *  Phy 0,2 and 4 -- MDI
+    *  Phy 1 and 3 -- MDX
+    */
+
+    if(phyAddr%2) {
+        s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+    }
+    else {
+        s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+    }
+
+    s27_wr_phy(phyAddr,0x1d,0x29);
+    s27_wr_phy(phyAddr,0x1e,0x0);
+    s27_wr_phy(phyAddr,0x10,0xc60);
+    s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,(0xa000|(duplex << 8)));
+}
+
+void athrs27_force_10M(int phyAddr,int duplex)
+{
+
+    athrs27_powersave_off(phyAddr);
+    athrs27_sleep_off(phyAddr);
+
+    s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,(0x8000 |(duplex << 8)));
+}
+
+int athrs27_reg_init(void)
+{
+#if S27_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+
+    /* if using header for register configuration, we have to     */
+    /* configure s27 register after frame transmission is enabled */
+    athrs27_reg_rmw(0x8,(1<<28));  /* Set WAN port is connected to GE0 */
+
+#if defined(S27_FORCE_100M)
+    athrs27_force_100M(ATHR_PHY4_ADDR,1);
+#elif  defined(S27_FORCE_10M)
+    athrs27_force_10M(ATHR_PHY4_ADDR,1);
+#else
+    s27_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x9000);
+
+#endif
+#ifdef S27_PHY_DEBUG
+    printf(MODULE_NAME":OPERATIONAL_MODE_REG0:%x\n",athrs27_reg_read(OPERATIONAL_MODE_REG0));
+    printf(MODULE_NAME":REG 0x4-->:%x\n",athrs27_reg_read(0x4));
+    printf(MODULE_NAME":REG 0x2c-->:%x\n",athrs27_reg_read(0x2c));
+    printf(MODULE_NAME":REG 0x8-->:%x\n",athrs27_reg_read(0x8));
+#endif
+
+    return 0;
+}
+ 
+int athrs27_reg_init_lan(void)
+{
+    int i = 60;
+#if S26_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+    int       phyUnit;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+
+
+    /* reset switch */
+    printf(MODULE_NAME ": resetting s27\n");
+    athrs27_reg_write(0x0, athrs27_reg_read(0x0)|0x80000000);
+
+    while(i--) {
+        sysMsDelay(100);
+        if(!(athrs27_reg_read(0x0)&0x80000000))
+            break;
+    }
+    printf(MODULE_NAME ": s27 reset done\n");
+    athrs27_reg_write(PORT_STATUS_REGISTER0,0x4e);
+
+    athrs27_reg_rmw(OPERATIONAL_MODE_REG0,(1<<6));  /* Set GMII mode */
+
+    if (is_emu() || is_wasp()) {
+       athrs27_reg_rmw(0x2c,((1<<26)| (1<<16) | 0x1)); /* FiX ME: EBU debug */
+    }
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+#if defined(S27_FORCE_100M)
+        athrs27_force_100M(phyAddr,1);
+#elif defined(S27_FORCE_10M)
+        athrs27_force_10M(phyAddr,1);
+#else
+        s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x9000);
+#endif
+
+#if S27_PHY_DEBUG
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_FUNC_CONTROL);
+        printf("S27 ATHR_PHY_FUNC_CONTROL (%d):%x\n",phyAddr,rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_ID1);
+        printf("S27 PHY ID  (%d) :%x\n",phyAddr, rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_SPEC_STATUS);
+        printf("S27 PHY CTRL  (%d) :%x\n",phyAddr, rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_STATUS);
+        printf("S27 ATHR PHY STATUS  (%d) :%x\n",phyAddr, rd_val);
+#endif
+    }
+
+    /* 
+     * status[1:0]=2'h2;   - (0x10 - 1000 Mbps , 0x01 - 100Mbps, 0x0 - 10 Mbps)
+     * status[2]=1'h1;     - Tx Mac En
+     * status[3]=1'h1;     - Rx Mac En
+     * status[4]=1'h1;     - Tx Flow Ctrl En
+     * status[5]=1'h1;     - Rx Flow Ctrl En
+     * status[6]=1'h1;     - Duplex Mode
+     */
+    athrs27_reg_write(PORT_STATUS_REGISTER1, 0x200);  /* LAN - 1 */
+    athrs27_reg_write(PORT_STATUS_REGISTER2, 0x200);  /* LAN - 2 */
+    athrs27_reg_write(PORT_STATUS_REGISTER3, 0x200);  /* LAN - 3 */
+    athrs27_reg_write(PORT_STATUS_REGISTER4, 0x200);  /* LAN - 4 */
+
+    if (is_emu()) {
+        athrs27_reg_write(PORT_STATUS_REGISTER1, 0x4C);  /* LAN - 1 */
+        athrs27_reg_write(PORT_STATUS_REGISTER2, 0x4c);  /* LAN - 2 */
+        athrs27_reg_write(PORT_STATUS_REGISTER3, 0x4c);  /* LAN - 3 */
+        athrs27_reg_write(PORT_STATUS_REGISTER4, 0x4c);  /* LAN - 4 */
+    }
+
+    /* QM Control */
+    athrs27_reg_write(0x38, 0xc000050e);
+
+    /*
+     * status[11]=1'h0;    - CPU Disable
+     * status[7] = 1'b1;   - Learn One Lock
+     * status[14] = 1'b0;  - Learn Enable
+     */
+#ifdef ATHEROS_HEADER_EN
+    athrs27_reg_write(PORT_CONTROL_REGISTER0, 0x4804);
+#else
+   /* Atheros Header Disable */
+    athrs27_reg_write(PORT_CONTROL_REGISTER0, 0x4004);
+#endif
+
+    /* Tag Priority Mapping */
+    athrs27_reg_write(0x70, 0xfa50);
+
+    /* Enable ARP packets to CPU port */
+    athrs27_reg_write(S27_ARL_TBL_CTRL_REG,(athrs27_reg_read(S27_ARL_TBL_CTRL_REG) | 0x100000));
+
+   /* Enable Broadcast packets to CPU port */
+    athrs27_reg_write(S27_FLD_MASK_REG,(athrs27_reg_read(S27_FLD_MASK_REG) |
+                           S27_ENABLE_CPU_BROADCAST | S27_ENABLE_CPU_BCAST_FWD ));
+
+    return 0;
+}
+
+/******************************************************************************
+*
+* athrs27_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs27_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+    phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs27_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*   
+* Resets the associated PHY port.
+*   
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+BOOL
+athrs27_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+//#if S27_PHY_DEBUG
+    uint32_t  rd_val = 0;
+//#endif
+    uint32_t  ar7240_revid;
+
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+        if (!is_emu()) {
+           s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+
+           s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+        }
+        else  {
+		printf("############ is emulation ############\n");
+
+           if(ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN) {
+               s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+               s27_wr_phy(phyAddr,0x9, 0x0); //donot advertise 1000Mbps mode
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,0x0);
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+           }
+           else { 
+
+               s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,(ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE |
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL));
+               s27_wr_phy(phyAddr,0x9, 0x0); //donot advertise 1000Mbps mode
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,0x0);
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+           }
+       }
+       rd_val = s27_rd_phy(phyAddr,ATHR_PHY_CONTROL);
+       printf("%s ATHR_PHY_CONTROL %d :%x\n",__func__,phyAddr,rd_val);
+       rd_val = s27_rd_phy(phyAddr,ATHR_PHY_SPEC_STATUS);
+       printf("%s ATHR_PHY_SPEC_STAUS %d :%x\n",__func__,phyAddr,rd_val);
+    }
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    if (ethUnit == ENET_UNIT_LAN)
+        sysMsDelay(1000);
+    else
+        sysMsDelay(3000);
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN)
+            continue;
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus =  s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+        /* extend the cable length */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x14);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xf52);
+
+       /* Force Class A setting phys */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 4);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xebbb);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 5);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0x2c47);
+
+        /* fine-tune PHYs */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x3c);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0x1c1);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x37);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xd600);
+
+
+#ifdef S27_VER_1_0
+        /* turn off power saving */
+        s27_wr_phy(phyUnit, 29, 41);
+        s27_wr_phy(phyUnit, 30, 0);
+        printf("def_ S27_VER_1_0\n");
+#endif
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit,
+            s27_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS)));
+    }
+
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs27_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs27_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = s27_rd_phy (phyAddr, ATHR_PHY_SPEC_STATUS);
+                        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+                                break;
+                sysMsDelay(10);
+            } while(--ii);
+            if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+            }
+        }
+    }
+
+    return FALSE;
+}
+/******************************************************************************
+*
+* athrs27_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               ATHR_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               ATHR_PHY_SPEED_1000T;
+*/
+
+int
+athrs27_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+    int       phySpeed;
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        phySpeed = _10BASET;
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+
+            do {
+                phyHwStatus = s27_rd_phy(phyAddr,
+                                              ATHR_PHY_SPEC_STATUS);
+                        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+                                break;
+                sysMsDelay(10);
+            }while(--ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                phySpeed = _10BASET;
+		break;
+            case 1:
+                phySpeed = _100BASET;
+		break;
+            case 2:
+                phySpeed = _1000BASET;
+		break;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+
+        phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x18);
+
+        if(phySpeed == _100BASET) {
+            phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_DATA, 0xba8);
+        } else {
+            phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_DATA, 0x2ea);
+        }
+    }
+
+    if (ethUnit == ENET_UNIT_LAN)
+         phySpeed = _1000BASET;
+
+    return phySpeed;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs27_phy_is_up(int ethUnit)
+{
+
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+    int           phyUnit;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                printf("enet%d port%d down\n",ethUnit, phyUnit);
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            if(is_emu())
+            {
+                phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_STATUS);
+                if(phyAddr%2) {
+                    s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+                }
+                else {
+                    s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+                }
+
+                if((phyHwStatus & 0x4)==0)
+                {
+                   s27_wr_phy(phyAddr,0x9,0x0);
+                   if(phyAddr !=0x4)
+                       s27_wr_phy(phyAddr,0x4,0x41);
+                   s27_wr_phy(phyAddr,0x0,0x9000);
+                }
+            }
+
+            phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+             phyHwControl = s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+             phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_STATUS);
+
+            /* Check for AutoNegotiation complete */
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = s27_rd_phy(phyAddr,
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                printf("enet%d port%d up\n",ethUnit, phyUnit);
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+    return (linkCount);
+}
+
+unsigned int athrs27_reg_read(unsigned int s27_addr)
+{
+    unsigned int addr_temp;
+    unsigned int s27_rd_csr_low, s27_rd_csr_high, s27_rd_csr;
+    unsigned int data,unit = 0;
+    unsigned int phy_address, reg_address;
+
+    addr_temp = s27_addr >>2;
+    data = addr_temp >> 7;
+
+    phy_address = 0x1f;
+    reg_address = 0x10;
+
+    if (is_ar7240()) {
+        unit = 0;
+    }
+    else if(is_ar7241() || is_ar7242() || is_wasp() || is_qca953x() || is_qca956x()) {
+        unit = 1;
+    }
+
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+    reg_address = ((addr_temp << 1) & 0x1e);
+    s27_rd_csr_low = (uint32_t) phy_reg_read(unit,phy_address, reg_address);
+
+    reg_address = reg_address | 0x1;
+    s27_rd_csr_high = (uint32_t) phy_reg_read(unit,phy_address, reg_address);
+    s27_rd_csr = (s27_rd_csr_high << 16) | s27_rd_csr_low ;
+	
+    return(s27_rd_csr);
+}
+
+void athrs27_reg_write(unsigned int s27_addr, unsigned int s27_write_data)
+{
+    unsigned int addr_temp;
+    unsigned int data;
+    unsigned int phy_address, reg_address,unit = 0;
+
+    addr_temp = (s27_addr ) >>2;
+    data = addr_temp >> 7;
+
+    phy_address = 0x1f;
+    reg_address = 0x10;
+
+    if (is_ar7240()) {
+        unit = 0;
+    }
+    else if(is_ar7241() || is_ar7242() || is_wasp() || is_qca953x() || is_qca956x()) {
+        unit = 1;
+    }
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+
+    reg_address = (((addr_temp << 1) & 0x1e) | 0x1);
+    data = (s27_write_data >> 16) & 0xffff;
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    reg_address = ((addr_temp << 1) & 0x1e);
+    data = s27_write_data  & 0xffff;
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+}
+
+void athrs27_reg_rmw(unsigned int s27_addr, unsigned int s27_write_data)
+{
+    int val = athrs27_reg_read(s27_addr);
+    athrs27_reg_write(s27_addr,(val | s27_write_data));
+}
+
+unsigned int s27_rd_phy(unsigned int phy_addr, unsigned int reg_addr)
+{
+  int unit, val = 0; 
+  
+  if (is_ar7240()) {
+    unit = 0;
+  } else if(is_ar7241() || is_ar7242() || is_wasp() || is_qca953x() || is_qca956x()) {
+    unit = 1;
+  }
+  val = (uint32_t) phy_reg_read(unit, phy_addr, reg_addr); 
+  return val;
+}
+
+void s27_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data)
+{
+  int unit; 
+  
+  if (is_ar7240()) {
+    unit = 0;
+  } else if(is_ar7241() || is_ar7242() || is_wasp() || is_qca953x() || is_qca956x()) {
+    unit = 1;
+  }
+  
+  phy_reg_write(unit, phy_addr, reg_addr, write_data);   
+}
+int athrs27_mdc_check()
+{
+    int i;
+
+    for (i=0; i<4000; i++) {
+        if(athrs27_reg_read(0x10c) != 0x18007fff)
+            return -1;
+    }
+    return 0;
+}
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/athr_s27_phy.h u-boot_1.1//board/atheros/common/athr_s27_phy.h
--- u-boot//board/atheros/common/athr_s27_phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/athr_s27_phy.h	2014-02-18 01:46:24.883050975 -0800
@@ -0,0 +1,214 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _ATHRS27_PHY_H
+#define _ATHRS27_PHY_H
+
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_FUNC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+#define ATHR_PHY_INTR_ENABLE             0x12
+#define ATHR_PHY_INTR_STATUS             0x13
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+#define ATHR_ADVERTISE_1000HALF		      0x0100
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DUPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_LATCH_LINK_PASS                  0x0004 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+#define OPERATIONAL_MODE_REG0                0x4
+
+/* S27 CSR Registers */
+
+#define PORT_STATUS_REGISTER0                0x0100 
+#define PORT_STATUS_REGISTER1                0x0200
+#define PORT_STATUS_REGISTER2                0x0300
+#define PORT_STATUS_REGISTER3                0x0400
+#define PORT_STATUS_REGISTER4                0x0500
+#define PORT_STATUS_REGISTER5                0x0600
+
+#define RATE_LIMIT_REGISTER0                 0x010C
+#define RATE_LIMIT_REGISTER1                 0x020C
+#define RATE_LIMIT_REGISTER2                 0x030C
+#define RATE_LIMIT_REGISTER3                 0x040C
+#define RATE_LIMIT_REGISTER4                 0x050C
+#define RATE_LIMIT_REGISTER5                 0x060C
+
+#define PORT_CONTROL_REGISTER0               0x0104
+#define PORT_CONTROL_REGISTER1               0x0204
+#define PORT_CONTROL_REGISTER2               0x0304
+#define PORT_CONTROL_REGISTER3               0x0404
+#define PORT_CONTROL_REGISTER4               0x0504
+#define PORT_CONTROL_REGISTER5               0x0604
+
+#define CPU_PORT_REGISTER                    0x0078
+#define MDIO_CTRL_REGISTER                   0x0098
+
+#define S27_ARL_TBL_FUNC_REG0                0x0050
+#define S27_ARL_TBL_FUNC_REG1                0x0054
+#define S27_ARL_TBL_FUNC_REG2                0x0058
+#define S27_FLD_MASK_REG                     0x002c
+#define S27_ARL_TBL_CTRL_REG                 0x005c
+#define S27_GLOBAL_INTR_REG                  0x10
+#define S27_GLOBAL_INTR_MASK_REG             0x14
+
+
+#define S27_ENABLE_CPU_BROADCAST             (1 << 26)
+#define S27_ENABLE_CPU_BCAST_FWD             (1 << 25)
+
+#define PHY_LINK_CHANGE_REG 		     0x4
+#define PHY_LINK_UP 		             0x400
+#define PHY_LINK_DOWN 		             0x800
+#define PHY_LINK_DUPLEX_CHANGE 		     0x2000
+#define PHY_LINK_SPEED_CHANGE		     0x4000
+#define PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+/* SWITCH QOS REGISTERS */
+
+#define ATHR_QOS_PORT_0			0x110 /* CPU PORT */
+#define ATHR_QOS_PORT_1			0x210
+#define ATHR_QOS_PORT_2			0x310
+#define ATHR_QOS_PORT_3			0x410
+#define ATHR_QOS_PORT_4			0x510
+
+#define ATHR_ENABLE_TOS                 (1 << 16)
+
+#define ATHR_QOS_MODE_REGISTER          0x030
+#define ATHR_QOS_FIXED_PRIORITY        ((0 << 31) | (0 << 28))
+#define ATHR_QOS_WEIGHTED              ((1 << 31) | (0 << 28)) /* Fixed weight 8,4,2,1 */
+#define ATHR_QOS_MIXED                 ((1 << 31) | (1 << 28)) /* Q3 for managment; Q2,Q1,Q0 - 4,2,1 */
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+#define mdelay(_x)      sysMsDelay(_x)
+
+#undef S27_VER_1_0
+
+/*
+ *  Atheros header defines
+ */
+#ifndef _ATH_HEADER_CONF
+#define _ATH_HEADER_CONF
+
+typedef enum {
+    NORMAL_PACKET,
+    RESERVED0,
+    MIB_1ST,
+    RESERVED1,
+    RESERVED2,
+    READ_WRITE_REG,
+    READ_WRITE_REG_ACK,
+    RESERVED3
+} AT_HEADER_TYPE;
+
+typedef struct {
+    uint16_t    reserved0  :2;
+    uint16_t    priority   :2;
+    uint16_t    type       :4;
+    uint16_t    broadcast  :1;
+    uint16_t    from_cpu   :1;
+    uint16_t    reserved1  :2;
+    uint16_t    port_num   :4;
+}at_header_t;
+
+#define ATHR_HEADER_LEN 2
+
+#endif // _ATH_HEADER_CONF
+
+typedef enum {
+    PORT_EG_UNMODIFIED = 0,  /**<  egress transmit packets unmodified */
+    PORT_EG_UNTAGGED,        /**<  egress transmit packets without vlan tag */
+    PORT_EG_TAGGED,          /**<  egress transmit packets with vlan tag */
+} port_1q_egmode_t;
+
+extern void set_packet_inspection_flag(int flag);
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/athrs_ar8033_phy.h u-boot_1.1//board/atheros/common/athrs_ar8033_phy.h
--- u-boot//board/atheros/common/athrs_ar8033_phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/athrs_ar8033_phy.h	2014-02-18 01:46:24.895050981 -0800
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS_8033_PHY_H
+#define _ATHRS_8033_PHY_H
+
+#define BOOL int
+
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_LATCH_LINK_PASS                  0x0004 
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+
+
+#ifdef ATH_MDC_GPIO
+#define ATH_GPIO	14
+#define GPIO_FUNCTION4_MASK  	(GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK)
+                		 
+#define GPIO_FUNCTION4_ENABLE	(GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(0x20))
+
+
+              			
+#else 
+#define GPIO_FUNCTION4_MASK  	(GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK |\
+                		 GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK)
+
+#define GPIO_FUNCTION4_ENABLE	(GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(0x20) | \
+              			 GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(0x21))
+
+#define ATH_GPIO	19
+#endif
+
+#define ATH_GPIO17 	17
+
+/*
+ *  Atheros header defines
+ */
+#ifndef _ATH_HEADER_CONF
+#define _ATH_HEADER_CONF
+
+
+
+#define ATHR_HEADER_LEN 2
+
+typedef enum {
+    NORMAL_PACKET,
+    RESERVED0,
+    MIB_1ST,
+    RESERVED1,
+    RESERVED2,
+    READ_WRITE_REG,
+    READ_WRITE_REG_ACK,
+    RESERVED3
+} AT_HEADER_TYPE;
+
+#endif // _ATH_HEADER_CONF
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/athrsf1_phy.c u-boot_1.1//board/atheros/common/athrsf1_phy.c
--- u-boot//board/atheros/common/athrsf1_phy.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/athrsf1_phy.c	2014-02-18 01:46:24.895050981 -0800
@@ -0,0 +1,440 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrsf1_phy.h"
+
+#define MODULE_NAME "ATHRSF1_PHY"
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY_MAX 5
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+ 
+/* Forward references */
+BOOL athr_phy_is_link_alive(int phyUnit);
+unsigned int last_phy_speed;
+
+void athr_enable_linkIntrs(int ethUnit) 
+{
+    return;
+}
+
+void athr_disable_linkIntrs(int ethUnit) 
+{
+	return;
+}
+void athr_auto_neg(int ethUnit,int phyUnit) 
+{ 
+    int timeout = 0;
+    uint16_t phyHwStatus;
+    
+    if(!is_emu()) {
+#if 0
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+       phy_reg_write(ethUnit, phyUnit , ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       phy_reg_write(ethUnit, phyUnit , ATHR_1000BASET_CONTROL, ATHR_ADVERTISE_1000FULL);
+#endif
+
+       printf("ATHR_AUTONEG_ADVERT:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_AUTONEG_ADVERT));
+       printf("ATHR_1000BASET_CONTROL:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_1000BASET_CONTROL));
+       printf("ATHR_PHY_CONTROL:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_PHY_CONTROL));
+    }
+    else {
+       phy_reg_write(ethUnit, phyUnit , ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       /* Do not advertise 1000 */
+       phy_reg_write(ethUnit, phyUnit , ATHR_1000BASET_CONTROL,0x0);
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+   /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    timeout=20;
+    for (;;) {
+        phyHwStatus = phy_reg_read(ethUnit, phyUnit, ATHR_PHY_CONTROL);
+
+        if (ATHR_RESET_DONE(phyHwStatus)) {
+            printf(MODULE_NAME": Port %d, Neg Success\n", phyUnit);
+            break;
+        }
+        if (timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+        if (--timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+
+        mdelay(150);
+    }
+
+    printf(MODULE_NAME": unit %d phy addr %x ", ethUnit, phyUnit);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_phy_is_link_alive(int phyUnit)
+{
+	uint16_t phyHwStatus;
+	uint32_t phyBase;
+	uint32_t phyAddr;
+
+	phyBase = ATHR_PHYBASE(phyUnit);
+	phyAddr = ATHR_PHYADDR(phyUnit);
+	phyHwStatus = phy_reg_read(0, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+	if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_phy_setup(int ethUnit)
+{
+	int       phyUnit = 0;
+	int       liveLinks = 0;
+
+	athr_auto_neg(ethUnit,phyUnit);
+
+	if (athr_phy_is_link_alive(phyUnit)) {
+		liveLinks++;
+		ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+	} else {
+		ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+	}
+	return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+         phyBase = ATHR_PHYBASE(phyUnit);
+         phyAddr = ATHR_PHYADDR(phyUnit);
+
+         do {
+                phyHwStatus = phy_reg_read(ethUnit, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+                mdelay(10);
+          } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+          
+          if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+          }
+    }
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        do {
+            phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+            mdelay(10);
+        } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+        phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                       ATHER_STATUS_LINK_SHIFT);
+
+        switch(phyHwStatus) {
+        case 0:
+	    if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x147);
+                last_phy_speed = phyHwStatus;
+            }
+            return _10BASET;
+        case 1:
+	     if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x147);
+                last_phy_speed = phyHwStatus;
+            }
+            return _100BASET;
+        case 2:
+   	      if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x0);
+                last_phy_speed = phyHwStatus;
+             }
+            return _1000BASET;
+        default:
+            printf("Unkown speed read!\n");
+        }
+    }
+
+      if (last_phy_speed != phyHwStatus)
+    	{
+        phy_reg_write(0, ATHR_PHYADDR(phyUnit), ATHR_DEBUG_PORT_ADDRESS, 0x0);
+        phy_reg_write(0, ATHR_PHYADDR(phyUnit), ATHR_DEBUG_PORT_DATA, 0x14e);
+        last_phy_speed = phyHwStatus;
+     }
+
+
+    //printf("athr_phy_speed: link down, returning 10t\n");
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < 1; phyUnit++) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+
+             phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) { /* check realtime link */
+                linkCount++;
+            } else {
+                phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+            /* If realtime failed check link in latch register before
+	     * asserting link down.
+             */
+                if (phyHwStatus & ATHR_LATCH_LINK_PASS)     
+                   linkCount++;
+		else
+                    lostLinks++;
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+
+            /* Check for reset complete */
+
+                phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+                phyHwControl = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_CONTROL);
+
+            /* Check for AutoNegotiation complete */ 
+           
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                    phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+                    if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                        gainedLinks++;
+                        linkCount++;
+                        lastStatus->isPhyAlive = TRUE;
+                   }  
+            }
+        }
+    }
+    return (linkCount);
+
+}
+/* Place holders */
+
+int 
+athr_reg_init(void *arg)
+{
+   return 0;
+}
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/athrsf1_phy.h u-boot_1.1//board/atheros/common/athrsf1_phy.h
--- u-boot//board/atheros/common/athrsf1_phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/athrsf1_phy.h	2014-02-18 01:46:24.895050981 -0800
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _ATHRS26_RGMII_H
+#define _ATHRS26_RGMII_H
+#define BOOL int
+#include "athr_s27_phy.h"
+int athr_phy_is_up(int unit);
+int athr_phy_is_fdx(int unit,int phyUnit);
+int athr_phy_speed(int unit,int phyUnit);
+BOOL athr_phy_setup(int unit);
+BOOL athr_phy_is_link_alive(int phyUnit);
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/athrs_vir_phy.c u-boot_1.1//board/atheros/common/athrs_vir_phy.c
--- u-boot//board/atheros/common/athrs_vir_phy.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/athrs_vir_phy.c	2014-02-18 01:46:24.895050981 -0800
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+#define MODULE_NAME "ATHRS_VIR_PHY"
+
+#define TRUE    1
+#define FALSE   0
+#define BOOL	int
+
+/* Forward references */
+BOOL athr_vir_phy_is_link_alive(int phyUnit);
+
+
+/******************************************************************************
+*
+* athr_vir_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_vir_phy_is_link_alive(int phyUnit)
+{
+    return TRUE;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_vir_phy_setup(int ethUnit)
+{
+    return 0;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_vir_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    return TRUE;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_vir_phy_speed(int ethUnit,int phyUnit)
+{
+    return _1000BASET;
+}
+
+/*****************************************************************************
+*
+* athr_vir_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_vir_phy_is_up(int ethUnit)
+{
+    return 1;
+
+}
+/* Place holders */
+
+int 
+athr_vir_reg_init(void *arg)
+{
+   return 0;
+}
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/init-953x.c u-boot_1.1//board/atheros/common/init-953x.c
--- u-boot//board/atheros/common/init-953x.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/init-953x.c	2014-02-18 01:46:24.895050981 -0800
@@ -0,0 +1,397 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+#define ATH_MAX_DDR_SIZE		(256 * 1024 * 1024)
+#define ATH_DDR_SIZE_INCR		(4 * 1024 * 1024)
+
+int
+ath_ddr_find_size(void)
+{
+	uint8_t  *p = (uint8_t *)KSEG1, pat = 0x77;
+	int i;
+
+#define max_i		(ATH_MAX_DDR_SIZE / ATH_DDR_SIZE_INCR)
+
+	*p = pat;
+
+	/*
+	 * DDR wraps around. Write a pattern to 0x0000_0000. Write an
+	 * address pattern at 4M, 8M, 16M etc. and check when
+	 * 0x0000_0000 gets overwritten.
+	 */
+	for(i = 1; (i < max_i); i++) {
+		*(p + i * ATH_DDR_SIZE_INCR) = (uint8_t)(i);
+		if (*p != pat) {
+			break;
+		}
+	}
+
+	return ((i < max_i) ? (i * ATH_DDR_SIZE_INCR) : ATH_MAX_DDR_SIZE);
+}
+
+inline int
+ath_ram_type(uint32_t bs)
+{
+	if (RST_BOOTSTRAP_DDR_SELECT_GET(bs)) {
+		return ATH_MEM_DDR1;
+	} else {
+		return ATH_MEM_DDR2;
+	}
+}
+
+#define CFG_DDR2_SCORPION_CAS_LATENCY	4
+
+#ifdef CONFIG_TB614
+#	define DDR_CONFIG2_SWAP_A26_A27_VAL	(0x1)
+#else
+#	define DDR_CONFIG2_SWAP_A26_A27_VAL	(0x0)
+#endif
+
+#if CFG_DDR2_SCORPION_CAS_LATENCY == 4
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x1) | \
+						DDR_CONFIG_TMRD_SET(0xf) | \
+						DDR_CONFIG_TRFC_SET(0x15) | \
+						DDR_CONFIG_TRRD_SET(0x7) | \
+						DDR_CONFIG_TRP_SET(0x9) | \
+						DDR_CONFIG_TRCD_SET(0x9) | \
+						DDR_CONFIG_TRAS_SET(0x1b)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x8) | \
+						DDR_CONFIG2_TWTR_SET(0x15) | \
+						DDR_CONFIG2_TRTP_SET(0x9) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0x1) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+#define CFG_DDR2_CONFIG3_VAL			0x0000000a
+#define CFG_DDR2_EXT_MODE_VAL			0x402
+#define CFG_DDR2_MODE_VAL_INIT			0x143
+#define CFG_DDR2_MODE_VAL			0x43
+#define CFG_DDR2_TAP_VAL			0x10
+#define CFG_DDR2_EN_TWL_VAL			0x0000167d
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+
+#elif CFG_DDR2_SCORPION_CAS_LATENCY == 5
+
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x4) | \
+						DDR_CONFIG_TMRD_SET(0xf) | \
+						DDR_CONFIG_TRFC_SET(0x15) | \
+						DDR_CONFIG_TRRD_SET(0x7) | \
+						DDR_CONFIG_TRP_SET(0x9) | \
+						DDR_CONFIG_TRCD_SET(0x9) | \
+						DDR_CONFIG_TRAS_SET(0x1b)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0xb) | \
+						DDR_CONFIG2_TWTR_SET(0x15) | \
+						DDR_CONFIG2_TRTP_SET(0x9) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0x1) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+#define CFG_DDR2_CONFIG3_VAL			0x0000000a
+#define CFG_DDR2_EXT_MODE_VAL			0x402
+#define CFG_DDR2_MODE_VAL_INIT			0x153
+#define CFG_DDR2_MODE_VAL			0x53
+#define CFG_DDR2_TAP_VAL			0x10
+#define CFG_DDR2_EN_TWL_VAL			0x00001e7d
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#endif
+
+#define CFG_DDR1_CONFIG_VAL			DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x7) | \
+						DDR_CONFIG_TMRD_SET(0x5) | \
+						DDR_CONFIG_TRFC_SET(0x7) | \
+						DDR_CONFIG_TRRD_SET(0x4) | \
+						DDR_CONFIG_TRP_SET(0x6) | \
+						DDR_CONFIG_TRCD_SET(0x6) | \
+						DDR_CONFIG_TRAS_SET(0x10)
+
+#define CFG_DDR1_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x6) | \
+						DDR_CONFIG2_TWTR_SET(0xe) | \
+						DDR_CONFIG2_TRTP_SET(0x8) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0xd) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+#define CFG_DDR1_CONFIG3_VAL			0x0
+#define CFG_DDR1_EXT_MODE_VAL			0x0
+#define CFG_DDR1_MODE_VAL_INIT			0x133
+#define CFG_DDR1_MODE_VAL			0x33
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR1_TAP_VAL			0x20
+
+#define CFG_DDR_CTL_CONFIG			DDR_CTL_CONFIG_SRAM_TSEL_SET(0x1) | \
+						DDR_CTL_CONFIG_GE0_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_GE1_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_USB_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_PCIE_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_WMAC_SRAM_SYNC_SET(0x1)
+
+int /* ram type */
+ath_ddr_initial_config(uint32_t refresh)
+{
+#if !defined(CONFIG_ATH_EMULATION)
+	int		ddr_config, ddr_config2, ddr_config3, ext_mod, mod_val,
+			mod_val_init, cycle_val, tap_val, type, ctl_config;
+	uint32_t	*pll = (unsigned *)PLL_CONFIG_VAL_F;
+	uint32_t	bootstrap;
+
+	prmsg("\nsri\n");
+	prmsg("Honey Bee 1.%d\n", ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf);
+
+	bootstrap = ath_reg_rd(RST_BOOTSTRAP_ADDRESS);
+
+	switch(type = ath_ram_type(bootstrap)) {
+	case ATH_MEM_DDR2:
+		ddr_config	= CFG_DDR2_CONFIG_VAL;
+		ddr_config2	= CFG_DDR2_CONFIG2_VAL;
+		ddr_config3	= CFG_DDR2_CONFIG3_VAL;
+		ext_mod		= CFG_DDR2_EXT_MODE_VAL;
+		mod_val_init	= CFG_DDR2_MODE_VAL_INIT;
+		mod_val		= CFG_DDR2_MODE_VAL;
+		tap_val		= CFG_DDR2_TAP_VAL;
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x10);
+		udelay(10);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x20);
+		udelay(10);
+		prmsg("%s(%d): (", __func__, __LINE__);
+
+		prmsg("16");
+		ctl_config =	CFG_DDR_CTL_CONFIG |
+				CPU_DDR_SYNC_MODE |
+				DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(0x1) |
+				DDR_CTL_CONFIG_HALF_WIDTH_SET(0x1);
+
+		cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16;
+
+		ath_reg_wr_nf(DDR_CTL_CONFIG_ADDRESS, ctl_config);
+
+		prmsg("bit) ddr2 init\n");
+		udelay(10);
+		break;
+	case ATH_MEM_DDR1:
+		ddr_config	= CFG_DDR1_CONFIG_VAL;
+		ddr_config2	= CFG_DDR1_CONFIG2_VAL;
+		ddr_config3	= CFG_DDR1_CONFIG3_VAL;
+		ext_mod		= CFG_DDR1_EXT_MODE_VAL;
+		mod_val_init	= CFG_DDR1_MODE_VAL_INIT;
+		mod_val		= CFG_DDR1_MODE_VAL;
+		tap_val		= CFG_DDR1_TAP_VAL;
+
+		prmsg("%s(%d): (", __func__, __LINE__);
+		prmsg("16");
+		cycle_val = CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16;
+
+		ctl_config =	CFG_DDR_CTL_CONFIG |
+				CPU_DDR_SYNC_MODE |
+				DDR_CTL_CONFIG_HALF_WIDTH_SET(0x1);
+
+		ath_reg_wr_nf(DDR_CTL_CONFIG_ADDRESS, ctl_config);
+		udelay(10);
+		prmsg("bit) ddr1 init\n");
+
+		break;
+	}
+
+	ath_reg_wr_nf(DDR_RD_DATA_THIS_CYCLE_ADDRESS, cycle_val);
+	udelay(100);
+	ath_reg_wr_nf(DDR_BURST_ADDRESS, 0x74444444);
+	udelay(100);
+	ath_reg_wr_nf(DDR_BURST2_ADDRESS, 0x4);
+	udelay(100);
+	ath_reg_wr_nf(DDR_AHB_MASTER_TIMEOUT_MAX_ADDRESS, 0xfffff);
+	udelay(100);
+	ath_reg_wr_nf(DDR_CONFIG_ADDRESS, ddr_config);
+	udelay(100);
+	ath_reg_wr_nf(DDR_CONFIG2_ADDRESS, ddr_config2);
+	udelay(100);
+	ath_reg_wr(DDR_CONFIG_3_ADDRESS, ddr_config3);
+	udelay(100);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR2_CONFIG_ADDRESS, CFG_DDR2_EN_TWL_VAL);
+		udelay(100);
+	}
+
+	ath_reg_wr_nf(DDR_CONFIG2_ADDRESS, ddr_config2 | 0x80);	// CKE Enable
+	udelay(100);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x8);	// Precharge
+	udelay(10);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x10);	// EMR2
+		udelay(10);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x20);	// EMR3
+		udelay(10);
+	}
+
+	if (type == ATH_MEM_DDR1 || type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL); // EMR DLL enable, Reduced Driver Impedance control, Differential DQS disabled
+		udelay(100);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(10);
+	}
+
+	ath_reg_wr_nf(DDR_MODE_REGISTER_ADDRESS, mod_val_init);
+	udelay(1000);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x1);	// MR Write
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x8);	// Precharge
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x4);	// Auto Refresh
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x4);	// Auto Refresh
+	udelay(10);
+
+	// Issue MRS to remove DLL out-of-reset
+	ath_reg_wr_nf(DDR_MODE_REGISTER_ADDRESS, mod_val);
+	udelay(100);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x1); // MR write
+	udelay(100);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, 0x782);
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL);
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(100);
+	}
+
+	ath_reg_wr_nf(DDR_REFRESH_ADDRESS, refresh);
+	udelay(100);
+
+        ath_reg_wr(TAP_CONTROL_0_ADDRESS, tap_val);
+	ath_reg_wr(TAP_CONTROL_1_ADDRESS, tap_val);
+
+	ath_reg_wr(PMU1_ADDRESS, 0x633c8178);
+	// Set DDR2 Voltage to 1.8 volts
+	ath_reg_wr(PMU2_ADDRESS, PMU2_SWREGMSB_SET(0x40) | PMU2_PGM_SET(0x1));
+	return type;
+#else	// !emulation
+	return 0;
+#endif
+}
+
+int
+ath_uart_freq(void)
+{
+	//if (ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_REF_CLK_MASK) {
+	//	return 40 * 1000 * 1000;
+	//} else {
+		return 25 * 1000 * 1000;
+	//}
+}
+
+void
+ath_sys_frequency(uint32_t *cpu, uint32_t *ddr, uint32_t *ahb)
+{
+#if !defined(CONFIG_ATH_EMULATION)
+	uint32_t pll, out_div, ref_div, nint, frac, clk_ctrl;
+#endif
+	uint32_t ref;
+	static uint32_t ath_cpu_freq, ath_ddr_freq, ath_ahb_freq;
+
+	if (ath_cpu_freq)
+		goto done;
+
+#ifdef CONFIG_ATH_EMULATION
+	ath_cpu_freq = 80000000;
+	ath_ddr_freq = 80000000;
+	ath_ahb_freq = 40000000;
+#else
+	prmsg("%s: ", __func__);
+
+	clk_ctrl = ath_reg_rd(ATH_DDR_CLK_CTRL);
+
+	pll = ath_reg_rd(ATH_PLL_CONFIG);
+	out_div	= CPU_PLL_CONFIG_OUTDIV_GET(pll);
+	ref_div	= CPU_PLL_CONFIG_REFDIV_GET(pll);
+	nint	= CPU_PLL_CONFIG_NINT_GET(pll);
+	frac	= CPU_PLL_CONFIG_NFRAC_GET(pll);
+	pll = ref >> 6;
+	frac	= frac * pll / ref_div;
+	prmsg("cpu apb ");
+	ath_cpu_freq = (((nint * (ref / ref_div)) + frac) >> out_div) /
+			(CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_GET(clk_ctrl) + 1);
+
+	pll = ath_reg_rd(ATH_DDR_PLL_CONFIG);
+	out_div	= DDR_PLL_CONFIG_OUTDIV_GET(pll);
+	ref_div	= DDR_PLL_CONFIG_REFDIV_GET(pll);
+	nint	= DDR_PLL_CONFIG_NINT_GET(pll);
+	frac	= DDR_PLL_CONFIG_NFRAC_GET(pll);
+	pll = ref >> 10;
+	frac	= frac * pll / ref_div;
+	prmsg("ddr apb ");
+	ath_ddr_freq = (((nint * (ref / ref_div)) + frac) >> out_div) /
+			(CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_GET(clk_ctrl) + 1);
+
+	if (CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_GET(clk_ctrl)) {
+		ath_ahb_freq = ath_ddr_freq /
+			(CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(clk_ctrl) + 1);
+	} else {
+		ath_ahb_freq = ath_cpu_freq /
+			(CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(clk_ctrl) + 1);
+	}
+#endif
+	prmsg("cpu %u ddr %u ahb %u\n",
+		ath_cpu_freq / 1000000,
+		ath_ddr_freq / 1000000,
+		ath_ahb_freq / 1000000);
+done:
+	*cpu = ath_cpu_freq;
+	*ddr = ath_ddr_freq;
+	*ahb = ath_ahb_freq;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/init-955x.c u-boot_1.1//board/atheros/common/init-955x.c
--- u-boot//board/atheros/common/init-955x.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/init-955x.c	2014-02-18 01:46:24.899050984 -0800
@@ -0,0 +1,492 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+#define ATH_MAX_DDR_SIZE		(256 * 1024 * 1024)
+#define ATH_DDR_SIZE_INCR		(4 * 1024 * 1024)
+
+int
+ath_ddr_find_size(void)
+{
+	uint8_t  *p = (uint8_t *)KSEG1, pat = 0x77;
+	int i;
+
+#define max_i		(ATH_MAX_DDR_SIZE / ATH_DDR_SIZE_INCR)
+
+	*p = pat;
+
+	/*
+	 * DDR wraps around. Write a pattern to 0x0000_0000. Write an
+	 * address pattern at 4M, 8M, 16M etc. and check when
+	 * 0x0000_0000 gets overwritten.
+	 */
+	for(i = 1; (i < max_i); i++) {
+		*(p + i * ATH_DDR_SIZE_INCR) = (uint8_t)(i);
+		if (*p != pat) {
+			break;
+		}
+	}
+
+	return ((i < max_i) ? (i * ATH_DDR_SIZE_INCR) : ATH_MAX_DDR_SIZE);
+}
+
+inline int
+ath_ram_type(uint32_t bs)
+{
+	if (RST_BOOTSTRAP_DDR_SELECT_GET(bs)) {
+		return ATH_MEM_DDR1;
+	} else {
+		return ATH_MEM_DDR2;
+	}
+}
+
+#define CFG_DDR2_SCORPION_CAS_LATENCY	4
+
+#ifdef CONFIG_TB614
+#	define DDR_CONFIG2_SWAP_A26_A27_VAL	(0x1)
+#else
+#	define DDR_CONFIG2_SWAP_A26_A27_VAL	(0x0)
+#endif
+
+#if CFG_DDR2_SCORPION_CAS_LATENCY == 4
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x1) | \
+						DDR_CONFIG_TMRD_SET(0xf) | \
+						DDR_CONFIG_TRFC_SET(0x15) | \
+						DDR_CONFIG_TRRD_SET(0x7) | \
+						DDR_CONFIG_TRP_SET(0x9) | \
+						DDR_CONFIG_TRCD_SET(0x9) | \
+						DDR_CONFIG_TRAS_SET(0x1b)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x8) | \
+						DDR_CONFIG2_TWTR_SET(0x15) | \
+						DDR_CONFIG2_TRTP_SET(0x9) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0x1) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+#define CFG_DDR2_CONFIG3_VAL			0x0000000a
+#define CFG_DDR2_EXT_MODE_VAL			0x402
+#define CFG_DDR2_MODE_VAL_INIT			0x143
+#define CFG_DDR2_MODE_VAL			0x43
+#define CFG_DDR2_TAP_VAL			0x10
+#define CFG_DDR2_EN_TWL_VAL			0x0000167d
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+
+#elif CFG_DDR2_SCORPION_CAS_LATENCY == 5
+
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x4) | \
+						DDR_CONFIG_TMRD_SET(0xf) | \
+						DDR_CONFIG_TRFC_SET(0x15) | \
+						DDR_CONFIG_TRRD_SET(0x7) | \
+						DDR_CONFIG_TRP_SET(0x9) | \
+						DDR_CONFIG_TRCD_SET(0x9) | \
+						DDR_CONFIG_TRAS_SET(0x1b)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0xb) | \
+						DDR_CONFIG2_TWTR_SET(0x15) | \
+						DDR_CONFIG2_TRTP_SET(0x9) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0x1) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+#define CFG_DDR2_CONFIG3_VAL			0x0000000a
+#define CFG_DDR2_EXT_MODE_VAL			0x402
+#define CFG_DDR2_MODE_VAL_INIT			0x153
+#define CFG_DDR2_MODE_VAL			0x53
+#define CFG_DDR2_TAP_VAL			0x10
+#define CFG_DDR2_EN_TWL_VAL			0x00001e7d
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#endif
+
+#define CFG_DDR1_CONFIG_VAL			DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x7) | \
+						DDR_CONFIG_TMRD_SET(0x5) | \
+						DDR_CONFIG_TRFC_SET(0x7) | \
+						DDR_CONFIG_TRRD_SET(0x4) | \
+						DDR_CONFIG_TRP_SET(0x6) | \
+						DDR_CONFIG_TRCD_SET(0x6) | \
+						DDR_CONFIG_TRAS_SET(0x10)
+
+#define CFG_DDR1_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x6) | \
+						DDR_CONFIG2_TWTR_SET(0xe) | \
+						DDR_CONFIG2_TRTP_SET(0x8) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0xd) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+#define CFG_DDR1_CONFIG3_VAL			0x0
+#define CFG_DDR1_EXT_MODE_VAL			0x0
+#define CFG_DDR1_MODE_VAL_INIT			0x133
+#define CFG_DDR1_MODE_VAL			0x33
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR1_TAP_VAL			0x20
+
+#define CFG_DDR_CTL_CONFIG			DDR_CTL_CONFIG_SRAM_TSEL_SET(0x1) | \
+						DDR_CTL_CONFIG_GE0_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_GE1_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_USB_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_PCIE_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_WMAC_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_SET(0x1)
+
+int /* ram type */
+ath_ddr_initial_config(uint32_t refresh)
+{
+#if !defined(CONFIG_ATH_NAND_BR) && !defined(CONFIG_ATH_EMULATION)
+	int		ddr_config, ddr_config2, ddr_config3, ext_mod, mod_val,
+			mod_val_init, cycle_val, tap_val, type, ctl_config;
+	uint32_t	*pll = (unsigned *)PLL_CONFIG_VAL_F;
+	uint32_t	bootstrap;
+
+	prmsg("\nsri\n");
+	prmsg("Scorpion 1.%d\n", ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf);
+
+	bootstrap = ath_reg_rd(RST_BOOTSTRAP_ADDRESS);
+
+	switch(type = ath_ram_type(bootstrap)) {
+	case ATH_MEM_DDR2:
+		ddr_config	= CFG_DDR2_CONFIG_VAL;
+		ddr_config2	= CFG_DDR2_CONFIG2_VAL;
+		ddr_config3	= CFG_DDR2_CONFIG3_VAL;
+		ext_mod		= CFG_DDR2_EXT_MODE_VAL;
+		mod_val_init	= CFG_DDR2_MODE_VAL_INIT;
+		mod_val		= CFG_DDR2_MODE_VAL;
+		tap_val		= CFG_DDR2_TAP_VAL;
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x10);
+		udelay(10);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x20);
+		udelay(10);
+		prmsg("%s(%d): (", __func__, __LINE__);
+
+		if (RST_BOOTSTRAP_DDR_WIDTH_GET(bootstrap)) {
+			prmsg("32");
+			ctl_config =	CFG_DDR_CTL_CONFIG |
+					DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(0x1);
+
+			cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32;
+		} else {
+			prmsg("16");
+			ctl_config =	CFG_DDR_CTL_CONFIG |
+					DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(0x1) |
+					DDR_CTL_CONFIG_HALF_WIDTH_SET(0x1);
+
+			cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16;
+		}
+
+		ctl_config |= CPU_DDR_SYNC_MODE;
+
+		ath_reg_wr_nf(DDR_CTL_CONFIG_ADDRESS, ctl_config);
+
+		prmsg("bit) ddr2 init\n");
+		udelay(10);
+		break;
+	case ATH_MEM_DDR1:
+		ddr_config	= CFG_DDR1_CONFIG_VAL;
+		ddr_config2	= CFG_DDR1_CONFIG2_VAL;
+		ddr_config3	= CFG_DDR1_CONFIG3_VAL;
+		ext_mod		= CFG_DDR1_EXT_MODE_VAL;
+		mod_val_init	= CFG_DDR1_MODE_VAL_INIT;
+		mod_val		= CFG_DDR1_MODE_VAL;
+		tap_val		= CFG_DDR1_TAP_VAL;
+
+		prmsg("%s(%d): (", __func__, __LINE__);
+		if (RST_BOOTSTRAP_DDR_WIDTH_GET(bootstrap)) {
+			prmsg("32");
+                        ctl_config = CFG_DDR_CTL_CONFIG; 
+			cycle_val = CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_32;
+		} else {
+			prmsg("16");
+			cycle_val = CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16;
+                        ctl_config = 0; 
+		}
+
+		ctl_config |= CPU_DDR_SYNC_MODE;
+
+		ath_reg_wr_nf(DDR_CTL_CONFIG_ADDRESS, ctl_config);
+		udelay(10);
+		prmsg("bit) ddr1 init\n");
+
+		break;
+	}
+#if 0
+	if (*pll == PLL_MAGIC) {
+		uint32_t cas = pll[5];
+		if (cas == 3 || cas == 4) {
+			cas = (cas * 2) + 2;
+			ddr_config &= ~(DDR_CONFIG_CAS_LATENCY_MSB_MASK |
+					DDR_CONFIG_CAS_LATENCY_MASK);
+			ddr_config |= DDR_CONFIG_CAS_LATENCY_SET(cas & 0x7) |
+				DDR_CONFIG_CAS_LATENCY_MSB_SET((cas >> 3) & 1);
+
+			cas = pll[5];
+
+			ddr_config2 &= ~DDR_CONFIG2_GATE_OPEN_LATENCY_MASK;
+			ddr_config2 |= DDR_CONFIG2_GATE_OPEN_LATENCY_SET((2 * cas) + 1);
+
+			if (type == ATH_MEM_DDR2) {
+				uint32_t tmp;
+				tmp = ath_reg_rd(DDR2_CONFIG_ADDRESS);
+				tmp &= ~DDR2_CONFIG_DDR2_TWL_MASK;
+				tmp |= DDR2_CONFIG_DDR2_TWL_SET(cas == 3 ? 3 : 5);
+				ath_reg_wr_nf(DDR2_CONFIG_ADDRESS, tmp);
+			}
+
+			mod_val = (cas == 3 ? 0x33 : 0x43);
+			mod_val_init = 0x100 | mod_val;
+		}
+	}
+#endif
+
+	ath_reg_wr_nf(DDR_RD_DATA_THIS_CYCLE_ADDRESS, cycle_val);
+	udelay(100);
+	ath_reg_wr_nf(DDR_BURST_ADDRESS, 0x74444444);
+	udelay(100);
+	ath_reg_wr_nf(DDR_BURST2_ADDRESS, 0x44444444);
+	udelay(100);
+	ath_reg_wr_nf(DDR_AHB_MASTER_TIMEOUT_MAX_ADDRESS, 0xfffff);
+	udelay(100);
+	ath_reg_wr_nf(DDR_CONFIG_ADDRESS, ddr_config);
+	udelay(100);
+	ath_reg_wr_nf(DDR_CONFIG2_ADDRESS, ddr_config2);
+	udelay(100);
+	ath_reg_wr(DDR_CONFIG_3_ADDRESS, ddr_config3);
+	udelay(100);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR2_CONFIG_ADDRESS, CFG_DDR2_EN_TWL_VAL);
+		udelay(100);
+	}
+
+	ath_reg_wr_nf(DDR_CONFIG2_ADDRESS, ddr_config2 | 0x80);	// CKE Enable
+	udelay(100);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x8);	// Precharge
+	udelay(10);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x10);	// EMR2
+		udelay(10);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x20);	// EMR3
+		udelay(10);
+	}
+
+	if (type == ATH_MEM_DDR1 || type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL); // EMR DLL enable, Reduced Driver Impedance control, Differential DQS disabled
+		udelay(100);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(10);
+	}
+
+	ath_reg_wr_nf(DDR_MODE_REGISTER_ADDRESS, mod_val_init);
+	udelay(1000);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x1);	// MR Write
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x8);	// Precharge
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x4);	// Auto Refresh
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x4);	// Auto Refresh
+	udelay(10);
+
+	// Issue MRS to remove DLL out-of-reset
+	ath_reg_wr_nf(DDR_MODE_REGISTER_ADDRESS, mod_val);
+	udelay(100);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x1); // MR write
+	udelay(100);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, 0x782);
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL);
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(100);
+	}
+
+	ath_reg_wr_nf(DDR_REFRESH_ADDRESS, refresh);
+	udelay(100);
+
+        ath_reg_wr(TAP_CONTROL_0_ADDRESS, tap_val);
+	ath_reg_wr(TAP_CONTROL_1_ADDRESS, tap_val);
+
+	if (RST_BOOTSTRAP_DDR_WIDTH_GET(bootstrap)) {
+		ath_reg_wr (TAP_CONTROL_2_ADDRESS, tap_val);
+		ath_reg_wr (TAP_CONTROL_3_ADDRESS, tap_val);
+	}
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr(PMU1_ADDRESS, 0x633c8176);
+		// Set DDR2 Voltage to 1.8 volts
+		ath_reg_wr(PMU2_ADDRESS, PMU2_LDO_TUNE_SET(3) |
+					 PMU2_PGM_SET(0x1));
+	}
+
+	/*
+         * Based on SGMII validation for stucks, packet errors were  observed and it was 
+         * mostly due to noise pickup on SGMII lines. Switching regulator register is to 
+         * be programmed with proper setting to avoid such stucks.
+	 */
+	ath_reg_rmw_clear(PMU1_ADDRESS, (7<<1));
+	ath_reg_rmw_set(PMU1_ADDRESS, (1<<3));
+
+	return type;
+#else	// !nand flash and !emulation
+	return 0;
+#endif
+}
+
+int
+ath_uart_freq(void)
+{
+	if (ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_REF_CLK_MASK) {
+		return 40 * 1000 * 1000;
+	} else {
+		return 25 * 1000 * 1000;
+	}
+}
+
+void
+ath_sys_frequency(uint32_t *cpu, uint32_t *ddr, uint32_t *ahb)
+{
+#if !defined(CONFIG_ATH_EMULATION)
+	uint32_t pll, out_div, ref_div, nint, frac, clk_ctrl;
+#endif
+	uint32_t ref;
+	static uint32_t ath_cpu_freq, ath_ddr_freq, ath_ahb_freq;
+
+	if (ath_cpu_freq)
+		goto done;
+
+#ifdef CONFIG_ATH_EMULATION
+	ath_cpu_freq = 80000000;
+	ath_ddr_freq = 80000000;
+	ath_ahb_freq = 40000000;
+#else
+	prmsg("%s: ", __func__);
+
+	clk_ctrl = ath_reg_rd(ATH_DDR_CLK_CTRL);
+
+#if 0
+	pll = ath_reg_rd(CPU_DPLL2_ADDRESS);
+	if (CPU_DPLL2_LOCAL_PLL_GET(pll)) {
+		out_div	= CPU_DPLL2_OUTDIV_GET(pll);
+
+		pll = ath_reg_rd(CPU_DPLL_ADDRESS);
+		nint = CPU_DPLL_NINT_GET(pll);
+		frac = CPU_DPLL_NFRAC_GET(pll);
+		ref_div = CPU_DPLL_REFDIV_GET(pll);
+		pll = ref >> 18;
+		frac	= frac * pll / ref_div;
+		prmsg("cpu srif ");
+	} else {
+#endif
+		pll = ath_reg_rd(ATH_PLL_CONFIG);
+		out_div	= CPU_PLL_CONFIG_OUTDIV_GET(pll);
+		ref_div	= CPU_PLL_CONFIG_REFDIV_GET(pll);
+		nint	= CPU_PLL_CONFIG_NINT_GET(pll);
+		frac	= CPU_PLL_CONFIG_NFRAC_GET(pll);
+		pll = ref >> 6;
+		frac	= frac * pll / ref_div;
+		prmsg("cpu apb ");
+//	}
+	ath_cpu_freq = (((nint * (ref / ref_div)) + frac) >> out_div) /
+			(CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_GET(clk_ctrl) + 1);
+
+#if 0
+	pll = ath_reg_rd(DDR_DPLL2_ADDRESS);
+	if (DDR_DPLL2_LOCAL_PLL_GET(pll)) {
+		out_div	= DDR_DPLL2_OUTDIV_GET(pll);
+
+		pll = ath_reg_rd(DDR_DPLL_ADDRESS);
+		nint = DDR_DPLL_NINT_GET(pll);
+		frac = DDR_DPLL_NFRAC_GET(pll);
+		ref_div = DDR_DPLL_REFDIV_GET(pll);
+		pll = ref >> 18;
+		frac	= frac * pll / ref_div;
+		prmsg("ddr srif ");
+	} else {
+#endif
+		pll = ath_reg_rd(ATH_DDR_PLL_CONFIG);
+		out_div	= DDR_PLL_CONFIG_OUTDIV_GET(pll);
+		ref_div	= DDR_PLL_CONFIG_REFDIV_GET(pll);
+		nint	= DDR_PLL_CONFIG_NINT_GET(pll);
+		frac	= DDR_PLL_CONFIG_NFRAC_GET(pll);
+		pll = ref >> 10;
+		frac	= frac * pll / ref_div;
+		prmsg("ddr apb ");
+//	}
+	ath_ddr_freq = (((nint * (ref / ref_div)) + frac) >> out_div) /
+			(CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_GET(clk_ctrl) + 1);
+
+	if (CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_GET(clk_ctrl)) {
+		ath_ahb_freq = ath_ddr_freq /
+			(CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(clk_ctrl) + 1);
+	} else {
+		ath_ahb_freq = ath_cpu_freq /
+			(CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(clk_ctrl) + 1);
+	}
+#endif
+		ath_cpu_freq = 720 * 1000000;
+		ath_ddr_freq = 600 * 1000000;
+		ath_ahb_freq = 200 * 1000000;
+	prmsg("cpu %u ddr %u ahb %u\n",
+		ath_cpu_freq / 1000000,
+		ath_ddr_freq / 1000000,
+		ath_ahb_freq / 1000000);
+done:
+	*cpu = ath_cpu_freq;
+	*ddr = ath_ddr_freq;
+	*ahb = ath_ahb_freq;
+
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/init-956x.c u-boot_1.1//board/atheros/common/init-956x.c
--- u-boot//board/atheros/common/init-956x.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/init-956x.c	2014-02-18 01:46:24.899050984 -0800
@@ -0,0 +1,679 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+#define ATH_MAX_DDR_SIZE		(256 * 1024 * 1024)
+#define ATH_DDR_SIZE_INCR		(4 * 1024 * 1024)
+
+int
+ath_ddr_find_size(void)
+{
+	uint8_t  *p = (uint8_t *)KSEG1, pat = 0x77;
+	int i;
+
+#define max_i		(ATH_MAX_DDR_SIZE / ATH_DDR_SIZE_INCR)
+
+	*p = pat;
+
+	/*
+	 * DDR wraps around. Write a pattern to 0x0000_0000. Write an
+	 * address pattern at 4M, 8M, 16M etc. and check when
+	 * 0x0000_0000 gets overwritten.
+	 */
+	for(i = 1; (i < max_i); i++) {
+		*(p + i * ATH_DDR_SIZE_INCR) = (uint8_t)(i);
+		if (*p != pat) {
+			break;
+		}
+	}
+
+	return ((i < max_i) ? (i * ATH_DDR_SIZE_INCR) : ATH_MAX_DDR_SIZE);
+}
+
+inline int
+ath_ram_type(uint32_t bs)
+{
+	if (RST_BOOTSTRAP_DDR_SELECT_GET(bs)) {
+		return ATH_MEM_DDR1;
+	} else {
+		return ATH_MEM_DDR2;
+	}
+}
+
+/* Notice the value CFG_DDR2_DRAGONFLY_CAS_LATENCY
+ * Should Sync with CFG_PLL_FREQ
+ * */
+#ifndef CFG_DDR2_DRAGONFLY_CAS_LATENCY
+#define CFG_DDR2_DRAGONFLY_CAS_LATENCY	4
+#endif
+
+#ifdef CONFIG_TB614
+#	define DDR_CONFIG2_SWAP_A26_A27_VAL	(0x1)
+#else
+#	define DDR_CONFIG2_SWAP_A26_A27_VAL	(0x0)
+#endif
+
+#if CFG_DDR2_DRAGONFLY_CAS_LATENCY == 3
+
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x0) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x7) | \
+						DDR_CONFIG_TMRD_SET(0x6) | \
+						DDR_CONFIG_TRFC_SET(0x10) | \
+						DDR_CONFIG_TRRD_SET(0x5) | \
+						DDR_CONFIG_TRP_SET(0x8) | \
+						DDR_CONFIG_TRCD_SET(0x8) | \
+						DDR_CONFIG_TRAS_SET(0x17)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x6) | \
+						DDR_CONFIG2_TWTR_SET(0x12) | \
+						DDR_CONFIG2_TRTP_SET(0xa) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0xf) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+#define CFG_DDR2_CONFIG3_VAL			0x00000002
+#define CFG_DDR2_EXT_MODE_VAL1			0x782
+#define CFG_DDR2_EXT_MODE_VAL2			0x402
+#define CFG_DDR2_MODE_VAL_INIT			0x733
+#define CFG_DDR2_MODE_VAL			0x633
+#define CFG_DDR2_TAP_VAL			0x10
+#define CFG_DDR2_EN_TWL_VAL			0x00000e65
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+
+#elif CFG_DDR2_DRAGONFLY_CAS_LATENCY == 4
+
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x1) | \
+						DDR_CONFIG_TMRD_SET(0x6) | \
+						DDR_CONFIG_TRFC_SET(0x11) | \
+						DDR_CONFIG_TRRD_SET(0x6) | \
+						DDR_CONFIG_TRP_SET(0x8) | \
+						DDR_CONFIG_TRCD_SET(0x8) | \
+						DDR_CONFIG_TRAS_SET(0x18)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x8) | \
+						DDR_CONFIG2_TWTR_SET(0x12) | \
+						DDR_CONFIG2_TRTP_SET(0xa) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0xf) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+#define CFG_DDR2_CONFIG3_VAL			0x0000000a
+#define CFG_DDR2_EXT_MODE_VAL1			0x782
+#define CFG_DDR2_EXT_MODE_VAL2			0x402
+#define CFG_DDR2_MODE_VAL_INIT			0x743
+#define CFG_DDR2_MODE_VAL			0x643
+#define CFG_DDR2_TAP_VAL			0x10
+#define CFG_DDR2_EN_TWL_VAL			0x0000166d
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+
+#elif CFG_DDR2_DRAGONFLY_CAS_LATENCY == 5
+
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x4) | \
+						DDR_CONFIG_TMRD_SET(0x6) | \
+						DDR_CONFIG_TRFC_SET(0x16) | \
+						DDR_CONFIG_TRRD_SET(0x7) | \
+						DDR_CONFIG_TRP_SET(0xb) | \
+						DDR_CONFIG_TRCD_SET(0xb) | \
+						DDR_CONFIG_TRAS_SET(0)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0xa) | \
+						DDR_CONFIG2_TWTR_SET(0x16) | \
+						DDR_CONFIG2_TRTP_SET(0xa) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0x2) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+
+#define CFG_DDR2_CONFIG3_VAL            0x0000000e
+#define CFG_DDR2_EXT_MODE_VAL1			0x782
+#define CFG_DDR2_EXT_MODE_VAL2          0x402
+#define CFG_DDR2_MODE_VAL_INIT          0xb53
+#define CFG_DDR2_MODE_VAL               0xa53
+#define CFG_DDR2_TAP_VAL                0x10
+#define CFG_DDR2_EN_TWL_VAL             0x00001e91
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+
+#elif CFG_DDR2_DRAGONFLY_CAS_LATENCY == 6
+
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x6) | \
+						DDR_CONFIG_TMRD_SET(0x6) | \
+						DDR_CONFIG_TRFC_SET(0x16) | \
+						DDR_CONFIG_TRRD_SET(0x7) | \
+						DDR_CONFIG_TRP_SET(0xb) | \
+						DDR_CONFIG_TRCD_SET(0xb) | \
+						DDR_CONFIG_TRAS_SET(0)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0xc) | \
+						DDR_CONFIG2_TWTR_SET(0x18) | \
+						DDR_CONFIG2_TRTP_SET(0xa) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0x2) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+
+#define CFG_DDR2_CONFIG3_VAL            0x0000000e
+#define CFG_DDR2_EXT_MODE_VAL1		    0x782
+#define CFG_DDR2_EXT_MODE_VAL2          0x402
+#define CFG_DDR2_MODE_VAL_INIT          0xb63
+#define CFG_DDR2_MODE_VAL               0xa63
+#define CFG_DDR2_TAP_VAL                0x10
+#define CFG_DDR2_EN_TWL_VAL             0x00002691
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+
+#endif
+
+/* CAL = 3 FOR DDR */
+#define CFG_DDR1_CONFIG_VAL			DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x7) | \
+						DDR_CONFIG_TMRD_SET(0x6) | \
+						DDR_CONFIG_TRFC_SET(0x9) | \
+						DDR_CONFIG_TRRD_SET(0x5) | \
+						DDR_CONFIG_TRP_SET(0x8) | \
+						DDR_CONFIG_TRCD_SET(0x8) | \
+						DDR_CONFIG_TRAS_SET(0x15)
+
+
+#define CFG_DDR1_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x6) | \
+						DDR_CONFIG2_TWTR_SET(0x10) | \
+						DDR_CONFIG2_TRTP_SET(0xa) | \
+						DDR_CONFIG2_TRTW_SET(0x10) | \
+						DDR_CONFIG2_TWR_SET(0xf) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+#define CFG_DDR1_CONFIG3_VAL			0x0
+#define CFG_DDR1_EXT_MODE_VAL			0x2
+#define CFG_DDR1_MODE_VAL_INIT			0x133
+#define CFG_DDR1_MODE_VAL			0x33
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR1_TAP_VAL			0x10
+#define CFG_DDR1_EN_TWL_VAL			0x00000664
+
+#define CFG_DDR_CTL_CONFIG			DDR_CTL_CONFIG_SRAM_TSEL_SET(0x1) | \
+						DDR_CTL_CONFIG_GE0_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_GE1_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_USB_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_PCIE_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_WMAC_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_SET(0x1)
+
+int /* ram type */
+ath_ddr_initial_config(uint32_t refresh)
+{
+#if !defined(CONFIG_ATH_NAND_BR) && !defined(CONFIG_ATH_EMULATION)
+	int		ddr_config, ddr_config2, ddr_config3, ext_mod, mod_val,
+			mod_val_init, cycle_val, tap_val, type, ctl_config;
+	uint32_t	*pll = (unsigned *)PLL_CONFIG_VAL_F;
+	uint32_t	bootstrap;
+
+	prmsg("\nsri\n");
+#ifdef CONFIG_MACH_955x
+	prmsg("Scorpion 1.%d\n", ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf);
+#elif defined (CONFIG_MACH_956x)
+	prmsg("Dragonfly 1.%d\n", ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf);
+#endif
+	bootstrap = ath_reg_rd(RST_BOOTSTRAP_ADDRESS);
+
+	switch(type = ath_ram_type(bootstrap)) {
+	case ATH_MEM_DDR2:
+		ddr_config	= CFG_DDR2_CONFIG_VAL;
+		ddr_config2	= CFG_DDR2_CONFIG2_VAL;
+		ddr_config3	= CFG_DDR2_CONFIG3_VAL;
+		ext_mod		= CFG_DDR2_EXT_MODE_VAL2;
+		mod_val_init	= CFG_DDR2_MODE_VAL_INIT;
+		mod_val		= CFG_DDR2_MODE_VAL;
+		tap_val		= CFG_DDR2_TAP_VAL;
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x10);
+		udelay(10);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x20);
+		udelay(10);
+		prmsg("%s(%d): (", __func__, __LINE__);
+
+        ctl_config =	CFG_DDR_CTL_CONFIG |
+					DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(0x1) |
+					DDR_CTL_CONFIG_HALF_WIDTH_SET(0x1);
+
+        cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16;
+
+
+		ctl_config |= CPU_DDR_SYNC_MODE;
+
+		ath_reg_wr_nf(DDR_CTL_CONFIG_ADDRESS, ctl_config);
+
+		prmsg("ddr2 init)\n");
+		udelay(10);
+		break;
+	case ATH_MEM_DDR1:
+		ddr_config	= CFG_DDR1_CONFIG_VAL;
+		ddr_config2	= CFG_DDR1_CONFIG2_VAL;
+		ddr_config3	= CFG_DDR1_CONFIG3_VAL;
+		ext_mod		= CFG_DDR1_EXT_MODE_VAL;
+		mod_val_init	= CFG_DDR1_MODE_VAL_INIT;
+		mod_val		= CFG_DDR1_MODE_VAL;
+		tap_val		= CFG_DDR1_TAP_VAL;
+
+		prmsg("%s(%d): (", __func__, __LINE__);
+        cycle_val = CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16;
+        ctl_config = CFG_DDR_CTL_CONFIG |
+                         DDR_CTL_CONFIG_HALF_WIDTH_SET(0x1);
+
+		ctl_config |= CPU_DDR_SYNC_MODE;
+
+		ath_reg_wr_nf(DDR_CTL_CONFIG_ADDRESS, ctl_config);
+		udelay(10);
+		prmsg("ddr1 init)\n");
+
+		break;
+	}
+#if 0
+	if (*pll == PLL_MAGIC) {
+		uint32_t cas = pll[5];
+		if (cas == 3 || cas == 4) {
+			cas = (cas * 2) + 2;
+			ddr_config &= ~(DDR_CONFIG_CAS_LATENCY_MSB_MASK |
+					DDR_CONFIG_CAS_LATENCY_MASK);
+			ddr_config |= DDR_CONFIG_CAS_LATENCY_SET(cas & 0x7) |
+				DDR_CONFIG_CAS_LATENCY_MSB_SET((cas >> 3) & 1);
+
+			cas = pll[5];
+
+			ddr_config2 &= ~DDR_CONFIG2_GATE_OPEN_LATENCY_MASK;
+			ddr_config2 |= DDR_CONFIG2_GATE_OPEN_LATENCY_SET((2 * cas) + 1);
+
+			if (type == ATH_MEM_DDR2) {
+				uint32_t tmp;
+				tmp = ath_reg_rd(DDR2_CONFIG_ADDRESS);
+				tmp &= ~DDR2_CONFIG_DDR2_TWL_MASK;
+				tmp |= DDR2_CONFIG_DDR2_TWL_SET(cas == 3 ? 3 : 5);
+				ath_reg_wr_nf(DDR2_CONFIG_ADDRESS, tmp);
+			}
+
+			mod_val = (cas == 3 ? 0x33 : 0x43);
+			mod_val_init = 0x100 | mod_val;
+		}
+	}
+#endif
+
+	ath_reg_wr_nf(DDR_RD_DATA_THIS_CYCLE_ADDRESS, cycle_val);
+	udelay(100);
+	ath_reg_wr_nf(DDR_BURST_ADDRESS, 0x74444444);
+	udelay(100);
+	ath_reg_wr_nf(DDR_BURST2_ADDRESS, 0x44444444);
+	udelay(100);
+	ath_reg_wr_nf(DDR_FSM_WAIT_CTRL_ADDRESS, DDR_FSM_WAIT_CTRL_VAL);
+	udelay(100);
+	ath_reg_wr_nf(DDR_AHB_MASTER_TIMEOUT_MAX_ADDRESS, 0xfffff);
+	udelay(100);
+	ath_reg_wr_nf(DDR_CONFIG_ADDRESS, ddr_config);
+	udelay(100);
+	ath_reg_wr_nf(DDR_CONFIG2_ADDRESS, ddr_config2);
+	udelay(100);
+	ath_reg_wr(DDR_CONFIG_3_ADDRESS, ddr_config3);
+	udelay(100);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR2_CONFIG_ADDRESS, CFG_DDR2_EN_TWL_VAL);
+		udelay(100);
+	}
+	if (type == ATH_MEM_DDR1) {
+		ath_reg_wr_nf(DDR2_CONFIG_ADDRESS, CFG_DDR1_EN_TWL_VAL);
+		udelay(100);
+	}	
+
+	ath_reg_wr_nf(DDR_CONFIG2_ADDRESS, ddr_config2 | 0x80);	// CKE Enable
+	udelay(100);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x8);	// Precharge
+	udelay(10);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EMR2_ADDRESS, 0);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x10);	// EMR2
+		udelay(10);
+		ath_reg_wr_nf(DDR_EMR3_ADDRESS, 0);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x20);	// EMR3
+		udelay(10);
+	}
+
+	if (type == ATH_MEM_DDR1 || type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL2); // EMR DLL enable, Reduced Driver Impedance control, Differential DQS disabled
+		udelay(100);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(10);
+	}
+
+	ath_reg_wr_nf(DDR_MODE_REGISTER_ADDRESS, mod_val_init);
+	udelay(1000);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x1);	// MR Write
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x8);	// Precharge
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x4);	// Auto Refresh
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x4);	// Auto Refresh
+	udelay(10);
+
+	// Issue MRS to remove DLL out-of-reset
+	ath_reg_wr_nf(DDR_MODE_REGISTER_ADDRESS, mod_val);
+	udelay(100);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x1); // MR write
+	udelay(100);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL1);
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL2);
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(100);
+		
+		refresh = CFG_DDR2_REFRESH_VAL;
+	}
+	ath_reg_wr_nf(DDR_REFRESH_ADDRESS, refresh);
+	udelay(100);
+	
+    ath_reg_wr(TAP_CONTROL_0_ADDRESS, tap_val);
+    ath_reg_wr(TAP_CONTROL_1_ADDRESS, tap_val);
+
+    ath_reg_wr (TAP_CONTROL_2_ADDRESS, tap_val);
+    ath_reg_wr (TAP_CONTROL_3_ADDRESS, tap_val);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr(PMU1_ADDRESS, 0x633c8176);
+		// Set DDR2 Voltage to 1.8 volts
+		ath_reg_wr(PMU2_ADDRESS, PMU2_SWREGMSB_SET(0x40) |
+					 PMU2_PGM_SET(0x1));
+	}
+
+	/*
+         * Based on SGMII validation for stucks, packet errors were  observed and it was 
+         * mostly due to noise pickup on SGMII lines. Switching regulator register is to 
+         * be programmed with proper setting to avoid such stucks.
+	 */
+	if (type == ATH_MEM_DDR1){
+		ath_reg_wr(PMU1_ADDRESS, 0x633c8176);
+		ath_reg_wr(PMU2_ADDRESS, 0x10200000);
+	}
+	ath_sys_frequency();
+	return type;
+#else	// !nand flash and !emulation
+	return 0;
+#endif
+}
+
+int
+ath_uart_freq(void)
+{
+	if (ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_REF_CLK_MASK) {
+		return 40 * 1000 * 1000;
+	} else {
+		return 25 * 1000 * 1000;
+	}
+}
+
+void
+ath_sys_frequency()
+{
+#if !defined(CONFIG_ATH_EMULATION)
+    unsigned int    rdata, i;
+	unsigned int	cpu_pll_low_int, cpu_pll_low_frac, cpu_pll_high_int, cpu_pll_high_frac;
+	unsigned int	ddr_pll_low_int, ddr_pll_low_frac, ddr_pll_high_int, ddr_pll_high_frac;
+	unsigned int	cpu_clk_low, cpu_clk_high;
+	unsigned int	ddr_clk_low, ddr_clk_high;
+	unsigned int	ahb_clk_low, ahb_clk_high;
+	/* CPU_DDR_CLOCK_CONTROL */
+	unsigned int	ahbclk_from_ddrpll, ahb_post_div, ddr_post_div, cpu_post_div;
+	unsigned int	cpu_ddr_clk_from_cpupll, cpu_ddr_clk_from_ddrpll;
+	unsigned int	ahb_pll_bypass, ddr_pll_bypass, cpu_pll_bypass;
+	/* CPU_PLL_CONFIG, CPU_PLL_CONFIG1, CPU_PLL_DITHER1, CPU_PLL_DITHER2 */
+	unsigned int cpu_pllpwd, cpu_outdiv, cpu_Refdiv, cpu_Nint;
+	unsigned int cpu_dither_en, cpu_NFrac_Min, cpu_NFrac_Max;
+    unsigned int cpu_NFrac_Min_17_5, cpu_NFrac_Min_4_0;
+    unsigned int cpu_NFrac_Max_17_5, cpu_NFrac_Max_4_0;
+	/* DDR_PLL_CONFIG, DDR_PLL_CONFIG1, DDR_PLL_DITHER1, DDR_PLL_DITHER2 */
+	unsigned int ddr_pllpwd, ddr_outdiv, ddr_Refdiv, ddr_Nint;
+	unsigned int ddr_dither_en, ddr_NFrac_Min, ddr_NFrac_Max;	
+    unsigned int ddr_NFrac_Min_17_5, ddr_NFrac_Min_4_0;
+    unsigned int ddr_NFrac_Max_17_5, ddr_NFrac_Max_4_0;
+	static uint32_t ath_cpu_freq, ath_ddr_freq, ath_ahb_freq;
+#endif
+	uint32_t ref_clk;
+
+#if defined(CONFIG_ATH_EMULATION)
+	ref_clk = (40 * 1000000);
+#else
+	ref_clk = ath_uart_freq();
+#endif	
+
+#ifdef CONFIG_ATH_EMULATION
+	ath_cpu_freq = 80000000;
+	ath_ddr_freq = 80000000;
+	ath_ahb_freq = 40000000;
+#else
+	rdata = ath_reg_rd(CPU_DDR_CLOCK_CONTROL_ADDRESS);
+	ahbclk_from_ddrpll	= CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_GET(rdata);
+	ahb_post_div		= CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(rdata);
+	ddr_post_div		= CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_GET(rdata);
+	cpu_post_div		= CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_GET(rdata);
+	cpu_ddr_clk_from_cpupll = CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_GET(rdata);
+	cpu_ddr_clk_from_ddrpll = CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_GET(rdata);
+	ahb_pll_bypass		= CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_GET(rdata);
+	ddr_pll_bypass		= CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_GET(rdata);
+	cpu_pll_bypass		= CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_GET(rdata);
+
+	if (ahb_pll_bypass) {
+		ath_ahb_freq = ref_clk / (ahb_post_div + 1);
+        //*ahb_clk_h = ref_clk / (ahb_post_div + 1);
+	}
+
+	if (ddr_pll_bypass) {
+		ath_ddr_freq = ref_clk;
+		//*ddr_clk_h = ref_clk;
+	}
+
+	if (cpu_pll_bypass) {
+		ath_cpu_freq = ref_clk;
+		//*cpu_clk_h = ref_clk;
+	}
+
+	if (ahb_pll_bypass && ddr_pll_bypass && cpu_pll_bypass) {
+		return;
+	}
+
+	rdata = ath_reg_rd(CPU_PLL_CONFIG_ADDRESS);
+	cpu_pllpwd	= CPU_PLL_CONFIG_PLLPWD_GET(rdata);
+	cpu_outdiv	= CPU_PLL_CONFIG_OUTDIV_GET(rdata);
+	cpu_Refdiv	= CPU_PLL_CONFIG_REFDIV_GET(rdata);
+
+	rdata = ath_reg_rd(CPU_PLL_CONFIG1_ADDRESS);
+	cpu_Nint	= CPU_PLL_CONFIG1_NINT_GET(rdata);
+
+	rdata = ath_reg_rd(CPU_PLL_DITHER1_ADDRESS);
+	cpu_dither_en	= CPU_PLL_DITHER1_DITHER_EN_GET(rdata);
+	cpu_NFrac_Min	= CPU_PLL_DITHER1_NFRAC_MIN_GET(rdata);
+    cpu_NFrac_Min_17_5 = (cpu_NFrac_Min >> 5) & 0x1fff;
+    cpu_NFrac_Min_4_0  = cpu_NFrac_Min & 0x1f;
+
+	rdata = ath_reg_rd(CPU_PLL_DITHER1_ADDRESS);
+	cpu_NFrac_Max	= CPU_PLL_DITHER2_NFRAC_MAX_GET(rdata);
+    cpu_NFrac_Max_17_5 = (cpu_NFrac_Max >> 5) & 0x1fff;
+    cpu_NFrac_Max_4_0  = cpu_NFrac_Max & 0x1f;
+
+	rdata = ath_reg_rd(DDR_PLL_CONFIG_ADDRESS);
+	ddr_pllpwd	= DDR_PLL_CONFIG_PLLPWD_GET(rdata);
+	ddr_outdiv	= DDR_PLL_CONFIG_OUTDIV_GET(rdata);
+	ddr_Refdiv	= DDR_PLL_CONFIG_REFDIV_GET(rdata);
+
+	rdata = ath_reg_rd(DDR_PLL_CONFIG1_ADDRESS);
+	ddr_Nint	= DDR_PLL_CONFIG1_NINT_GET(rdata);
+
+	rdata = ath_reg_rd(DDR_PLL_DITHER1_ADDRESS);
+	ddr_dither_en	= DDR_PLL_DITHER1_DITHER_EN_GET(rdata);
+	ddr_NFrac_Min	= DDR_PLL_DITHER1_NFRAC_MIN_GET(rdata);
+    ddr_NFrac_Min_17_5 = (ddr_NFrac_Min >> 5) & 0x1fff;
+    ddr_NFrac_Min_4_0  = ddr_NFrac_Min & 0x1f;
+
+	rdata = ath_reg_rd(DDR_PLL_DITHER1_ADDRESS);
+	ddr_NFrac_Max	= DDR_PLL_DITHER2_NFRAC_MAX_GET(rdata);
+    ddr_NFrac_Max_17_5 = (ddr_NFrac_Max >> 5) & 0x1fff;
+    ddr_NFrac_Max_4_0  = ddr_NFrac_Max & 0x1f;
+
+	/* CPU PLL */
+    i = (ref_clk/cpu_Refdiv);
+
+    cpu_pll_low_int  = i*cpu_Nint;
+    cpu_pll_high_int = cpu_pll_low_int;
+
+    cpu_pll_low_frac = (i/(25*32))*((cpu_NFrac_Min_17_5*25 + cpu_NFrac_Min_4_0)/(8192/32));
+    cpu_pll_high_frac = (i/(25*32))*((cpu_NFrac_Max_17_5*25 + cpu_NFrac_Max_4_0)/(8192/32));
+
+    if (!cpu_dither_en || cpu_pll_high_frac <= cpu_pll_low_frac) {
+        cpu_pll_high_frac = cpu_pll_low_frac;
+    }
+
+     /* DDR PLL */
+    i = (ref_clk/ddr_Refdiv);
+
+    ddr_pll_low_int  = i*ddr_Nint;
+    ddr_pll_high_int = ddr_pll_low_int;
+
+    ddr_pll_low_frac = (i/(25*32))*((ddr_NFrac_Min_17_5*25 + ddr_NFrac_Min_4_0)/(8192/32));
+    ddr_pll_high_frac = (i/(25*32))*((ddr_NFrac_Max_17_5*25 + ddr_NFrac_Max_4_0)/(8192/32));
+
+    if (!ddr_dither_en || ddr_pll_high_frac <= ddr_pll_low_frac) {
+        ddr_pll_high_frac = ddr_pll_low_frac;
+    }
+
+    /* CPU Clock, DDR Clock, AHB Clock (before post div) */
+    if (cpu_ddr_clk_from_cpupll) {
+        cpu_clk_low  = cpu_pll_low_int + cpu_pll_low_frac;
+        cpu_clk_high = cpu_pll_high_int + cpu_pll_high_frac;
+
+        if (cpu_outdiv != 0) {
+            cpu_clk_low  /= (2*cpu_outdiv);
+            cpu_clk_high /= (2*cpu_outdiv);
+        }
+
+        ddr_clk_low  = cpu_clk_low;
+        ddr_clk_high = cpu_clk_high;
+    } else if (cpu_ddr_clk_from_ddrpll) {
+        ddr_clk_low  = ddr_pll_low_int + ddr_pll_low_frac;
+        ddr_clk_high = ddr_pll_high_int + ddr_pll_high_frac;
+
+        if (ddr_outdiv != 0) {
+            ddr_clk_low  /= (2*ddr_outdiv);
+            ddr_clk_high /= (2*ddr_outdiv);
+        }
+
+        cpu_clk_low  = ddr_clk_low;
+        cpu_clk_high = ddr_clk_high;
+    } else {
+        cpu_clk_low  = cpu_pll_low_int + cpu_pll_low_frac;
+        cpu_clk_high = cpu_pll_high_int + cpu_pll_high_frac;
+        ddr_clk_low  = ddr_pll_low_int + ddr_pll_low_frac;
+        ddr_clk_high = ddr_pll_high_int + ddr_pll_high_frac;
+
+        if (cpu_outdiv != 0) {
+            cpu_clk_low  /= (2*cpu_outdiv);
+            cpu_clk_high /= (2*cpu_outdiv);
+        }
+
+        if (ddr_outdiv != 0) {
+            ddr_clk_low  /= (2*ddr_outdiv);
+            ddr_clk_high /= (2*ddr_outdiv);
+        }
+    }
+
+    if (ahbclk_from_ddrpll) {
+        ahb_clk_low  = ddr_clk_low;
+        ahb_clk_high = ddr_clk_high;
+    } else {
+        ahb_clk_low  = cpu_clk_low;
+        ahb_clk_high = cpu_clk_high;
+    }
+
+    /* CPU Clock, DDR Clock, AHB Clock */
+    cpu_clk_low  /= (cpu_post_div + 1);
+    cpu_clk_high /= (cpu_post_div + 1);
+    ddr_clk_low  /= (ddr_post_div + 1);
+    ddr_clk_high /= (ddr_post_div + 1);
+    ahb_clk_low  /= (ahb_post_div + 1);
+    ahb_clk_high /= (ahb_post_div + 1);
+
+	ath_cpu_freq = cpu_clk_low;
+	ath_ddr_freq = ddr_clk_low;
+	ath_ahb_freq = ahb_clk_low;
+	//*cpu_clk_h = cpu_clk_high;
+	//*ddr_clk_h = ddr_clk_high;
+	//*ahb_clk_h = ahb_clk_high;
+#endif
+
+prmsg("%s: cpu %u ddr %u ahb %u\n", __func__,
+	ath_cpu_freq / 1000000,
+	ath_ddr_freq / 1000000,
+	ath_ahb_freq / 1000000);
+
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/phy.h u-boot_1.1//board/atheros/common/phy.h
--- u-boot//board/atheros/common/phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/phy.h	2014-02-18 01:46:24.899050984 -0800
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _PHY_H
+#define _PHY_H
+
+#include <config.h>
+
+#define ath_gmac_unit2name(_unit) (_unit ?  "eth1" : "eth0")
+
+extern int ath_gmac_miiphy_read(char *devname, uint32_t phaddr, uint8_t reg, uint16_t *data);
+extern int ath_gmac_miiphy_write(char *devname, uint32_t phaddr, uint8_t reg, uint16_t data);
+
+#define phy_reg_read(base, addr, reg)	\
+	ath_gmac_miiphy_read(ath_gmac_unit2name(base), addr, reg, NULL)
+
+#define phy_reg_write(base, addr, reg, data)	\
+	ath_gmac_miiphy_write(ath_gmac_unit2name(base), addr, reg, data)
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/qca-eth-953x.c u-boot_1.1//board/atheros/common/qca-eth-953x.c
--- u-boot//board/atheros/common/qca-eth-953x.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/qca-eth-953x.c	2014-02-18 01:46:24.903050987 -0800
@@ -0,0 +1,706 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#include <atheros.h>
+#include "qca-eth-953x.h"
+#include "qca-eth-953x_phy.h"
+#define SGMII_LINK_WAR_MAX_TRY 10
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ath_gmac_unit2mac(_unit)     ath_gmac_macs[(_unit)]
+#define ath_gmac_name2mac(name)	   is_drqfn() ? ath_gmac_unit2mac(1):strcmp(name,"eth0") ? ath_gmac_unit2mac(1) : ath_gmac_unit2mac(0)
+
+int ath_gmac_miiphy_read(char *devname, uint32_t phaddr, uint8_t reg, uint16_t *data);
+int ath_gmac_miiphy_write(char *devname, uint32_t phaddr, uint8_t reg, uint16_t data);
+extern void ath_sys_frequency(uint32_t *, uint32_t *, uint32_t *);
+
+#ifndef CFG_ATH_GMAC_NMACS
+#define CFG_ATH_GMAC_NMACS	1
+#endif /* CFG_ATH_GMAC_NMACS */
+
+ath_gmac_mac_t *ath_gmac_macs[CFG_ATH_GMAC_NMACS];
+
+
+
+#ifdef  CFG_ATHRS27_PHY
+#define is_s27() 1
+
+#else 
+#define is_s27() 0
+
+#endif 
+#ifdef  CFG_ATHRS27_PHY
+extern void athrs27_reg_init(void);
+extern void athrs27_reg_init_wan(void);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+extern int athr_vir_phy_setup(int unit);
+extern int athr_vir_phy_is_up(int unit);
+extern int athr_vir_phy_is_fdx(int unit);
+extern int athr_vir_phy_speed(int unit);
+extern void athr_vir_reg_init(void);
+#endif
+
+static int
+ath_gmac_send(struct eth_device *dev, volatile void *packet, int length)
+{
+	int i;
+
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
+
+	ath_gmac_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+	f->pkt_size = length;
+	f->res1 = 0;
+	f->pkt_start_addr = virt_to_phys(packet);
+
+	ath_gmac_tx_give_to_dma(f);
+	flush_cache((u32) packet, length);
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_DESC, virt_to_phys(f));
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, ATH_TXE);
+
+	for (i = 0; i < MAX_WAIT; i++) {
+		udelay(10);
+		if (!ath_gmac_tx_owned_by_dma(f))
+			break;
+	}
+	if (i == MAX_WAIT)
+		printf("Tx Timed out\n");
+
+	f->pkt_start_addr = 0;
+	f->pkt_size = 0;
+
+	if (++mac->next_tx >= NO_OF_TX_FIFOS)
+		mac->next_tx = 0;
+
+	return (0);
+}
+
+static int ath_gmac_recv(struct eth_device *dev)
+{
+	int length;
+	ath_gmac_desc_t *f;
+	ath_gmac_mac_t *mac;
+	volatile int dmaed_pkt=0;
+	int count = 0;
+
+	mac = (ath_gmac_mac_t *)dev->priv;
+
+	for (;;) {
+		f = mac->fifo_rx[mac->next_rx];
+		if (ath_gmac_rx_owned_by_dma(f)) {
+			/* check if the current Descriptor is_empty is 1,But the DMAed count is not-zero
+			   then move to desciprot where the packet is available */
+			dmaed_pkt = (ath_gmac_reg_rd(mac, 0x194) >> 16);
+			if (!dmaed_pkt) {
+				break ;
+			} else {
+				if (f->is_empty == 1) {
+					while (count < NO_OF_RX_FIFOS) {
+						if (++mac->next_rx >= NO_OF_RX_FIFOS) {
+							mac->next_rx = 0;
+						}
+						f = mac->fifo_rx[mac->next_rx];
+						/*
+						 * Break on valid data in the desc by checking
+						 * empty bit.
+						 */
+						if (!f->is_empty) {
+							count = 0;
+							break;
+						}
+						count++;
+					}
+				}
+			}
+		}
+
+		length = f->pkt_size;
+
+		NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+		flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+		ath_gmac_reg_wr(mac,0x194,1);
+		ath_gmac_rx_give_to_dma(f);
+
+		if (++mac->next_rx >= NO_OF_RX_FIFOS)
+			mac->next_rx = 0;
+	}
+
+	if (!(ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL))) {
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, virt_to_phys(f));
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 1);
+	}
+
+	return (0);
+}
+
+void ath_gmac_mii_setup(ath_gmac_mac_t *mac)
+{
+	u32 mgmt_cfg_val;
+
+	ath_reg_wr(SWITCH_CLOCK_SPARE_ADDRESS, 0x231);
+	//ath_reg_wr(SWITCH_CLOCK_SPARE_ADDRESS, 0x520);
+	if ((mac->mac_unit == 1)) {
+		printf("Honey Bee ---->  MAC 1 S27 PHY *\n");
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(3)|
+					ETH_CFG_RGMII_GE0_SET(1));
+
+		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
+						ETH_XMII_RX_DELAY_SET(2) |
+						ETH_XMII_TX_DELAY_SET(1) |
+						ETH_XMII_GIGE_SET(1));
+        	mgmt_cfg_val = 2;
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+		return;
+	}
+
+	if (is_vir_phy()) {
+		printf("Honey Bee ---->VIR PHY*\n");
+
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(3)|
+					ETH_CFG_RGMII_GE0_SET(1));
+		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
+						ETH_XMII_RX_DELAY_SET(2) |
+						ETH_XMII_TX_DELAY_SET(1) |
+						ETH_XMII_GIGE_SET(1));
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+		return;
+	}
+	if (is_s27()) {
+        	mgmt_cfg_val = 2;
+        	printf("Scorpion ---->S27 PHY*\n");
+		ath_reg_wr(ETH_CFG_ADDRESS, ETH_CFG_MII_GE0_SET(1)|
+                                        ETH_CFG_MII_GE0_SLAVE_SET(1));
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+	}
+
+
+
+
+}
+
+
+static void ath_gmac_hw_start(ath_gmac_mac_t *mac)
+{
+
+
+	if(mac->mac_unit)
+	{
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_1000));
+	} else {
+
+
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_10_100));
+	}
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_1, 0x10ffff);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_2, 0xAAA0555);
+
+	ath_gmac_reg_rmw_set(mac, ATH_MAC_FIFO_CFG_4, 0x3ffff);
+	/*
+	 * Setting Drop CRC Errors, Pause Frames,Length Error frames
+	 * and Multi/Broad cast frames.
+	 */
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_5, 0x7eccf);
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_3, 0x1f00140);
+
+	printf(": cfg1 %#x cfg2 %#x\n", ath_gmac_reg_rd(mac, ATH_MAC_CFG1),
+			ath_gmac_reg_rd(mac, ATH_MAC_CFG2));
+
+
+}
+
+static int ath_gmac_check_link(ath_gmac_mac_t *mac)
+{
+	int link, duplex, speed;
+
+	ath_gmac_phy_link(mac->mac_unit, &link);
+	ath_gmac_phy_duplex(mac->mac_unit, &duplex);
+	ath_gmac_phy_speed(mac->mac_unit, &speed);
+
+	mac->link = link;
+
+	if(!mac->link) {
+		printf("%s link down\n",mac->dev->name);
+		return 0;
+	}
+
+	switch (speed)
+	{
+		case _1000BASET:
+			ath_gmac_set_mac_if(mac, 1);
+			ath_gmac_reg_rmw_set(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+			break;
+
+		case _100BASET:
+			ath_gmac_set_mac_if(mac, 0);
+			ath_gmac_set_mac_speed(mac, 1);
+			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+			break;
+
+		case _10BASET:
+			ath_gmac_set_mac_if(mac, 0);
+			ath_gmac_set_mac_speed(mac, 0);
+			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+			break;
+
+		default:
+			printf("Invalid speed detected\n");
+			return 0;
+	}
+
+	if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+		return 1;
+
+	mac->duplex = duplex;
+	mac->speed = speed;
+
+	printf("dup %d speed %d\n", duplex, speed);
+
+	ath_gmac_set_mac_duplex(mac,duplex);
+
+	return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ath_gmac_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+	int i;
+	ath_gmac_desc_t *fr;
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t*)dev->priv;
+
+	if (!ath_gmac_check_link(mac))
+		return 0;
+
+	mac->next_rx = 0;
+
+        ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+        ath_gmac_reg_wr(mac, ATH_MAC_CFG1, (ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+
+	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+		fr = mac->fifo_rx[i];
+		fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+		flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+		ath_gmac_rx_give_to_dma(fr);
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, ATH_RXE);	/* rx start */
+	udelay(1000 * 1000);
+
+
+	return 1;
+
+}
+
+static int ath_gmac_alloc_fifo(int ndesc, ath_gmac_desc_t ** fifo)
+{
+	int i;
+	u32 size;
+	uchar *p = NULL;
+
+	size = sizeof(ath_gmac_desc_t) * ndesc;
+	size += CFG_CACHELINE_SIZE - 1;
+
+	if ((p = malloc(size)) == NULL) {
+		printf("Cant allocate fifos\n");
+		return -1;
+	}
+
+	p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+			~(CFG_CACHELINE_SIZE - 1));
+	p = UNCACHED_SDRAM(p);
+
+	for (i = 0; i < ndesc; i++)
+		fifo[i] = (ath_gmac_desc_t *) p + i;
+
+	return 0;
+}
+
+static int ath_gmac_setup_fifos(ath_gmac_mac_t *mac)
+{
+	int i;
+
+	if (ath_gmac_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+		return 1;
+
+	for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+		mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+			virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+		ath_gmac_tx_own(mac->fifo_tx[i]);
+	}
+
+	if (ath_gmac_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+		return 1;
+
+	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+		mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+			virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+	}
+
+	return (1);
+}
+
+static void ath_gmac_halt(struct eth_device *dev)
+{
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
+        ath_gmac_reg_rmw_clear(mac, ATH_MAC_CFG1,(ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+        ath_gmac_reg_wr(mac,ATH_MAC_FIFO_CFG_0,0x1f1f);
+	ath_gmac_reg_wr(mac,ATH_DMA_RX_CTRL, 0);
+	while (ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL));
+}
+
+unsigned char *
+ath_gmac_mac_addr_loc(void)
+{
+#ifdef BOARDCAL
+	/*
+	 ** BOARDCAL environmental variable has the address of the cal sector
+	 */
+
+	return ((unsigned char *)BOARDCAL);
+
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+			(KSEG1ADDR(ATH_SPI_BASE) + (4 * 1024) +
+			 flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+static void ath_gmac_get_ethaddr(struct eth_device *dev)
+{
+	unsigned char *eeprom;
+	unsigned char *mac = dev->enetaddr;
+#ifndef CONFIG_ATH_EMULATION
+
+	eeprom = ath_gmac_mac_addr_loc();
+
+	if (strcmp(dev->name, "eth0") == 0) {
+		memcpy(mac, eeprom, 6);
+	} else if (strcmp(dev->name, "eth1") == 0) {
+		eeprom += 6;
+		memcpy(mac, eeprom, 6);
+	} else {
+		printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+		return;
+	}
+	/* Use fixed address if the above address is invalid */
+	if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff))
+#else
+	if (1)
+#endif
+	{
+		mac[0] = 0x00;
+		mac[1] = 0x03;
+		mac[2] = 0x7f;
+		mac[3] = 0x09;
+		mac[4] = 0x0b;
+		mac[5] = 0xad;
+		printf("No valid address in Flash. Using fixed address\n");
+	} else {
+		printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+	}
+}
+
+void
+athr_mgmt_init(void)
+{
+
+#ifdef CONFIG_MGMT_INIT
+	uint32_t rddata;
+
+	rddata = ath_reg_rd(GPIO_IN_ENABLE3_ADDRESS)&
+		~GPIO_IN_ENABLE3_MII_GE1_MDI_MASK;
+	rddata |= GPIO_IN_ENABLE3_MII_GE1_MDI_SET(19);
+	ath_reg_wr(GPIO_IN_ENABLE3_ADDRESS, rddata);
+
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 19));
+
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 17));
+
+
+	rddata = ath_reg_rd(GPIO_OUT_FUNCTION4_ADDRESS) &
+		~ (GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK |
+		GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK);
+
+	rddata |= GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(0x20) |
+	GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(0x21);
+
+	ath_reg_wr(GPIO_OUT_FUNCTION4_ADDRESS, rddata);
+#endif
+	printf ("%s ::done\n",__func__);
+}
+
+int ath_gmac_enet_initialize(bd_t * bis)
+{
+	struct eth_device *dev[CFG_ATH_GMAC_NMACS];
+	u32 mask, mac_h, mac_l;
+	int i;
+
+	printf("%s...\n", __func__);
+
+	/* Switch Analog and digital reset seq */
+	mask = ATH_RESET_GE1_PHY |  ATH_RESET_GE0_PHY;
+	ath_reg_rmw_set(RST_RESET_ADDRESS, mask);
+
+	udelay(1000 * 100);
+	mask = ATH_RESET_GE1_PHY ;
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+
+	udelay(1000 * 100);
+	mask = ATH_RESET_GE0_PHY ;
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+	udelay(100);
+
+
+	for (i = 0;i < CFG_ATH_GMAC_NMACS;i++) {
+
+		if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+			puts("malloc failed\n");
+			return 0;
+		}
+
+		if ((ath_gmac_macs[i] = (ath_gmac_mac_t *) malloc(sizeof (ath_gmac_mac_t))) == NULL) {
+			puts("malloc failed\n");
+			return 0;
+		}
+
+		memset(ath_gmac_macs[i], 0, sizeof(ath_gmac_macs[i]));
+		memset(dev[i], 0, sizeof(dev[i]));
+
+		sprintf(dev[i]->name, "eth%d", i);
+		ath_gmac_get_ethaddr(dev[i]);
+
+		ath_gmac_macs[i]->mac_unit = i;
+		ath_gmac_macs[i]->mac_base = i ? ATH_GE1_BASE : ATH_GE0_BASE ;
+		ath_gmac_macs[i]->dev = dev[i];
+
+		dev[i]->iobase = 0;
+		dev[i]->init = ath_gmac_clean_rx;
+		dev[i]->halt = ath_gmac_halt;
+		dev[i]->send = ath_gmac_send;
+		dev[i]->recv = ath_gmac_recv;
+		dev[i]->priv = (void *)ath_gmac_macs[i];
+	}
+
+	for (i = 0;i < CFG_ATH_GMAC_NMACS;i++) {
+
+		if(!i) {
+			mask = (ATH_RESET_GE0_MAC | ATH_RESET_GE1_MAC | ATH_RESET_GE0_MDIO | ATH_RESET_GE1_MDIO);
+
+
+			printf("%s: reset mask:%x \n", __func__, mask);
+
+			ath_reg_rmw_set(RST_RESET_ADDRESS, mask);
+			udelay(1000 * 100);
+
+			mask = mask | ATH_RESET_GE0_MDIO | ATH_RESET_GE1_MDIO;
+			ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+			udelay(1000 * 100);
+
+			udelay(10 * 1000);
+		}
+#if defined(CONFIG_MGMT_INIT) && defined (CONFIG_ATHR_SWITCH_ONLY_MODE) || defined ATH_MDC_GPIO
+		if (!i)
+			athr_mgmt_init();
+
+		if (ath_gmac_macs[i]->mac_unit == 0)
+                        continue;
+#endif
+		eth_register(dev[i]);
+#if(CONFIG_COMMANDS & CFG_CMD_MII)
+		miiphy_register(dev[i]->name, ath_gmac_miiphy_read, ath_gmac_miiphy_write);
+#endif
+		ath_gmac_mii_setup(ath_gmac_macs[i]);
+
+		/* if using header for register configuration, we have to     */
+		/* configure s26 register after frame transmission is enabled */
+
+		if (ath_gmac_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef  CFG_ATHRS27_PHY
+			printf("S27 reg init\n");
+			athrs27_reg_init();
+			mask = ATH_RESET_GE0_MAC;
+                        ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			printf("VIRPhy reg init \n");
+			athr_vir_reg_init();
+#endif
+		} else {
+#ifdef  CFG_ATHRS27_PHY
+			printf("S27 reg init\n");
+			athrs27_reg_init_lan();
+			mask = ATH_RESET_GE1_MAC;
+                        ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+#endif
+
+		}
+
+	 	ath_gmac_reg_rmw_set(ath_gmac_macs[i], ATH_MAC_CFG1, ATH_MAC_CFG1_SOFT_RST
+                                | ATH_MAC_CFG1_RX_RST | ATH_MAC_CFG1_TX_RST);
+
+
+		ath_gmac_hw_start(ath_gmac_macs[i]);
+		ath_gmac_setup_fifos(ath_gmac_macs[i]);
+
+
+
+		udelay(100 * 1000);
+
+		{
+			unsigned char *mac = dev[i]->enetaddr;
+
+			printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+					mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+					mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+		}
+		mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+		mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+			(dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+		ath_gmac_reg_wr(ath_gmac_macs[i], ATH_GE_MAC_ADDR1, mac_l);
+		ath_gmac_reg_wr(ath_gmac_macs[i], ATH_GE_MAC_ADDR2, mac_h);
+
+
+	ath_gmac_phy_setup(ath_gmac_macs[i]->mac_unit);
+		printf("%s up\n",dev[i]->name);
+	}
+
+
+	return 1;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+int
+ath_gmac_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t *data)
+{
+	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
+	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg, val;
+	volatile int           rddata;
+	uint16_t      ii = 0xFFFF;
+
+
+	/*
+	 * Check for previous transactions are complete. Added to avoid
+	 * race condition while running at higher frequencies.
+	 */
+	do
+	{
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	}while(rddata && --ii);
+
+	if (ii == 0)
+		printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_ADDRESS, addr);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, ATH_MGMT_CMD_READ);
+
+	do
+	{
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	}while(rddata && --ii);
+
+	if(ii==0)
+		printf("Error!!! Leave ath_gmac_miiphy_read without polling correct status!\n");
+
+	val = ath_gmac_reg_rd(mac, ATH_MII_MGMT_STATUS);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
+
+	if (data != NULL)
+            *data = val; 
+
+	return val;
+}
+
+int
+ath_gmac_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
+	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg;
+	volatile int rddata;
+	uint16_t      ii = 0xFFFF;
+
+
+	/*
+	 * Check for previous transactions are complete. Added to avoid
+	 * race condition while running at higher frequencies.
+	 */
+	do {
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	} while (rddata && --ii);
+
+	if (ii == 0)
+		printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_ADDRESS, addr);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CTRL, data);
+
+	do {
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	} while (rddata && --ii);
+
+	if (ii == 0)
+		printf("Error!!! Leave ath_gmac_miiphy_write without polling correct status!\n");
+	
+	return 0; 
+}
+#endif		/* CONFIG_COMMANDS & CFG_CMD_MII */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/qca-eth-953x.h u-boot_1.1//board/atheros/common/qca-eth-953x.h
--- u-boot//board/atheros/common/qca-eth-953x.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/qca-eth-953x.h	2014-02-18 01:46:24.903050987 -0800
@@ -0,0 +1,371 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __QCA_ETH_953X_H
+#define __QCA_ETH_953X_H
+
+#include <linux/types.h>
+
+#ifdef ATH_RGMII_CAL
+#define rgmii_cal_alg()    rgmii_calib(mac);
+#else
+#define rgmii_cal_alg()
+#endif
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+	uint32_t	pkt_start_addr,
+			is_empty	:  1,
+			res1		: 10,
+			ftpp_override	:  5,
+			res2		:  4,
+			pkt_size	: 12,
+			next_desc;
+} ath_gmac_desc_t;
+
+#define NO_OF_TX_FIFOS			8
+#define NO_OF_RX_FIFOS			8
+
+typedef struct {
+	ath_gmac_desc_t		*fifo_tx[NO_OF_TX_FIFOS],
+				*fifo_rx[NO_OF_RX_FIFOS];
+	struct eth_device	*dev;
+	uint32_t		next_tx,
+				next_rx,
+				link,
+				duplex,
+				speed,
+				mac_unit,
+				mac_base;
+} ath_gmac_mac_t;
+
+#define ath_gmac_reg_wr(_mac, _x, _y)	ath_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ath_gmac_reg_rd(_mac, _x)	ath_reg_rd(((_x) + _mac->mac_base))
+
+#define ath_gmac_reg_rmw_set(_mac, _x, _y)	\
+	ath_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ath_gmac_reg_rmw_clear(_mac, _x, _y)	\
+	ath_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+#ifdef COMPRESSED_UBOOT
+#define _1000BASET		1000
+#define _100BASET		100
+#define _10BASET		10
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+#define mii_reg(_mac)	(ATH_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)	(((_mac)->mac_unit == 0) ? mii0_if : mii1_if)
+
+#define ath_gmac_set_mii_ctrl_speed(_mac, _spd)	do {	\
+	ath_reg_rmw_clear(mii_reg(_mac), (3 << 4));	\
+	ath_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));	\
+} while (0)
+
+#if defined (CFG_MII0_GMII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_MII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_RGMII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_RMII)
+#	define ath_gmac_get_mii_if()	0
+#endif
+
+#define MAX_WAIT			1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define ATH_MAC_CFG1			0x00
+#define ATH_MAC_CFG2			0x04
+#define ATH_MAC_IFCTL			0x38
+
+/*
+ * fifo control registers
+ */
+#define ATH_MAC_FIFO_CFG_0		0x48
+#define ATH_MAC_FIFO_CFG_1		0x4c
+#define ATH_MAC_FIFO_CFG_2		0x50
+#define ATH_MAC_FIFO_CFG_3		0x54
+#define ATH_MAC_FIFO_CFG_4		0x58
+
+#define ATH_MAC_FIFO_CFG_5		0x5c
+#define ATH_BYTE_PER_CLK_EN		(1 << 19)
+
+#define ATH_MAC_FIFO_RAM_0		0x60
+#define ATH_MAC_FIFO_RAM_1		0x64
+#define ATH_MAC_FIFO_RAM_2		0x68
+#define ATH_MAC_FIFO_RAM_3		0x6c
+#define ATH_MAC_FIFO_RAM_4		0x70
+#define ATH_MAC_FIFO_RAM_5		0x74
+#define ATH_MAC_FIFO_RAM_6		0x78
+#define ATH_MAC_FIFO_RAM_7		0x7c
+
+/*
+ * fields
+ */
+#define ATH_MAC_CFG1_SOFT_RST		(1 << 31)
+#define ATH_MAC_CFG1_RX_RST		(1 << 19)
+#define ATH_MAC_CFG1_TX_RST		(1 << 18)
+#define ATH_MAC_CFG1_LOOPBACK		(1 << 8)
+#define ATH_MAC_CFG1_RX_EN		(1 << 2)
+#define ATH_MAC_CFG1_TX_EN		(1 << 0)
+
+#define ATH_MAC_CFG2_FDX		(1 << 0)
+#define ATH_MAC_CFG2_PAD_CRC_EN		(1 << 2)
+#define ATH_MAC_CFG2_LEN_CHECK		(1 << 4)
+#define ATH_MAC_CFG2_HUGE_FRAME_EN	(1 << 5)
+#define ATH_MAC_CFG2_IF_1000		(1 << 9)
+#define ATH_MAC_CFG2_IF_10_100		(1 << 8)
+
+#define ATH_MAC_IFCTL_SPEED		(1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define ATH_DMA_TX_CTRL			0x180
+#define ATH_DMA_TX_DESC			0x184
+#define ATH_DMA_TX_STATUS		0x188
+#define ATH_DMA_RX_CTRL			0x18c
+#define ATH_DMA_RX_DESC			0x190
+#define ATH_DMA_RX_STATUS		0x194
+#define ATH_DMA_INTR_MASK		0x198
+#define ATH_DMA_INTR			0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define ATH_TXE				(1 << 0)
+#define ATH_TX_STATUS_PKTCNT_SHIFT	16
+#define ATH_TX_STATUS_PKT_SENT		0x1
+#define ATH_TX_STATUS_URN		0x2
+#define ATH_TX_STATUS_BUS_ERROR		0x8
+
+#define ATH_RXE				(1 << 0)
+
+#define ATH_RX_STATUS_PKTCNT_MASK	0xff0000
+#define ATH_RX_STATUS_PKT_RCVD		(1 << 0)
+#define ATH_RX_STATUS_OVF		(1 << 2)
+#define ATH_RX_STATUS_BUS_ERROR		(1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define ATH_INTR_TX			(1 << 0)
+#define ATH_INTR_TX_URN			(1 << 1)
+#define ATH_INTR_TX_BUS_ERROR		(1 << 3)
+#define ATH_INTR_RX			(1 << 4)
+#define ATH_INTR_RX_OVF			(1 << 6)
+#define ATH_INTR_RX_BUS_ERROR		(1 << 7)
+
+/*
+ * MII registers
+ */
+#define ATH_MAC_MII_MGMT_CFG		0x20
+#define ATH_MGMT_CFG_CLK_DIV_20		0x07
+
+#define ATH_MII_MGMT_CMD		0x24
+#define ATH_MGMT_CMD_READ		0x1
+
+#define ATH_MII_MGMT_ADDRESS		0x28
+#define ATH_ADDR_SHIFT			8
+
+#define ATH_MII_MGMT_CTRL		0x2c
+#define ATH_MII_MGMT_STATUS		0x30
+
+#define ATH_MII_MGMT_IND		0x34
+#define ATH_MGMT_IND_BUSY		(1 << 0)
+#define ATH_MGMT_IND_INVALID		(1 << 2)
+
+#define ATH_GE_MAC_ADDR1		0x40
+#define ATH_GE_MAC_ADDR2		0x44
+
+/*
+ * Ethernet config registers
+ */
+#define ATH_ETH_CFG			0x18070000
+#define ATH_ETH_CFG_RGMII_GE0		(1<<0)
+#define ATH_ETH_CFG_MII_GE0		(1<<1)
+#define ATH_ETH_CFG_GMII_GE0		(1<<2)
+#define ATH_ETH_CFG_RMII_GE0		(1<<10)
+#define ATH_ETH_CFG_RMII_HISPD_GE0	(1<<11)
+#define ATH_ETH_CFG_RMII_MASTER_MODE	(1<<12)
+#define ATH_ETH_CFG_MII_GE0_MASTER	(1<<3)
+#define ATH_ETH_CFG_MII_GE0_SLAVE	(1<<4)
+#define ATH_ETH_CFG_GE0_ERR_EN		(1<<5)
+#define ATH_ETH_CFG_SW_ONLY_MODE	(1<<6)
+#define ATH_ETH_CFG_SW_PHY_SWAP		(1<<7)
+#define ATH_ETH_CFG_SW_PHY_ADDR_SWAP	(1<<8)
+#define ATH_ETH_CFG_RXD_DELAY		(1 << 14)
+#define ATH_ETH_CFG_RDV_DELAY		(1 << 16)
+#define ATH_ETH_SWITCH_CLK_SPARE	0x18050024
+
+#define ETH_CFG_ETH_SPARE_MSB                                        31
+#define ETH_CFG_ETH_SPARE_LSB                                        22
+#define ETH_CFG_ETH_SPARE_MASK                                       0xffc00000
+#define ETH_CFG_ETH_SPARE_GET(x)                                     (((x) & ETH_CFG_ETH_SPARE_MASK) >> ETH_CFG_ETH_SPARE_LSB)
+#define ETH_CFG_ETH_SPARE_SET(x)                                     (((x) << ETH_CFG_ETH_SPARE_LSB) & ETH_CFG_ETH_SPARE_MASK)
+#define ETH_CFG_ETH_SPARE_RESET                                      0x0 // 0
+#define ETH_CFG_ETH_TXEN_DELAY_MSB                                   21
+#define ETH_CFG_ETH_TXEN_DELAY_LSB                                   20
+#define ETH_CFG_ETH_TXEN_DELAY_MASK                                  0x00300000
+#define ETH_CFG_ETH_TXEN_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_TXEN_DELAY_MASK) >> ETH_CFG_ETH_TXEN_DELAY_LSB)
+#define ETH_CFG_ETH_TXEN_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_TXEN_DELAY_LSB) & ETH_CFG_ETH_TXEN_DELAY_MASK)
+#define ETH_CFG_ETH_TXEN_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_TXD_DELAY_MSB                                    19
+#define ETH_CFG_ETH_TXD_DELAY_LSB                                    18
+#define ETH_CFG_ETH_TXD_DELAY_MASK                                   0x000c0000
+#define ETH_CFG_ETH_TXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_TXD_DELAY_MASK) >> ETH_CFG_ETH_TXD_DELAY_LSB)
+#define ETH_CFG_ETH_TXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_TXD_DELAY_LSB) & ETH_CFG_ETH_TXD_DELAY_MASK)
+#define ETH_CFG_ETH_TXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_ETH_RXDV_DELAY_MSB                                   17
+#define ETH_CFG_ETH_RXDV_DELAY_LSB                                   16
+#define ETH_CFG_ETH_RXDV_DELAY_MASK                                  0x00030000
+#define ETH_CFG_ETH_RXDV_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_RXDV_DELAY_MASK) >> ETH_CFG_ETH_RXDV_DELAY_LSB)
+#define ETH_CFG_ETH_RXDV_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_RXDV_DELAY_LSB) & ETH_CFG_ETH_RXDV_DELAY_MASK)
+#define ETH_CFG_ETH_RXDV_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_RXD_DELAY_MSB                                    15
+#define ETH_CFG_ETH_RXD_DELAY_LSB                                    14
+#define ETH_CFG_ETH_RXD_DELAY_MASK                                   0x0000c000
+#define ETH_CFG_ETH_RXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_RXD_DELAY_MASK) >> ETH_CFG_ETH_RXD_DELAY_LSB)
+#define ETH_CFG_ETH_RXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_RXD_DELAY_LSB) & ETH_CFG_ETH_RXD_DELAY_MASK)
+#define ETH_CFG_ETH_RXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_RMII_GE0_MASTER_MSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_LSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_MASK                                 0x00001000
+#define ETH_CFG_RMII_GE0_MASTER_GET(x)                               (((x) & ETH_CFG_RMII_GE0_MASTER_MASK) >> ETH_CFG_RMII_GE0_MASTER_LSB)
+#define ETH_CFG_RMII_GE0_MASTER_SET(x)                               (((x) << ETH_CFG_RMII_GE0_MASTER_LSB) & ETH_CFG_RMII_GE0_MASTER_MASK)
+#define ETH_CFG_RMII_GE0_MASTER_RESET                                0x1 // 1
+#define ETH_CFG_MII_CNTL_SPEED_MSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_LSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_MASK                                  0x00000800
+#define ETH_CFG_MII_CNTL_SPEED_GET(x)                                (((x) & ETH_CFG_MII_CNTL_SPEED_MASK) >> ETH_CFG_MII_CNTL_SPEED_LSB)
+#define ETH_CFG_MII_CNTL_SPEED_SET(x)                                (((x) << ETH_CFG_MII_CNTL_SPEED_LSB) & ETH_CFG_MII_CNTL_SPEED_MASK)
+#define ETH_CFG_MII_CNTL_SPEED_RESET                                 0x0 // 0
+#define ETH_CFG_RMII_GE0_MSB                                         10
+#define ETH_CFG_RMII_GE0_LSB                                         10
+#define ETH_CFG_RMII_GE0_MASK                                        0x00000400
+#define ETH_CFG_RMII_GE0_GET(x)                                      (((x) & ETH_CFG_RMII_GE0_MASK) >> ETH_CFG_RMII_GE0_LSB)
+#define ETH_CFG_RMII_GE0_SET(x)                                      (((x) << ETH_CFG_RMII_GE0_LSB) & ETH_CFG_RMII_GE0_MASK)
+#define ETH_CFG_RMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_GE0_SGMII_MSB                                        6
+#define ETH_CFG_GE0_SGMII_LSB                                        6
+#define ETH_CFG_GE0_SGMII_MASK                                       0x00000040
+#define ETH_CFG_GE0_SGMII_GET(x)                                     (((x) & ETH_CFG_GE0_SGMII_MASK) >> ETH_CFG_GE0_SGMII_LSB)
+#define ETH_CFG_GE0_SGMII_SET(x)                                     (((x) << ETH_CFG_GE0_SGMII_LSB) & ETH_CFG_GE0_SGMII_MASK)
+#define ETH_CFG_GE0_SGMII_RESET                                      0x0 // 0
+#define ETH_CFG_GE0_ERR_EN_MSB                                       5
+#define ETH_CFG_GE0_ERR_EN_LSB                                       5
+#define ETH_CFG_GE0_ERR_EN_MASK                                      0x00000020
+#define ETH_CFG_GE0_ERR_EN_GET(x)                                    (((x) & ETH_CFG_GE0_ERR_EN_MASK) >> ETH_CFG_GE0_ERR_EN_LSB)
+#define ETH_CFG_GE0_ERR_EN_SET(x)                                    (((x) << ETH_CFG_GE0_ERR_EN_LSB) & ETH_CFG_GE0_ERR_EN_MASK)
+#define ETH_CFG_GE0_ERR_EN_RESET                                     0x0 // 0
+#define ETH_CFG_MII_GE0_SLAVE_MSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_LSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_MASK                                   0x00000010
+#define ETH_CFG_MII_GE0_SLAVE_GET(x)                                 (((x) & ETH_CFG_MII_GE0_SLAVE_MASK) >> ETH_CFG_MII_GE0_SLAVE_LSB)
+#define ETH_CFG_MII_GE0_SLAVE_SET(x)                                 (((x) << ETH_CFG_MII_GE0_SLAVE_LSB) & ETH_CFG_MII_GE0_SLAVE_MASK)
+#define ETH_CFG_MII_GE0_SLAVE_RESET                                  0x0 // 0
+#define ETH_CFG_MII_GE0_MASTER_MSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_LSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_MASK                                  0x00000008
+#define ETH_CFG_MII_GE0_MASTER_GET(x)                                (((x) & ETH_CFG_MII_GE0_MASTER_MASK) >> ETH_CFG_MII_GE0_MASTER_LSB)
+#define ETH_CFG_MII_GE0_MASTER_SET(x)                                (((x) << ETH_CFG_MII_GE0_MASTER_LSB) & ETH_CFG_MII_GE0_MASTER_MASK)
+#define ETH_CFG_MII_GE0_MASTER_RESET                                 0x0 // 0
+#define ETH_CFG_GMII_GE0_MSB                                         2
+#define ETH_CFG_GMII_GE0_LSB                                         2
+#define ETH_CFG_GMII_GE0_MASK                                        0x00000004
+#define ETH_CFG_GMII_GE0_GET(x)                                      (((x) & ETH_CFG_GMII_GE0_MASK) >> ETH_CFG_GMII_GE0_LSB)
+#define ETH_CFG_GMII_GE0_SET(x)                                      (((x) << ETH_CFG_GMII_GE0_LSB) & ETH_CFG_GMII_GE0_MASK)
+#define ETH_CFG_GMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_MII_GE0_MSB                                          1
+#define ETH_CFG_MII_GE0_LSB                                          1
+#define ETH_CFG_MII_GE0_MASK                                         0x00000002
+#define ETH_CFG_MII_GE0_GET(x)                                       (((x) & ETH_CFG_MII_GE0_MASK) >> ETH_CFG_MII_GE0_LSB)
+#define ETH_CFG_MII_GE0_SET(x)                                       (((x) << ETH_CFG_MII_GE0_LSB) & ETH_CFG_MII_GE0_MASK)
+#define ETH_CFG_MII_GE0_RESET                                        0x0 // 0
+#define ETH_CFG_RGMII_GE0_MSB                                        0
+#define ETH_CFG_RGMII_GE0_LSB                                        0
+#define ETH_CFG_RGMII_GE0_MASK                                       0x00000001
+#define ETH_CFG_RGMII_GE0_GET(x)                                     (((x) & ETH_CFG_RGMII_GE0_MASK) >> ETH_CFG_RGMII_GE0_LSB)
+#define ETH_CFG_RGMII_GE0_SET(x)                                     (((x) << ETH_CFG_RGMII_GE0_LSB) & ETH_CFG_RGMII_GE0_MASK)
+#define ETH_CFG_RGMII_GE0_RESET                                      0x0 // 0
+#define ETH_CFG_ADDRESS                                              0x18070000
+
+
+
+
+/*
+ * ownership of descriptors between DMA and cpu
+ */
+#define ath_gmac_rx_owned_by_dma(_ds)	((_ds)->is_empty == 1)
+#define ath_gmac_rx_give_to_dma(_ds)	((_ds)->is_empty = 1)
+#define ath_gmac_tx_owned_by_dma(_ds)	((_ds)->is_empty == 0)
+#define ath_gmac_tx_give_to_dma(_ds)	((_ds)->is_empty = 0)
+#define ath_gmac_tx_own(_ds)		((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ath_gmac_set_mac_duplex(_mac, _fdx)	do {	\
+	if ((_fdx)) {					\
+		ath_gmac_reg_rmw_set(_mac,		\
+			ATH_MAC_CFG2, ATH_MAC_CFG2_FDX);\
+	} else {					\
+		ath_gmac_reg_rmw_clear(_mac,		\
+			ATH_MAC_CFG2, ATH_MAC_CFG2_FDX);\
+	}						\
+} while (0)
+
+#define ath_gmac_set_mac_if(_mac, _isXGMII)	do {		\
+	ath_gmac_reg_rmw_clear(_mac, ATH_MAC_CFG2,		\
+				ATH_MAC_CFG2_IF_1000 |		\
+				ATH_MAC_CFG2_IF_10_100);	\
+	if ((_isXGMII)) {					\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_CFG2,	\
+				ATH_MAC_CFG2_IF_1000);		\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_FIFO_CFG_5,	\
+				ATH_BYTE_PER_CLK_EN);		\
+	} else {						\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_CFG2,	\
+				ATH_MAC_CFG2_IF_10_100);	\
+		ath_gmac_reg_rmw_clear(_mac, ATH_MAC_FIFO_CFG_5,\
+				ATH_BYTE_PER_CLK_EN);		\
+	}							\
+} while (0)
+
+#define ath_gmac_set_mac_speed(_mac, _is100)	do {		\
+	if ((_is100)) {						\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_IFCTL,	\
+					ATH_MAC_IFCTL_SPEED);	\
+	} else {						\
+		ath_gmac_reg_rmw_clear(_mac, ATH_MAC_IFCTL,	\
+					ATH_MAC_IFCTL_SPEED);	\
+	}							\
+} while (0)
+
+#endif /* __QCA_ETH_953X_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/qca-eth-953x_phy.h u-boot_1.1//board/atheros/common/qca-eth-953x_phy.h
--- u-boot//board/atheros/common/qca-eth-953x_phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/qca-eth-953x_phy.h	2014-02-18 01:46:24.903050987 -0800
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _QCA_ETH_953x_PHY_H
+#define _QCA_ETH_953x_PHY_H
+#include <miiphy.h>
+
+
+#ifdef CONFIG_ATHR_8033_PHY
+extern int athrs_ar8033_reg_init(void *arg);
+extern int athrs_ar8033_phy_setup(void  *arg);
+extern int athrs_ar8033_phy_is_fdx(int ethUnit);
+extern int athrs_ar8033_phy_is_link_alive(int phyUnit);
+extern int athrs_ar8033_phy_is_up(int ethUnit);
+extern int athrs_ar8033_phy_speed(int ethUnit,int phyUnit);
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+extern int athrs27_phy_setup(int ethUnit);
+extern int athrs27_phy_is_up(int ethUnit);
+extern int athrs27_phy_is_fdx(int ethUnit);
+extern int athrs27_phy_speed(int ethUnit);
+#endif
+
+#ifdef CONFIG_ATHRS17_PHY
+extern int athrs17_phy_setup(int ethUnit);
+extern int athrs17_phy_is_up(int ethUnit);
+extern int athrs17_phy_is_fdx(int ethUnit);
+extern int athrs17_phy_speed(int ethUnit);
+#endif
+
+static inline void ath_gmac_phy_setup(int unit)
+{
+#ifdef CFG_ATHRS27_PHY
+                        athrs27_phy_setup(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+			athr_vir_phy_setup(unit);
+#endif
+}
+
+static inline void ath_gmac_phy_link(int unit, int *link)
+{
+
+#ifdef CFG_ATHRS27_PHY
+                        *link = athrs27_phy_is_up(unit);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			*link = athr_vir_phy_is_up(unit);
+#endif
+}
+
+static inline void ath_gmac_phy_duplex(int unit, int *duplex)
+{
+#ifdef CFG_ATHRS27_PHY
+                        *duplex = athrs27_phy_is_fdx(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+			*duplex = athr_vir_phy_is_fdx(unit);
+#endif
+}
+
+static inline void ath_gmac_phy_speed(int unit, int *speed)
+{
+#ifdef CFG_ATHRS27_PHY
+			 *speed = athrs27_phy_speed(unit);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			*speed = athr_vir_phy_speed(unit);
+#endif
+
+}
+
+#endif /* _QCA_ETH_953x_PHY_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/qca-eth-955x.c u-boot_1.1//board/atheros/common/qca-eth-955x.c
--- u-boot//board/atheros/common/qca-eth-955x.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/qca-eth-955x.c	2014-02-18 01:46:24.903050987 -0800
@@ -0,0 +1,1005 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#include <atheros.h>
+#include "qca-eth-955x.h"
+#include "qca-eth-955x_phy.h"
+#define SGMII_LINK_WAR_MAX_TRY 10
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ath_gmac_unit2mac(_unit)     ath_gmac_macs[(_unit)]
+#define ath_gmac_name2mac(name)	   is_drqfn() ? ath_gmac_unit2mac(1):strcmp(name,"eth0") ? ath_gmac_unit2mac(1) : ath_gmac_unit2mac(0)
+
+int ath_gmac_miiphy_read(char *devname, uint32_t phaddr, uint8_t reg, uint16_t *data);
+int ath_gmac_miiphy_write(char *devname, uint32_t phaddr, uint8_t reg, uint16_t data);
+extern void ath_sys_frequency(uint32_t *, uint32_t *, uint32_t *);
+
+#ifndef CFG_ATH_GMAC_NMACS
+#define CFG_ATH_GMAC_NMACS	1
+#endif /* CFG_ATH_GMAC_NMACS */
+
+ath_gmac_mac_t *ath_gmac_macs[CFG_ATH_GMAC_NMACS];
+
+
+#ifdef CONFIG_VIR_PHY
+extern int athr_vir_phy_setup(int unit);
+extern int athr_vir_phy_is_up(int unit);
+extern int athr_vir_phy_is_fdx(int unit);
+extern int athr_vir_phy_speed(int unit);
+extern void athr_vir_reg_init(void);
+#endif
+
+#ifdef  CONFIG_ATHRS17_PHY
+extern void athrs17_reg_init(void);
+extern void athrs17_reg_init_wan(void);
+#endif
+
+
+#ifdef CONFIG_ATHR_8033_PHY
+extern int athrs_ar8033_reg_init(void *arg);
+extern int athrs_ar8033_phy_setup(void  *arg);
+extern int athrs_ar8033_phy_is_fdx(int ethUnit);
+extern int athrs_ar8033_phy_is_link_alive(int phyUnit);
+extern int athrs_ar8033_phy_is_up(int ethUnit);
+extern int athrs_ar8033_phy_speed(int ethUnit,int phyUnit);
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+
+#define ATH_ETH_MAC_READ_SIZE 4096
+extern unsigned long long
+ath_nand_get_cal_offset(const char *ba);
+#endif
+
+static int
+ath_gmac_send(struct eth_device *dev, volatile void *packet, int length)
+{
+	int i;
+
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
+
+	ath_gmac_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+	f->pkt_size = length;
+	f->res1 = 0;
+	f->pkt_start_addr = virt_to_phys(packet);
+
+	ath_gmac_tx_give_to_dma(f);
+	flush_cache((u32) packet, length);
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_DESC, virt_to_phys(f));
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, ATH_TXE);
+
+	for (i = 0; i < MAX_WAIT; i++) {
+		udelay(10);
+		if (!ath_gmac_tx_owned_by_dma(f))
+			break;
+	}
+	if (i == MAX_WAIT)
+		printf("Tx Timed out\n");
+
+	f->pkt_start_addr = 0;
+	f->pkt_size = 0;
+
+	if (++mac->next_tx >= NO_OF_TX_FIFOS)
+		mac->next_tx = 0;
+
+	return (0);
+}
+
+static int ath_gmac_recv(struct eth_device *dev)
+{
+	int length;
+	ath_gmac_desc_t *f;
+	ath_gmac_mac_t *mac;
+    	volatile int dmaed_pkt=0;
+	int count = 0;
+
+	mac = (ath_gmac_mac_t *)dev->priv;
+
+	for (;;) {
+	     f = mac->fifo_rx[mac->next_rx];
+        if (ath_gmac_rx_owned_by_dma(f)) { 
+	 /* check if the current Descriptor is_empty is 1,But the DMAed count is not-zero 
+	    then move to desciprot where the packet is available */ 
+	   dmaed_pkt = (ath_gmac_reg_rd(mac, 0x194) >> 16);
+            if (!dmaed_pkt) {
+	        break ;
+              } else {  
+                if (f->is_empty == 1) {
+                    while ( count < NO_OF_RX_FIFOS ) {
+                        if (++mac->next_rx >= NO_OF_RX_FIFOS) {
+                            mac->next_rx = 0;
+                        }
+                        f = mac->fifo_rx[mac->next_rx];
+                        /*
+                         * Break on valid data in the desc by checking
+                         *  empty bit.
+                         */
+                        if (!f->is_empty){
+                            count = 0;
+                            break;
+                        }
+                        count++;
+                    }
+               }
+            } 
+	} 
+ 
+		length = f->pkt_size;
+
+		NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+		flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+		ath_gmac_reg_wr(mac,0x194,1);
+		ath_gmac_rx_give_to_dma(f);
+
+		if (++mac->next_rx >= NO_OF_RX_FIFOS)
+			mac->next_rx = 0;
+	}
+
+	if (!(ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL))) {
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, virt_to_phys(f));
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 1);
+	}
+
+	return (0);
+}
+
+void ath_gmac_mii_setup(ath_gmac_mac_t *mac)
+{
+	u32 mgmt_cfg_val;
+
+	ath_reg_wr(SWITCH_CLOCK_SPARE_ADDRESS, 0x520);
+
+	if ((is_s17()  && mac->mac_unit == 0) || is_drqfn()) {
+		printf("Scorpion  ----> S17 PHY *\n");
+		mgmt_cfg_val = 7;
+#ifndef ATH_RGMII_CAL
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(3)|
+					ETH_CFG_RGMII_GE0_SET(1));
+
+		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
+                			     ETH_XMII_RX_DELAY_SET(2)  |
+                			     ETH_XMII_TX_DELAY_SET(1)  |
+					     ETH_XMII_GIGE_SET(1));
+#else
+        rgmii_cal_alg()
+#endif
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+		return;
+	}
+
+	if (is_ar8033 () && mac->mac_unit == 1) {
+        	printf("Scorpion ---->8033 PHY*\n");
+
+		mgmt_cfg_val = 7;
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+		return;
+
+
+        }
+        if (is_vir_phy()) {
+        	printf("Scorpion ---->VIR PHY*\n");
+		
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(3)|
+					ETH_CFG_RGMII_GE0_SET(1));
+		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
+                			     ETH_XMII_RX_DELAY_SET(2)  |
+                			     ETH_XMII_TX_DELAY_SET(1)  |
+					     ETH_XMII_GIGE_SET(1));
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+		
+                return;
+	}
+
+
+
+}
+
+void
+athrs_sgmii_res_cal(void)
+{
+	unsigned int read_data, read_data_otp, otp_value, otp_per_val, rbias_per;
+	unsigned int read_data_spi;
+	unsigned int *address_spi = (unsigned int *)0xbffffffc;
+	unsigned int rbias_pos_or_neg, res_cal_val;
+	unsigned int sgmii_pos, sgmii_res_cal_value;
+	unsigned int reversed_sgmii_value, use_value;
+
+	ath_reg_wr(OTP_INTF2_ADDRESS, 0x7d);
+	ath_reg_wr(OTP_LDO_CONTROL_ADDRESS, 0x0);
+
+	while (ath_reg_rd(OTP_LDO_STATUS_ADDRESS) & OTP_LDO_STATUS_POWER_ON_MASK);
+
+	read_data = ath_reg_rd(OTP_MEM_0_ADDRESS + 4);
+
+	while (!(ath_reg_rd(OTP_STATUS0_ADDRESS) & OTP_STATUS0_EFUSE_READ_DATA_VALID_MASK));
+
+	read_data_otp = ath_reg_rd(OTP_STATUS1_ADDRESS);
+
+	if (read_data_otp & 0x1fff) {
+		read_data = read_data_otp;
+	} else {
+		read_data_spi = *(address_spi);
+		if ((read_data_spi & 0xffff0000) == 0x5ca10000) {
+			read_data = read_data_spi;
+		} else {
+			read_data = read_data_otp;
+		}
+	}
+
+	if (read_data & 0x00001000) {
+		otp_value = (read_data & 0xfc0) >> 6;
+	} else {
+		otp_value = read_data & 0x3f;
+	}
+
+	if (otp_value > 31) {
+		otp_per_val = 63 - otp_value;
+		rbias_pos_or_neg = 1;
+	} else {
+		otp_per_val = otp_value;
+		rbias_pos_or_neg = 0;
+	}
+
+	rbias_per = otp_per_val * 15;
+
+	if (rbias_pos_or_neg == 1) {
+		res_cal_val = (rbias_per + 34) / 21;
+		sgmii_pos = 1;
+	} else {
+		if (rbias_per > 34) {
+			res_cal_val = (rbias_per - 34) / 21;
+			sgmii_pos = 0;
+		} else {
+			res_cal_val = (34 - rbias_per) / 21;
+			sgmii_pos = 1;
+		}
+	}
+
+	if (sgmii_pos == 1) {
+		sgmii_res_cal_value = 8 + res_cal_val;
+	} else {
+		sgmii_res_cal_value = 8 - res_cal_val;
+	}
+
+	reversed_sgmii_value = 0;
+	use_value = 0x8;
+	reversed_sgmii_value = reversed_sgmii_value | ((sgmii_res_cal_value & use_value) >> 3);
+	use_value = 0x4;
+	reversed_sgmii_value = reversed_sgmii_value | ((sgmii_res_cal_value & use_value) >> 1);
+	use_value = 0x2;
+	reversed_sgmii_value = reversed_sgmii_value | ((sgmii_res_cal_value & use_value) << 1);
+	use_value = 0x1;
+	reversed_sgmii_value = reversed_sgmii_value | ((sgmii_res_cal_value & use_value) << 3);
+
+	reversed_sgmii_value &= 0xf;
+
+	printf("%s: cal value = 0x%x\n", __func__, reversed_sgmii_value);
+
+	// To Check the locking of the SGMII PLL
+
+	read_data = (ath_reg_rd(SGMII_SERDES_ADDRESS) &
+				~SGMII_SERDES_RES_CALIBRATION_MASK) |
+			SGMII_SERDES_RES_CALIBRATION_SET(reversed_sgmii_value);
+
+	ath_reg_wr(SGMII_SERDES_ADDRESS, read_data);
+
+
+	ath_reg_wr(ETH_SGMII_SERDES_ADDRESS,
+			ETH_SGMII_SERDES_EN_LOCK_DETECT_MASK |
+			ETH_SGMII_SERDES_PLL_REFCLK_SEL_MASK |
+			ETH_SGMII_SERDES_EN_PLL_MASK);
+
+	ath_reg_rmw_set(SGMII_SERDES_ADDRESS,
+			SGMII_SERDES_CDR_BW_SET(3) |
+			SGMII_SERDES_TX_DR_CTRL_SET(1) |
+			SGMII_SERDES_PLL_BW_SET(1) |
+			SGMII_SERDES_EN_SIGNAL_DETECT_SET(1) |
+			SGMII_SERDES_FIBER_SDO_SET(1) |
+			SGMII_SERDES_VCO_REG_SET(3));
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_ARESET_MASK);
+	udelay(25);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_RESET_MASK);
+
+	while (!(ath_reg_rd(SGMII_SERDES_ADDRESS) & SGMII_SERDES_LOCK_DETECT_STATUS_MASK));
+}
+
+
+static void athr_gmac_sgmii_setup()
+{
+	int status = 0, count = 0;
+
+#ifdef ATH_SGMII_FORCED_MODE
+        ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_SPEED_SEL1_SET(1) |
+                                           MR_AN_CONTROL_PHY_RESET_SET(1)  |
+                                           MR_AN_CONTROL_DUPLEX_MODE_SET(1));
+        udelay(10);
+
+        ath_reg_wr(SGMII_CONFIG_ADDRESS, SGMII_CONFIG_MODE_CTRL_SET(2)   |
+                                          SGMII_CONFIG_FORCE_SPEED_SET(1) |
+                                          SGMII_CONFIG_SPEED_SET(2));
+
+        printf ("SGMII in forced mode\n");
+#else
+
+	ath_reg_wr(SGMII_CONFIG_ADDRESS, SGMII_CONFIG_MODE_CTRL_SET(2));
+
+	ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_AN_ENABLE_SET(1)
+                                      |MR_AN_CONTROL_PHY_RESET_SET(1));
+
+	ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_AN_ENABLE_SET(1));
+#endif
+/*
+ * SGMII reset sequence suggested by systems team.
+ */
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_RX_CLK_N_RESET);
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_TX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_TX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_CLK_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_TX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_CLK_N_SET(1)
+                                    |SGMII_RESET_TX_CLK_N_SET(1));
+
+        ath_reg_rmw_clear(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
+	/*
+	 * WAR::Across resets SGMII link status goes to weird
+	 * state.
+	 * if 0xb8070058 (SGMII_DEBUG register) reads other then 0x1f or 0x10
+	 * for sure we are in bad  state.
+	 * Issue a PHY reset in MR_AN_CONTROL_ADDRESS to keep going.
+	 */
+	status = (ath_reg_rd(SGMII_DEBUG_ADDRESS) & 0xff);
+	while (!(status == 0xf || status == 0x10)) {
+
+		ath_reg_rmw_set(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
+		udelay(100);
+		ath_reg_rmw_clear(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
+		if (count++ == SGMII_LINK_WAR_MAX_TRY) {
+			printf ("Max resets limit reached exiting...\n");
+			break;
+	    	}
+		status = (ath_reg_rd(SGMII_DEBUG_ADDRESS) & 0xff);
+	}
+
+	printf("%s SGMII done\n",__func__);
+
+}
+
+static void ath_gmac_hw_start(ath_gmac_mac_t *mac)
+{
+
+
+#ifndef ATH_RGMII_CAL /* Moved after mii_setup since these registers are touched in RGMII cal code */
+	if(mac->mac_unit)
+	{
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_1000));
+	} else {
+
+
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_10_100));
+	}
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+#endif
+
+
+#ifdef ATH_RGMII_CAL
+	if(mac->mac_unit)
+	{
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_1000));
+	} else {
+
+
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_10_100));
+	}
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+#endif
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_1, 0x10ffff);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_2, 0xAAA0555);
+
+	ath_gmac_reg_rmw_set(mac, ATH_MAC_FIFO_CFG_4, 0x3ffff);
+	/*
+	 * Setting Drop CRC Errors, Pause Frames,Length Error frames
+	 * and Multi/Broad cast frames.
+	 */
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_5, 0x7eccf);
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_3, 0x1f00140);
+
+	printf(": cfg1 %#x cfg2 %#x\n", ath_gmac_reg_rd(mac, ATH_MAC_CFG1),
+			ath_gmac_reg_rd(mac, ATH_MAC_CFG2));
+
+
+}
+
+static int ath_gmac_check_link(ath_gmac_mac_t *mac)
+{
+	int link, duplex, speed;
+
+	ath_gmac_phy_link(mac->mac_unit, &link);
+	ath_gmac_phy_duplex(mac->mac_unit, &duplex);
+	ath_gmac_phy_speed(mac->mac_unit, &speed);
+
+	mac->link = link;
+
+	if(!mac->link) {
+		printf("%s link down\n",mac->dev->name);
+		return 0;
+	}
+
+	switch (speed)
+	{
+		case _1000BASET:
+			ath_gmac_set_mac_if(mac, 1);
+			ath_gmac_reg_rmw_set(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+
+			if (is_ar8033() && mac->mac_unit == 1) {
+				ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_GIGE_SET(1) |
+                                           ETH_SGMII_CLK_SEL_SET(1));
+			}
+	
+			break;
+
+		case _100BASET:
+			ath_gmac_set_mac_if(mac, 0);
+			ath_gmac_set_mac_speed(mac, 1);
+			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+
+                        if (is_ar8033() && mac->mac_unit == 1) {
+                        	ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_PHASE0_COUNT_SET(1) |
+                                           ETH_SGMII_PHASE1_COUNT_SET(1));
+			}
+
+			break;
+
+		case _10BASET:
+			ath_gmac_set_mac_if(mac, 0);
+			ath_gmac_set_mac_speed(mac, 0);
+			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+
+			if (is_ar8033() && mac->mac_unit == 1) {
+				ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_PHASE0_COUNT_SET(19) |
+                                           ETH_SGMII_PHASE1_COUNT_SET(19));
+			}
+
+			break;
+
+		default:
+			printf("Invalid speed detected\n");
+			return 0;
+	}
+
+	if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+		return 1;
+
+	mac->duplex = duplex;
+	mac->speed = speed;
+
+	printf("dup %d speed %d\n", duplex, speed);
+
+	ath_gmac_set_mac_duplex(mac,duplex);
+
+	return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ath_gmac_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+	int i;
+	ath_gmac_desc_t *fr;
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t*)dev->priv;
+
+	if (!ath_gmac_check_link(mac))
+		return 0;
+
+	mac->next_rx = 0;
+
+        ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00); 
+        ath_gmac_reg_wr(mac, ATH_MAC_CFG1, (ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+
+	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+		fr = mac->fifo_rx[i];
+		fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+		flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+		ath_gmac_rx_give_to_dma(fr);
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, ATH_RXE);	/* rx start */
+	udelay(1000 * 1000);
+
+
+	return 1;
+
+}
+
+static int ath_gmac_alloc_fifo(int ndesc, ath_gmac_desc_t ** fifo)
+{
+	int i;
+	u32 size;
+	uchar *p = NULL;
+
+	size = sizeof(ath_gmac_desc_t) * ndesc;
+	size += CFG_CACHELINE_SIZE - 1;
+
+	if ((p = malloc(size)) == NULL) {
+		printf("Cant allocate fifos\n");
+		return -1;
+	}
+
+	p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+			~(CFG_CACHELINE_SIZE - 1));
+	p = UNCACHED_SDRAM(p);
+
+	for (i = 0; i < ndesc; i++)
+		fifo[i] = (ath_gmac_desc_t *) p + i;
+
+	return 0;
+}
+
+static int ath_gmac_setup_fifos(ath_gmac_mac_t *mac)
+{
+	int i;
+
+	if (ath_gmac_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+		return 1;
+
+	for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+		mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+			virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+		ath_gmac_tx_own(mac->fifo_tx[i]);
+	}
+
+	if (ath_gmac_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+		return 1;
+
+	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+		mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+			virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+	}
+
+	return (1);
+}
+
+static void ath_gmac_halt(struct eth_device *dev)
+{
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
+        ath_gmac_reg_rmw_clear(mac, ATH_MAC_CFG1,(ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+        ath_gmac_reg_wr(mac,ATH_MAC_FIFO_CFG_0,0x1f1f);
+	ath_gmac_reg_wr(mac,ATH_DMA_RX_CTRL, 0);
+	while (ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL));
+}
+
+#ifdef CONFIG_ATH_NAND_BR
+
+unsigned char *
+ath_eth_mac_addr(unsigned char *sectorBuff)
+{
+	ulong   off, size;
+	nand_info_t *nand;
+	unsigned char ret;
+
+	/*
+	 * caldata partition is of 128k
+	 */
+	nand = &nand_info[nand_curr_device];
+	size = ATH_ETH_MAC_READ_SIZE; /* To read 4k setting size as 4k */
+
+	/*
+	 * Get the Offset of Caldata partition
+	 */
+	off = ath_nand_get_cal_offset(getenv("bootargs"));
+	if(off == ATH_CAL_OFF_INVAL) {
+		printf("Invalid CAL offset \n");
+		return NULL;
+	}
+	/*
+	 * Get the values from flash, and program into the MAC address
+	 * registers
+	 */
+	ret = nand_read(nand, (loff_t)off, &size, (u_char *)sectorBuff);
+	printf(" %d bytes %s: %s\n", size,
+			"read", ret ? "ERROR" : "OK");
+	if(ret != 0 ) {
+		return NULL;
+	}
+
+	return sectorBuff;
+}
+
+#else  /* CONFIG_ATH_NAND_BR */
+
+unsigned char *
+ath_gmac_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+	/*
+	 ** BOARDCAL environmental variable has the address of the cal sector
+	 */
+
+	return ((unsigned char *)BOARDCAL);
+
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+			(KSEG1ADDR(ATH_SPI_BASE) + (4 * 1024) +
+			 flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+#endif  /* CONFIG_ATH_NAND_BR */
+
+static void ath_gmac_get_ethaddr(struct eth_device *dev)
+{
+	unsigned char *eeprom;
+	unsigned char *mac = dev->enetaddr;
+#ifndef CONFIG_ATH_EMULATION
+
+#ifdef CONFIG_ATH_NAND_BR
+	unsigned char sectorBuff[ATH_ETH_MAC_READ_SIZE];
+
+	eeprom = ath_eth_mac_addr(sectorBuff);
+	if(eeprom == NULL) {
+		/* mac address will be set to default mac address */
+		mac[0] = 0xff;
+	}
+	else {
+#else  /* CONFIG_ATH_NAND_BR */
+		eeprom = ath_gmac_mac_addr_loc();
+#endif  /* CONFIG_ATH_NAND_BR */
+
+		if (strcmp(dev->name, "eth0") == 0) {
+			memcpy(mac, eeprom, 6);
+		} else if (strcmp(dev->name, "eth1") == 0) {
+			eeprom += 6;
+			memcpy(mac, eeprom, 6);
+		} else {
+			printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+			return;
+		}
+#ifdef CONFIG_ATH_NAND_BR
+	}
+#endif  /* CONFIG_ATH_NAND_BR */
+	/* Use fixed address if the above address is invalid */
+	if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff))
+#else
+	if (1)
+#endif
+	{
+			mac[0] = 0x00;
+			mac[1] = 0x03;
+			mac[2] = 0x7f;
+			mac[3] = 0x09;
+			mac[4] = 0x0b;
+			mac[5] = 0xad;
+			printf("No valid address in Flash. Using fixed address\n");
+		} else {
+			printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+		}
+}
+
+void
+athr_mgmt_init(void)
+{
+
+#ifdef CONFIG_MGMT_INIT
+	uint32_t rddata;
+
+	rddata = ath_reg_rd(GPIO_IN_ENABLE3_ADDRESS)&
+		~GPIO_IN_ENABLE3_MII_GE1_MDI_MASK;
+	rddata |= GPIO_IN_ENABLE3_MII_GE1_MDI_SET(19);
+	ath_reg_wr(GPIO_IN_ENABLE3_ADDRESS, rddata);
+
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 19));
+
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 17));
+
+
+	rddata = ath_reg_rd(GPIO_OUT_FUNCTION4_ADDRESS) &
+		~ (GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK |
+		GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK);
+
+	rddata |= GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(0x20) |
+	GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(0x21);
+
+	ath_reg_wr(GPIO_OUT_FUNCTION4_ADDRESS, rddata);
+#endif
+	printf ("%s ::done\n",__func__);
+}
+
+
+int ath_gmac_enet_initialize(bd_t * bis)
+{
+	struct eth_device *dev[CFG_ATH_GMAC_NMACS];
+	u32 mask, mac_h, mac_l;
+	int i;
+
+	printf("%s...\n", __func__);
+
+	athrs_sgmii_res_cal();
+
+	for (i = 0;i < CFG_ATH_GMAC_NMACS;i++) {
+
+		if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+			puts("malloc failed\n");
+			return 0;
+		}
+
+		if ((ath_gmac_macs[i] = (ath_gmac_mac_t *) malloc(sizeof (ath_gmac_mac_t))) == NULL) {
+			puts("malloc failed\n");
+			return 0;
+		}
+
+		memset(ath_gmac_macs[i], 0, sizeof(ath_gmac_macs[i]));
+		memset(dev[i], 0, sizeof(dev[i]));
+
+		sprintf(dev[i]->name, "eth%d", i);
+		ath_gmac_get_ethaddr(dev[i]);
+
+		ath_gmac_macs[i]->mac_unit = i;
+		ath_gmac_macs[i]->mac_base = i ? ATH_GE1_BASE : ATH_GE0_BASE ;
+		ath_gmac_macs[i]->dev = dev[i];
+
+		dev[i]->iobase = 0;
+		dev[i]->init = ath_gmac_clean_rx;
+		dev[i]->halt = ath_gmac_halt;
+		dev[i]->send = ath_gmac_send;
+		dev[i]->recv = ath_gmac_recv;
+		dev[i]->priv = (void *)ath_gmac_macs[i];
+	}
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	ath_reg_rmw_set(RST_RESET_ADDRESS,  RST_RESET_ETH_SGMII_ARESET_SET(1));
+	udelay(1000 * 100);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_ARESET_SET(1));
+	udelay(100);
+#endif
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_RESET_SET(1) | RST_RESET_EXTERNAL_RESET_SET(1));
+	udelay(1000 * 100);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_RESET_SET(1) | RST_RESET_EXTERNAL_RESET_SET(1));
+	udelay(1000 * 100);
+
+	for (i = 0;i < CFG_ATH_GMAC_NMACS;i++) {
+
+		ath_gmac_reg_rmw_set(ath_gmac_macs[i], ATH_MAC_CFG1, ATH_MAC_CFG1_SOFT_RST
+				| ATH_MAC_CFG1_RX_RST | ATH_MAC_CFG1_TX_RST);
+
+		if(!i) {
+			mask = (ATH_RESET_GE0_MAC | ATH_RESET_GE1_MAC);
+
+			mask = mask | ATH_RESET_GE0_MDIO | ATH_RESET_GE1_MDIO;
+
+			printf("%s: reset mask:%x \n", __func__, mask);
+
+			ath_reg_rmw_set(RST_RESET_ADDRESS, mask);
+			udelay(1000 * 100);
+
+			ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+			udelay(1000 * 100);
+
+			udelay(10 * 1000);
+		}
+#if defined(CONFIG_MGMT_INIT) && defined (CONFIG_ATHR_SWITCH_ONLY_MODE) || defined ATH_MDC_GPIO
+		if (!i)
+			athr_mgmt_init();
+
+		if (ath_gmac_macs[i]->mac_unit == 0)
+                        continue;
+#endif
+		eth_register(dev[i]);
+#if(CONFIG_COMMANDS & CFG_CMD_MII)
+		miiphy_register(dev[i]->name, ath_gmac_miiphy_read, ath_gmac_miiphy_write);
+#endif
+		ath_gmac_mii_setup(ath_gmac_macs[i]);
+
+		/* if using header for register configuration, we have to     */
+		/* configure s26 register after frame transmission is enabled */
+
+		if (ath_gmac_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef  CONFIG_ATHRS17_PHY
+			athrs17_reg_init();
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			printf("VIRPhy reg init \n");
+			athr_vir_reg_init();
+#endif
+
+		} else {
+#ifdef CONFIG_ATHR_8033_PHY
+			printf("AR8033 PHY init \n");
+			athrs_ar8033_reg_init(NULL);
+
+#endif
+
+#if defined(CONFIG_MGMT_INIT) && defined (CONFIG_ATHR_SWITCH_ONLY_MODE)
+			athrs17_reg_init();
+#elif defined (CONFIG_ATHRS17_PHY) && !defined(CFG_DUAL_PHY_SUPPORT)
+			athrs17_reg_init_wan();
+#endif
+		}
+#ifdef CONFIG_ATHRS_GMAC_SGMII
+	/*
+         * MAC unit 1 or drqfn package call sgmii setup.
+	 */
+	if (i == 1 || is_drqfn())
+		athr_gmac_sgmii_setup();
+#endif
+		ath_gmac_hw_start(ath_gmac_macs[i]);
+		ath_gmac_setup_fifos(ath_gmac_macs[i]);
+
+
+
+		udelay(100 * 1000);
+
+		{
+			unsigned char *mac = dev[i]->enetaddr;
+
+			printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+					mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+					mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+		}
+		mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+		mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+			(dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+		ath_gmac_reg_wr(ath_gmac_macs[i], ATH_GE_MAC_ADDR1, mac_l);
+		ath_gmac_reg_wr(ath_gmac_macs[i], ATH_GE_MAC_ADDR2, mac_h);
+
+
+	ath_gmac_phy_setup(ath_gmac_macs[i]->mac_unit);
+		printf("%s up\n",dev[i]->name);
+	}
+
+
+	return 1;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+int
+ath_gmac_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t *data)
+{
+	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
+	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg, val;
+	volatile int           rddata;
+	uint16_t      ii = 0xFFFF;
+
+
+
+
+	/*
+	 * Check for previous transactions are complete. Added to avoid
+	 * race condition while running at higher frequencies.
+	 */
+	do
+	{
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	}while(rddata && --ii);
+
+	if (ii == 0)
+		printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_ADDRESS, addr);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, ATH_MGMT_CMD_READ);
+
+	do
+	{
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	}while(rddata && --ii);
+
+	if(ii==0)
+		printf("Error!!! Leave ath_gmac_miiphy_read without polling correct status!\n");
+
+	val = ath_gmac_reg_rd(mac, ATH_MII_MGMT_STATUS);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
+
+        if (data != NULL)
+	    *data = val; 
+	return val;
+}
+
+int
+ath_gmac_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
+	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg;
+	volatile int rddata;
+	uint16_t      ii = 0xFFFF;
+
+
+	/*
+	 * Check for previous transactions are complete. Added to avoid
+	 * race condition while running at higher frequencies.
+	 */
+	do {
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	} while (rddata && --ii);
+
+	if (ii == 0)
+		printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_ADDRESS, addr);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CTRL, data);
+
+	do {
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	} while (rddata && --ii);
+
+	if (ii == 0)
+		printf("Error!!! Leave ath_gmac_miiphy_write without polling correct status!\n");
+	return 0; 
+}
+#endif		/* CONFIG_COMMANDS & CFG_CMD_MII */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/qca-eth-955x.h u-boot_1.1//board/atheros/common/qca-eth-955x.h
--- u-boot//board/atheros/common/qca-eth-955x.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/qca-eth-955x.h	2014-02-18 01:46:24.903050987 -0800
@@ -0,0 +1,429 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _AGxxxx_H
+#define _AGxxxx_H
+
+#include <linux/types.h>
+
+#ifdef ATH_RGMII_CAL
+#define rgmii_cal_alg()    rgmii_calib(mac);
+#else
+#define rgmii_cal_alg()    
+#endif
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+	uint32_t	pkt_start_addr,
+			is_empty	:  1,
+			res1		: 10,
+			ftpp_override	:  5,
+			res2		:  4,
+			pkt_size	: 12,
+			next_desc;
+} ath_gmac_desc_t;
+
+#define NO_OF_TX_FIFOS			8
+#define NO_OF_RX_FIFOS			8
+
+typedef struct {
+	ath_gmac_desc_t		*fifo_tx[NO_OF_TX_FIFOS],
+				*fifo_rx[NO_OF_RX_FIFOS];
+	struct eth_device	*dev;
+	uint32_t		next_tx,
+				next_rx,
+				link,
+				duplex,
+				speed,
+				mac_unit,
+				mac_base;
+} ath_gmac_mac_t;
+
+#define ath_gmac_reg_wr(_mac, _x, _y)	ath_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ath_gmac_reg_rd(_mac, _x)	ath_reg_rd(((_x) + _mac->mac_base))
+
+#define ath_gmac_reg_rmw_set(_mac, _x, _y)	\
+	ath_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ath_gmac_reg_rmw_clear(_mac, _x, _y)	\
+	ath_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+#ifdef COMPRESSED_UBOOT
+#define _1000BASET		1000
+#define _100BASET		100
+#define _10BASET		10
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+#define mii_reg(_mac)	(ATH_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)	(((_mac)->mac_unit == 0) ? mii0_if : mii1_if)
+
+#define ath_gmac_set_mii_ctrl_speed(_mac, _spd)	do {	\
+	ath_reg_rmw_clear(mii_reg(_mac), (3 << 4));	\
+	ath_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));	\
+} while (0)
+
+#if defined (CFG_MII0_GMII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_MII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_RGMII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_RMII)
+#	define ath_gmac_get_mii_if()	0
+#endif
+
+#define MAX_WAIT			1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define ATH_MAC_CFG1			0x00
+#define ATH_MAC_CFG2			0x04
+#define ATH_MAC_IFCTL			0x38
+
+/*
+ * fifo control registers
+ */
+#define ATH_MAC_FIFO_CFG_0		0x48
+#define ATH_MAC_FIFO_CFG_1		0x4c
+#define ATH_MAC_FIFO_CFG_2		0x50
+#define ATH_MAC_FIFO_CFG_3		0x54
+#define ATH_MAC_FIFO_CFG_4		0x58
+
+#define ATH_MAC_FIFO_CFG_5		0x5c
+#define ATH_BYTE_PER_CLK_EN		(1 << 19)
+
+#define ATH_MAC_FIFO_RAM_0		0x60
+#define ATH_MAC_FIFO_RAM_1		0x64
+#define ATH_MAC_FIFO_RAM_2		0x68
+#define ATH_MAC_FIFO_RAM_3		0x6c
+#define ATH_MAC_FIFO_RAM_4		0x70
+#define ATH_MAC_FIFO_RAM_5		0x74
+#define ATH_MAC_FIFO_RAM_6		0x78
+#define ATH_MAC_FIFO_RAM_7		0x7c
+
+/*
+ * fields
+ */
+#define ATH_MAC_CFG1_SOFT_RST		(1 << 31)
+#define ATH_MAC_CFG1_RX_RST		(1 << 19)
+#define ATH_MAC_CFG1_TX_RST		(1 << 18)
+#define ATH_MAC_CFG1_LOOPBACK		(1 << 8)
+#define ATH_MAC_CFG1_RX_EN		(1 << 2)
+#define ATH_MAC_CFG1_TX_EN		(1 << 0)
+
+#define ATH_MAC_CFG2_FDX		(1 << 0)
+#define ATH_MAC_CFG2_PAD_CRC_EN		(1 << 2)
+#define ATH_MAC_CFG2_LEN_CHECK		(1 << 4)
+#define ATH_MAC_CFG2_HUGE_FRAME_EN	(1 << 5)
+#define ATH_MAC_CFG2_IF_1000		(1 << 9)
+#define ATH_MAC_CFG2_IF_10_100		(1 << 8)
+
+#define ATH_MAC_IFCTL_SPEED		(1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define ATH_DMA_TX_CTRL			0x180
+#define ATH_DMA_TX_DESC			0x184
+#define ATH_DMA_TX_STATUS		0x188
+#define ATH_DMA_RX_CTRL			0x18c
+#define ATH_DMA_RX_DESC			0x190
+#define ATH_DMA_RX_STATUS		0x194
+#define ATH_DMA_INTR_MASK		0x198
+#define ATH_DMA_INTR			0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define ATH_TXE				(1 << 0)
+#define ATH_TX_STATUS_PKTCNT_SHIFT	16
+#define ATH_TX_STATUS_PKT_SENT		0x1
+#define ATH_TX_STATUS_URN		0x2
+#define ATH_TX_STATUS_BUS_ERROR		0x8
+
+#define ATH_RXE				(1 << 0)
+
+#define ATH_RX_STATUS_PKTCNT_MASK	0xff0000
+#define ATH_RX_STATUS_PKT_RCVD		(1 << 0)
+#define ATH_RX_STATUS_OVF		(1 << 2)
+#define ATH_RX_STATUS_BUS_ERROR		(1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define ATH_INTR_TX			(1 << 0)
+#define ATH_INTR_TX_URN			(1 << 1)
+#define ATH_INTR_TX_BUS_ERROR		(1 << 3)
+#define ATH_INTR_RX			(1 << 4)
+#define ATH_INTR_RX_OVF			(1 << 6)
+#define ATH_INTR_RX_BUS_ERROR		(1 << 7)
+
+/*
+ * MII registers
+ */
+#define ATH_MAC_MII_MGMT_CFG		0x20
+#define ATH_MGMT_CFG_CLK_DIV_20		0x07
+
+#define ATH_MII_MGMT_CMD		0x24
+#define ATH_MGMT_CMD_READ		0x1
+
+#define ATH_MII_MGMT_ADDRESS		0x28
+#define ATH_ADDR_SHIFT			8
+
+#define ATH_MII_MGMT_CTRL		0x2c
+#define ATH_MII_MGMT_STATUS		0x30
+
+#define ATH_MII_MGMT_IND		0x34
+#define ATH_MGMT_IND_BUSY		(1 << 0)
+#define ATH_MGMT_IND_INVALID		(1 << 2)
+
+#define ATH_GE_MAC_ADDR1		0x40
+#define ATH_GE_MAC_ADDR2		0x44
+
+/*
+ * Ethernet config registers
+ */
+#define ATH_ETH_CFG			0x18070000
+#define ATH_ETH_CFG_RGMII_GE0		(1<<0)
+#define ATH_ETH_CFG_MII_GE0		(1<<1)
+#define ATH_ETH_CFG_GMII_GE0		(1<<2)
+#define ATH_ETH_CFG_RMII_GE0		(1<<10)
+#define ATH_ETH_CFG_RMII_HISPD_GE0	(1<<11)
+#define ATH_ETH_CFG_RMII_MASTER_MODE	(1<<12)
+#define ATH_ETH_CFG_MII_GE0_MASTER	(1<<3)
+#define ATH_ETH_CFG_MII_GE0_SLAVE	(1<<4)
+#define ATH_ETH_CFG_GE0_ERR_EN		(1<<5)
+#define ATH_ETH_CFG_SW_ONLY_MODE	(1<<6)
+#define ATH_ETH_CFG_SW_PHY_SWAP		(1<<7)
+#define ATH_ETH_CFG_SW_PHY_ADDR_SWAP	(1<<8)
+#define ATH_ETH_CFG_RXD_DELAY		(1 << 14)
+#define ATH_ETH_CFG_RDV_DELAY		(1 << 16)
+#define ATH_ETH_SWITCH_CLK_SPARE	0x18050024
+
+#define ETH_XMII_TX_INVERT_MSB                                       31
+#define ETH_XMII_TX_INVERT_LSB                                       31
+#define ETH_XMII_TX_INVERT_MASK                                      0x80000000
+#define ETH_XMII_TX_INVERT_GET(x)                                    (((x) & ETH_XMII_TX_INVERT_MASK) >> ETH_XMII_TX_INVERT_LSB)
+#define ETH_XMII_TX_INVERT_SET(x)                                    (((x) << ETH_XMII_TX_INVERT_LSB) & ETH_XMII_TX_INVERT_MASK)
+#define ETH_XMII_TX_INVERT_RESET                                     0x0 // 0
+#define ETH_XMII_GIGE_QUAD_MSB                                       30
+#define ETH_XMII_GIGE_QUAD_LSB                                       30
+#define ETH_XMII_GIGE_QUAD_MASK                                      0x40000000
+#define ETH_XMII_GIGE_QUAD_GET(x)                                    (((x) & ETH_XMII_GIGE_QUAD_MASK) >> ETH_XMII_GIGE_QUAD_LSB)
+#define ETH_XMII_GIGE_QUAD_SET(x)                                    (((x) << ETH_XMII_GIGE_QUAD_LSB) & ETH_XMII_GIGE_QUAD_MASK)
+#define ETH_XMII_GIGE_QUAD_RESET                                     0x0 // 0
+#define ETH_XMII_RX_DELAY_MSB                                        29
+#define ETH_XMII_RX_DELAY_LSB                                        28
+#define ETH_XMII_RX_DELAY_MASK                                       0x30000000
+#define ETH_XMII_RX_DELAY_GET(x)                                     (((x) & ETH_XMII_RX_DELAY_MASK) >> ETH_XMII_RX_DELAY_LSB)
+#define ETH_XMII_RX_DELAY_SET(x)                                     (((x) << ETH_XMII_RX_DELAY_LSB) & ETH_XMII_RX_DELAY_MASK)
+#define ETH_XMII_RX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_TX_DELAY_MSB                                        27
+#define ETH_XMII_TX_DELAY_LSB                                        26
+#define ETH_XMII_TX_DELAY_MASK                                       0x0c000000
+#define ETH_XMII_TX_DELAY_GET(x)                                     (((x) & ETH_XMII_TX_DELAY_MASK) >> ETH_XMII_TX_DELAY_LSB)
+#define ETH_XMII_TX_DELAY_SET(x)                                     (((x) << ETH_XMII_TX_DELAY_LSB) & ETH_XMII_TX_DELAY_MASK)
+#define ETH_XMII_TX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_GIGE_MSB                                            25
+#define ETH_XMII_GIGE_LSB                                            25
+#define ETH_XMII_GIGE_MASK                                           0x02000000
+#define ETH_XMII_GIGE_GET(x)                                         (((x) & ETH_XMII_GIGE_MASK) >> ETH_XMII_GIGE_LSB)
+#define ETH_XMII_GIGE_SET(x)                                         (((x) << ETH_XMII_GIGE_LSB) & ETH_XMII_GIGE_MASK)
+#define ETH_XMII_GIGE_RESET                                          0x0 // 0
+#define ETH_XMII_OFFSET_PHASE_MSB                                    24
+#define ETH_XMII_OFFSET_PHASE_LSB                                    24
+#define ETH_XMII_OFFSET_PHASE_MASK                                   0x01000000
+#define ETH_XMII_OFFSET_PHASE_GET(x)                                 (((x) & ETH_XMII_OFFSET_PHASE_MASK) >> ETH_XMII_OFFSET_PHASE_LSB)
+#define ETH_XMII_OFFSET_PHASE_SET(x)                                 (((x) << ETH_XMII_OFFSET_PHASE_LSB) & ETH_XMII_OFFSET_PHASE_MASK)
+#define ETH_XMII_OFFSET_PHASE_RESET                                  0x0 // 0
+#define ETH_XMII_OFFSET_COUNT_MSB                                    23
+#define ETH_XMII_OFFSET_COUNT_LSB                                    16
+#define ETH_XMII_OFFSET_COUNT_MASK                                   0x00ff0000
+#define ETH_XMII_OFFSET_COUNT_GET(x)                                 (((x) & ETH_XMII_OFFSET_COUNT_MASK) >> ETH_XMII_OFFSET_COUNT_LSB)
+#define ETH_XMII_OFFSET_COUNT_SET(x)                                 (((x) << ETH_XMII_OFFSET_COUNT_LSB) & ETH_XMII_OFFSET_COUNT_MASK)
+#define ETH_XMII_OFFSET_COUNT_RESET                                  0x0 // 0
+#define ETH_XMII_PHASE1_COUNT_MSB                                    15
+#define ETH_XMII_PHASE1_COUNT_LSB                                    8
+#define ETH_XMII_PHASE1_COUNT_MASK                                   0x0000ff00
+#define ETH_XMII_PHASE1_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE1_COUNT_MASK) >> ETH_XMII_PHASE1_COUNT_LSB)
+#define ETH_XMII_PHASE1_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE1_COUNT_LSB) & ETH_XMII_PHASE1_COUNT_MASK)
+#define ETH_XMII_PHASE1_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_PHASE0_COUNT_MSB                                    7
+#define ETH_XMII_PHASE0_COUNT_LSB                                    0
+#define ETH_XMII_PHASE0_COUNT_MASK                                   0x000000ff
+#define ETH_XMII_PHASE0_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE0_COUNT_MASK) >> ETH_XMII_PHASE0_COUNT_LSB)
+#define ETH_XMII_PHASE0_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE0_COUNT_LSB) & ETH_XMII_PHASE0_COUNT_MASK)
+#define ETH_XMII_PHASE0_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_ADDRESS                                             0x18050028
+
+
+
+#define ETH_CFG_ETH_SPARE_MSB                                        31
+#define ETH_CFG_ETH_SPARE_LSB                                        22
+#define ETH_CFG_ETH_SPARE_MASK                                       0xffc00000
+#define ETH_CFG_ETH_SPARE_GET(x)                                     (((x) & ETH_CFG_ETH_SPARE_MASK) >> ETH_CFG_ETH_SPARE_LSB)
+#define ETH_CFG_ETH_SPARE_SET(x)                                     (((x) << ETH_CFG_ETH_SPARE_LSB) & ETH_CFG_ETH_SPARE_MASK)
+#define ETH_CFG_ETH_SPARE_RESET                                      0x0 // 0
+#define ETH_CFG_ETH_TXEN_DELAY_MSB                                   21
+#define ETH_CFG_ETH_TXEN_DELAY_LSB                                   20
+#define ETH_CFG_ETH_TXEN_DELAY_MASK                                  0x00300000
+#define ETH_CFG_ETH_TXEN_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_TXEN_DELAY_MASK) >> ETH_CFG_ETH_TXEN_DELAY_LSB)
+#define ETH_CFG_ETH_TXEN_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_TXEN_DELAY_LSB) & ETH_CFG_ETH_TXEN_DELAY_MASK)
+#define ETH_CFG_ETH_TXEN_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_TXD_DELAY_MSB                                    19
+#define ETH_CFG_ETH_TXD_DELAY_LSB                                    18
+#define ETH_CFG_ETH_TXD_DELAY_MASK                                   0x000c0000
+#define ETH_CFG_ETH_TXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_TXD_DELAY_MASK) >> ETH_CFG_ETH_TXD_DELAY_LSB)
+#define ETH_CFG_ETH_TXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_TXD_DELAY_LSB) & ETH_CFG_ETH_TXD_DELAY_MASK)
+#define ETH_CFG_ETH_TXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_ETH_RXDV_DELAY_MSB                                   17
+#define ETH_CFG_ETH_RXDV_DELAY_LSB                                   16
+#define ETH_CFG_ETH_RXDV_DELAY_MASK                                  0x00030000
+#define ETH_CFG_ETH_RXDV_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_RXDV_DELAY_MASK) >> ETH_CFG_ETH_RXDV_DELAY_LSB)
+#define ETH_CFG_ETH_RXDV_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_RXDV_DELAY_LSB) & ETH_CFG_ETH_RXDV_DELAY_MASK)
+#define ETH_CFG_ETH_RXDV_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_RXD_DELAY_MSB                                    15
+#define ETH_CFG_ETH_RXD_DELAY_LSB                                    14
+#define ETH_CFG_ETH_RXD_DELAY_MASK                                   0x0000c000
+#define ETH_CFG_ETH_RXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_RXD_DELAY_MASK) >> ETH_CFG_ETH_RXD_DELAY_LSB)
+#define ETH_CFG_ETH_RXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_RXD_DELAY_LSB) & ETH_CFG_ETH_RXD_DELAY_MASK)
+#define ETH_CFG_ETH_RXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_RMII_GE0_MASTER_MSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_LSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_MASK                                 0x00001000
+#define ETH_CFG_RMII_GE0_MASTER_GET(x)                               (((x) & ETH_CFG_RMII_GE0_MASTER_MASK) >> ETH_CFG_RMII_GE0_MASTER_LSB)
+#define ETH_CFG_RMII_GE0_MASTER_SET(x)                               (((x) << ETH_CFG_RMII_GE0_MASTER_LSB) & ETH_CFG_RMII_GE0_MASTER_MASK)
+#define ETH_CFG_RMII_GE0_MASTER_RESET                                0x1 // 1
+#define ETH_CFG_MII_CNTL_SPEED_MSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_LSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_MASK                                  0x00000800
+#define ETH_CFG_MII_CNTL_SPEED_GET(x)                                (((x) & ETH_CFG_MII_CNTL_SPEED_MASK) >> ETH_CFG_MII_CNTL_SPEED_LSB)
+#define ETH_CFG_MII_CNTL_SPEED_SET(x)                                (((x) << ETH_CFG_MII_CNTL_SPEED_LSB) & ETH_CFG_MII_CNTL_SPEED_MASK)
+#define ETH_CFG_MII_CNTL_SPEED_RESET                                 0x0 // 0
+#define ETH_CFG_RMII_GE0_MSB                                         10
+#define ETH_CFG_RMII_GE0_LSB                                         10
+#define ETH_CFG_RMII_GE0_MASK                                        0x00000400
+#define ETH_CFG_RMII_GE0_GET(x)                                      (((x) & ETH_CFG_RMII_GE0_MASK) >> ETH_CFG_RMII_GE0_LSB)
+#define ETH_CFG_RMII_GE0_SET(x)                                      (((x) << ETH_CFG_RMII_GE0_LSB) & ETH_CFG_RMII_GE0_MASK)
+#define ETH_CFG_RMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_GE0_SGMII_MSB                                        6
+#define ETH_CFG_GE0_SGMII_LSB                                        6
+#define ETH_CFG_GE0_SGMII_MASK                                       0x00000040
+#define ETH_CFG_GE0_SGMII_GET(x)                                     (((x) & ETH_CFG_GE0_SGMII_MASK) >> ETH_CFG_GE0_SGMII_LSB)
+#define ETH_CFG_GE0_SGMII_SET(x)                                     (((x) << ETH_CFG_GE0_SGMII_LSB) & ETH_CFG_GE0_SGMII_MASK)
+#define ETH_CFG_GE0_SGMII_RESET                                      0x0 // 0
+#define ETH_CFG_GE0_ERR_EN_MSB                                       5
+#define ETH_CFG_GE0_ERR_EN_LSB                                       5
+#define ETH_CFG_GE0_ERR_EN_MASK                                      0x00000020
+#define ETH_CFG_GE0_ERR_EN_GET(x)                                    (((x) & ETH_CFG_GE0_ERR_EN_MASK) >> ETH_CFG_GE0_ERR_EN_LSB)
+#define ETH_CFG_GE0_ERR_EN_SET(x)                                    (((x) << ETH_CFG_GE0_ERR_EN_LSB) & ETH_CFG_GE0_ERR_EN_MASK)
+#define ETH_CFG_GE0_ERR_EN_RESET                                     0x0 // 0
+#define ETH_CFG_MII_GE0_SLAVE_MSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_LSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_MASK                                   0x00000010
+#define ETH_CFG_MII_GE0_SLAVE_GET(x)                                 (((x) & ETH_CFG_MII_GE0_SLAVE_MASK) >> ETH_CFG_MII_GE0_SLAVE_LSB)
+#define ETH_CFG_MII_GE0_SLAVE_SET(x)                                 (((x) << ETH_CFG_MII_GE0_SLAVE_LSB) & ETH_CFG_MII_GE0_SLAVE_MASK)
+#define ETH_CFG_MII_GE0_SLAVE_RESET                                  0x0 // 0
+#define ETH_CFG_MII_GE0_MASTER_MSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_LSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_MASK                                  0x00000008
+#define ETH_CFG_MII_GE0_MASTER_GET(x)                                (((x) & ETH_CFG_MII_GE0_MASTER_MASK) >> ETH_CFG_MII_GE0_MASTER_LSB)
+#define ETH_CFG_MII_GE0_MASTER_SET(x)                                (((x) << ETH_CFG_MII_GE0_MASTER_LSB) & ETH_CFG_MII_GE0_MASTER_MASK)
+#define ETH_CFG_MII_GE0_MASTER_RESET                                 0x0 // 0
+#define ETH_CFG_GMII_GE0_MSB                                         2
+#define ETH_CFG_GMII_GE0_LSB                                         2
+#define ETH_CFG_GMII_GE0_MASK                                        0x00000004
+#define ETH_CFG_GMII_GE0_GET(x)                                      (((x) & ETH_CFG_GMII_GE0_MASK) >> ETH_CFG_GMII_GE0_LSB)
+#define ETH_CFG_GMII_GE0_SET(x)                                      (((x) << ETH_CFG_GMII_GE0_LSB) & ETH_CFG_GMII_GE0_MASK)
+#define ETH_CFG_GMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_MII_GE0_MSB                                          1
+#define ETH_CFG_MII_GE0_LSB                                          1
+#define ETH_CFG_MII_GE0_MASK                                         0x00000002
+#define ETH_CFG_MII_GE0_GET(x)                                       (((x) & ETH_CFG_MII_GE0_MASK) >> ETH_CFG_MII_GE0_LSB)
+#define ETH_CFG_MII_GE0_SET(x)                                       (((x) << ETH_CFG_MII_GE0_LSB) & ETH_CFG_MII_GE0_MASK)
+#define ETH_CFG_MII_GE0_RESET                                        0x0 // 0
+#define ETH_CFG_RGMII_GE0_MSB                                        0
+#define ETH_CFG_RGMII_GE0_LSB                                        0
+#define ETH_CFG_RGMII_GE0_MASK                                       0x00000001
+#define ETH_CFG_RGMII_GE0_GET(x)                                     (((x) & ETH_CFG_RGMII_GE0_MASK) >> ETH_CFG_RGMII_GE0_LSB)
+#define ETH_CFG_RGMII_GE0_SET(x)                                     (((x) << ETH_CFG_RGMII_GE0_LSB) & ETH_CFG_RGMII_GE0_MASK)
+#define ETH_CFG_RGMII_GE0_RESET                                      0x0 // 0
+#define ETH_CFG_ADDRESS                                              0x18070000
+
+
+
+
+/*
+ * ownership of descriptors between DMA and cpu
+ */
+#define ath_gmac_rx_owned_by_dma(_ds)	((_ds)->is_empty == 1)
+#define ath_gmac_rx_give_to_dma(_ds)	((_ds)->is_empty = 1)
+#define ath_gmac_tx_owned_by_dma(_ds)	((_ds)->is_empty == 0)
+#define ath_gmac_tx_give_to_dma(_ds)	((_ds)->is_empty = 0)
+#define ath_gmac_tx_own(_ds)		((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ath_gmac_set_mac_duplex(_mac, _fdx)	do {	\
+	if ((_fdx)) {					\
+		ath_gmac_reg_rmw_set(_mac,		\
+			ATH_MAC_CFG2, ATH_MAC_CFG2_FDX);\
+	} else {					\
+		ath_gmac_reg_rmw_clear(_mac,		\
+			ATH_MAC_CFG2, ATH_MAC_CFG2_FDX);\
+	}						\
+} while (0)
+
+#define ath_gmac_set_mac_if(_mac, _isXGMII)	do {		\
+	ath_gmac_reg_rmw_clear(_mac, ATH_MAC_CFG2,		\
+				ATH_MAC_CFG2_IF_1000 |		\
+				ATH_MAC_CFG2_IF_10_100);	\
+	if ((_isXGMII)) {					\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_CFG2,	\
+				ATH_MAC_CFG2_IF_1000);		\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_FIFO_CFG_5,	\
+				ATH_BYTE_PER_CLK_EN);		\
+	} else {						\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_CFG2,	\
+				ATH_MAC_CFG2_IF_10_100);	\
+		ath_gmac_reg_rmw_clear(_mac, ATH_MAC_FIFO_CFG_5,\
+				ATH_BYTE_PER_CLK_EN);		\
+	}							\
+} while (0)
+
+#define ath_gmac_set_mac_speed(_mac, _is100)	do {		\
+	if ((_is100)) {						\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_IFCTL,	\
+					ATH_MAC_IFCTL_SPEED);	\
+	} else {						\
+		ath_gmac_reg_rmw_clear(_mac, ATH_MAC_IFCTL,	\
+					ATH_MAC_IFCTL_SPEED);	\
+	}							\
+} while (0)
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/qca-eth-955x_phy.h u-boot_1.1//board/atheros/common/qca-eth-955x_phy.h
--- u-boot//board/atheros/common/qca-eth-955x_phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/qca-eth-955x_phy.h	2014-02-18 01:46:24.903050987 -0800
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _QCA_ETH_955x_PHY_H
+#define _QCA_ETH_955x_PHY_H
+#include <miiphy.h>
+
+
+#ifdef CONFIG_ATHR_8033_PHY
+extern int athrs_ar8033_reg_init(void *arg);
+extern int athrs_ar8033_phy_setup(void  *arg);
+extern int athrs_ar8033_phy_is_fdx(int ethUnit);
+extern int athrs_ar8033_phy_is_link_alive(int phyUnit);
+extern int athrs_ar8033_phy_is_up(int ethUnit);
+extern int athrs_ar8033_phy_speed(int ethUnit,int phyUnit);
+#endif
+
+#ifdef CONFIG_ATHRS17_PHY
+extern int athrs17_phy_setup(int ethUnit);
+extern int athrs17_phy_is_up(int ethUnit);
+extern int athrs17_phy_is_fdx(int ethUnit);
+extern int athrs17_phy_speed(int ethUnit);
+#endif
+
+static inline void ath_gmac_phy_setup(int unit)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			athrs17_phy_setup(unit);
+		} else
+#endif
+		{
+#ifdef CONFIG_VIR_PHY
+			athr_vir_phy_setup(unit);
+#endif
+#if defined(CONFIG_ATHRS17_PHY) && !defined (CFG_DUAL_PHY_SUPPORT)
+			athrs17_phy_setup(unit);
+#endif
+
+		}
+}
+
+static inline void ath_gmac_phy_link(int unit, int *link)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			*link = athrs17_phy_is_up(unit);
+		} else
+#endif
+		{
+#ifdef CONFIG_VIR_PHY
+			*link = athr_vir_phy_is_up(unit);
+#endif
+#ifdef CONFIG_ATHR_8033_PHY
+			*link = athrs_ar8033_phy_is_up(unit);
+#endif
+#if defined(CONFIG_ATHRS17_PHY) && !defined (CFG_DUAL_PHY_SUPPORT)
+			*link = athrs17_phy_is_up(unit);
+#endif
+
+		}
+}
+
+static inline void ath_gmac_phy_duplex(int unit, int *duplex)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			*duplex = athrs17_phy_is_fdx(unit);
+		} else
+#endif
+		{
+#ifdef CONFIG_VIR_PHY
+			*duplex = athr_vir_phy_is_fdx(unit);
+#endif
+#ifdef CONFIG_ATHR_8033_PHY
+			*duplex = athrs_ar8033_phy_is_fdx(unit);
+#endif
+#if defined(CONFIG_ATHRS17_PHY) && !defined(CFG_DUAL_PHY_SUPPORT)
+			*duplex = athrs17_phy_is_fdx(unit);
+#endif
+		}
+}
+
+static inline void ath_gmac_phy_speed(int unit, int *speed)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			*speed = _1000BASET;
+		} else
+#endif
+		{
+#ifdef CONFIG_VIR_PHY
+			*speed = athr_vir_phy_speed(unit);
+#endif
+#ifdef CONFIG_ATHR_8033_PHY
+			*speed = athrs_ar8033_phy_speed(unit, 5);
+#endif
+
+#if defined(CONFIG_ATHRS17_PHY) && !defined (CFG_DUAL_PHY_SUPPORT)
+			*speed = _1000BASET;
+#endif
+		}
+}
+
+#endif /* _QCA_ETH_955x_PHY_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/qca-eth-956x.c u-boot_1.1//board/atheros/common/qca-eth-956x.c
--- u-boot//board/atheros/common/qca-eth-956x.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/qca-eth-956x.c	2014-02-18 01:46:24.911050993 -0800
@@ -0,0 +1,1016 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#include <atheros.h>
+#include "qca-eth-956x.h"
+#include "qca-eth-956x_phy.h"
+#define SGMII_LINK_WAR_MAX_TRY 10
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ath_gmac_unit2mac(_unit)     ath_gmac_macs[(_unit)]
+#define ath_gmac_name2mac(name)	   is_drqfn() ? ath_gmac_unit2mac(1):strcmp(name,"eth0") ? ath_gmac_unit2mac(1) : ath_gmac_unit2mac(0)
+
+int ath_gmac_miiphy_read(char *devname, uint32_t phaddr, uint8_t reg, uint16_t *data);
+int ath_gmac_miiphy_write(char *devname, uint32_t phaddr, uint8_t reg, uint16_t data);
+extern void ath_sys_frequency(uint32_t *, uint32_t *, uint32_t *);
+
+#ifndef CFG_ATH_GMAC_NMACS
+#define CFG_ATH_GMAC_NMACS	1
+#endif /* CFG_ATH_GMAC_NMACS */
+
+ath_gmac_mac_t *ath_gmac_macs[CFG_ATH_GMAC_NMACS];
+
+
+#ifdef CONFIG_VIR_PHY
+extern int athr_vir_phy_setup(int unit);
+extern int athr_vir_phy_is_up(int unit);
+extern int athr_vir_phy_is_fdx(int unit);
+extern int athr_vir_phy_speed(int unit);
+extern void athr_vir_reg_init(void);
+#endif
+
+#ifdef  CONFIG_ATHRS17_PHY
+extern void athrs17_reg_init(void);
+extern void athrs17_reg_init_wan(void);
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+extern void athrs27_reg_init();
+extern void athrs27_reg_init_lan();
+#endif
+
+
+#ifdef CONFIG_ATH_NAND_BR
+
+#define ATH_ETH_MAC_READ_SIZE 4096
+extern unsigned long long
+ath_nand_get_cal_offset(const char *ba);
+#endif
+
+static int
+ath_gmac_send(struct eth_device *dev, volatile void *packet, int length)
+{
+	int i;
+
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
+
+	ath_gmac_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+	f->pkt_size = length;
+	f->res1 = 0;
+	f->pkt_start_addr = virt_to_phys(packet);
+
+	ath_gmac_tx_give_to_dma(f);
+	flush_cache((u32) packet, length);
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_DESC, virt_to_phys(f));
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, ATH_TXE);
+
+	for (i = 0; i < MAX_WAIT; i++) {
+		udelay(10);
+		if (!ath_gmac_tx_owned_by_dma(f))
+			break;
+	}
+	if (i == MAX_WAIT)
+		printf("Tx Timed out\n");
+
+	f->pkt_start_addr = 0;
+	f->pkt_size = 0;
+
+	if (++mac->next_tx >= NO_OF_TX_FIFOS)
+		mac->next_tx = 0;
+
+	return (0);
+}
+
+static int ath_gmac_recv(struct eth_device *dev)
+{
+	int length;
+	ath_gmac_desc_t *f;
+	ath_gmac_mac_t *mac;
+    	volatile int dmaed_pkt=0;
+	int count = 0;
+
+	mac = (ath_gmac_mac_t *)dev->priv;
+
+	for (;;) {
+	     f = mac->fifo_rx[mac->next_rx];
+        if (ath_gmac_rx_owned_by_dma(f)) { 
+	 /* check if the current Descriptor is_empty is 1,But the DMAed count is not-zero 
+	    then move to desciprot where the packet is available */ 
+	   dmaed_pkt = (ath_gmac_reg_rd(mac, 0x194) >> 16);
+            if (!dmaed_pkt) {
+	        break ;
+              } else {  
+                if (f->is_empty == 1) {
+                    while ( count < NO_OF_RX_FIFOS ) {
+                        if (++mac->next_rx >= NO_OF_RX_FIFOS) {
+                            mac->next_rx = 0;
+                        }
+                        f = mac->fifo_rx[mac->next_rx];
+                        /*
+                         * Break on valid data in the desc by checking
+                         *  empty bit.
+                         */
+                        if (!f->is_empty){
+                            count = 0;
+                            break;
+                        }
+                        count++;
+                    }
+               }
+            } 
+	} 
+ 
+		length = f->pkt_size;
+
+		NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+		flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+		ath_gmac_reg_wr(mac,0x194,1);
+		ath_gmac_rx_give_to_dma(f);
+
+		if (++mac->next_rx >= NO_OF_RX_FIFOS)
+			mac->next_rx = 0;
+	}
+
+	if (!(ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL))) {
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, virt_to_phys(f));
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 1);
+	}
+
+	return (0);
+}
+
+void ath_gmac_mii_setup(ath_gmac_mac_t *mac)
+{
+	u32 mgmt_cfg_val;
+
+
+	if (RST_BOOTSTRAP_REF_CLK_GET(ath_reg_rd(RST_BOOTSTRAP_ADDRESS))) {
+		//40Mhz
+		ath_reg_wr(SWITCH_CLOCK_SPARE_ADDRESS, 0x45500);
+	} else {
+		//25Mhz
+		ath_reg_wr(SWITCH_CLOCK_SPARE_ADDRESS, 0xc5200);
+	}
+
+	if (is_s27() && (mac->mac_unit == 0)) {
+		printf("Dragonfly----> S27 PHY *\n");
+	
+		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
+						ETH_XMII_RX_DELAY_SET(2) |
+						ETH_XMII_TX_DELAY_SET(1) |
+						ETH_XMII_GIGE_SET(1));
+
+       	mgmt_cfg_val = 7;
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+		//GMAC1 need to set for MDC/MDIO Works
+		udelay(1000);
+		ath_gmac_reg_wr(ath_gmac_macs[1], ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		udelay(1000);
+		ath_gmac_reg_wr(ath_gmac_macs[1], ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+		
+		return;
+	}
+
+	if ( CFG_ATH_GMAC_NMACS == 1){
+		printf("Dragonfly  ----> S17 PHY *\n");
+		mgmt_cfg_val = 7;
+
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(3)|
+					ETH_CFG_RGMII_GE0_SET(1) |
+					ETH_CFG_GE0_SGMII_SET(1) );
+
+		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
+                			     ETH_XMII_RX_DELAY_SET(2)  |
+                			     ETH_XMII_TX_DELAY_SET(1)  |
+					     ETH_XMII_GIGE_SET(1));
+
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+		return;		
+	}
+
+}
+
+void
+athrs_sgmii_res_cal(void)
+{
+	unsigned int read_data;
+	unsigned int reversed_sgmii_value;
+	unsigned int i=0;
+	unsigned int vco_fast,vco_slow;
+	unsigned int startValue=0, endValue=0;
+
+	ath_reg_wr(ETH_SGMII_SERDES_ADDRESS,
+			ETH_SGMII_SERDES_EN_LOCK_DETECT_MASK |
+			ETH_SGMII_SERDES_EN_PLL_MASK);
+
+	read_data = ath_reg_rd(SGMII_SERDES_ADDRESS);
+
+	vco_fast = SGMII_SERDES_VCO_FAST_GET(read_data);
+	vco_slow = SGMII_SERDES_VCO_SLOW_GET(read_data);
+	/* set resistor Calibration from 0000 -> 1111 */
+	for (i=0; i < 0x10; i++)
+	{
+		read_data = (ath_reg_rd(SGMII_SERDES_ADDRESS) &
+					~SGMII_SERDES_RES_CALIBRATION_MASK) |
+				SGMII_SERDES_RES_CALIBRATION_SET(i);	
+		ath_reg_wr(SGMII_SERDES_ADDRESS, read_data);
+
+		udelay(50);
+
+		read_data = ath_reg_rd(SGMII_SERDES_ADDRESS);
+		if ((vco_fast != SGMII_SERDES_VCO_FAST_GET(read_data)) ||
+			(vco_slow != SGMII_SERDES_VCO_SLOW_GET(read_data)) ){
+			if (startValue == 0){
+				startValue=endValue=i;
+			}else{
+				endValue=i;
+			}
+		}
+		vco_fast = SGMII_SERDES_VCO_FAST_GET(read_data);
+		vco_slow = SGMII_SERDES_VCO_SLOW_GET(read_data);		
+	}
+	
+	if (startValue == 0){
+		/* No boundary found, use middle value for resistor calibration value */
+		reversed_sgmii_value = 0x7;
+	}else{
+		/* get resistor calibration from the middle of boundary */
+		reversed_sgmii_value = (startValue + endValue)/2; 
+	}
+
+	read_data = (ath_reg_rd(SGMII_SERDES_ADDRESS) &
+				~SGMII_SERDES_RES_CALIBRATION_MASK) |
+			SGMII_SERDES_RES_CALIBRATION_SET(reversed_sgmii_value);
+
+	ath_reg_wr(SGMII_SERDES_ADDRESS, read_data);
+
+
+	ath_reg_wr(ETH_SGMII_SERDES_ADDRESS,
+			ETH_SGMII_SERDES_EN_LOCK_DETECT_MASK |
+			/*ETH_SGMII_SERDES_PLL_REFCLK_SEL_MASK |*/
+			ETH_SGMII_SERDES_EN_PLL_MASK);
+
+	ath_reg_rmw_set(SGMII_SERDES_ADDRESS,
+			SGMII_SERDES_CDR_BW_SET(3) |
+			SGMII_SERDES_TX_DR_CTRL_SET(1) |
+			SGMII_SERDES_PLL_BW_SET(1) |
+			SGMII_SERDES_EN_SIGNAL_DETECT_SET(1) |
+			SGMII_SERDES_FIBER_SDO_SET(1) |
+			SGMII_SERDES_VCO_REG_SET(3));
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_ARESET_MASK);
+	udelay(25);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_RESET_MASK);
+
+	while (!(ath_reg_rd(SGMII_SERDES_ADDRESS) & SGMII_SERDES_LOCK_DETECT_STATUS_MASK));
+}
+
+
+static void athr_gmac_sgmii_setup()
+{
+	int status = 0, count = 0;
+
+#ifdef ATH_SGMII_FORCED_MODE
+        ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_SPEED_SEL1_SET(1) |
+                                           MR_AN_CONTROL_PHY_RESET_SET(1)  |
+                                           MR_AN_CONTROL_DUPLEX_MODE_SET(1));
+        udelay(10);
+
+        ath_reg_wr(SGMII_CONFIG_ADDRESS, SGMII_CONFIG_MODE_CTRL_SET(2)   |
+                                          SGMII_CONFIG_FORCE_SPEED_SET(1) |
+                                          SGMII_CONFIG_SPEED_SET(2));
+
+        printf ("SGMII in forced mode\n");
+#else
+
+	ath_reg_wr(SGMII_CONFIG_ADDRESS, SGMII_CONFIG_MODE_CTRL_SET(2));
+
+	ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_AN_ENABLE_SET(1)
+                                      |MR_AN_CONTROL_PHY_RESET_SET(1));
+
+	ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_AN_ENABLE_SET(1));
+#endif
+/*
+ * SGMII reset sequence suggested by systems team.
+ */
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_RX_CLK_N_RESET);
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_TX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_TX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_CLK_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_TX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_CLK_N_SET(1)
+                                    |SGMII_RESET_TX_CLK_N_SET(1));
+
+        ath_reg_rmw_clear(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
+	/*
+	 * WAR::Across resets SGMII link status goes to weird
+	 * state.
+	 * if 0xb8070058 (SGMII_DEBUG register) reads other then 0x1f or 0x10
+	 * for sure we are in bad  state.
+	 * Issue a PHY reset in MR_AN_CONTROL_ADDRESS to keep going.
+	 */
+	status = (ath_reg_rd(SGMII_DEBUG_ADDRESS) & 0xff);
+	while (!(status == 0xf || status == 0x10)) {
+
+		ath_reg_rmw_set(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
+		udelay(100);
+		ath_reg_rmw_clear(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
+		if (count++ == SGMII_LINK_WAR_MAX_TRY) {
+			printf ("Max resets limit reached exiting...\n");
+			break;
+	    	}
+		status = (ath_reg_rd(SGMII_DEBUG_ADDRESS) & 0xff);
+	}
+
+	printf("%s SGMII done\n",__func__);
+
+}
+
+static void ath_gmac_hw_start(ath_gmac_mac_t *mac)
+{
+
+
+#ifndef ATH_RGMII_CAL /* Moved after mii_setup since these registers are touched in RGMII cal code */
+	if(mac->mac_unit)
+	{
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_1000));
+	} else {
+
+
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_10_100));
+	}
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+#endif
+
+
+#ifdef ATH_RGMII_CAL
+	if(mac->mac_unit)
+	{
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_1000));
+	} else {
+
+
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_10_100));
+	}
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+#endif
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_1, 0x10ffff);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_2, 0xAAA0555);
+
+	ath_gmac_reg_rmw_set(mac, ATH_MAC_FIFO_CFG_4, 0x3ffff);
+	/*
+	 * Setting Drop CRC Errors, Pause Frames,Length Error frames
+	 * and Multi/Broad cast frames.
+	 */
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_5, 0x7eccf);
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_3, 0x1f00140);
+
+	printf(": cfg1 %#x cfg2 %#x\n", ath_gmac_reg_rd(mac, ATH_MAC_CFG1),
+			ath_gmac_reg_rd(mac, ATH_MAC_CFG2));
+
+
+}
+
+static int ath_gmac_check_link(ath_gmac_mac_t *mac)
+{
+	int link, duplex, speed;
+
+	ath_gmac_phy_link(mac->mac_unit, &link);
+	ath_gmac_phy_duplex(mac->mac_unit, &duplex);
+	ath_gmac_phy_speed(mac->mac_unit, &speed);
+
+	mac->link = link;
+
+	if(!mac->link) {
+		printf("%s link down\n",mac->dev->name);
+		return 0;
+	}
+
+	switch (speed)
+	{
+		case _1000BASET:
+			ath_gmac_set_mac_if(mac, 1);
+			ath_gmac_reg_rmw_set(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+
+			if (is_ar8033() && mac->mac_unit == 1) {
+				ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_GIGE_SET(1) |
+                                           ETH_SGMII_CLK_SEL_SET(1));
+			}
+	
+			break;
+
+		case _100BASET:
+			ath_gmac_set_mac_if(mac, 0);
+			ath_gmac_set_mac_speed(mac, 1);
+			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+
+                        if (is_ar8033() && mac->mac_unit == 1) {
+                        	ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_PHASE0_COUNT_SET(1) |
+                                           ETH_SGMII_PHASE1_COUNT_SET(1));
+			}
+
+			break;
+
+		case _10BASET:
+			ath_gmac_set_mac_if(mac, 0);
+			ath_gmac_set_mac_speed(mac, 0);
+			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+
+
+			break;
+
+		default:
+			printf("Invalid speed detected\n");
+			return 0;
+	}
+
+	if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+		return 1;
+
+	mac->duplex = duplex;
+	mac->speed = speed;
+
+	printf("dup %d speed %d\n", duplex, speed);
+
+	ath_gmac_set_mac_duplex(mac,duplex);
+
+	return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ath_gmac_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+	int i;
+	ath_gmac_desc_t *fr;
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t*)dev->priv;
+
+	if (!ath_gmac_check_link(mac))
+		return 0;
+
+	mac->next_rx = 0;
+
+        ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00); 
+        ath_gmac_reg_wr(mac, ATH_MAC_CFG1, (ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+
+	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+		fr = mac->fifo_rx[i];
+		fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+		flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+		ath_gmac_rx_give_to_dma(fr);
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, ATH_RXE);	/* rx start */
+	udelay(1000 * 1000);
+
+
+	return 1;
+
+}
+
+static int ath_gmac_alloc_fifo(int ndesc, ath_gmac_desc_t ** fifo)
+{
+	int i;
+	u32 size;
+	uchar *p = NULL;
+
+	size = sizeof(ath_gmac_desc_t) * ndesc;
+	size += CFG_CACHELINE_SIZE - 1;
+
+	if ((p = malloc(size)) == NULL) {
+		printf("Cant allocate fifos\n");
+		return -1;
+	}
+
+	p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+			~(CFG_CACHELINE_SIZE - 1));
+	p = UNCACHED_SDRAM(p);
+
+	for (i = 0; i < ndesc; i++)
+		fifo[i] = (ath_gmac_desc_t *) p + i;
+
+	return 0;
+}
+
+static int ath_gmac_setup_fifos(ath_gmac_mac_t *mac)
+{
+	int i;
+
+	if (ath_gmac_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+		return 1;
+
+	for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+		mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+			virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+		ath_gmac_tx_own(mac->fifo_tx[i]);
+	}
+
+	if (ath_gmac_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+		return 1;
+
+	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+		mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+			virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+	}
+
+	return (1);
+}
+
+static void ath_gmac_halt(struct eth_device *dev)
+{
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
+        ath_gmac_reg_rmw_clear(mac, ATH_MAC_CFG1,(ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+        ath_gmac_reg_wr(mac,ATH_MAC_FIFO_CFG_0,0x1f1f);
+	ath_gmac_reg_wr(mac,ATH_DMA_RX_CTRL, 0);
+	while (ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL));
+}
+
+#ifdef CONFIG_ATH_NAND_BR
+
+unsigned char *
+ath_eth_mac_addr(unsigned char *sectorBuff)
+{
+	ulong   off, size;
+	nand_info_t *nand;
+	unsigned char ret;
+
+	/*
+	 * caldata partition is of 128k
+	 */
+	nand = &nand_info[nand_curr_device];
+	size = ATH_ETH_MAC_READ_SIZE; /* To read 4k setting size as 4k */
+
+	/*
+	 * Get the Offset of Caldata partition
+	 */
+	off = ath_nand_get_cal_offset(getenv("bootargs"));
+	if(off == ATH_CAL_OFF_INVAL) {
+		printf("Invalid CAL offset \n");
+		return NULL;
+	}
+	/*
+	 * Get the values from flash, and program into the MAC address
+	 * registers
+	 */
+	ret = nand_read(nand, (loff_t)off, &size, (u_char *)sectorBuff);
+	printf(" %d bytes %s: %s\n", size,
+			"read", ret ? "ERROR" : "OK");
+	if(ret != 0 ) {
+		return NULL;
+	}
+
+	return sectorBuff;
+}
+
+#else  /* CONFIG_ATH_NAND_BR */
+
+unsigned char *
+ath_gmac_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+	/*
+	 ** BOARDCAL environmental variable has the address of the cal sector
+	 */
+
+	return ((unsigned char *)BOARDCAL);
+
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+			(KSEG1ADDR(ATH_SPI_BASE) + (4 * 1024) +
+			 flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+#endif  /* CONFIG_ATH_NAND_BR */
+
+static void ath_gmac_get_ethaddr(struct eth_device *dev)
+{
+	unsigned char *eeprom;
+	unsigned char *mac = dev->enetaddr;
+#ifndef CONFIG_ATH_EMULATION
+
+#ifdef CONFIG_ATH_NAND_BR
+	unsigned char sectorBuff[ATH_ETH_MAC_READ_SIZE];
+
+	eeprom = ath_eth_mac_addr(sectorBuff);
+	if(eeprom == NULL) {
+		/* mac address will be set to default mac address */
+		mac[0] = 0xff;
+	}
+	else {
+#else  /* CONFIG_ATH_NAND_BR */
+		eeprom = ath_gmac_mac_addr_loc();
+#endif  /* CONFIG_ATH_NAND_BR */
+
+		if (strcmp(dev->name, "eth0") == 0) {
+			memcpy(mac, eeprom, 6);
+		} else if (strcmp(dev->name, "eth1") == 0) {
+			eeprom += 6;
+			memcpy(mac, eeprom, 6);
+		} else {
+			printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+			return;
+		}
+#ifdef CONFIG_ATH_NAND_BR
+	}
+#endif  /* CONFIG_ATH_NAND_BR */
+	/* Use fixed address if the above address is invalid */
+	if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff))
+#else
+	if (1)
+#endif
+	{
+			mac[0] = 0x00;
+			mac[1] = 0x03;
+			mac[2] = 0x7f;
+			mac[3] = 0x09;
+			mac[4] = 0x0b;
+			mac[5] = 0xad;
+			printf("No valid address in Flash. Using fixed address\n");
+		} else {
+			printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+		}
+}
+
+void
+athr_mgmt_init(void)
+{
+#if defined (CONFIG_ATHRS17_PHY)
+uint32_t rddata;
+
+// init MDI/ MDO/ MDC
+if (CFG_ATH_GMAC_NMACS == 1){
+/*
+ * GPIO 4 as MDI
+ */
+rddata = ath_reg_rd(GPIO_IN_ENABLE3_ADDRESS)&
+		 ~GPIO_IN_ENABLE3_MII_GE1_MDI_MASK;
+rddata |= GPIO_IN_ENABLE3_MII_GE1_MDI_SET(4);
+ath_reg_wr(GPIO_IN_ENABLE3_ADDRESS, rddata);
+
+/*
+ * GPIO 4 as MDO
+ */
+rddata = ath_reg_rd(GPIO_OUT_FUNCTION1_ADDRESS) &
+		 ~ (GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+rddata |= (GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x20));
+ath_reg_wr(GPIO_OUT_FUNCTION1_ADDRESS, rddata);
+
+/*
+ * GPIO 4 as MDO
+ */
+rddata = ath_reg_rd(GPIO_OE_ADDRESS);
+rddata &= ~(1<<4);
+ath_reg_wr(GPIO_OE_ADDRESS, rddata);
+
+/*
+ * GPIO 3 as MDC
+ */
+rddata = ath_reg_rd(GPIO_OE_ADDRESS);
+rddata &= ~(1<<3);
+ath_reg_wr(GPIO_OE_ADDRESS, rddata);
+
+rddata = ath_reg_rd(GPIO_OUT_FUNCTION0_ADDRESS) &
+	   ~ (GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_MASK);
+rddata |= GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_SET(0x21);
+ath_reg_wr(GPIO_OUT_FUNCTION0_ADDRESS, rddata);
+
+}
+#endif /* CONFIG_ATHRS17_PHY */
+
+	printf ("%s ::done\n",__func__);
+}
+
+
+int ath_gmac_enet_initialize(bd_t * bis)
+{
+	struct eth_device *dev[CFG_ATH_GMAC_NMACS];
+	u32 mask, mac_h, mac_l;
+	int i;
+	u32 val;
+	
+	printf("%s...\n", __func__);
+
+	if ( CFG_ATH_GMAC_NMACS == 1){
+		athrs_sgmii_res_cal();
+	}
+	
+	for (i = 0;i < CFG_ATH_GMAC_NMACS;i++) {
+
+		if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+			puts("malloc failed\n");
+			return 0;
+		}
+
+		if ((ath_gmac_macs[i] = (ath_gmac_mac_t *) malloc(sizeof (ath_gmac_mac_t))) == NULL) {
+			puts("malloc failed\n");
+			return 0;
+		}
+
+		memset(ath_gmac_macs[i], 0, sizeof(ath_gmac_macs[i]));
+		memset(dev[i], 0, sizeof(dev[i]));
+
+		sprintf(dev[i]->name, "eth%d", i);
+		ath_gmac_get_ethaddr(dev[i]);
+
+		ath_gmac_macs[i]->mac_unit = i;
+		ath_gmac_macs[i]->mac_base = i ? ATH_GE1_BASE : ATH_GE0_BASE ;
+		ath_gmac_macs[i]->dev = dev[i];
+
+		dev[i]->iobase = 0;
+		dev[i]->init = ath_gmac_clean_rx;
+		dev[i]->halt = ath_gmac_halt;
+		dev[i]->send = ath_gmac_send;
+		dev[i]->recv = ath_gmac_recv;
+		dev[i]->priv = (void *)ath_gmac_macs[i];
+	}
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	ath_reg_rmw_set(RST_RESET_ADDRESS,  RST_RESET_ETH_SGMII_ARESET_SET(1));
+	udelay(1000 * 100);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_ARESET_SET(1));
+	udelay(100);
+#endif
+	if ( CFG_ATH_GMAC_NMACS == 1){
+	mask =	RST_RESET_ETH_SGMII_RESET_SET(1) | RST_RESET_ETH_SGMII_ARESET_SET(1) | RST_RESET_EXTERNAL_RESET_SET(1) | 
+				RST_RESET_ETH_SWITCH_ANALOG_RESET_SET(1) | RST_RESET_ETH_SWITCH_RESET_SET(1);
+	}else{
+		mask =  RST_RESET_ETH_SGMII_RESET_SET(1) | RST_RESET_EXTERNAL_RESET_SET(1) | 
+				RST_RESET_ETH_SWITCH_ANALOG_RESET_SET(1) | RST_RESET_ETH_SWITCH_RESET_SET(1);
+	}
+	ath_reg_rmw_set(RST_RESET_ADDRESS, mask);
+	udelay(1000 * 100);
+	if ( CFG_ATH_GMAC_NMACS == 1){
+			mask =	RST_RESET_ETH_SGMII_RESET_SET(1) | RST_RESET_ETH_SGMII_ARESET_SET(1)  | RST_RESET_EXTERNAL_RESET_SET(1);
+	}
+	
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+	udelay(1000 * 100);
+
+#if defined(CONFIG_ATHRS17_PHY)
+	if ( CFG_ATH_GMAC_NMACS == 1) {
+		//   S17 SWITCH RESET
+		val = ath_reg_rd(GPIO_OE_ADDRESS) & ~(1 << 11);
+		ath_reg_wr(GPIO_OE_ADDRESS, val);
+		udelay(1000 * 100);
+		ath_reg_rmw_set(GPIO_OUT_ADDRESS, ( 1 << 11));
+		udelay(1000 * 100);
+		ath_reg_rmw_clear(GPIO_OUT_ADDRESS, ( 1 << 11));
+		udelay(1000 * 100);
+		ath_reg_rmw_set(GPIO_OUT_ADDRESS, ( 1 << 11));
+	}
+#endif
+	for (i = 0;i < CFG_ATH_GMAC_NMACS;i++) {
+
+		ath_gmac_reg_rmw_set(ath_gmac_macs[i], ATH_MAC_CFG1, ATH_MAC_CFG1_SOFT_RST
+				| ATH_MAC_CFG1_RX_RST | ATH_MAC_CFG1_TX_RST);
+
+		if(!i) {
+			mask = (ATH_RESET_GE0_MAC | ATH_RESET_GE1_MAC);
+
+			mask = mask | ATH_RESET_GE0_MDIO | ATH_RESET_GE1_MDIO;
+
+			printf("%s: reset mask:%x \n", __func__, mask);
+
+			ath_reg_rmw_set(RST_RESET_ADDRESS, mask);
+			udelay(1000 * 100);
+
+			ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+			udelay(1000 * 100);
+
+			udelay(10 * 1000);
+		}
+#if defined(CONFIG_MGMT_INIT) && defined (CONFIG_ATHR_SWITCH_ONLY_MODE) || defined ATH_MDC_GPIO
+		if (!i)
+			athr_mgmt_init();
+
+		if (ath_gmac_macs[i]->mac_unit == 0)
+                        continue;
+#endif
+		if (CFG_ATH_GMAC_NMACS == 1){
+			athr_mgmt_init();
+		}
+		eth_register(dev[i]);
+#if(CONFIG_COMMANDS & CFG_CMD_MII)
+		miiphy_register(dev[i]->name, ath_gmac_miiphy_read, ath_gmac_miiphy_write);
+#endif
+		ath_gmac_mii_setup(ath_gmac_macs[i]);
+
+		/* if using header for register configuration, we have to     */
+		/* configure s26 register after frame transmission is enabled */
+
+		if (ath_gmac_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef  CONFIG_ATHRS17_PHY
+			athrs17_reg_init();
+#endif
+
+#ifdef CFG_ATHRS26_PHY
+                	athrs26_reg_init();
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+                	athrs27_reg_init();
+#endif
+
+
+		} else {
+
+#if defined(CONFIG_MGMT_INIT) && defined (CONFIG_ATHR_SWITCH_ONLY_MODE)
+			athrs17_reg_init();
+#elif defined (CONFIG_ATHRS17_PHY) && !defined(CFG_DUAL_PHY_SUPPORT)
+			athrs17_reg_init_wan();
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+                	athrs27_reg_init_lan();
+#endif
+
+		}
+#ifdef CONFIG_ATHRS_GMAC_SGMII
+	/*
+         * MAC unit 1 or drqfn package call sgmii setup.
+	 */
+	if (i == 0 && CFG_ATH_GMAC_NMACS == 1)
+		athr_gmac_sgmii_setup();
+#endif
+		ath_gmac_hw_start(ath_gmac_macs[i]);
+		ath_gmac_setup_fifos(ath_gmac_macs[i]);
+
+
+
+		udelay(100 * 1000);
+
+		{
+			unsigned char *mac = dev[i]->enetaddr;
+
+			printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+					mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+					mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+		}
+		mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+		mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+			(dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+		ath_gmac_reg_wr(ath_gmac_macs[i], ATH_GE_MAC_ADDR1, mac_l);
+		ath_gmac_reg_wr(ath_gmac_macs[i], ATH_GE_MAC_ADDR2, mac_h);
+
+
+	ath_gmac_phy_setup(ath_gmac_macs[i]->mac_unit);
+		printf("%s up\n",dev[i]->name);
+	}
+
+
+	return 1;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+int
+ath_gmac_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t *data)
+{
+	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
+	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg, val;
+	volatile int           rddata;
+	uint16_t      ii = 0xFFFF;
+
+
+
+
+	/*
+	 * Check for previous transactions are complete. Added to avoid
+	 * race condition while running at higher frequencies.
+	 */
+	do
+	{
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	}while(rddata && --ii);
+
+	if (ii == 0)
+		printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_ADDRESS, addr);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, ATH_MGMT_CMD_READ);
+
+	do
+	{
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	}while(rddata && --ii);
+
+	if(ii==0)
+		printf("Error!!! Leave ath_gmac_miiphy_read without polling correct status!\n");
+
+	val = ath_gmac_reg_rd(mac, ATH_MII_MGMT_STATUS);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
+
+        if (data != NULL)
+	    *data = val; 
+	return val;
+}
+
+int
+ath_gmac_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
+	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg;
+	volatile int rddata;
+	uint16_t      ii = 0xFFFF;
+
+
+	/*
+	 * Check for previous transactions are complete. Added to avoid
+	 * race condition while running at higher frequencies.
+	 */
+	do {
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	} while (rddata && --ii);
+
+	if (ii == 0)
+		printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_ADDRESS, addr);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CTRL, data);
+
+	do {
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	} while (rddata && --ii);
+
+	if (ii == 0)
+		printf("Error!!! Leave ath_gmac_miiphy_write without polling correct status!\n");
+	return 0; 
+}
+#endif		/* CONFIG_COMMANDS & CFG_CMD_MII */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/qca-eth-956x.h u-boot_1.1//board/atheros/common/qca-eth-956x.h
--- u-boot//board/atheros/common/qca-eth-956x.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/qca-eth-956x.h	2014-02-18 01:46:24.915050996 -0800
@@ -0,0 +1,423 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _AGxxxx_H
+#define _AGxxxx_H
+
+#include <linux/types.h>
+
+#ifndef CONFIG_MACH_QCA956x
+#ifdef ATH_RGMII_CAL
+#define rgmii_cal_alg()    rgmii_calib(mac);
+#else
+#define rgmii_cal_alg()    
+#endif
+#endif
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+	uint32_t	pkt_start_addr,
+			is_empty	:  1,
+			res1		: 10,
+			ftpp_override	:  5,
+			res2		:  4,
+			pkt_size	: 12,
+			next_desc;
+} ath_gmac_desc_t;
+
+#define NO_OF_TX_FIFOS			8
+#define NO_OF_RX_FIFOS			8
+
+typedef struct {
+	ath_gmac_desc_t		*fifo_tx[NO_OF_TX_FIFOS],
+				*fifo_rx[NO_OF_RX_FIFOS];
+	struct eth_device	*dev;
+	uint32_t		next_tx,
+				next_rx,
+				link,
+				duplex,
+				speed,
+				mac_unit,
+				mac_base;
+} ath_gmac_mac_t;
+
+#define ath_gmac_reg_wr(_mac, _x, _y)	ath_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ath_gmac_reg_rd(_mac, _x)	ath_reg_rd(((_x) + _mac->mac_base))
+
+#define ath_gmac_reg_rmw_set(_mac, _x, _y)	\
+	ath_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ath_gmac_reg_rmw_clear(_mac, _x, _y)	\
+	ath_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+#ifdef COMPRESSED_UBOOT
+#define _1000BASET		1000
+#define _100BASET		100
+#define _10BASET		10
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+#define mii_reg(_mac)	(ATH_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)	(((_mac)->mac_unit == 0) ? mii0_if : mii1_if)
+
+#define ath_gmac_set_mii_ctrl_speed(_mac, _spd)	do {	\
+	ath_reg_rmw_clear(mii_reg(_mac), (3 << 4));	\
+	ath_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));	\
+} while (0)
+
+#if defined (CFG_MII0_GMII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_MII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_RGMII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_RMII)
+#	define ath_gmac_get_mii_if()	0
+#endif
+
+#define MAX_WAIT			1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define ATH_MAC_CFG1			0x00
+#define ATH_MAC_CFG2			0x04
+#define ATH_MAC_IFCTL			0x38
+
+/*
+ * fifo control registers
+ */
+#define ATH_MAC_FIFO_CFG_0		0x48
+#define ATH_MAC_FIFO_CFG_1		0x4c
+#define ATH_MAC_FIFO_CFG_2		0x50
+#define ATH_MAC_FIFO_CFG_3		0x54
+#define ATH_MAC_FIFO_CFG_4		0x58
+
+#define ATH_MAC_FIFO_CFG_5		0x5c
+#define ATH_BYTE_PER_CLK_EN		(1 << 19)
+
+#define ATH_MAC_FIFO_RAM_0		0x60
+#define ATH_MAC_FIFO_RAM_1		0x64
+#define ATH_MAC_FIFO_RAM_2		0x68
+#define ATH_MAC_FIFO_RAM_3		0x6c
+#define ATH_MAC_FIFO_RAM_4		0x70
+#define ATH_MAC_FIFO_RAM_5		0x74
+#define ATH_MAC_FIFO_RAM_6		0x78
+#define ATH_MAC_FIFO_RAM_7		0x7c
+
+/*
+ * fields
+ */
+#define ATH_MAC_CFG1_SOFT_RST		(1 << 31)
+#define ATH_MAC_CFG1_RX_RST		(1 << 19)
+#define ATH_MAC_CFG1_TX_RST		(1 << 18)
+#define ATH_MAC_CFG1_LOOPBACK		(1 << 8)
+#define ATH_MAC_CFG1_RX_EN		(1 << 2)
+#define ATH_MAC_CFG1_TX_EN		(1 << 0)
+
+#define ATH_MAC_CFG2_FDX		(1 << 0)
+#define ATH_MAC_CFG2_PAD_CRC_EN		(1 << 2)
+#define ATH_MAC_CFG2_LEN_CHECK		(1 << 4)
+#define ATH_MAC_CFG2_HUGE_FRAME_EN	(1 << 5)
+#define ATH_MAC_CFG2_IF_1000		(1 << 9)
+#define ATH_MAC_CFG2_IF_10_100		(1 << 8)
+
+#define ATH_MAC_IFCTL_SPEED		(1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define ATH_DMA_TX_CTRL			0x180
+#define ATH_DMA_TX_DESC			0x184
+#define ATH_DMA_TX_STATUS		0x188
+#define ATH_DMA_RX_CTRL			0x18c
+#define ATH_DMA_RX_DESC			0x190
+#define ATH_DMA_RX_STATUS		0x194
+#define ATH_DMA_INTR_MASK		0x198
+#define ATH_DMA_INTR			0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define ATH_TXE				(1 << 0)
+#define ATH_TX_STATUS_PKTCNT_SHIFT	16
+#define ATH_TX_STATUS_PKT_SENT		0x1
+#define ATH_TX_STATUS_URN		0x2
+#define ATH_TX_STATUS_BUS_ERROR		0x8
+
+#define ATH_RXE				(1 << 0)
+
+#define ATH_RX_STATUS_PKTCNT_MASK	0xff0000
+#define ATH_RX_STATUS_PKT_RCVD		(1 << 0)
+#define ATH_RX_STATUS_OVF		(1 << 2)
+#define ATH_RX_STATUS_BUS_ERROR		(1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define ATH_INTR_TX			(1 << 0)
+#define ATH_INTR_TX_URN			(1 << 1)
+#define ATH_INTR_TX_BUS_ERROR		(1 << 3)
+#define ATH_INTR_RX			(1 << 4)
+#define ATH_INTR_RX_OVF			(1 << 6)
+#define ATH_INTR_RX_BUS_ERROR		(1 << 7)
+
+/*
+ * MII registers
+ */
+#define ATH_MAC_MII_MGMT_CFG		0x20
+#define ATH_MGMT_CFG_CLK_DIV_20		0x07
+
+#define ATH_MII_MGMT_CMD		0x24
+#define ATH_MGMT_CMD_READ		0x1
+
+#define ATH_MII_MGMT_ADDRESS		0x28
+#define ATH_ADDR_SHIFT			8
+
+#define ATH_MII_MGMT_CTRL		0x2c
+#define ATH_MII_MGMT_STATUS		0x30
+
+#define ATH_MII_MGMT_IND		0x34
+#define ATH_MGMT_IND_BUSY		(1 << 0)
+#define ATH_MGMT_IND_INVALID		(1 << 2)
+
+#define ATH_GE_MAC_ADDR1		0x40
+#define ATH_GE_MAC_ADDR2		0x44
+
+/*
+ * Ethernet config registers
+ */
+#define ATH_ETH_CFG			0x18070000
+#define ATH_ETH_CFG_RGMII_GE0		(1<<0)
+#define ATH_ETH_CFG_MII_GE0		(1<<1)
+#define ATH_ETH_CFG_GMII_GE0		(1<<2)
+#define ATH_ETH_CFG_RMII_HISPD_GE0	(1<<11)
+#define ATH_ETH_CFG_RMII_MASTER_MODE	(1<<12)
+#define ATH_ETH_CFG_MII_GE0_MASTER	(1<<3)
+#define ATH_ETH_CFG_MII_GE0_SLAVE	(1<<4)
+#define ATH_ETH_CFG_GE0_ERR_EN		(1<<5)
+#define ATH_ETH_CFG_SW_PHY_SWAP		(1<<7)
+#define ATH_ETH_CFG_SW_PHY_ADDR_SWAP	(1<<8)
+#define ATH_ETH_CFG_RXD_DELAY		(1 << 14)
+#define ATH_ETH_CFG_RDV_DELAY		(1 << 16)
+#define ATH_ETH_SWITCH_CLK_SPARE	0x18050024
+
+#define ETH_XMII_TX_INVERT_MSB                                       31
+#define ETH_XMII_TX_INVERT_LSB                                       31
+#define ETH_XMII_TX_INVERT_MASK                                      0x80000000
+#define ETH_XMII_TX_INVERT_GET(x)                                    (((x) & ETH_XMII_TX_INVERT_MASK) >> ETH_XMII_TX_INVERT_LSB)
+#define ETH_XMII_TX_INVERT_SET(x)                                    (((x) << ETH_XMII_TX_INVERT_LSB) & ETH_XMII_TX_INVERT_MASK)
+#define ETH_XMII_TX_INVERT_RESET                                     0x0 // 0
+#define ETH_XMII_GIGE_QUAD_MSB                                       30
+#define ETH_XMII_GIGE_QUAD_LSB                                       30
+#define ETH_XMII_GIGE_QUAD_MASK                                      0x40000000
+#define ETH_XMII_GIGE_QUAD_GET(x)                                    (((x) & ETH_XMII_GIGE_QUAD_MASK) >> ETH_XMII_GIGE_QUAD_LSB)
+#define ETH_XMII_GIGE_QUAD_SET(x)                                    (((x) << ETH_XMII_GIGE_QUAD_LSB) & ETH_XMII_GIGE_QUAD_MASK)
+#define ETH_XMII_GIGE_QUAD_RESET                                     0x0 // 0
+#define ETH_XMII_RX_DELAY_MSB                                        29
+#define ETH_XMII_RX_DELAY_LSB                                        28
+#define ETH_XMII_RX_DELAY_MASK                                       0x30000000
+#define ETH_XMII_RX_DELAY_GET(x)                                     (((x) & ETH_XMII_RX_DELAY_MASK) >> ETH_XMII_RX_DELAY_LSB)
+#define ETH_XMII_RX_DELAY_SET(x)                                     (((x) << ETH_XMII_RX_DELAY_LSB) & ETH_XMII_RX_DELAY_MASK)
+#define ETH_XMII_RX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_TX_DELAY_MSB                                        27
+#define ETH_XMII_TX_DELAY_LSB                                        26
+#define ETH_XMII_TX_DELAY_MASK                                       0x0c000000
+#define ETH_XMII_TX_DELAY_GET(x)                                     (((x) & ETH_XMII_TX_DELAY_MASK) >> ETH_XMII_TX_DELAY_LSB)
+#define ETH_XMII_TX_DELAY_SET(x)                                     (((x) << ETH_XMII_TX_DELAY_LSB) & ETH_XMII_TX_DELAY_MASK)
+#define ETH_XMII_TX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_GIGE_MSB                                            25
+#define ETH_XMII_GIGE_LSB                                            25
+#define ETH_XMII_GIGE_MASK                                           0x02000000
+#define ETH_XMII_GIGE_GET(x)                                         (((x) & ETH_XMII_GIGE_MASK) >> ETH_XMII_GIGE_LSB)
+#define ETH_XMII_GIGE_SET(x)                                         (((x) << ETH_XMII_GIGE_LSB) & ETH_XMII_GIGE_MASK)
+#define ETH_XMII_GIGE_RESET                                          0x0 // 0
+#define ETH_XMII_OFFSET_PHASE_MSB                                    24
+#define ETH_XMII_OFFSET_PHASE_LSB                                    24
+#define ETH_XMII_OFFSET_PHASE_MASK                                   0x01000000
+#define ETH_XMII_OFFSET_PHASE_GET(x)                                 (((x) & ETH_XMII_OFFSET_PHASE_MASK) >> ETH_XMII_OFFSET_PHASE_LSB)
+#define ETH_XMII_OFFSET_PHASE_SET(x)                                 (((x) << ETH_XMII_OFFSET_PHASE_LSB) & ETH_XMII_OFFSET_PHASE_MASK)
+#define ETH_XMII_OFFSET_PHASE_RESET                                  0x0 // 0
+#define ETH_XMII_OFFSET_COUNT_MSB                                    23
+#define ETH_XMII_OFFSET_COUNT_LSB                                    16
+#define ETH_XMII_OFFSET_COUNT_MASK                                   0x00ff0000
+#define ETH_XMII_OFFSET_COUNT_GET(x)                                 (((x) & ETH_XMII_OFFSET_COUNT_MASK) >> ETH_XMII_OFFSET_COUNT_LSB)
+#define ETH_XMII_OFFSET_COUNT_SET(x)                                 (((x) << ETH_XMII_OFFSET_COUNT_LSB) & ETH_XMII_OFFSET_COUNT_MASK)
+#define ETH_XMII_OFFSET_COUNT_RESET                                  0x0 // 0
+#define ETH_XMII_PHASE1_COUNT_MSB                                    15
+#define ETH_XMII_PHASE1_COUNT_LSB                                    8
+#define ETH_XMII_PHASE1_COUNT_MASK                                   0x0000ff00
+#define ETH_XMII_PHASE1_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE1_COUNT_MASK) >> ETH_XMII_PHASE1_COUNT_LSB)
+#define ETH_XMII_PHASE1_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE1_COUNT_LSB) & ETH_XMII_PHASE1_COUNT_MASK)
+#define ETH_XMII_PHASE1_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_PHASE0_COUNT_MSB                                    7
+#define ETH_XMII_PHASE0_COUNT_LSB                                    0
+#define ETH_XMII_PHASE0_COUNT_MASK                                   0x000000ff
+#define ETH_XMII_PHASE0_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE0_COUNT_MASK) >> ETH_XMII_PHASE0_COUNT_LSB)
+#define ETH_XMII_PHASE0_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE0_COUNT_LSB) & ETH_XMII_PHASE0_COUNT_MASK)
+#define ETH_XMII_PHASE0_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_ADDRESS                                             0x18050030
+
+
+
+#define ETH_CFG_ETH_SPARE_MSB                                        31
+#define ETH_CFG_ETH_SPARE_LSB                                        22
+#define ETH_CFG_ETH_SPARE_MASK                                       0xffc00000
+#define ETH_CFG_ETH_SPARE_GET(x)                                     (((x) & ETH_CFG_ETH_SPARE_MASK) >> ETH_CFG_ETH_SPARE_LSB)
+#define ETH_CFG_ETH_SPARE_SET(x)                                     (((x) << ETH_CFG_ETH_SPARE_LSB) & ETH_CFG_ETH_SPARE_MASK)
+#define ETH_CFG_ETH_SPARE_RESET                                      0x0 // 0
+#define ETH_CFG_ETH_TXEN_DELAY_MSB                                   21
+#define ETH_CFG_ETH_TXEN_DELAY_LSB                                   20
+#define ETH_CFG_ETH_TXEN_DELAY_MASK                                  0x00300000
+#define ETH_CFG_ETH_TXEN_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_TXEN_DELAY_MASK) >> ETH_CFG_ETH_TXEN_DELAY_LSB)
+#define ETH_CFG_ETH_TXEN_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_TXEN_DELAY_LSB) & ETH_CFG_ETH_TXEN_DELAY_MASK)
+#define ETH_CFG_ETH_TXEN_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_TXD_DELAY_MSB                                    19
+#define ETH_CFG_ETH_TXD_DELAY_LSB                                    18
+#define ETH_CFG_ETH_TXD_DELAY_MASK                                   0x000c0000
+#define ETH_CFG_ETH_TXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_TXD_DELAY_MASK) >> ETH_CFG_ETH_TXD_DELAY_LSB)
+#define ETH_CFG_ETH_TXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_TXD_DELAY_LSB) & ETH_CFG_ETH_TXD_DELAY_MASK)
+#define ETH_CFG_ETH_TXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_ETH_RXDV_DELAY_MSB                                   17
+#define ETH_CFG_ETH_RXDV_DELAY_LSB                                   16
+#define ETH_CFG_ETH_RXDV_DELAY_MASK                                  0x00030000
+#define ETH_CFG_ETH_RXDV_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_RXDV_DELAY_MASK) >> ETH_CFG_ETH_RXDV_DELAY_LSB)
+#define ETH_CFG_ETH_RXDV_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_RXDV_DELAY_LSB) & ETH_CFG_ETH_RXDV_DELAY_MASK)
+#define ETH_CFG_ETH_RXDV_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_RXD_DELAY_MSB                                    15
+#define ETH_CFG_ETH_RXD_DELAY_LSB                                    14
+#define ETH_CFG_ETH_RXD_DELAY_MASK                                   0x0000c000
+#define ETH_CFG_ETH_RXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_RXD_DELAY_MASK) >> ETH_CFG_ETH_RXD_DELAY_LSB)
+#define ETH_CFG_ETH_RXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_RXD_DELAY_LSB) & ETH_CFG_ETH_RXD_DELAY_MASK)
+#define ETH_CFG_ETH_RXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_RMII_GE0_MASTER_MSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_LSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_MASK                                 0x00001000
+#define ETH_CFG_RMII_GE0_MASTER_GET(x)                               (((x) & ETH_CFG_RMII_GE0_MASTER_MASK) >> ETH_CFG_RMII_GE0_MASTER_LSB)
+#define ETH_CFG_RMII_GE0_MASTER_SET(x)                               (((x) << ETH_CFG_RMII_GE0_MASTER_LSB) & ETH_CFG_RMII_GE0_MASTER_MASK)
+#define ETH_CFG_RMII_GE0_MASTER_RESET                                0x1 // 1
+#define ETH_CFG_MII_CNTL_SPEED_MSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_LSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_MASK                                  0x00000800
+#define ETH_CFG_MII_CNTL_SPEED_GET(x)                                (((x) & ETH_CFG_MII_CNTL_SPEED_MASK) >> ETH_CFG_MII_CNTL_SPEED_LSB)
+#define ETH_CFG_MII_CNTL_SPEED_SET(x)                                (((x) << ETH_CFG_MII_CNTL_SPEED_LSB) & ETH_CFG_MII_CNTL_SPEED_MASK)
+#define ETH_CFG_MII_CNTL_SPEED_RESET                                 0x0 // 0
+#define ETH_CFG_GE0_SGMII_MSB                                        6
+#define ETH_CFG_GE0_SGMII_LSB                                        6
+#define ETH_CFG_GE0_SGMII_MASK                                       0x00000040
+#define ETH_CFG_GE0_SGMII_GET(x)                                     (((x) & ETH_CFG_GE0_SGMII_MASK) >> ETH_CFG_GE0_SGMII_LSB)
+#define ETH_CFG_GE0_SGMII_SET(x)                                     (((x) << ETH_CFG_GE0_SGMII_LSB) & ETH_CFG_GE0_SGMII_MASK)
+#define ETH_CFG_GE0_SGMII_RESET                                      0x0 // 0
+#define ETH_CFG_GE0_ERR_EN_MSB                                       5
+#define ETH_CFG_GE0_ERR_EN_LSB                                       5
+#define ETH_CFG_GE0_ERR_EN_MASK                                      0x00000020
+#define ETH_CFG_GE0_ERR_EN_GET(x)                                    (((x) & ETH_CFG_GE0_ERR_EN_MASK) >> ETH_CFG_GE0_ERR_EN_LSB)
+#define ETH_CFG_GE0_ERR_EN_SET(x)                                    (((x) << ETH_CFG_GE0_ERR_EN_LSB) & ETH_CFG_GE0_ERR_EN_MASK)
+#define ETH_CFG_GE0_ERR_EN_RESET                                     0x0 // 0
+#define ETH_CFG_MII_GE0_SLAVE_MSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_LSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_MASK                                   0x00000010
+#define ETH_CFG_MII_GE0_SLAVE_GET(x)                                 (((x) & ETH_CFG_MII_GE0_SLAVE_MASK) >> ETH_CFG_MII_GE0_SLAVE_LSB)
+#define ETH_CFG_MII_GE0_SLAVE_SET(x)                                 (((x) << ETH_CFG_MII_GE0_SLAVE_LSB) & ETH_CFG_MII_GE0_SLAVE_MASK)
+#define ETH_CFG_MII_GE0_SLAVE_RESET                                  0x0 // 0
+#define ETH_CFG_MII_GE0_MASTER_MSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_LSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_MASK                                  0x00000008
+#define ETH_CFG_MII_GE0_MASTER_GET(x)                                (((x) & ETH_CFG_MII_GE0_MASTER_MASK) >> ETH_CFG_MII_GE0_MASTER_LSB)
+#define ETH_CFG_MII_GE0_MASTER_SET(x)                                (((x) << ETH_CFG_MII_GE0_MASTER_LSB) & ETH_CFG_MII_GE0_MASTER_MASK)
+#define ETH_CFG_MII_GE0_MASTER_RESET                                 0x0 // 0
+#define ETH_CFG_GMII_GE0_MSB                                         2
+#define ETH_CFG_GMII_GE0_LSB                                         2
+#define ETH_CFG_GMII_GE0_MASK                                        0x00000004
+#define ETH_CFG_GMII_GE0_GET(x)                                      (((x) & ETH_CFG_GMII_GE0_MASK) >> ETH_CFG_GMII_GE0_LSB)
+#define ETH_CFG_GMII_GE0_SET(x)                                      (((x) << ETH_CFG_GMII_GE0_LSB) & ETH_CFG_GMII_GE0_MASK)
+#define ETH_CFG_GMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_MII_GE0_MSB                                          1
+#define ETH_CFG_MII_GE0_LSB                                          1
+#define ETH_CFG_MII_GE0_MASK                                         0x00000002
+#define ETH_CFG_MII_GE0_GET(x)                                       (((x) & ETH_CFG_MII_GE0_MASK) >> ETH_CFG_MII_GE0_LSB)
+#define ETH_CFG_MII_GE0_SET(x)                                       (((x) << ETH_CFG_MII_GE0_LSB) & ETH_CFG_MII_GE0_MASK)
+#define ETH_CFG_MII_GE0_RESET                                        0x0 // 0
+#define ETH_CFG_RGMII_GE0_MSB                                        0
+#define ETH_CFG_RGMII_GE0_LSB                                        0
+#define ETH_CFG_RGMII_GE0_MASK                                       0x00000001
+#define ETH_CFG_RGMII_GE0_GET(x)                                     (((x) & ETH_CFG_RGMII_GE0_MASK) >> ETH_CFG_RGMII_GE0_LSB)
+#define ETH_CFG_RGMII_GE0_SET(x)                                     (((x) << ETH_CFG_RGMII_GE0_LSB) & ETH_CFG_RGMII_GE0_MASK)
+#define ETH_CFG_RGMII_GE0_RESET                                      0x0 // 0
+#define ETH_CFG_ADDRESS                                              0x18070000
+
+
+
+
+/*
+ * ownership of descriptors between DMA and cpu
+ */
+#define ath_gmac_rx_owned_by_dma(_ds)	((_ds)->is_empty == 1)
+#define ath_gmac_rx_give_to_dma(_ds)	((_ds)->is_empty = 1)
+#define ath_gmac_tx_owned_by_dma(_ds)	((_ds)->is_empty == 0)
+#define ath_gmac_tx_give_to_dma(_ds)	((_ds)->is_empty = 0)
+#define ath_gmac_tx_own(_ds)		((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ath_gmac_set_mac_duplex(_mac, _fdx)	do {	\
+	if ((_fdx)) {					\
+		ath_gmac_reg_rmw_set(_mac,		\
+			ATH_MAC_CFG2, ATH_MAC_CFG2_FDX);\
+	} else {					\
+		ath_gmac_reg_rmw_clear(_mac,		\
+			ATH_MAC_CFG2, ATH_MAC_CFG2_FDX);\
+	}						\
+} while (0)
+
+#define ath_gmac_set_mac_if(_mac, _isXGMII)	do {		\
+	ath_gmac_reg_rmw_clear(_mac, ATH_MAC_CFG2,		\
+				ATH_MAC_CFG2_IF_1000 |		\
+				ATH_MAC_CFG2_IF_10_100);	\
+	if ((_isXGMII)) {					\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_CFG2,	\
+				ATH_MAC_CFG2_IF_1000);		\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_FIFO_CFG_5,	\
+				ATH_BYTE_PER_CLK_EN);		\
+	} else {						\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_CFG2,	\
+				ATH_MAC_CFG2_IF_10_100);	\
+		ath_gmac_reg_rmw_clear(_mac, ATH_MAC_FIFO_CFG_5,\
+				ATH_BYTE_PER_CLK_EN);		\
+	}							\
+} while (0)
+
+#define ath_gmac_set_mac_speed(_mac, _is100)	do {		\
+	if ((_is100)) {						\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_IFCTL,	\
+					ATH_MAC_IFCTL_SPEED);	\
+	} else {						\
+		ath_gmac_reg_rmw_clear(_mac, ATH_MAC_IFCTL,	\
+					ATH_MAC_IFCTL_SPEED);	\
+	}							\
+} while (0)
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/qca-eth-956x_phy.h u-boot_1.1//board/atheros/common/qca-eth-956x_phy.h
--- u-boot//board/atheros/common/qca-eth-956x_phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/qca-eth-956x_phy.h	2014-02-18 01:46:24.915050996 -0800
@@ -0,0 +1,167 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _QCA_ETH_955x_PHY_H
+#define _QCA_ETH_955x_PHY_H
+#include <miiphy.h>
+
+
+#ifdef CONFIG_ATHR_8033_PHY
+extern int athrs_ar8033_reg_init(void *arg);
+extern int athrs_ar8033_phy_setup(void  *arg);
+extern int athrs_ar8033_phy_is_fdx(int ethUnit);
+extern int athrs_ar8033_phy_is_link_alive(int phyUnit);
+extern int athrs_ar8033_phy_is_up(int ethUnit);
+extern int athrs_ar8033_phy_speed(int ethUnit,int phyUnit);
+#endif
+
+#ifdef CONFIG_ATHRS17_PHY
+extern int athrs17_phy_setup(int ethUnit);
+extern int athrs17_phy_is_up(int ethUnit);
+extern int athrs17_phy_is_fdx(int ethUnit);
+extern int athrs17_phy_speed(int ethUnit);
+#endif
+
+#ifdef CFG_ATHRS26_PHY
+extern int athrs26_phy_setup(int ethUnit);
+extern int athrs26_phy_is_up(int ethUnit);
+extern int athrs26_phy_is_fdx(int ethUnit);
+extern int athrs26_phy_speed(int ethUnit);
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+extern int athrs27_phy_setup(int ethUnit);
+extern int athrs27_phy_is_up(int ethUnit);
+extern int athrs27_phy_is_fdx(int ethUnit);
+extern int athrs27_phy_speed(int ethUnit);
+#endif
+ 
+static inline void ath_gmac_phy_setup(int unit)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			athrs17_phy_setup(unit);
+		} else
+#endif
+		{
+#ifdef CFG_ATHRS26_PHY
+        		athrs26_phy_setup(unit);
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+        		athrs27_phy_setup(unit);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			athr_vir_phy_setup(unit);
+#endif
+#if defined(CONFIG_ATHRS17_PHY) && !defined (CFG_DUAL_PHY_SUPPORT)
+			athrs17_phy_setup(unit);
+#endif
+
+		}
+}
+
+static inline void ath_gmac_phy_link(int unit, int *link)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			*link = athrs17_phy_is_up(unit);
+		} else
+#endif
+		{
+#ifdef CFG_ATHRS26_PHY
+         		*link = athrs26_phy_is_up(unit);
+#endif
+#ifdef CFG_ATHRS27_PHY
+         		*link = athrs27_phy_is_up(unit);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			*link = athr_vir_phy_is_up(unit);
+#endif
+#ifdef CONFIG_ATHR_8033_PHY
+			*link = athrs_ar8033_phy_is_up(unit);
+#endif
+#if defined(CONFIG_ATHRS17_PHY) && !defined (CFG_DUAL_PHY_SUPPORT)
+			*link = athrs17_phy_is_up(unit);
+#endif
+
+		}
+}
+
+static inline void ath_gmac_phy_duplex(int unit, int *duplex)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			*duplex = athrs17_phy_is_fdx(unit);
+		} else
+#endif
+		{
+#ifdef CFG_ATHRS26_PHY
+			*duplex = athrs26_phy_is_fdx(unit);
+#endif
+#ifdef CFG_ATHRS27_PHY
+			*duplex = athrs27_phy_is_fdx(unit);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			*duplex = athr_vir_phy_is_fdx(unit);
+#endif
+#ifdef CONFIG_ATHR_8033_PHY
+			*duplex = athrs_ar8033_phy_is_fdx(unit);
+#endif
+#if defined(CONFIG_ATHRS17_PHY) && !defined(CFG_DUAL_PHY_SUPPORT)
+			*duplex = athrs17_phy_is_fdx(unit);
+#endif
+		}
+}
+
+static inline void ath_gmac_phy_speed(int unit, int *speed)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			*speed = _1000BASET;
+		} else
+#endif
+		{
+#ifdef CFG_ATHRS26_PHY
+			*speed = athrs26_phy_speed(unit);
+#endif
+#ifdef CFG_ATHRS27_PHY
+			*speed = athrs27_phy_speed(unit);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			*speed = athr_vir_phy_speed(unit);
+#endif
+#ifdef CONFIG_ATHR_8033_PHY
+			*speed = athrs_ar8033_phy_speed(unit, 5);
+#endif
+
+#if defined(CONFIG_ATHRS17_PHY) && !defined (CFG_DUAL_PHY_SUPPORT)
+			*speed = _1000BASET;
+#endif
+		}
+}
+
+#endif /* _QCA_ETH_955x_PHY_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/rgmii-cal-955x.c u-boot_1.1//board/atheros/common/rgmii-cal-955x.c
--- u-boot//board/atheros/common/rgmii-cal-955x.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/rgmii-cal-955x.c	2014-02-18 01:46:24.951051016 -0800
@@ -0,0 +1,626 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+//#include <gmac_defines.h>
+//#include <prototypes.h>
+
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#include <atheros.h>
+#include "qca-eth-955x.h"
+#include "qca-eth-955x_phy.h"
+
+#ifdef ATH_RGMII_CAL
+
+#define NUM_DESCRIPTORS		10	//Number of packets to be looped back
+#define node_tx_buf_len		100	// No of bytes per packet to be looped back
+
+#define DEBUG		0
+#define DEBUG_1 	1
+
+#define GE0_PEMSTAT_RBYT	(0x9c + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RPKT	(0xA0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RFCS	(0xA4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RMCA	(0xA8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RBCA	(0xAC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RXCF	(0xB0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RXPF	(0xB4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RXUO	(0xB8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RALN	(0xBC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RFLR	(0xC0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RCDE	(0xC4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RCSE	(0xC8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RUND	(0xCC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_ROVR	(0xD0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RFRG	(0xD4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RJBR	(0xD8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RDRP	(0xDC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_TPKT	(0xE0 + ATH_GE0_BASE)
+
+#define NUM_DESCS 10
+
+void init_s17_lpbk(void);
+uint32_t athrs17_reg_read(uint32_t reg_addr);
+void athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val);
+
+int results[5] = { 0, 1, 1, 1, 0 };
+
+int find;
+
+void big_del(void)
+{
+	int i;
+	for (i = 0; i < 10000; i++) ;
+}
+
+// This should tell us what the best of the 4 values is. It should also tell us what the longest sequence is.
+// Since only four bits are used the best of 4 values can be easily arrived at by a truth table.
+// Presently we have an algorithm though.
+int find_value(void)
+{
+	int i;
+	int start_ok = 9;
+	int end_ok = 9;
+	int longest_start_ok = 0;
+	int longest_end_ok = 0;
+	int longest_ok_cnt = -1;
+	int first = 0;
+
+	for (i = 0; i < 5; i++) {
+#if DEBUG
+		printf("results [%d]: %d\n", i, results[i]);
+#endif
+		if (results[i] == 1) {
+			if (start_ok == 9) {
+				start_ok = i;
+				if (first == 0) {
+					longest_start_ok = i;
+					longest_end_ok = i;
+					first = 1;
+				}
+			}
+		}
+		if (results[i] == 0) {
+			if (end_ok == 9) {
+				end_ok = i - 1;
+			}
+			if ((end_ok - start_ok) > longest_ok_cnt) {
+				longest_start_ok = start_ok;
+				longest_end_ok = end_ok;
+				longest_ok_cnt = (end_ok - start_ok);
+			}
+			start_ok = 9;
+			end_ok = 9;
+		}
+	}
+
+#if DEBUG
+	printf("FINAL VALUE - ");
+#endif
+	find = (longest_end_ok + longest_start_ok) / 2;
+#if DEBUG
+	printf("find - %d\n", find);
+	printf("FINAL OK COUNT - %d\n", longest_ok_cnt + 1);
+#endif
+	return (longest_ok_cnt + 1);
+}
+
+int pkt_compare_data(void)
+{
+	unsigned int i, j;
+	//unsigned int k,rddata;
+	unsigned int node_rx_buf_len;
+	//unsigned int * node_tx_desc_ptr = (unsigned int *) 0xa0280000;
+	unsigned int *node_rx_desc_ptr = (unsigned int *)0xa0380000;
+	unsigned int *node_tx_buf_addr = (unsigned int *)0xa0680000;
+	unsigned int *node_rx_buf_addr = (unsigned int *)0xa0580000;
+	unsigned int error = 0;
+	unsigned pkt_err[NUM_DESCS];
+
+	node_rx_buf_len = (*(node_rx_desc_ptr + 0x1) & 0xfff) - 0x4;
+	// node_tx_buf_len = *(node_tx_desc_ptr + (NUM_DESCS-1)*0x3+0x1) & 0xfff;
+
+	for (j = 0; j < NUM_DESCS; j++) {
+		node_rx_buf_len = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & 0xfff) - 0x4;
+		pkt_err[j] = 0;
+		for (i = 0; i < (node_rx_buf_len / 4); i++) {
+			if (((*(node_rx_buf_addr + i + (j * 0x100))) != *(node_tx_buf_addr + i))) {
+				error = error + 0x1;
+				pkt_err[j] = 1;
+			}
+		}
+		//node_rx_buf_addr = node_rx_buf_addr + 0x100;
+	}
+	if (error == 0) {
+		return 0;
+	} else {
+		for (j = 0; j < NUM_DESCS; j++) {
+			node_rx_buf_len = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & 0xfff) - 0x4;
+			if (pkt_err[j] == 1) {
+#if DEBUG
+				printf("PKT %d\n", j);
+				printf("---------------------------------\n");
+
+				for (i = 0; i < (node_rx_buf_len / 4); i++) {
+					//if(((*(node_rx_buf_addr + i )) != *(node_tx_buf_addr + i)))
+					if (((*(node_rx_buf_addr + i + (j * 0x100))) != *(node_tx_buf_addr + i))) {
+						printf("->");
+					} else {
+						printf("  ");
+					}
+					printf("%x", (*(node_rx_buf_addr + i + (j * 0x100))));
+					printf("  ");
+					printf("%x\n", (*(node_tx_buf_addr + i)));
+				}
+				printf("---------------------------------\n");
+#endif
+			}
+			//node_rx_buf_addr = node_rx_buf_addr + 0x100;
+		}
+		return 1;
+	}
+}
+
+void rgmii_calib(ath_gmac_mac_t * mac)
+{
+
+	unsigned int i;
+	unsigned int j;
+	unsigned int k, l, m;
+	unsigned int rddata, error = 0;
+    volatile unsigned int * rd_register;
+	unsigned int node_rx_buf_len = 1600;
+	unsigned int node_rx_buf_len1;
+	unsigned int *node_tx_desc_ptr = (unsigned int *)0xa0280000;
+	unsigned int *node_rx_desc_ptr = (unsigned int *)0xa0380000;
+	unsigned int *node_rx_buf_addr = (unsigned int *)0xa0580000;
+	unsigned int *node_tx_buf_addr = (unsigned int *)0xa0680000;
+	unsigned int *node_comp_result = (unsigned int *)0xa0200000;
+	unsigned int s17_tx_pkt = 0;
+	unsigned int s17_rx_pkt = 0;
+	unsigned int to;
+	unsigned int pass = 1;
+	unsigned int fail = 0;
+	int lgst = 0;
+	int old_lgst = 0;
+	unsigned int xmii[16];
+	unsigned int eth_cfg[16];
+	unsigned int xmii_val = 0;
+	unsigned int eth_cfg_val = 1;
+	unsigned int tx_fix = 0;
+
+
+	// GIGE Enable
+	ath_reg_wr(ETH_XMII_ADDRESS,	ETH_XMII_TX_INVERT_SET(0x1) |
+					ETH_XMII_RX_DELAY_SET(0x2) |
+					ETH_XMII_TX_DELAY_SET(0x1) |
+					ETH_XMII_GIGE_SET(0x1));
+
+	while ((ath_reg_rd(SGMII_SERDES_ADDRESS) & SGMII_SERDES_LOCK_DETECT_STATUS_SET(1)) == 0) {
+		printf("TEST: WAIT FOR LOCK\n");
+	}
+
+	big_del();
+
+	// MAC INITS
+	// RGMII Enable on GE0
+	//eth_init();
+	init_s17_lpbk();
+	athrs17_reg_write(0x30, 1);
+
+	ath_reg_wr(ETH_CFG_ADDRESS,	ETH_CFG_ETH_RXDV_DELAY_SET(0x3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(0x3) |
+					ETH_CFG_RGMII_GE0_SET(0x1));
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_GE0_MAC_RESET_MASK);	// Bringing GE0 out of RESET
+	ath_gmac_reg_wr(mac, ATH_MAC_CFG2, 0x7235);	//for 1000mbps
+	//ath_reg_wr(GE0_MAC_CONFIG_2,0x7135);  //for 100mbps
+	ath_gmac_reg_wr(mac, ATH_MAC_IFCTL, 0x00000);
+	ath_gmac_reg_wr(mac, ATH_MAC_CFG1, 0x005);
+	//ath_reg_wr(GE0_MAC_CONFIG_1,0x105);  // For MAC Loopback
+	ath_gmac_reg_wr(mac, ATH_DMA_INTR_MASK, 0);	// Disable interrupt mask
+	ath_gmac_reg_wr(mac, ATH_GE_MAC_ADDR1, 0x003fffff);	//ethernet mac address
+	ath_gmac_reg_wr(mac, ATH_GE_MAC_ADDR2, 0xfffe0000);	//ethernet mac address
+	ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, 0x6);	//clock/20= 2MHz
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);	// Enable the FIFO modules
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_1, 0x10ffff);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_3, 0x1f00140);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_4, 0x1000);
+	//ath_reg_wr(GE0_FIFO_CFG_REG_5, 0xbefff); //enable drop
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_5, 0xfffff);	//for 1000Mbps
+	//ath_reg_wr(GE0_FIFO_CFG_REG_5, 0x7ffff);//for 100Mbps
+
+	//************
+	// PACKETS
+	//***********
+
+	// Initialise Data in Memory for TX and RX
+	for (i = 0; i < node_tx_buf_len; i++)
+		*(node_tx_buf_addr + i) = i | (i + 1) << 8 | (i + 2) << 16 | (i + 3) << 24;
+
+#if DEBUG
+	printf("TEST: Inits Done\n");
+#endif
+	// Set Up Transmit Descriptor Table
+
+	for (i = 0; i < NUM_DESCRIPTORS; i++) {
+		*(node_tx_desc_ptr + (i * 0x3)) = ((unsigned int)node_tx_buf_addr & 0x0fffffff);
+		*(node_tx_desc_ptr + (i * 0x3) + 0x1) = (node_tx_buf_len & 0x7fffffff);
+
+		if (i == (NUM_DESCRIPTORS - 1))
+			*(node_tx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_tx_desc_ptr & 0x0fffffff);
+		else
+			*(node_tx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_tx_desc_ptr & 0x0fffffff) + (i * 0xc) + 0xc;
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_DESC, ((unsigned int)node_tx_desc_ptr & 0x0fffffff));
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_STATUS, 0xfffffff);	// clear dma status
+
+	for (i = 0; i < NUM_DESCRIPTORS; i++) {
+		*(node_rx_desc_ptr + (i * 0x3)) = ((unsigned int)node_rx_buf_addr & 0x0fffffff);
+		*(node_rx_desc_ptr + (i * 0x3) + 0x1) = (node_rx_buf_len & 0xfff) | (1 << 31);
+		if (i == (NUM_DESCRIPTORS - 1))
+			*(node_rx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_rx_desc_ptr & 0x0fffffff);
+		else
+			*(node_rx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_rx_desc_ptr & 0x0fffffff) + (i * 0xc) + 0xc;
+		node_rx_buf_addr = node_rx_buf_addr + 0x100;
+
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, ((unsigned int)node_rx_desc_ptr & 0x0fffffff));
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_STATUS, 0xfffffff);	// clear dma status
+
+	k = 0;
+
+	// Enable TX and RX MAC
+	ath_gmac_reg_wr(mac, ATH_MAC_CFG1, 0x005);
+
+	// This routine will go through 16 combinations to find the best value for TX_DELAY, GIGE_QUAD, TX_INVERT
+	for (l = 0; l < 16; l++) {
+		// initialize pass. this will be made zero if there is a failure in packet reception compare
+		pass = 1;
+		// fail due to checks in rx etc. this is not the same as !pass
+		fail = 0;
+
+		// GIGE_QUAD  - 0
+		// TX_INVERT  - 0
+		// TX_DELAY   - 0,1,2,3
+		if (l < 4) {
+			// GIGE Enable and TX_DELAY
+			rddata = ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		// GIGE_QUAD  - 1
+		// TX_INVERT  - 0
+		// TX_DELAY   - 0,1,2,3
+		if ((l < 8) && (l > 3)) {
+			// GIGE Enable and TX_DELAY & GIGE_QUAD
+			rddata = ETH_XMII_GIGE_QUAD_SET(0x1) |
+				ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		// GIGE_QUAD  - 0
+		// TX_INVERT  - 1
+		// TX_DELAY   - 0,1,2,3
+		if ((l < 12) && (l > 7)) {
+			// GIGE Enable and TX_DELAY and TX_INVERT
+			rddata = ETH_XMII_TX_INVERT_SET(0x1) |
+				ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		// GIGE_QUAD  - 0
+		// TX_INVERT  - 1
+		// TX_DELAY   - 0,1,2,3
+		if ((l < 16) && (l > 11)) {
+			// GIGE Enable and TX_DELAY and TX_INVERT and GIGE_QUAD
+			rddata = ETH_XMII_TX_INVERT_SET(0x1) |
+				ETH_XMII_GIGE_QUAD_SET(0x1) |
+				ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		xmii[l] = rddata;
+
+		// counts when to print out counter stats
+		k++;
+		// Set Up Receive Descriptor Table
+		node_rx_buf_len = 0x0;
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 0x1);	// enable dma rx
+		ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, 0x1);	// enable dma tx
+
+        rd_register = node_tx_desc_ptr + (NUM_DESCRIPTORS - 1) * 0x3 + 0x1; 
+        rddata = (*(rd_register) & (1 << 31));
+		while (rddata != (1 << 31))
+			rddata = (*(rd_register) & (1 << 31));
+#if DEBUG
+		printf("TEST: Tx Done \n");
+#endif
+
+		to = 0;
+        rd_register = node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1;
+		rddata = (*(rd_register) & (1 << 31));
+		while (rddata != 0x0) {
+			rddata = (*(rd_register) & (1 << 31));
+			to++;
+			if (to > 100000) {
+#if DEBUG
+				printf("TEST: ERROR!! Atleast 1 packet in GE0 not seen.\n");
+#endif
+				fail = 1;
+				break;
+			}
+		}
+#if DEBUG
+		printf("TEST: Rx Done \n");
+#endif
+
+		if (k % 1 == 0) {
+			for (j = GE0_PEMSTAT_RBYT; j <= GE0_PEMSTAT_RDRP; j = j + 4) {
+				rddata = ath_reg_rd(j);
+				switch (j) {
+#if DEBUG
+				case GE0_PEMSTAT_RPKT:
+					printf("TEST: RPKT - 0x%08x\n", rddata);
+					break;
+				case GE0_PEMSTAT_TPKT:
+					printf("TEST: TPKT - 0x%08x\n", rddata);
+					break;
+#endif
+				}
+			}
+#ifdef ATH_S17_MAC0_SGMII
+			s17_rx_pkt = athrs17_reg_read(0x163c) + (athrs17_reg_read(0x1640) << 16);
+#else
+			s17_rx_pkt = athrs17_reg_read(0x103c) + (athrs17_reg_read(0x1040) << 16);
+#endif
+#if DEBUG
+			printf("TEST: RPKT in S17 0x%08x\n", s17_rx_pkt);
+#endif
+#ifdef ATH_S17_MAC0_SGMII
+			s17_tx_pkt = athrs17_reg_read(0x1684) + (athrs17_reg_read(0x1688) << 16);
+#else
+			s17_tx_pkt = athrs17_reg_read(0x1084) + (athrs17_reg_read(0x1088) << 16);
+#endif
+#if DEBUG
+			printf("TEST: TPKT in S17 0x%08x\n", s17_tx_pkt);
+#endif
+			// Compare BYTES in TX
+			if (s17_tx_pkt != 0x410) {
+#if DEBUG
+				printf("TEST: PKTS @ S17 - 0x%08x\n", rddata);
+#endif
+				pass = 0;
+				fail = 1;
+			}
+
+		}
+		if (fail == 0) {
+			error = pkt_compare_data();
+		}
+		if (error == 0) {
+#if DEBUG
+			printf("TEST: PACKET COMPARISON PASS\n");
+#endif
+		} else {
+#if DEBUG
+			printf("TEST: ERROR!! PACKET COMPARISON FAIL\n");
+#endif
+			fail = 1;
+		}
+
+		for (i = 0; i < NUM_DESCRIPTORS; i++) {
+			*(node_tx_desc_ptr + (i * 0x3) + 0x1) = (node_tx_buf_len & 0x7fffffff);
+			*(node_rx_desc_ptr + (i * 0x3) + 0x1) = (node_rx_buf_len & 0xfff) | (1 << 31);
+		}
+
+		// populate results and find the optimum value of programming
+		results[(l % 4)] = pass;
+		if (((l % 4) == 3)) {
+			lgst = find_value();
+			if (lgst > old_lgst) {
+				old_lgst = lgst;
+				xmii_val = xmii[(l - 3) + find];
+			}
+		}
+	}
+#if DEBUG_1
+	printf("TEST: FINAL REG VAL after TX Calibration - 0x%08x\n", xmii_val);
+#endif
+	tx_fix = xmii_val;
+
+	old_lgst = 0;
+
+	// Using the previously arrived at value of TX Calib we calibrate RX DELAYS. For this we use RX DAT and EN Delays
+	for (l = 0; l < 16; l++) {
+		// initialize pass. this will be made zero if there is a failure in packet reception compare
+		pass = 1;
+		// fail due to checks in rx etc. this is not the same as !pass
+		fail = 0;
+		rddata = ath_reg_rd(ETH_CFG_ADDRESS);
+#if DEBUG
+		printf("TEST: Initial ETH_CFG - 0x%08x\n", rddata);
+#endif
+
+		// RXD_DELAY  - l / 4 -> 0, 1, 2, 3
+		// RXEN_DELAY - l / 4 -> 0, 1, 2, 3
+		// RX_DELAY   - l & 3 -> 0, 1, 2, 3
+		ath_reg_rmw_clear(ETH_CFG_ADDRESS,
+					ETH_CFG_ETH_RXDV_DELAY_MASK |
+					ETH_CFG_ETH_RXD_DELAY_MASK);
+		ath_reg_rmw_set(ETH_CFG_ADDRESS,
+					ETH_CFG_ETH_RXDV_DELAY_SET(l / 4) |
+					ETH_CFG_ETH_RXD_DELAY_SET(l / 4));
+		rddata = ath_reg_rd(ETH_CFG_ADDRESS);
+#if DEBUG
+		printf("TEST: ETH_CFG - 0x%08x\n", rddata);
+#endif
+		eth_cfg[l] = rddata;
+		rddata = tx_fix | ETH_XMII_RX_DELAY_SET(l);
+		ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+
+		xmii[l] = rddata;
+
+		// counts when to print out counter stats
+		k++;
+		// Set Up Receive Descriptor Table
+		node_rx_buf_len = 0x0;
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 0x1);	// enable dma rx
+		ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, 0x1);	// enable dma tx
+        rd_register = node_tx_desc_ptr + (NUM_DESCRIPTORS - 1) * 0x3 + 0x1;
+		rddata = (*(rd_register) & (1 << 31));
+		while (rddata != (1 << 31))
+			rddata = (*(rd_register) & (1 << 31));
+#if DEBUG
+		printf("TEST: Tx Done \n");
+#endif
+
+		to = 0;
+        rd_register = node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1;
+		rddata = (*(rd_register) & (1 << 31));
+		while (rddata != 0x0) {
+			rddata = (*(rd_register) & (1 << 31));
+			to++;
+			if (to > 100000) {
+#if DEBUG
+				printf("TEST: ERROR!! Atleast 1 packet in GE0 not seen.\n");
+#endif
+				// This check for RX.
+				pass = 0;
+				fail = 1;
+				break;
+			}
+		}
+#if DEBUG
+		printf("TEST: Rx Done \n");
+#endif
+
+		if (k % 1 == 0) {
+			for (j = GE0_PEMSTAT_RBYT; j <= GE0_PEMSTAT_RDRP; j = j + 4) {
+				rddata = ath_reg_rd(j);
+				switch (j) {
+#if DEBUG
+				case GE0_PEMSTAT_RPKT:
+					printf("TEST: RPKT 0x%08x\n", rddata);
+					break;
+				case GE0_PEMSTAT_TPKT:
+					printf("TEST: TPKT 0x%08x\n", rddata);
+					break;
+#endif
+				}
+			}
+#ifdef ATH_S17_MAC0_SGMII
+			s17_rx_pkt = athrs17_reg_read(0x163c) + (athrs17_reg_read(0x1640) << 16);
+#else
+			s17_rx_pkt = athrs17_reg_read(0x103c) + (athrs17_reg_read(0x1040) << 16);
+#endif
+#if DEBUG
+			printf("TEST: RPKT in S17 0x%08x\n", s17_rx_pkt);
+#endif
+#ifdef ATH_S17_MAC0_SGMII
+			s17_tx_pkt = athrs17_reg_read(0x1684) + (athrs17_reg_read(0x1688) << 16);
+#else
+			s17_tx_pkt = athrs17_reg_read(0x1084) + (athrs17_reg_read(0x1088) << 16);
+#endif
+#if DEBUG
+			printf("TEST: TPKT in S17 0x%08x\n", s17_tx_pkt);
+#endif
+			// Compare BYTES in TX
+			if (s17_tx_pkt != 0x410) {
+#if DEBUG
+				printf("TEST: PKTS @ S17 - 0x%08x\n", rddata);
+#endif
+				pass = 0;
+				fail = 1;
+			}
+
+		}
+		if (fail == 0) {
+			error = pkt_compare_data();
+		}
+		if (error == 0) {
+			//printf("TEST: PACKET COMPARISON PASS\n");
+		} else {
+#if DEBUG
+			printf("TEST: ERROR!! PACKET COMPARISON FAIL\n");
+#endif
+			fail = 1;
+			// Different from TX. This ensures packets are received back properly for a valid config.
+			pass = 0;
+		}
+
+		for (i = 0; i < NUM_DESCRIPTORS; i++) {
+			*(node_tx_desc_ptr + (i * 0x3) + 0x1) = (node_tx_buf_len & 0x7fffffff);
+			*(node_rx_desc_ptr + (i * 0x3) + 0x1) = (node_rx_buf_len & 0xfff) | (1 << 31);
+		}
+
+		// populate results and find the optimum value of programming
+		// For every set of 4 configurations find longest valid configs and number.
+		results[(l % 4)] = pass;
+		if (((l % 4) == 3)) {
+			lgst = find_value();
+			if (lgst > old_lgst) {
+				old_lgst = lgst;
+				xmii_val = xmii[(l - 3) + find];
+				eth_cfg_val = eth_cfg[(l - 3) + find];
+			}
+		}
+	}
+	// And write to these registers.
+#if DEBUG_1
+	printf("TEST: FINAL XMII VAL after RX Calibration - 0x%08x\n", xmii_val);
+#endif
+	ath_reg_wr(ETH_XMII_ADDRESS, xmii_val);
+#if DEBUG_1
+	printf("TEST: FINAL ETH_CFG VAL after RX Calibration - 0x%08x\n", eth_cfg_val);
+#endif
+	ath_reg_wr(ETH_CFG_ADDRESS, eth_cfg_val);
+	ath_gmac_reg_wr(mac,ATH_MAC_CFG1,1<<31);
+
+}
+
+#endif /* #ifdef RGMII_CAL */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/rgmii-cal-956x.c u-boot_1.1//board/atheros/common/rgmii-cal-956x.c
--- u-boot//board/atheros/common/rgmii-cal-956x.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/rgmii-cal-956x.c	2014-02-18 01:46:24.951051016 -0800
@@ -0,0 +1,626 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+//#include <gmac_defines.h>
+//#include <prototypes.h>
+
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#include <atheros.h>
+#include "qca-eth-956x.h"
+#include "qca-eth-956x_phy.h"
+
+#ifdef ATH_RGMII_CAL
+
+#define NUM_DESCRIPTORS		10	//Number of packets to be looped back
+#define node_tx_buf_len		100	// No of bytes per packet to be looped back
+
+#define DEBUG		0
+#define DEBUG_1 	1
+
+#define GE0_PEMSTAT_RBYT	(0x9c + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RPKT	(0xA0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RFCS	(0xA4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RMCA	(0xA8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RBCA	(0xAC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RXCF	(0xB0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RXPF	(0xB4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RXUO	(0xB8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RALN	(0xBC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RFLR	(0xC0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RCDE	(0xC4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RCSE	(0xC8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RUND	(0xCC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_ROVR	(0xD0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RFRG	(0xD4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RJBR	(0xD8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RDRP	(0xDC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_TPKT	(0xE0 + ATH_GE0_BASE)
+
+#define NUM_DESCS 10
+
+void init_s17_lpbk(void);
+uint32_t athrs17_reg_read(uint32_t reg_addr);
+void athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val);
+
+int results[5] = { 0, 1, 1, 1, 0 };
+
+int find;
+
+void big_del(void)
+{
+	int i;
+	for (i = 0; i < 10000; i++) ;
+}
+
+// This should tell us what the best of the 4 values is. It should also tell us what the longest sequence is.
+// Since only four bits are used the best of 4 values can be easily arrived at by a truth table.
+// Presently we have an algorithm though.
+int find_value(void)
+{
+	int i;
+	int start_ok = 9;
+	int end_ok = 9;
+	int longest_start_ok = 0;
+	int longest_end_ok = 0;
+	int longest_ok_cnt = -1;
+	int first = 0;
+
+	for (i = 0; i < 5; i++) {
+#if DEBUG
+		printf("results [%d]: %d\n", i, results[i]);
+#endif
+		if (results[i] == 1) {
+			if (start_ok == 9) {
+				start_ok = i;
+				if (first == 0) {
+					longest_start_ok = i;
+					longest_end_ok = i;
+					first = 1;
+				}
+			}
+		}
+		if (results[i] == 0) {
+			if (end_ok == 9) {
+				end_ok = i - 1;
+			}
+			if ((end_ok - start_ok) > longest_ok_cnt) {
+				longest_start_ok = start_ok;
+				longest_end_ok = end_ok;
+				longest_ok_cnt = (end_ok - start_ok);
+			}
+			start_ok = 9;
+			end_ok = 9;
+		}
+	}
+
+#if DEBUG
+	printf("FINAL VALUE - ");
+#endif
+	find = (longest_end_ok + longest_start_ok) / 2;
+#if DEBUG
+	printf("find - %d\n", find);
+	printf("FINAL OK COUNT - %d\n", longest_ok_cnt + 1);
+#endif
+	return (longest_ok_cnt + 1);
+}
+
+int pkt_compare_data(void)
+{
+	unsigned int i, j;
+	//unsigned int k,rddata;
+	unsigned int node_rx_buf_len;
+	//unsigned int * node_tx_desc_ptr = (unsigned int *) 0xa0280000;
+	unsigned int *node_rx_desc_ptr = (unsigned int *)0xa0380000;
+	unsigned int *node_tx_buf_addr = (unsigned int *)0xa0680000;
+	unsigned int *node_rx_buf_addr = (unsigned int *)0xa0580000;
+	unsigned int error = 0;
+	unsigned pkt_err[NUM_DESCS];
+
+	node_rx_buf_len = (*(node_rx_desc_ptr + 0x1) & 0xfff) - 0x4;
+	// node_tx_buf_len = *(node_tx_desc_ptr + (NUM_DESCS-1)*0x3+0x1) & 0xfff;
+
+	for (j = 0; j < NUM_DESCS; j++) {
+		node_rx_buf_len = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & 0xfff) - 0x4;
+		pkt_err[j] = 0;
+		for (i = 0; i < (node_rx_buf_len / 4); i++) {
+			if (((*(node_rx_buf_addr + i + (j * 0x100))) != *(node_tx_buf_addr + i))) {
+				error = error + 0x1;
+				pkt_err[j] = 1;
+			}
+		}
+		//node_rx_buf_addr = node_rx_buf_addr + 0x100;
+	}
+	if (error == 0) {
+		return 0;
+	} else {
+		for (j = 0; j < NUM_DESCS; j++) {
+			node_rx_buf_len = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & 0xfff) - 0x4;
+			if (pkt_err[j] == 1) {
+#if DEBUG
+				printf("PKT %d\n", j);
+				printf("---------------------------------\n");
+
+				for (i = 0; i < (node_rx_buf_len / 4); i++) {
+					//if(((*(node_rx_buf_addr + i )) != *(node_tx_buf_addr + i)))
+					if (((*(node_rx_buf_addr + i + (j * 0x100))) != *(node_tx_buf_addr + i))) {
+						printf("->");
+					} else {
+						printf("  ");
+					}
+					printf("%x", (*(node_rx_buf_addr + i + (j * 0x100))));
+					printf("  ");
+					printf("%x\n", (*(node_tx_buf_addr + i)));
+				}
+				printf("---------------------------------\n");
+#endif
+			}
+			//node_rx_buf_addr = node_rx_buf_addr + 0x100;
+		}
+		return 1;
+	}
+}
+
+void rgmii_calib(ath_gmac_mac_t * mac)
+{
+
+	unsigned int i;
+	unsigned int j;
+	unsigned int k, l, m;
+	unsigned int rddata, error = 0;
+    volatile unsigned int * rd_register;
+	unsigned int node_rx_buf_len = 1600;
+	unsigned int node_rx_buf_len1;
+	unsigned int *node_tx_desc_ptr = (unsigned int *)0xa0280000;
+	unsigned int *node_rx_desc_ptr = (unsigned int *)0xa0380000;
+	unsigned int *node_rx_buf_addr = (unsigned int *)0xa0580000;
+	unsigned int *node_tx_buf_addr = (unsigned int *)0xa0680000;
+	unsigned int *node_comp_result = (unsigned int *)0xa0200000;
+	unsigned int s17_tx_pkt = 0;
+	unsigned int s17_rx_pkt = 0;
+	unsigned int to;
+	unsigned int pass = 1;
+	unsigned int fail = 0;
+	int lgst = 0;
+	int old_lgst = 0;
+	unsigned int xmii[16];
+	unsigned int eth_cfg[16];
+	unsigned int xmii_val = 0;
+	unsigned int eth_cfg_val = 1;
+	unsigned int tx_fix = 0;
+
+
+	// GIGE Enable
+	ath_reg_wr(ETH_XMII_ADDRESS,	ETH_XMII_TX_INVERT_SET(0x1) |
+					ETH_XMII_RX_DELAY_SET(0x2) |
+					ETH_XMII_TX_DELAY_SET(0x1) |
+					ETH_XMII_GIGE_SET(0x1));
+
+	while ((ath_reg_rd(SGMII_SERDES_ADDRESS) & SGMII_SERDES_LOCK_DETECT_STATUS_SET(1)) == 0) {
+		printf("TEST: WAIT FOR LOCK\n");
+	}
+
+	big_del();
+
+	// MAC INITS
+	// RGMII Enable on GE0
+	//eth_init();
+	init_s17_lpbk();
+	athrs17_reg_write(0x30, 1);
+
+	ath_reg_wr(ETH_CFG_ADDRESS,	ETH_CFG_ETH_RXDV_DELAY_SET(0x3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(0x3) |
+					ETH_CFG_RGMII_GE0_SET(0x1));
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_GE0_MAC_RESET_MASK);	// Bringing GE0 out of RESET
+	ath_gmac_reg_wr(mac, ATH_MAC_CFG2, 0x7235);	//for 1000mbps
+	//ath_reg_wr(GE0_MAC_CONFIG_2,0x7135);  //for 100mbps
+	ath_gmac_reg_wr(mac, ATH_MAC_IFCTL, 0x00000);
+	ath_gmac_reg_wr(mac, ATH_MAC_CFG1, 0x005);
+	//ath_reg_wr(GE0_MAC_CONFIG_1,0x105);  // For MAC Loopback
+	ath_gmac_reg_wr(mac, ATH_DMA_INTR_MASK, 0);	// Disable interrupt mask
+	ath_gmac_reg_wr(mac, ATH_GE_MAC_ADDR1, 0x003fffff);	//ethernet mac address
+	ath_gmac_reg_wr(mac, ATH_GE_MAC_ADDR2, 0xfffe0000);	//ethernet mac address
+	ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, 0x6);	//clock/20= 2MHz
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);	// Enable the FIFO modules
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_1, 0x10ffff);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_3, 0x1f00140);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_4, 0x1000);
+	//ath_reg_wr(GE0_FIFO_CFG_REG_5, 0xbefff); //enable drop
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_5, 0xfffff);	//for 1000Mbps
+	//ath_reg_wr(GE0_FIFO_CFG_REG_5, 0x7ffff);//for 100Mbps
+
+	//************
+	// PACKETS
+	//***********
+
+	// Initialise Data in Memory for TX and RX
+	for (i = 0; i < node_tx_buf_len; i++)
+		*(node_tx_buf_addr + i) = i | (i + 1) << 8 | (i + 2) << 16 | (i + 3) << 24;
+
+#if DEBUG
+	printf("TEST: Inits Done\n");
+#endif
+	// Set Up Transmit Descriptor Table
+
+	for (i = 0; i < NUM_DESCRIPTORS; i++) {
+		*(node_tx_desc_ptr + (i * 0x3)) = ((unsigned int)node_tx_buf_addr & 0x0fffffff);
+		*(node_tx_desc_ptr + (i * 0x3) + 0x1) = (node_tx_buf_len & 0x7fffffff);
+
+		if (i == (NUM_DESCRIPTORS - 1))
+			*(node_tx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_tx_desc_ptr & 0x0fffffff);
+		else
+			*(node_tx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_tx_desc_ptr & 0x0fffffff) + (i * 0xc) + 0xc;
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_DESC, ((unsigned int)node_tx_desc_ptr & 0x0fffffff));
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_STATUS, 0xfffffff);	// clear dma status
+
+	for (i = 0; i < NUM_DESCRIPTORS; i++) {
+		*(node_rx_desc_ptr + (i * 0x3)) = ((unsigned int)node_rx_buf_addr & 0x0fffffff);
+		*(node_rx_desc_ptr + (i * 0x3) + 0x1) = (node_rx_buf_len & 0xfff) | (1 << 31);
+		if (i == (NUM_DESCRIPTORS - 1))
+			*(node_rx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_rx_desc_ptr & 0x0fffffff);
+		else
+			*(node_rx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_rx_desc_ptr & 0x0fffffff) + (i * 0xc) + 0xc;
+		node_rx_buf_addr = node_rx_buf_addr + 0x100;
+
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, ((unsigned int)node_rx_desc_ptr & 0x0fffffff));
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_STATUS, 0xfffffff);	// clear dma status
+
+	k = 0;
+
+	// Enable TX and RX MAC
+	ath_gmac_reg_wr(mac, ATH_MAC_CFG1, 0x005);
+
+	// This routine will go through 16 combinations to find the best value for TX_DELAY, GIGE_QUAD, TX_INVERT
+	for (l = 0; l < 16; l++) {
+		// initialize pass. this will be made zero if there is a failure in packet reception compare
+		pass = 1;
+		// fail due to checks in rx etc. this is not the same as !pass
+		fail = 0;
+
+		// GIGE_QUAD  - 0
+		// TX_INVERT  - 0
+		// TX_DELAY   - 0,1,2,3
+		if (l < 4) {
+			// GIGE Enable and TX_DELAY
+			rddata = ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		// GIGE_QUAD  - 1
+		// TX_INVERT  - 0
+		// TX_DELAY   - 0,1,2,3
+		if ((l < 8) && (l > 3)) {
+			// GIGE Enable and TX_DELAY & GIGE_QUAD
+			rddata = ETH_XMII_GIGE_QUAD_SET(0x1) |
+				ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		// GIGE_QUAD  - 0
+		// TX_INVERT  - 1
+		// TX_DELAY   - 0,1,2,3
+		if ((l < 12) && (l > 7)) {
+			// GIGE Enable and TX_DELAY and TX_INVERT
+			rddata = ETH_XMII_TX_INVERT_SET(0x1) |
+				ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		// GIGE_QUAD  - 0
+		// TX_INVERT  - 1
+		// TX_DELAY   - 0,1,2,3
+		if ((l < 16) && (l > 11)) {
+			// GIGE Enable and TX_DELAY and TX_INVERT and GIGE_QUAD
+			rddata = ETH_XMII_TX_INVERT_SET(0x1) |
+				ETH_XMII_GIGE_QUAD_SET(0x1) |
+				ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		xmii[l] = rddata;
+
+		// counts when to print out counter stats
+		k++;
+		// Set Up Receive Descriptor Table
+		node_rx_buf_len = 0x0;
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 0x1);	// enable dma rx
+		ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, 0x1);	// enable dma tx
+
+        rd_register = node_tx_desc_ptr + (NUM_DESCRIPTORS - 1) * 0x3 + 0x1; 
+        rddata = (*(rd_register) & (1 << 31));
+		while (rddata != (1 << 31))
+			rddata = (*(rd_register) & (1 << 31));
+#if DEBUG
+		printf("TEST: Tx Done \n");
+#endif
+
+		to = 0;
+        rd_register = node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1;
+		rddata = (*(rd_register) & (1 << 31));
+		while (rddata != 0x0) {
+			rddata = (*(rd_register) & (1 << 31));
+			to++;
+			if (to > 100000) {
+#if DEBUG
+				printf("TEST: ERROR!! Atleast 1 packet in GE0 not seen.\n");
+#endif
+				fail = 1;
+				break;
+			}
+		}
+#if DEBUG
+		printf("TEST: Rx Done \n");
+#endif
+
+		if (k % 1 == 0) {
+			for (j = GE0_PEMSTAT_RBYT; j <= GE0_PEMSTAT_RDRP; j = j + 4) {
+				rddata = ath_reg_rd(j);
+				switch (j) {
+#if DEBUG
+				case GE0_PEMSTAT_RPKT:
+					printf("TEST: RPKT - 0x%08x\n", rddata);
+					break;
+				case GE0_PEMSTAT_TPKT:
+					printf("TEST: TPKT - 0x%08x\n", rddata);
+					break;
+#endif
+				}
+			}
+#ifdef ATH_S17_MAC0_SGMII
+			s17_rx_pkt = athrs17_reg_read(0x163c) + (athrs17_reg_read(0x1640) << 16);
+#else
+			s17_rx_pkt = athrs17_reg_read(0x103c) + (athrs17_reg_read(0x1040) << 16);
+#endif
+#if DEBUG
+			printf("TEST: RPKT in S17 0x%08x\n", s17_rx_pkt);
+#endif
+#ifdef ATH_S17_MAC0_SGMII
+			s17_tx_pkt = athrs17_reg_read(0x1684) + (athrs17_reg_read(0x1688) << 16);
+#else
+			s17_tx_pkt = athrs17_reg_read(0x1084) + (athrs17_reg_read(0x1088) << 16);
+#endif
+#if DEBUG
+			printf("TEST: TPKT in S17 0x%08x\n", s17_tx_pkt);
+#endif
+			// Compare BYTES in TX
+			if (s17_tx_pkt != 0x410) {
+#if DEBUG
+				printf("TEST: PKTS @ S17 - 0x%08x\n", rddata);
+#endif
+				pass = 0;
+				fail = 1;
+			}
+
+		}
+		if (fail == 0) {
+			error = pkt_compare_data();
+		}
+		if (error == 0) {
+#if DEBUG
+			printf("TEST: PACKET COMPARISON PASS\n");
+#endif
+		} else {
+#if DEBUG
+			printf("TEST: ERROR!! PACKET COMPARISON FAIL\n");
+#endif
+			fail = 1;
+		}
+
+		for (i = 0; i < NUM_DESCRIPTORS; i++) {
+			*(node_tx_desc_ptr + (i * 0x3) + 0x1) = (node_tx_buf_len & 0x7fffffff);
+			*(node_rx_desc_ptr + (i * 0x3) + 0x1) = (node_rx_buf_len & 0xfff) | (1 << 31);
+		}
+
+		// populate results and find the optimum value of programming
+		results[(l % 4)] = pass;
+		if (((l % 4) == 3)) {
+			lgst = find_value();
+			if (lgst > old_lgst) {
+				old_lgst = lgst;
+				xmii_val = xmii[(l - 3) + find];
+			}
+		}
+	}
+#if DEBUG_1
+	printf("TEST: FINAL REG VAL after TX Calibration - 0x%08x\n", xmii_val);
+#endif
+	tx_fix = xmii_val;
+
+	old_lgst = 0;
+
+	// Using the previously arrived at value of TX Calib we calibrate RX DELAYS. For this we use RX DAT and EN Delays
+	for (l = 0; l < 16; l++) {
+		// initialize pass. this will be made zero if there is a failure in packet reception compare
+		pass = 1;
+		// fail due to checks in rx etc. this is not the same as !pass
+		fail = 0;
+		rddata = ath_reg_rd(ETH_CFG_ADDRESS);
+#if DEBUG
+		printf("TEST: Initial ETH_CFG - 0x%08x\n", rddata);
+#endif
+
+		// RXD_DELAY  - l / 4 -> 0, 1, 2, 3
+		// RXEN_DELAY - l / 4 -> 0, 1, 2, 3
+		// RX_DELAY   - l & 3 -> 0, 1, 2, 3
+		ath_reg_rmw_clear(ETH_CFG_ADDRESS,
+					ETH_CFG_ETH_RXDV_DELAY_MASK |
+					ETH_CFG_ETH_RXD_DELAY_MASK);
+		ath_reg_rmw_set(ETH_CFG_ADDRESS,
+					ETH_CFG_ETH_RXDV_DELAY_SET(l / 4) |
+					ETH_CFG_ETH_RXD_DELAY_SET(l / 4));
+		rddata = ath_reg_rd(ETH_CFG_ADDRESS);
+#if DEBUG
+		printf("TEST: ETH_CFG - 0x%08x\n", rddata);
+#endif
+		eth_cfg[l] = rddata;
+		rddata = tx_fix | ETH_XMII_RX_DELAY_SET(l);
+		ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+
+		xmii[l] = rddata;
+
+		// counts when to print out counter stats
+		k++;
+		// Set Up Receive Descriptor Table
+		node_rx_buf_len = 0x0;
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 0x1);	// enable dma rx
+		ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, 0x1);	// enable dma tx
+        rd_register = node_tx_desc_ptr + (NUM_DESCRIPTORS - 1) * 0x3 + 0x1;
+		rddata = (*(rd_register) & (1 << 31));
+		while (rddata != (1 << 31))
+			rddata = (*(rd_register) & (1 << 31));
+#if DEBUG
+		printf("TEST: Tx Done \n");
+#endif
+
+		to = 0;
+        rd_register = node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1;
+		rddata = (*(rd_register) & (1 << 31));
+		while (rddata != 0x0) {
+			rddata = (*(rd_register) & (1 << 31));
+			to++;
+			if (to > 100000) {
+#if DEBUG
+				printf("TEST: ERROR!! Atleast 1 packet in GE0 not seen.\n");
+#endif
+				// This check for RX.
+				pass = 0;
+				fail = 1;
+				break;
+			}
+		}
+#if DEBUG
+		printf("TEST: Rx Done \n");
+#endif
+
+		if (k % 1 == 0) {
+			for (j = GE0_PEMSTAT_RBYT; j <= GE0_PEMSTAT_RDRP; j = j + 4) {
+				rddata = ath_reg_rd(j);
+				switch (j) {
+#if DEBUG
+				case GE0_PEMSTAT_RPKT:
+					printf("TEST: RPKT 0x%08x\n", rddata);
+					break;
+				case GE0_PEMSTAT_TPKT:
+					printf("TEST: TPKT 0x%08x\n", rddata);
+					break;
+#endif
+				}
+			}
+#ifdef ATH_S17_MAC0_SGMII
+			s17_rx_pkt = athrs17_reg_read(0x163c) + (athrs17_reg_read(0x1640) << 16);
+#else
+			s17_rx_pkt = athrs17_reg_read(0x103c) + (athrs17_reg_read(0x1040) << 16);
+#endif
+#if DEBUG
+			printf("TEST: RPKT in S17 0x%08x\n", s17_rx_pkt);
+#endif
+#ifdef ATH_S17_MAC0_SGMII
+			s17_tx_pkt = athrs17_reg_read(0x1684) + (athrs17_reg_read(0x1688) << 16);
+#else
+			s17_tx_pkt = athrs17_reg_read(0x1084) + (athrs17_reg_read(0x1088) << 16);
+#endif
+#if DEBUG
+			printf("TEST: TPKT in S17 0x%08x\n", s17_tx_pkt);
+#endif
+			// Compare BYTES in TX
+			if (s17_tx_pkt != 0x410) {
+#if DEBUG
+				printf("TEST: PKTS @ S17 - 0x%08x\n", rddata);
+#endif
+				pass = 0;
+				fail = 1;
+			}
+
+		}
+		if (fail == 0) {
+			error = pkt_compare_data();
+		}
+		if (error == 0) {
+			//printf("TEST: PACKET COMPARISON PASS\n");
+		} else {
+#if DEBUG
+			printf("TEST: ERROR!! PACKET COMPARISON FAIL\n");
+#endif
+			fail = 1;
+			// Different from TX. This ensures packets are received back properly for a valid config.
+			pass = 0;
+		}
+
+		for (i = 0; i < NUM_DESCRIPTORS; i++) {
+			*(node_tx_desc_ptr + (i * 0x3) + 0x1) = (node_tx_buf_len & 0x7fffffff);
+			*(node_rx_desc_ptr + (i * 0x3) + 0x1) = (node_rx_buf_len & 0xfff) | (1 << 31);
+		}
+
+		// populate results and find the optimum value of programming
+		// For every set of 4 configurations find longest valid configs and number.
+		results[(l % 4)] = pass;
+		if (((l % 4) == 3)) {
+			lgst = find_value();
+			if (lgst > old_lgst) {
+				old_lgst = lgst;
+				xmii_val = xmii[(l - 3) + find];
+				eth_cfg_val = eth_cfg[(l - 3) + find];
+			}
+		}
+	}
+	// And write to these registers.
+#if DEBUG_1
+	printf("TEST: FINAL XMII VAL after RX Calibration - 0x%08x\n", xmii_val);
+#endif
+	ath_reg_wr(ETH_XMII_ADDRESS, xmii_val);
+#if DEBUG_1
+	printf("TEST: FINAL ETH_CFG VAL after RX Calibration - 0x%08x\n", eth_cfg_val);
+#endif
+	ath_reg_wr(ETH_CFG_ADDRESS, eth_cfg_val);
+	ath_gmac_reg_wr(mac,ATH_MAC_CFG1,1<<31);
+
+}
+
+#endif /* #ifdef RGMII_CAL */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/serial.c u-boot_1.1//board/atheros/common/serial.c
--- u-boot//board/atheros/common/serial.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/serial.c	2014-02-18 01:46:24.951051016 -0800
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <config.h>
+#include <atheros.h>
+
+int serial_init(void)
+{
+//#if !defined(CONFIG_ATH_EMULATION)
+	uint32_t div, val;
+
+	div = ath_uart_freq() / (16 * CONFIG_BAUDRATE);
+#if defined(CONFIG_SCO_SLAVE_CONNECTED)
+	val = ath_reg_rd(GPIO_OE_ADDRESS) & (~0xcbf410u);
+#elif defined(CONFIG_MACH_QCA956x)
+	val = ath_reg_rd(GPIO_OE_ADDRESS) & 0xbbfdf6;
+#else
+	val = ath_reg_rd(GPIO_OE_ADDRESS) & (~0xcffc10u);
+#endif
+	ath_reg_wr(GPIO_OE_ADDRESS, val);
+
+#ifdef CONFIG_MACH_QCA956x
+
+#if defined(UART_RX20_TX22)
+
+	val = (ath_reg_rd(GPIO_OE_ADDRESS) & (~0x400000));
+	ath_reg_wr(GPIO_OE_ADDRESS, val);
+
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION5_ADDRESS,
+			GPIO_OUT_FUNCTION5_ENABLE_GPIO_22_MASK);
+
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION5_ADDRESS,
+			GPIO_OUT_FUNCTION5_ENABLE_GPIO_22_SET(0x16));
+
+	ath_reg_rmw_clear(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_MASK);
+   
+	ath_reg_rmw_set(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0x14));
+#elif defined(UART_RX18_TX22)
+	val = (ath_reg_rd(GPIO_OE_ADDRESS) & (~0x400000)) | 0x40000;
+	ath_reg_wr(GPIO_OE_ADDRESS, val);
+
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION5_ADDRESS,
+			GPIO_OUT_FUNCTION5_ENABLE_GPIO_22_MASK);
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION5_ADDRESS,
+			GPIO_OUT_FUNCTION5_ENABLE_GPIO_22_SET(0x16));
+	ath_reg_rmw_clear(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_MASK);
+  
+	ath_reg_rmw_set(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0x12));
+
+#elif defined(UART_RX18_TX20)
+	val = (ath_reg_rd(GPIO_OE_ADDRESS) & (~0x100000)) | 0x40000;
+	ath_reg_wr(GPIO_OE_ADDRESS, val);
+
+	val = ath_reg_rd(GPIO_OUT_ADDRESS) | 0xeffff6;
+	ath_reg_wr(GPIO_OUT_ADDRESS, val);
+
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION5_ADDRESS,
+			GPIO_OUT_FUNCTION5_ENABLE_GPIO_20_MASK);
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION5_ADDRESS,
+			GPIO_OUT_FUNCTION5_ENABLE_GPIO_20_SET(0x16));
+	ath_reg_rmw_clear(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_MASK);
+  
+	ath_reg_rmw_set(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0x12));
+
+#elif defined(UART_RX24_TX20)
+	// Turn off LED before XLNA swap to GPO
+	val = ath_reg_rd(GPIO_OUT_ADDRESS) | 0xaffff6;
+	ath_reg_wr(GPIO_OUT_ADDRESS, val);
+	//Switch GPI and GPO and XPA, XLNA
+	ath_reg_wr(GPIO_FUNCTION_ADDRESS, 0x8000);
+
+	val = (ath_reg_rd(GPIO_OE_ADDRESS) & (~0x100000)) | 0x1000000;
+	ath_reg_wr(GPIO_OE_ADDRESS, val);
+
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION5_ADDRESS,
+			GPIO_OUT_FUNCTION5_ENABLE_GPIO_20_SET(0x16));
+	ath_reg_rmw_clear(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0xff));
+
+	ath_reg_rmw_set(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0x18));
+  
+#elif defined(TEST_BOARD_UART)
+	//Switch GPI and GPO and XPA1, ANTC
+	ath_reg_wr(GPIO_FUNCTION_ADDRESS, 0xc000);
+
+	val = ath_reg_rd(GPIO_OE_ADDRESS) & (~0x2000);
+	ath_reg_wr(GPIO_OE_ADDRESS, val);
+
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION3_ADDRESS,
+			GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK);
+
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION3_ADDRESS,
+			GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_SET(0x16));
+	
+	ath_reg_rmw_clear(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0xff));
+
+	ath_reg_rmw_set(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0x17));
+
+#else
+	val = (ath_reg_rd(GPIO_OE_ADDRESS) & (~0x100000)) | 0x80000;
+	ath_reg_wr(GPIO_OE_ADDRESS, val);
+
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION5_ADDRESS,
+			GPIO_OUT_FUNCTION5_ENABLE_GPIO_20_SET(0x16));
+	ath_reg_rmw_clear(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0xff));
+
+	ath_reg_rmw_set(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0x13));
+
+#endif
+
+	val = ath_reg_rd(GPIO_OUT_ADDRESS) | 0xaffff6;
+	ath_reg_wr(GPIO_OUT_ADDRESS, val);
+
+	val = ath_reg_rd(GPIO_SPARE_ADDRESS);
+	ath_reg_wr(GPIO_SPARE_ADDRESS, (val | 0x8402));
+
+
+#else
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION2_ADDRESS,
+			GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_SET(0x16));
+
+	ath_reg_rmw_clear(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0xff));
+
+	ath_reg_rmw_set(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0x9));
+
+	val = ath_reg_rd(GPIO_OUT_ADDRESS) | 0xcffc10u;
+	ath_reg_wr(GPIO_OUT_ADDRESS, val);
+
+	val = ath_reg_rd(GPIO_SPARE_ADDRESS);
+	ath_reg_wr(GPIO_SPARE_ADDRESS, (val | 0x8402));
+
+	ath_reg_wr(GPIO_OUT_ADDRESS, 0x2f);
+#endif
+	/*
+	 * set DIAB bit
+	 */
+	ath_uart_wr(OFS_LINE_CONTROL, 0x80);
+
+	/* set divisor */
+	ath_uart_wr(OFS_DIVISOR_LSB, (div & 0xff));
+	ath_uart_wr(OFS_DIVISOR_MSB, ((div >> 8) & 0xff));
+
+	/* clear DIAB bit*/
+	ath_uart_wr(OFS_LINE_CONTROL, 0x00);
+
+	/* set data format */
+	ath_uart_wr(OFS_DATA_FORMAT, 0x3);
+
+	ath_uart_wr(OFS_INTR_ENABLE, 0);
+//#endif
+	return 0;
+}
+
+int serial_tstc (void)
+{
+	return(ath_uart_rd(OFS_LINE_STATUS) & 0x1);
+}
+
+u8 serial_getc(void)
+{
+	while(!serial_tstc());
+
+	return ath_uart_rd(OFS_RCV_BUFFER);
+}
+
+
+void serial_putc(u8 byte)
+{
+	if (byte == '\n') serial_putc ('\r');
+
+	while (((ath_uart_rd(OFS_LINE_STATUS)) & 0x20) == 0x0);
+
+	ath_uart_wr(OFS_SEND_BUFFER, byte);
+}
+
+void serial_setbrg (void)
+{
+}
+
+void serial_puts (const char *s)
+{
+	while (*s)
+	{
+		serial_putc (*s++);
+	}
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/tap-953x.S u-boot_1.1//board/atheros/common/tap-953x.S
--- u-boot//board/atheros/common/tap-953x.S	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/tap-953x.S	2014-02-18 01:46:24.951051016 -0800
@@ -0,0 +1,204 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+.globl ath_ddr_tap_cal
+	.type	ath_ddr_tap_cal,	@function
+	.text
+	.align 4
+ath_ddr_tap_cal:
+	li	a0,	0xbd001f00
+	sw	zero,	0x0(a0)			// Place where the tap values are saved and used for SWEEP
+	sw	zero,	0x4(a0)			// Place where the number of passing taps are saved.
+	sw	zero,	0x14(a0)		// Place where the last pass tap value is stored
+	li	a1,	0xaa55aa55		// Indicates that the First pass tap value is not found
+	sw	a1,	0x10(a0)		// Place where the First pass tap value is stored
+	nop
+
+	li	a0,	0xb8060000		// RESET_BASE_ADDRESS
+	lw	a1,	0x1c(a0)		// Reading the RST_RESET_ADDRESS
+	li	a2,	0x08000000		// Setting the RST_RESET_RTC_RESET
+	or	a1,	a1,	a2
+	sw	a1,	0x1c(a0)
+
+	li	a3,	0xffffffff
+	xor	a2,	a2,	a3
+	and	a1,	a1,	a2
+	sw	a1,	0x1c(a0)		// Taking the RTC out of RESET
+	nop
+
+	li	a0,	0xb8107000		// RTC_BASE_ADDRESS
+	li	a1,	0x1
+	sw	a1,	0x0040(a0)		// RTC_SYNC_RESET_ADDRESS
+
+	li	a2,	0x2
+
+_poll_for_RTC_ON:
+	lw	a1,	0x0044(a0)		// RTC_SYNC_STATUS_ADDRESS
+	and	a1,	a2,	a1
+	bne	a1,	a2,	_poll_for_RTC_ON
+
+
+_CHANGE_TAPS:
+
+	li	t0,	0xbd001f00		// Read the current value of the TAP for programming
+	lw	t1,	0x0(t0)
+	li	t2,	0x00000000
+	or	t3,	t1,	t2
+
+
+	li	t0,	0xb8000000		// DDR_BASE_ADDRESS
+
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	li	t1,	0x00000010		// Running the test 8 times
+	sw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+
+	li	t1,	0xfa5de83f		// 4 Row Address Bits, 4 Column Address Bits, 2 BA bits
+	sw	t1,	0x002c(t0)		// PERF_MASK_ADDR_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x00000001
+	sw	t1,	0x011c(t0)		// DDR_BIST_ADDRESS
+
+	li	t2,	0x1
+_bist_done_poll:
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	and	t1,	t1,	t2
+	bne	t1,	t2,	_bist_done_poll
+
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	li	t4,	0x000001fe
+	and	t2,	t1,	t4
+	srl	t2,	t2,	0x1		// no. of Pass Runs
+
+	li	t5,	0x00000000
+	sw	t5,	0x011c(t0)		//DDR_BIST_ADDRESS	- Stop the DDR BIST test
+
+	li	t5,	0x0001fe00
+	and	t5,	t5,	t1
+	bnez	t5,	_iterate_tap		// This is a redundant compare but nevertheless - Comparing the FAILS
+
+	lw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+	li	t3,	0x000001fe
+	and	t3,	t3,	t1
+	srl	t3,	t3,	0x1		// No. of runs in the config register.
+
+	bne	t3,	t2,	_iterate_tap
+
+pass_tap:
+	li	t0,	0xbd001f00
+	lw	t1,	0x4(t0)
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x4(t0)
+
+	li	t0,	0xbd001f10
+	lw	t1,	0x0(t0)
+	li	t2,	0xaa55aa55
+	beq	t1,	t2,	_first_pass
+	nop
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd001f10
+	sw	t1,	0x4(t0)
+	nop
+	b	_iterate_tap
+	nop
+
+_first_pass:
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd001f10
+	sw	t1,	0x0(t0)
+	sw	t1,	0x4(t0)
+	nop
+
+_iterate_tap:
+
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t2,	0x3f
+	beq	t1,	t2,	_STOP_TEST
+	nop
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x0(t0)
+	nop
+	b	_CHANGE_TAPS
+
+_STOP_TEST:
+	li	t0,	0xbd001f00
+	lw	t1,	0x4(t0)
+	bnez	t1,	_load_center_tap
+	nop
+	li	t3,	0x8			// Default Tap to be used
+	b	_load_tap_into_reg
+
+_load_center_tap:
+	li	t0,	0xbd001f10
+	lw	t1,	0x0(t0)
+	lw	t2,	0x4(t0)
+	add	t3,	t1,	t2
+	srl	t3,	t3,	0x1
+	li	t4,	0x3f
+	and	t3,	t3,	t4
+_load_tap_into_reg:
+	li	t0,	0xb8000000
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	jr	ra
+	nop
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/tap-955x.S u-boot_1.1//board/atheros/common/tap-955x.S
--- u-boot//board/atheros/common/tap-955x.S	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/tap-955x.S	2014-02-18 01:46:24.951051016 -0800
@@ -0,0 +1,206 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+.globl ath_ddr_tap_cal
+	.type	ath_ddr_tap_cal,	@function
+	.text
+	.align 4
+ath_ddr_tap_cal:
+
+	li	a0,	0xbd007f00
+	sw	zero,	0x0(a0)			// Place where the tap values are saved and used for SWEEP
+	sw	zero,	0x4(a0)			// Place where the number of passing taps are saved.
+	sw	zero,	0x14(a0)		// Place where the last pass tap value is stored
+	li	a1,	0xaa55aa55		// Indicates that the First pass tap value is not found
+	sw	a1,	0x10(a0)		// Place where the First pass tap value is stored
+	nop
+
+	li	a0,	0xb8060000		// RESET_BASE_ADDRESS
+	lw	a1,	0x1c(a0)		// Reading the RST_RESET_ADDRESS
+	li	a2,	0x08000000		// Setting the RST_RESET_RTC_RESET
+	or	a1,	a1,	a2
+	sw	a1,	0x1c(a0)
+
+	li	a3,	0xffffffff
+	xor	a2,	a2,	a3
+	and	a1,	a1,	a2
+	sw	a1,	0x1c(a0)		// Taking the RTC out of RESET
+	nop
+
+	li	a0,	0xb8107000		// RTC_BASE_ADDRESS
+	li	a1,	0x1
+	sw	a1,	0x0040(a0)		// RTC_SYNC_RESET_ADDRESS
+
+	li	a2,	0x2
+
+_poll_for_RTC_ON:
+	lw	a1,	0x0044(a0)		// RTC_SYNC_STATUS_ADDRESS
+	and	a1,	a2,	a1
+	bne	a1,	a2,	_poll_for_RTC_ON
+
+
+_CHANGE_TAPS:
+
+	li	t0,	0xbd007f00		// Read the current value of the TAP for programming
+	lw	t1,	0x0(t0)
+	li	t2,	0x00000000
+	or	t3,	t1,	t2
+
+
+	li	t0,	0xb8000000		// DDR_BASE_ADDRESS
+
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	li	t1,	0x00000010		// Running the test 8 times
+	sw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+
+	li	t1,	0xfa5de83f		// 4 Row Address Bits, 4 Column Address Bits, 2 BA bits
+	sw	t1,	0x002c(t0)		// PERF_MASK_ADDR_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x00000001
+	sw	t1,	0x011c(t0)		// DDR_BIST_ADDRESS
+
+	li	t2,	0x1
+_bist_done_poll:
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	and	t1,	t1,	t2
+	bne	t1,	t2,	_bist_done_poll
+
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	li	t4,	0x000001fe
+	and	t2,	t1,	t4
+	srl	t2,	t2,	0x1		// no. of Pass Runs
+
+	li	t5,	0x00000000
+	sw	t5,	0x011c(t0)		//DDR_BIST_ADDRESS	- Stop the DDR BIST test
+
+	li	t5,	0x0001fe00
+	and	t5,	t5,	t1
+	bnez	t5,	_iterate_tap		// This is a redundant compare but nevertheless - Comparing the FAILS
+
+	lw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+	li	t3,	0x000001fe
+	and	t3,	t3,	t1
+	srl	t3,	t3,	0x1		// No. of runs in the config register.
+
+	bne	t3,	t2,	_iterate_tap
+
+pass_tap:
+	li	t0,	0xbd007f00
+	lw	t1,	0x4(t0)
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x4(t0)
+
+	li	t0,	0xbd007f10
+	lw	t1,	0x0(t0)
+	li	t2,	0xaa55aa55
+	beq	t1,	t2,	_first_pass
+	nop
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd007f10
+	sw	t1,	0x4(t0)
+	nop
+	b	_iterate_tap
+	nop
+
+_first_pass:
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd007f10
+	sw	t1,	0x0(t0)
+	sw	t1,	0x4(t0)
+	nop
+
+_iterate_tap:
+
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t2,	0x3f
+	beq	t1,	t2,	_STOP_TEST
+	nop
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x0(t0)
+	nop
+	b	_CHANGE_TAPS
+
+_STOP_TEST:
+	li	t0,	0xbd007f00
+	lw	t1,	0x4(t0)
+	bnez	t1,	_load_center_tap
+	nop
+	li	t3,	0x8			// Default Tap to be used
+	b	_load_tap_into_reg
+
+_load_center_tap:
+	li	t0,	0xbd007f10
+	lw	t1,	0x0(t0)
+	lw	t2,	0x4(t0)
+	add	t3,	t1,	t2
+	srl	t3,	t3,	0x1
+	li	t4,	0x3f
+	and	t3,	t3,	t4
+
+_load_tap_into_reg:
+	li	t0,	0xb8000000
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	jr	ra
+	nop
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/common/tap-956x.S u-boot_1.1//board/atheros/common/tap-956x.S
--- u-boot//board/atheros/common/tap-956x.S	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/common/tap-956x.S	2014-02-18 01:46:24.951051016 -0800
@@ -0,0 +1,204 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+.globl ath_ddr_tap_cal
+	.type	ath_ddr_tap_cal,	@function
+	.text
+	.align 4
+ath_ddr_tap_cal:
+	li	a0,	0xbd001f00
+	sw	zero,	0x0(a0)			// Place where the tap values are saved and used for SWEEP
+	sw	zero,	0x4(a0)			// Place where the number of passing taps are saved.
+	sw	zero,	0x14(a0)		// Place where the last pass tap value is stored
+	li	a1,	0xaa55aa55		// Indicates that the First pass tap value is not found
+	sw	a1,	0x10(a0)		// Place where the First pass tap value is stored
+	nop
+
+	li	a0,	0xb8060000		// RESET_BASE_ADDRESS
+	lw	a1,	0x1c(a0)		// Reading the RST_RESET_ADDRESS
+	li	a2,	0x08000000		// Setting the RST_RESET_RTC_RESET
+	or	a1,	a1,	a2
+	sw	a1,	0x1c(a0)
+
+	li	a3,	0xffffffff
+	xor	a2,	a2,	a3
+	and	a1,	a1,	a2
+	sw	a1,	0x1c(a0)		// Taking the RTC out of RESET
+	nop
+
+	li	a0,	0xb8107000		// RTC_BASE_ADDRESS
+	li	a1,	0x1
+	sw	a1,	0x0040(a0)		// RTC_SYNC_RESET_ADDRESS
+
+	li	a2,	0x2
+
+_poll_for_RTC_ON:
+	lw	a1,	0x0044(a0)		// RTC_SYNC_STATUS_ADDRESS
+	and	a1,	a2,	a1
+	bne	a1,	a2,	_poll_for_RTC_ON
+
+
+_CHANGE_TAPS:
+
+	li	t0,	0xbd001f00		// Read the current value of the TAP for programming
+	lw	t1,	0x0(t0)
+	li	t2,	0x00000000
+	or	t3,	t1,	t2
+
+
+	li	t0,	0xb8000000		// DDR_BASE_ADDRESS
+
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	li	t1,	0x00000010		// Running the test 8 times
+	sw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+
+	li	t1,	0xfa5de83f		// 4 Row Address Bits, 4 Column Address Bits, 2 BA bits
+	sw	t1,	0x002c(t0)		// PERF_MASK_ADDR_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x00000001
+	sw	t1,	0x011c(t0)		// DDR_BIST_ADDRESS
+
+	li	t2,	0x1
+_bist_done_poll:
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	and	t1,	t1,	t2
+	bne	t1,	t2,	_bist_done_poll
+
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	li	t4,	0x000001fe
+	and	t2,	t1,	t4
+	srl	t2,	t2,	0x1		// no. of Pass Runs
+
+	li	t5,	0x00000000
+	sw	t5,	0x011c(t0)		//DDR_BIST_ADDRESS	- Stop the DDR BIST test
+
+	li	t5,	0x0001fe00
+	and	t5,	t5,	t1
+	bnez	t5,	_iterate_tap		// This is a redundant compare but nevertheless - Comparing the FAILS
+
+	lw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+	li	t3,	0x000001fe
+	and	t3,	t3,	t1
+	srl	t3,	t3,	0x1		// No. of runs in the config register.
+
+	bne	t3,	t2,	_iterate_tap
+
+pass_tap:
+	li	t0,	0xbd001f00
+	lw	t1,	0x4(t0)
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x4(t0)
+
+	li	t0,	0xbd001f10
+	lw	t1,	0x0(t0)
+	li	t2,	0xaa55aa55
+	beq	t1,	t2,	_first_pass
+	nop
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd001f10
+	sw	t1,	0x4(t0)
+	nop
+	b	_iterate_tap
+	nop
+
+_first_pass:
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd001f10
+	sw	t1,	0x0(t0)
+	sw	t1,	0x4(t0)
+	nop
+
+_iterate_tap:
+
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t2,	0x3f
+	beq	t1,	t2,	_STOP_TEST
+	nop
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x0(t0)
+	nop
+	b	_CHANGE_TAPS
+
+_STOP_TEST:
+	li	t0,	0xbd001f00
+	lw	t1,	0x4(t0)
+	bnez	t1,	_load_center_tap
+	nop
+	li	t3,	0x8			// Default Tap to be used
+	b	_load_tap_into_reg
+
+_load_center_tap:
+	li	t0,	0xbd001f10
+	lw	t1,	0x0(t0)
+	lw	t2,	0x4(t0)
+	add	t3,	t1,	t2
+	srl	t3,	t3,	0x1
+	li	t4,	0x3f
+	and	t3,	t3,	t4
+_load_tap_into_reg:
+	li	t0,	0xb8000000
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	jr	ra
+	nop
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/scoemu/config.mk u-boot_1.1//board/atheros/scoemu/config.mk
--- u-boot//board/atheros/scoemu/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/scoemu/config.mk	2014-02-18 01:46:24.951051016 -0800
@@ -0,0 +1,41 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/scoemu/flash.c u-boot_1.1//board/atheros/scoemu/flash.c
--- u-boot//board/atheros/scoemu/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/scoemu/flash.c	2014-02-18 01:46:24.951051016 -0800
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+#ifndef CONFIG_ATH_NAND_BR
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
+#endif /* CONFIG_ATH_NAND_BR */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/scoemu/Makefile u-boot_1.1//board/atheros/scoemu/Makefile
--- u-boot//board/atheros/scoemu/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/scoemu/Makefile	2014-02-18 01:46:24.951051016 -0800
@@ -0,0 +1,95 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-955x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-955x.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/955x.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/scoemu/scoemu.c u-boot_1.1//board/atheros/scoemu/scoemu.c
--- u-boot//board/atheros/scoemu/scoemu.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/scoemu/scoemu.c	2014-02-18 01:46:24.951051016 -0800
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(x)	strcpy(s, x)
+#	define CHECKBOARD_PARAMS	char *s
+#else
+#	define prmsg	printf
+#	define CHECKBOARD_PARAMS	void
+#endif
+
+void
+ath_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if (RST_BOOTSTRAP_REF_CLK_GET(ath_reg_rd(RST_BOOTSTRAP_ADDRESS)) == 0) {
+		ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+			ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+			ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ath_reg_wr(RST_RESET_ADDRESS,
+		ath_reg_rd(RST_RESET_ADDRESS) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_wr(RST_RESET_ADDRESS,
+		ath_reg_rd(RST_RESET_ADDRESS) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ath_reg_wr(RST_RESET_ADDRESS,
+		ath_reg_rd(RST_RESET_ADDRESS) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ath_reg_wr(RST_RESET_ADDRESS,
+		ath_reg_rd(RST_RESET_ADDRESS) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ath_reg_wr(0xb8116c84 ,
+			ath_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void ath_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32;
+
+#if !defined(CONFIG_ATH_EMULATION)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 &  ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+
+	/* Switching regulator settings */
+	ath_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_BR)
+	if (ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ath_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ath_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ath_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	ath_usb_initial_config();
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	reg32 = ath_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(CHECKBOARD_PARAMS)
+{
+	prmsg("U-boot Scorpion Emulation\n");
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/scoemu/u-boot.lds u-boot_1.1//board/atheros/scoemu/u-boot.lds
--- u-boot//board/atheros/scoemu/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/scoemu/u-boot.lds	2014-02-18 01:46:24.951051016 -0800
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/tb6xx/config.mk u-boot_1.1//board/atheros/tb6xx/config.mk
--- u-boot//board/atheros/tb6xx/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/tb6xx/config.mk	2014-02-18 01:46:24.979051052 -0800
@@ -0,0 +1,41 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/tb6xx/flash.c u-boot_1.1//board/atheros/tb6xx/flash.c
--- u-boot//board/atheros/tb6xx/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/tb6xx/flash.c	2014-02-18 01:46:24.979051052 -0800
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ 
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+#ifndef CONFIG_ATH_NAND_BR
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
+#endif /* CONFIG_ATH_NAND_BR */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/tb6xx/Makefile u-boot_1.1//board/atheros/tb6xx/Makefile
--- u-boot//board/atheros/tb6xx/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/tb6xx/Makefile	2014-02-18 01:46:24.951051016 -0800
@@ -0,0 +1,95 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-955x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-955x.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/955x.o ../common/tap-955x.S
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/tb6xx/tb6xx.c u-boot_1.1//board/atheros/tb6xx/tb6xx.c
--- u-boot//board/atheros/tb6xx/tb6xx.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/tb6xx/tb6xx.c	2014-02-18 01:46:24.979051052 -0800
@@ -0,0 +1,148 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ 
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(x)	strcpy(s, x)
+#	define CHECKBOARD_PARAMS	char *s
+#else
+#	define prmsg	printf
+#	define CHECKBOARD_PARAMS	void
+#endif
+
+void
+ath_usb1_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+		ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+		SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	udelay(1000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS,
+				RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB1_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+void
+ath_usb2_initial_config(void)
+{
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_MODE_SET(1));
+	udelay(10);
+	ath_reg_rmw_set(RST_RESET2_ADDRESS,
+				RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_HOST2_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+
+void ath_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32, *tap;
+	extern uint32_t *ath_ddr_tap_cal(void);
+
+#if !defined(CONFIG_ATH_EMULATION)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	tap = ath_ddr_tap_cal();
+	prmsg("tap = 0x%p\n", tap);
+
+	tap = (uint32_t *)0xbd007f10;
+	prmsg("Tap (low, high) = (0x%x, 0x%x)\n", tap[0], tap[1]);
+
+	tap = (uint32_t *)TAP_CONTROL_0_ADDRESS;
+	prmsg("Tap values = (0x%x, 0x%x, 0x%x, 0x%x)\n",
+		tap[0], tap[2], tap[2], tap[3]);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 & ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+
+	ath_usb1_initial_config();
+	ath_usb2_initial_config();
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	return ath_ddr_find_size();
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(CHECKBOARD_PARAMS)
+{
+	prmsg("U-boot Scorpion\n");
+	return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//board/atheros/tb6xx/u-boot.lds u-boot_1.1//board/atheros/tb6xx/u-boot.lds
--- u-boot//board/atheros/tb6xx/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//board/atheros/tb6xx/u-boot.lds	2014-02-18 01:46:24.979051052 -0800
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/cmd_bdr.c u-boot_1.1//common/cmd_bdr.c
--- u-boot//common/cmd_bdr.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//common/cmd_bdr.c	2014-02-18 01:46:26.479052086 -0800
@@ -0,0 +1,449 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*     The module is designed to support a BDR with the highest sequence number in the flash.
+ *	If it is successfule, bootloader will choose the BDR to startup.
+ *  
+ *	Author Tos Xu		April 22, 2009
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <flash.h>
+#include <malloc.h>
+#include <configs/ap93-hgw.h>
+
+#define TOTALFLASHSIZE 		CFG_FLASH_SIZE
+#define FLASHSTARTADDRESS 	CFG_FLASH_BASE
+#define FLASH_BLOCK_SIZE	CFG_FLASH_SECTOR_SIZE
+/*
+* Boot description record definitions
+*/
+#define BDRWordSize 4
+
+#define BDRHeaderNWords 4
+#define BDRHeaderNBytes (BDRHeaderNWords * BDRWordSize)
+#define BDRHeader_OffsetMagic 0      /* bytes */
+#define BDRHeader_OffsetSize 4      /* bytes */
+#define BDRHeader_OffsetChecksum 8      /* bytes */
+#define BDRHeader_OffsetSequence 12      /* bytes */
+#define BDR_BeginMagic 0xFEEDCAFE
+
+#define BDRTailerNWords 4
+#define BDRTailerNBytes (BDRTailerNWords * BDRWordSize)
+#define BDRTailer_OffsetMagic 4      /* bytes before end */
+#define BDRTailer_OffsetSize 8      /* bytes before end */
+#define BDR_EndMagic   0xFEEDFADE
+
+#define TagWordToSelf(TagWord) (((TagWord)>>24)&0xff)
+#define TagWordToTag(TagWord) (((TagWord)>>16)&0xff)
+#define TagWordToNWords(TagWord) ((TagWord)&0x3fff)
+
+#define BDRTag_STOP 1
+#define BDRTag_BOOTADDR 2
+#define BDRTag_BOOTARGS 3
+#define BDRTag_REQUESTNUMBER 4
+
+#define BDR_SIZE	256
+
+unsigned int bdr_bootaddr = 0;
+unsigned int bdr_seq = 0; 
+char bdr_bootarg[512];
+
+extern flash_info_t flash_info[];
+/*
+* Boot description records can be written at begin and/or end of each
+*       64KB block of flash (regardless of erase block size)
+*/
+#define BDRBlockSize 0x10000
+
+#define flashaddr(x)	(char *)((volatile char *)0xbf000000+(x))
+
+
+/* big endian -- extract big endian integer from byte stream
+*/
+static inline unsigned big_endian(unsigned char *p)
+{
+    return ((p[0]<<24) | (p[1]<<16) | (p[2]<<8) | p[3]);
+}	
+
+/*
+ * fix endian
+ */
+static inline unsigned fix_endian(unsigned word)
+{
+	return word;
+}
+
+/*
+ * Big endian in the flash.
+ * 0:OK,-1:parameters error,-2: NO STOP tag.
+ */
+int parse_tag(int * bdrp,int size){
+
+	int tags = 0,tagname = 0,tagsize = 0,tagno = 0;
+	int i = 0;
+	unsigned data;
+
+	// Reset the value to prevent the failure of parsing the bdr.	
+	bdr_bootaddr = 0;
+	memset(bdr_bootarg,0,sizeof(bdr_bootarg));
+
+	for(i = 0;i<size;i++)
+	{
+		data = big_endian((char *)bdrp);
+		printf(" -Tag 0x%x.\n",*bdrp);
+		tagname = (data>>16)&0xff;
+		tagno = (data>>24)&0xff;
+		tagsize = (data & 0xffff) - 1;
+
+		if((tags != tagno)||(tagsize<0)) return -1;
+
+		switch(tagname)
+		{
+			case BDRTag_STOP:
+				if(tagsize==0) return 0;
+				else return -1;
+
+			case BDRTag_BOOTADDR:
+				bdrp++;
+				if(tagsize==1){
+					bdr_bootaddr = big_endian((char *)bdrp);
+					printf("  --Boot address:0x%x at sequence 0x%x.\n",bdr_bootaddr,bdr_seq);
+					bdrp++;
+					break;
+				}else return -1;
+
+			case BDRTag_BOOTARGS:
+				bdrp++;
+				if(tagsize < 130){
+					memcpy(bdr_bootarg,(char *)bdrp,tagsize * BDRWordSize);
+					bdrp += tagsize;
+					break;
+				}else return -1;
+
+			case BDRTag_REQUESTNUMBER:
+				bdrp += tagsize +1;
+				break;
+
+			default:
+				bdrp += tagsize + 1;
+				break;
+		}
+			
+		tags++;
+	}
+
+	return -2;
+}
+
+/* findBDRstart -- look for BDR at the beginning of 64KB of flash,
+*       return sequence no.
+*       Return 0 if not found (which is not a valid sequence number).
+*
+*       This is used for searching for existing sequence number so we
+*       can be sure to have a larger one.
+*       Sequence numbers are in BDRs (Boot Description Records) which
+*       can be at the begin or end of any 64KB section of flash
+*       (regardless of the erase block size).
+*/
+
+unsigned findBDRstart(int offset)
+{
+    unsigned magic1;
+    unsigned magic2;
+    unsigned size;
+    unsigned sequence;
+    unsigned char bottom[BDRHeaderNBytes];
+    unsigned char top[BDRTailerNBytes];
+    unsigned topoffset;
+    unsigned bdrblock[BDR_SIZE];
+
+    memcpy(bottom, flashaddr(offset),sizeof(bottom));
+    memcpy(bdrblock,flashaddr(offset),sizeof(bdrblock));
+    magic1 = big_endian(bottom + BDRHeader_OffsetMagic);
+
+    if (magic1 != BDR_BeginMagic)
+        return 0;
+
+    size = BDRWordSize*big_endian( bottom + BDRHeader_OffsetSize);
+
+    if (size <= BDRHeaderNBytes+BDRTailerNBytes)
+        return 0;
+
+    if (size >= BDRBlockSize)
+        return 0;
+
+    topoffset = offset + size;
+
+    memcpy(top, flashaddr(topoffset-sizeof(top)),sizeof(top));
+
+    magic2 = big_endian(top + sizeof(top)-BDRTailer_OffsetMagic);
+    if (magic2 != BDR_EndMagic)
+        return 0;
+
+    if (BDRWordSize*big_endian(
+                top+sizeof(top)-BDRTailer_OffsetSize) != size)
+        return 0;
+
+    sequence = big_endian(bottom + BDRHeader_OffsetSequence);
+
+    if (sequence == 0 || sequence == 0xffffffff)
+        return 0;       /* invalid */
+
+    printf("Found starting sequence: 0x%x in offset 0x%x.\n",sequence,offset);
+    if(sequence > bdr_seq){
+	bdr_seq = sequence;
+	parse_tag(bdrblock + BDRHeaderNWords,BDR_SIZE);
+    }
+
+    return sequence;
+}
+
+unsigned findBDRend(int offset) /* offset of begin of 64KB section */
+{
+    unsigned magic1;
+    unsigned magic2;
+    unsigned size;
+    unsigned sequence;
+    unsigned char bottom[BDRHeaderNBytes];
+    unsigned char top[BDRTailerNBytes];
+    unsigned topoffset;
+    unsigned bottomoffset;
+    unsigned bdrblock[BDR_SIZE];
+
+    topoffset = offset + BDRBlockSize;
+
+    memcpy(top, flashaddr(topoffset-sizeof(top)),sizeof(top));
+    memcpy(bdrblock, flashaddr(topoffset-sizeof(bdrblock)),sizeof(bdrblock));
+
+    magic2 = big_endian(top + sizeof(top)-BDRTailer_OffsetMagic);
+
+    if (magic2 != BDR_EndMagic)
+        return 0;
+
+    size = BDRWordSize*big_endian(top+sizeof(top)-BDRTailer_OffsetSize);
+
+    if (size <= BDRHeaderNBytes+BDRTailerNBytes)
+        return 0;
+
+    if (size >= BDRBlockSize)
+        return 0;
+
+    bottomoffset = topoffset - size;
+
+    memcpy(bottom, flashaddr(bottomoffset),sizeof(bottom));
+
+    magic1 = big_endian(bottom + BDRHeader_OffsetMagic);
+
+    if (magic1 != BDR_BeginMagic)
+        return 0;
+
+    if (BDRWordSize*big_endian(bottom + BDRHeader_OffsetSize) != size)
+        return 0;
+
+    sequence = big_endian(bottom+BDRHeader_OffsetSequence);
+
+    if (sequence == 0 || sequence == 0xffffffff)
+        return 0;       /* invalid */
+
+    printf("Found end sequence: 0x%x in offset 0x%x.\n",sequence,offset);
+    if(sequence > bdr_seq){
+	bdr_seq = sequence;
+	parse_tag(bdrblock + BDRTailerNWords,BDR_SIZE);
+    }
+	
+    return sequence;
+}
+
+
+/* return  0: no existing valid Boot Description Recorder
+ *         1: Found a valid DBR and set bootm and bootarg.
+ */
+unsigned findbdr(unsigned int flashaddr){
+	int offset = 0;
+	char buf[64];
+
+	if(flashaddr >= FLASHSTARTADDRESS) flashaddr -= FLASHSTARTADDRESS;
+
+	printf("findbdr flashaddr 0x%x.\n",flashaddr);
+	bdr_seq = 0;
+	bdr_bootaddr = 0xffffffff;
+	memset(bdr_bootarg,0,sizeof(bdr_bootarg));
+
+	for(offset =flashaddr;offset < TOTALFLASHSIZE;offset += BDRBlockSize)
+	{
+		findBDRstart(offset);
+		findBDRend(offset);		
+	}
+
+	// if bootaddr is equal to 0xffffffff or 0x0, it is not valid.
+	if(bdr_seq == 0||bdr_bootaddr==0xffffffff||bdr_bootaddr==0x0){
+		printf("Failed to find a good BDR at seq 0x%x.\n",bdr_seq);
+		return 0;
+	}
+	
+	if(bdr_bootaddr < TOTALFLASHSIZE) bdr_bootaddr |= FLASHSTARTADDRESS;
+	sprintf(buf,"%s 0x%x","bootm",bdr_bootaddr);
+	setenv("bootcmd",buf);
+	setenv("bootargs",bdr_bootarg);
+	printf("Got a good Boot Descriptor Record.\n  -Sequence:0x%x.\n",bdr_seq);
+	printf("  -Boot address: 0x%x.\n",bdr_bootaddr);
+	if(strlen(bdr_bootarg) < 512)	
+		printf("  -Boot arguments: %s.\n",bdr_bootarg);
+	return 1;
+
+}
+
+
+int do_findbdr (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int err = 0;
+
+	unsigned int addr;
+
+	if(argc < 2)
+		err = findbdr(0);
+	else{
+		addr = simple_strtoul(argv[1], NULL, 16);
+		err = findbdr(addr);
+	}
+	
+	return err;
+}
+/*
+ * flashaddr is the aboslute address.(0xbf.....)
+ */
+static unsigned writebdr(unsigned int flashaddr,unsigned bootaddr,char * cmdline){
+	unsigned bdrblock[BDR_SIZE];
+	unsigned * bdrp =  bdrblock;
+	unsigned flash_offset = flashaddr - FLASHSTARTADDRESS;
+	int err;
+	unsigned seq;
+	unsigned tags;
+	char * p;
+	char buffer[64];
+	
+	//Make sure the flashaddr is located at X*1024.
+	if(flashaddr &0x3ff) return 1;
+	
+	err = findbdr(0);
+	seq = bdr_seq + 1;
+
+	bdrp[0]	= fix_endian(BDR_BeginMagic);
+	bdrp[BDR_SIZE-1] = fix_endian(BDR_EndMagic);
+	bdrp[1] = bdrp[BDR_SIZE-2] = fix_endian(BDR_SIZE);
+	bdrp[2] = 0;
+	bdrp[3] = seq;
+	
+	bdrp += 4;
+	tags = 0;
+
+	*bdrp++ = fix_endian(tags++<<24| BDRTag_REQUESTNUMBER<<16|2);
+	*bdrp++ = fix_endian(0);//request number.
+
+	*bdrp++ = fix_endian(tags++<<24| BDRTag_BOOTADDR <<16|2);
+	*bdrp++ = fix_endian(bootaddr);//bootaddr.
+
+
+	*bdrp++ = fix_endian(tags++<<24| BDRTag_BOOTARGS <<16|(1+sizeof(bdr_bootarg)/sizeof(int)));
+	memcpy(bdrp,cmdline,sizeof(bdr_bootarg));
+	bdrp += sizeof(bdr_bootarg)/sizeof(int);//bootarg.	
+
+	*bdrp++ = fix_endian(tags++<<24| BDRTag_STOP<<16|1);//STOP tag
+	p = (char *)malloc(FLASH_BLOCK_SIZE);
+
+	memcpy(p,(char *)(((unsigned int )flashaddr/FLASH_BLOCK_SIZE )* FLASH_BLOCK_SIZE),FLASH_BLOCK_SIZE);
+	memcpy(p + ((unsigned int )flashaddr%FLASH_BLOCK_SIZE), bdrblock,BDR_SIZE * 4);
+
+	flash_erase(&flash_info[0],flash_offset/FLASH_BLOCK_SIZE,flash_offset/FLASH_BLOCK_SIZE);
+	err = flash_write(p,((unsigned int )flashaddr/FLASH_BLOCK_SIZE )* FLASH_BLOCK_SIZE, FLASH_BLOCK_SIZE);
+
+	free(p);
+
+	if(err){
+		flash_perror(err);
+		return 1;
+	}
+
+	if(memcmp((char *)flashaddr,bdrblock,BDR_SIZE * 4)){
+		printf("Error when writing bdr into flash.\n");
+		return 1;
+	}
+	
+	printf("BDR has been successfully written.\n");
+	printf("BDR boot address: 0x%x.\n",bootaddr);
+	printf("BDR boot arg: %s.\n",cmdline);
+
+	sprintf(buffer,"%s 0x%x","bootm",bootaddr);
+	setenv("bootcmd",buffer);
+	setenv("bootargs",cmdline);
+
+	return 0;
+}
+
+int do_writebdr (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int err = 0;
+
+	unsigned int flashaddr;
+	unsigned int bootaddr;
+	char cmd[512];
+
+	char * s = getenv("bootargs");
+	
+	printf("do_writebdr :: size %d bootargs = %s .\n",sizeof(s),s);
+	if(argc < 2)
+		return 1;
+	else{
+		flashaddr = simple_strtoul(argv[1], NULL, 16);
+		if(argc == 3 ) bootaddr = simple_strtoul(argv[2], NULL, 16);
+
+		if(flashaddr < TOTALFLASHSIZE) flashaddr |= FLASHSTARTADDRESS;
+		if(flashaddr < (FLASHSTARTADDRESS|0x80000)) return 1;
+		memset(cmd,0,sizeof(cmd));
+		memcpy(cmd,s,sizeof(cmd));
+		//printf("do_writebdr :: bdr_bootargs = %s size %d.\n",bdr_bootarg,sizeof(bdr_bootarg));		
+		err = writebdr(flashaddr,bootaddr,cmd);
+	}
+	
+	return err;
+}
+
+U_BOOT_CMD(
+ 	writebdr,	CFG_MAXARGS,	1,	do_writebdr,
+ 	"writebdr- write a valid bdr in the flash based on existing sequences\n",
+ 	"[writebdr [arg ...]]\n  write a valid bdr based on existing sequences at the designed address  - \n"
+ 	"\tpassing arguments 'flash_offset, bootaddr'; you may assign the flash address,\n"
+ 	"\t'bootaddr' can be ignored or set it.\n"
+);
+
+U_BOOT_CMD(
+ 	findbdr,	CFG_MAXARGS,	1,	do_findbdr,
+ 	"findbdr - find a valid bdr with the highest sequence in the flash\n",
+ 	"[findbdr [arg ...]]\n  find a valid bdr with the highest sequence in the flash from the starting address  - \n"
+ 	"\tpassing arguments 'arg ...'; you may assign the address or not,\n"
+ 	"\t'arg' can be the starting address of search.\n"
+);
+
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/cmd_boot.c u-boot_1.1//common/cmd_boot.c
--- u-boot//common/cmd_boot.c	2014-02-18 01:46:22.483049297 -0800
+++ u-boot_1.1//common/cmd_boot.c	2014-02-18 01:46:26.479052086 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2000-2003
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -28,10 +30,10 @@
 #include <command.h>
 #include <net.h>
 
-#if defined(CONFIG_I386)
+#if defined(CONFIG_I386) || defined(CONFIG_MIPS)
 DECLARE_GLOBAL_DATA_PTR;
 #endif
-
+#ifndef COMPRESSED_UBOOT
 int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	ulong	addr, rc;
@@ -58,7 +60,12 @@
 	argv[0] = (char *)gd;
 #endif
 #if !defined(CONFIG_NIOS)
-	rc = ((ulong (*)(int, char *[]))addr) (--argc, &argv[1]);
+	if (argc > 2 && argv[2][0] == 'b') {
+		printf ("## Board info at 0x%08lX ...\n", gd->bd);
+		rc = ((ulong (*)(int, int, int, int))addr)(gd->bd, 0, 0, 0);
+	} else {
+		rc = ((ulong (*)(int, char *[]))addr) (--argc, &argv[1]);
+	}
 #else
 	/*
 	 * Nios function pointers are address >> 1
@@ -79,7 +86,7 @@
 	"addr [arg ...]\n    - start application at address 'addr'\n"
 	"      passing 'arg' as arguments\n"
 );
-
+#endif /* #ifndef COMPRESSED_UBOOT */
 extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
 
 U_BOOT_CMD(
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/cmd_bootm.c u-boot_1.1//common/cmd_bootm.c
--- u-boot//common/cmd_bootm.c	2014-02-18 01:46:22.487049300 -0800
+++ u-boot_1.1//common/cmd_bootm.c	2014-02-18 01:46:26.483052090 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2000-2006
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -151,6 +153,8 @@
 
 ulong load_addr = CFG_LOAD_ADDR;		/* Default Load Address */
 
+#define CONFIG_LZMA 1
+
 int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	ulong	iflag;
@@ -181,7 +185,9 @@
 		read_dataflash(addr, sizeof(image_header_t), (char *)&header);
 	} else
 #endif
-	memmove (&header, (char *)addr, sizeof(image_header_t));
+	{
+		memmove (&header, (char *)addr, sizeof(image_header_t));
+	}
 
 	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
 #ifdef __I386__	/* correct image format not implemented yet - fake it */
@@ -223,7 +229,6 @@
 	}
 #endif
 
-
 	/* for multi-file images we need the data part, too */
 	print_image_hdr ((image_header_t *)addr);
 
@@ -231,7 +236,7 @@
 	len  = ntohl(hdr->ih_size);
 
 	if (verify) {
-		puts ("   Verifying Checksum ... ");
+		printf("   Verifying Checksum at 0x%p ...", data);
 		if (crc32 (0, (uchar *)data, len) != ntohl(hdr->ih_dcrc)) {
 			printf ("Bad Data CRC\n");
 			SHOW_BOOT_PROGRESS (-3);
@@ -315,6 +320,17 @@
 	dcache_disable();
 #endif
 
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+	/*
+	 * Flush everything, restore caches for linux
+	 */
+	mips_cache_flush();
+	mips_icache_flush_ix();
+
+	/* XXX - this causes problems when booting from flash */
+	/* dcache_disable(); */
+#endif
+
 	switch (hdr->ih_comp) {
 	case IH_COMP_NONE:
 		if(ntohl(hdr->ih_load) == addr) {
@@ -340,7 +356,7 @@
 #endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
 		}
 		break;
-#ifndef CONFIG_NO_GZIP
+#ifndef COMPRESSED_UBOOT
 	case IH_COMP_GZIP:
 		printf ("   Uncompressing %s ... ", name);
 		if (gunzip ((void *)ntohl(hdr->ih_load), unc_len,
@@ -350,7 +366,6 @@
 			do_reset (cmdtp, flag, argc, argv);
 		}
 		break;
-#endif
 #ifdef CONFIG_BZIP2
 	case IH_COMP_BZIP2:
 		printf ("   Uncompressing %s ... ", name);
@@ -370,19 +385,17 @@
 		}
 		break;
 #endif /* CONFIG_BZIP2 */
+#endif /* #ifndef COMPRESSED_UBOOT */
 #ifdef CONFIG_LZMA
 	case IH_COMP_LZMA:
-		printf ("   Uncompressing %s ... ", type_name);
-		int i = lzma_inflate ((unsigned char *)os_data, os_len,
-					(unsigned char *)load_start, &unc_len);
+		printf ("   Uncompressing %s ... ", name);
+		i = lzma_inflate ((unsigned char *)data, len, (unsigned char*)ntohl(hdr->ih_load), &unc_len);
 		if (i != LZMA_RESULT_OK) {
-			printf ("LZMA: uncompress or overwrite error %d "
-				"- must RESET board to recover\n", i);
-			show_boot_progress (-6);
+			printf ("LZMA ERROR %d - must RESET board to recover\n", i);
+			SHOW_BOOT_PROGRESS (-6);
+			udelay(100000);
 			do_reset (cmdtp, flag, argc, argv);
 		}
-
-		load_end = load_start + unc_len;
 		break;
 #endif /* CONFIG_LZMA */
 	default:
@@ -1285,6 +1298,7 @@
 	case IH_COMP_NONE:	comp = "uncompressed";		break;
 	case IH_COMP_GZIP:	comp = "gzip compressed";	break;
 	case IH_COMP_BZIP2:	comp = "bzip2 compressed";	break;
+	case IH_COMP_LZMA:	comp = "lzma compressed";	break;
 	default:		comp = "unknown compression";	break;
 	}
 
@@ -1317,7 +1331,7 @@
 #define RESERVED	0xe0
 
 #define DEFLATED	8
-
+#ifndef COMPRESSED_UBOOT
 int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
 {
 	z_stream s;
@@ -1379,7 +1393,7 @@
 	printf ("BZIP2 internal error %d\n", errcode);
 }
 #endif /* CONFIG_BZIP2 */
-
+#endif /* #ifndef COMPRESSED_UBOOT */
 static void
 do_bootm_rtems (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
 		ulong addr, ulong *len_ptr, int verify)
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/cmd_ethreg.c u-boot_1.1//common/cmd_ethreg.c
--- u-boot//common/cmd_ethreg.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//common/cmd_ethreg.c	2014-02-18 01:46:26.487052093 -0800
@@ -0,0 +1,266 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_ETHREG)
+
+/*-----------------------------------------------------------------------
+ * Definitions
+ */
+#ifdef CONFIG_ATHRS26E_PHY
+extern unsigned int s26e_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+extern void s26e_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+extern uint32_t athrs26e_reg_read(uint32_t reg_addr);
+extern void athrs26e_reg_write(uint32_t reg_addr, uint32_t reg_val);
+#endif
+
+#ifdef CFG_ATHRS26_PHY
+extern unsigned int s26_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+extern void s26_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+extern uint32_t athrs26_reg_read(uint32_t reg_addr);
+extern void athrs26_reg_write(uint32_t reg_addr, uint32_t reg_val);
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+extern unsigned int s27_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+extern void s27_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+extern uint32_t athrs27_reg_read(uint32_t reg_addr);
+extern void athrs27_reg_write(uint32_t reg_addr, uint32_t reg_val);
+#endif
+
+#ifdef CONFIG_AR7242_S16_PHY
+extern uint32_t athrs16_reg_read(uint32_t reg_addr);
+extern void athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val);
+extern int  ag7240_miiphy_read(char *devname, uint32_t phaddr,
+                uint8_t reg);
+extern int  ag7240_miiphy_write(char *devname, uint32_t phaddr,
+                uint8_t reg, uint16_t data);
+#endif
+
+#ifdef CONFIG_ATHRS17_PHY
+extern uint32_t athrs17_reg_read(uint32_t reg_addr);
+extern void athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val);
+extern unsigned int s17_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+extern void s17_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+#endif
+
+
+#define READ_MAC  0x01
+#define WRITE_MAC 0x02
+#define READ_PHY  0x10
+#define WRITE_PHY 0x20
+
+/*
+ * Values from last command.
+ */
+static int   reg;
+static int   val,rd_value;
+static int phyaddr;
+static int portnum;
+
+int do_ethreg (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int   rcode = 0;
+
+	/*
+	 * We use the last specified parameters, unless new ones are
+	 * entered.
+	 */
+
+	if ((flag & CMD_FLAG_REPEAT) == 0)
+	{
+		if (argc == 2) {
+			reg = simple_strtoul(argv[1], NULL, 10);
+			rcode = READ_MAC;
+		}
+		if (argc == 3) {
+			reg = simple_strtoul(argv[1], NULL, 10);
+			val = simple_strtoul(argv[2],NULL,10);
+			rcode = WRITE_MAC;
+		}
+		if (argc == 4) {
+    	                if(*argv[1] == 'p') {
+				portnum = simple_strtoul(argv[2], NULL, 10);
+				reg = simple_strtoul(argv[3],NULL,10);
+				rcode = READ_PHY; 
+			}
+			else
+			    return 1;
+		}
+        	if (argc == 5) {
+    	                if(*argv[1] == 'p') {
+				portnum = simple_strtoul(argv[2], NULL, 10);
+				reg = simple_strtoul(argv[3],NULL,10);
+				val = simple_strtoul(argv[4],NULL,10);
+				rcode = WRITE_PHY; 
+			}
+			else
+			    return 1;
+		}
+
+		if ((argc > 4) && (argc < 2))
+			return 1;
+	}
+#ifdef CONFIG_AR7242_S16_PHY
+   if(rcode == READ_PHY) {
+   	rd_value = ag7240_miiphy_read("eth0",portnum,reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode == READ_MAC) {
+        rd_value = athrs16_reg_read(reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode  == WRITE_PHY) {
+   	rd_value = ag7240_miiphy_read("eth0",portnum,reg);
+        ag7240_miiphy_write("eth0",portnum,reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else if(rcode == WRITE_MAC) {
+        rd_value = athrs16_reg_read(reg);
+        athrs16_reg_write(reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else
+	return 1;
+#endif
+#ifdef CFG_ATHRS26_PHY        
+   if(rcode == READ_PHY) {
+   	rd_value = s26_rd_phy(portnum,reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode == READ_MAC) {
+        rd_value = athrs26_reg_read(reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode  == WRITE_PHY) {
+   	rd_value = s26_rd_phy(portnum,reg);
+        s26_wr_phy(portnum,reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else if(rcode == WRITE_MAC) {
+        rd_value = athrs26_reg_read(reg);
+        athrs26_reg_write(reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else
+	return 1;
+#endif
+#ifdef CFG_ATHRS27_PHY        
+   if(rcode == READ_PHY) {
+   	rd_value = s27_rd_phy(portnum,reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode == READ_MAC) {
+        rd_value = athrs27_reg_read(reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode  == WRITE_PHY) {
+   	rd_value = s27_rd_phy(portnum,reg);
+        s27_wr_phy(portnum,reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else if(rcode == WRITE_MAC) {
+        rd_value = athrs27_reg_read(reg);
+        athrs27_reg_write(reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else
+	return 1;
+#endif
+
+#ifdef CONFIG_F1E_PHY
+   if(rcode == READ_PHY) {
+   	rd_value = f1e_rd_phy(portnum, reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode  == WRITE_PHY) {
+   	rd_value = f1e_rd_phy(portnum, reg);
+        f1e_wr_phy(portnum, reg, val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else
+	return 1;
+#endif
+
+#ifdef CONFIG_ATHRS17_PHY 
+   if(rcode == READ_PHY) {
+   	rd_value = s17_rd_phy(portnum,reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode == READ_MAC) {
+        rd_value = athrs17_reg_read(reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode  == WRITE_PHY) {
+   	rd_value = s17_rd_phy(portnum,reg);
+        s17_wr_phy(portnum,reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else if(rcode == WRITE_MAC) {
+        rd_value = athrs17_reg_read(reg);
+        athrs17_reg_write(reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else
+	return 1;
+#endif
+
+#ifdef CONFIG_ATHRS26E_PHY
+   if(rcode == READ_PHY) {
+   	rd_value = s26e_rd_phy(portnum,reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode == READ_MAC) {
+        rd_value = athrs26e_reg_read(reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode  == WRITE_PHY) {
+   	rd_value = s26e_rd_phy(portnum,reg);
+        s26e_wr_phy(portnum,reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else if(rcode == WRITE_MAC) {
+        rd_value = athrs26e_reg_read(reg);
+        athrs26e_reg_write(reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else
+	return 1;
+#endif
+   return 0;
+}
+
+/***************************************************/
+
+U_BOOT_CMD(
+	ethreg,	6,	1,	do_ethreg,
+	"ethreg  - Switch/PHY Reg rd/wr  utility\n",
+	"<p> <phyaddr> <reg> <value> - Send <bit_len> bits from <dout> out the SPI\n"
+	"<p>  - operates on the phy; by default is rd/wr s26 mac registers\n"
+	"<phyaddr> - Address of the phy\n"
+	"<reg>    - Register offset\n"
+	"<value>  - value to write\n"
+);
+
+#endif	/* CONFIG_COMMANDS & CFG_CMD_ETHREG */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/cmd_flash.c u-boot_1.1//common/cmd_flash.c
--- u-boot//common/cmd_flash.c	2014-02-18 01:46:22.491049303 -0800
+++ u-boot_1.1//common/cmd_flash.c	2014-02-18 01:46:26.487052093 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2000
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -157,7 +159,6 @@
 		 * boundary. We want to round such an address to the next
 		 * sector boundary, so that the commands don't fail later on.
 		 */
-
 		/* find the end addr of the sector where the *addr_last is */
 		for (bank = 0; bank < CFG_MAX_FLASH_BANKS && !found; ++bank){
 			int i;
@@ -276,7 +277,7 @@
 
 	return rcode;
 }
-
+#ifndef COMPRESSED_UBOOT
 int do_flinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	ulong bank;
@@ -304,6 +305,7 @@
 	flash_print_info (&flash_info[bank-1]);
 	return 0;
 }
+#endif /* #ifndef COMPRESSED_UBOOT */
 
 int do_flerase (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
@@ -324,7 +326,9 @@
 
 	if (strcmp(argv[1], "all") == 0) {
 		for (bank=1; bank<=CFG_MAX_FLASH_BANKS; ++bank) {
+#ifdef FLASH_DEBUG
 			printf ("Erase Flash Bank # %ld ", bank);
+#endif
 			info = &flash_info[bank-1];
 			rcode = flash_erase (info, 0, info->sector_count-1);
 		}
@@ -336,8 +340,10 @@
 			puts ("Bad sector specification\n");
 			return 1;
 		}
+#ifdef FLASH_DEBUG
 		printf ("Erase Flash Sectors %d-%d in Bank # %d ",
 			sect_first, sect_last, (info-flash_info)+1);
+#endif
 		rcode = flash_erase(info, sect_first, sect_last);
 		return rcode;
 	}
@@ -352,12 +358,12 @@
 				info = &flash_info[bank];
 				addr_first = part->offset + info->start[0];
 				addr_last = addr_first + part->size - 1;
-
+#ifdef FLASH_DEBUG
 				printf ("Erase Flash Parition %s, "
 						"bank %d, 0x%08lx - 0x%08lx ",
 						argv[1], bank, addr_first,
 						addr_last);
-
+#endif
 				rcode = flash_sect_erase(addr_first, addr_last);
 				return rcode;
 			}
@@ -380,12 +386,13 @@
 				CFG_MAX_FLASH_BANKS);
 			return 1;
 		}
+#ifdef FLASH_DEBUG
 		printf ("Erase Flash Bank # %ld ", bank);
+#endif
 		info = &flash_info[bank-1];
 		rcode = flash_erase (info, 0, info->sector_count-1);
 		return rcode;
 	}
-
 	if (addr_spec(argv[1], argv[2], &addr_first, &addr_last) < 0){
 		printf ("Bad address format\n");
 		return 1;
@@ -422,6 +429,7 @@
 		     ++bank, ++info) {
 			if (s_first[bank]>=0) {
 				erased += s_last[bank] - s_first[bank] + 1;
+#ifdef FLASH_DEBUG
 				debug ("Erase Flash from 0x%08lx to 0x%08lx "
 					"in Bank # %ld ",
 					info->start[s_first[bank]],
@@ -429,6 +437,9 @@
 						info->start[0] + info->size - 1:
 						info->start[s_last[bank]+1] - 1,
 					bank+1);
+#else
+				printf( "Erasing flash... ");
+#endif
 				rcode = flash_erase (info, s_first[bank], s_last[bank]);
 			}
 		}
@@ -441,6 +452,7 @@
 	return rcode;
 }
 
+#ifndef COMPRESSED_UBOOT
 int do_protect (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	flash_info_t *info;
@@ -670,7 +682,7 @@
 	}
 	return rcode;
 }
-
+#endif /* #ifndef COMPRESSED_UBOOT */
 
 /**************************************************/
 #if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
@@ -683,6 +695,7 @@
 # define TMP_PROT_OFF	/* empty */
 #endif
 
+#ifndef COMPRESSED_UBOOT
 U_BOOT_CMD(
 	flinfo,    2,    1,    do_flinfo,
 	"flinfo  - print FLASH memory information\n",
@@ -691,20 +704,6 @@
 );
 
 U_BOOT_CMD(
-	erase,   3,   1,  do_flerase,
-	"erase   - erase FLASH memory\n",
-	"start end\n"
-	"    - erase FLASH from addr 'start' to addr 'end'\n"
-	"erase start +len\n"
-	"    - erase FLASH from addr 'start' to the end of sect "
-	"w/addr 'start'+'len'-1\n"
-	"erase N:SF[-SL]\n    - erase sectors SF-SL in FLASH bank # N\n"
-	"erase bank N\n    - erase FLASH bank # N\n"
-	TMP_ERASE
-	"erase all\n    - erase all FLASH banks\n"
-);
-
-U_BOOT_CMD(
 	protect,  4,  1,   do_protect,
 	"protect - enable or disable FLASH write protection\n",
 	"on  start end\n"
@@ -729,6 +728,24 @@
 	"protect off all\n    - make all FLASH banks writable\n"
 );
 
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+U_BOOT_CMD(
+	erase,   3,   1,  do_flerase,
+	"erase   - erase FLASH memory\n",
+	"start end\n"
+	"    - erase FLASH from addr 'start' to addr 'end'\n"
+	"erase start +len\n"
+	"    - erase FLASH from addr 'start' to the end of sect "
+	"w/addr 'start'+'len'-1\n"
+	"erase N:SF[-SL]\n    - erase sectors SF-SL in FLASH bank # N\n"
+	"erase bank N\n    - erase FLASH bank # N\n"
+	TMP_ERASE
+	"erase all\n    - erase all FLASH banks\n"
+);
+
+
+
 #undef	TMP_ERASE
 #undef	TMP_PROT_ON
 #undef	TMP_PROT_OFF
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/cmd_load.c u-boot_1.1//common/cmd_load.c
--- u-boot//common/cmd_load.c	2014-02-18 01:46:22.495049306 -0800
+++ u-boot_1.1//common/cmd_load.c	2014-02-18 01:46:26.503052105 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2000-2004
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -431,6 +433,7 @@
 char his_pad_char;   /* pad chars he needs */
 char his_quote;      /* quote chars he'll use */
 
+#ifndef COMPRESSED_UBOOT
 int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	ulong offset = 0;
@@ -523,6 +526,7 @@
 #endif
 	return rcode;
 }
+#endif /* #ifndef COMPRESSED_UBOOT */
 
 
 static ulong load_serial_bin (ulong offset)
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/cmd_mem.c u-boot_1.1//common/cmd_mem.c
--- u-boot//common/cmd_mem.c	2014-02-18 01:46:22.495049306 -0800
+++ u-boot_1.1//common/cmd_mem.c	2014-02-18 01:46:26.507052108 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2000
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -35,6 +37,7 @@
 #ifdef CONFIG_HAS_DATAFLASH
 #include <dataflash.h>
 #endif
+#include "defines.h"
 
 #if (CONFIG_COMMANDS & (CFG_CMD_MEMORY	| \
 			CFG_CMD_I2C	| \
@@ -312,7 +315,7 @@
 	return 0;
 }
 #endif /* CONFIG_MX_CYCLIC */
-
+#ifndef COMPRESSED_UBOOT
 int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	ulong	addr1, addr2, count, ngood;
@@ -390,6 +393,8 @@
 		ngood == 1 ? "" : "s");
 	return rcode;
 }
+#endif /* #ifndef COMPRESSED_UBOOT  */
+
 
 int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
@@ -419,7 +424,7 @@
 		return 1;
 	}
 
-#ifndef CFG_NO_FLASH
+#if !defined(CFG_NO_FLASH) && !defined(CONFIG_ATH_NAND_BR)
 	/* check if we are copying to Flash */
 	if ( (addr2info(dest) != NULL)
 #ifdef CONFIG_HAS_DATAFLASH
@@ -527,6 +532,8 @@
 	return 0;
 }
 
+
+#ifndef COMPRESSED_UBOOT
 int do_mem_base (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	if (argc > 1) {
@@ -684,6 +691,7 @@
 	}
 }
 #endif /* CONFIG_LOOPW */
+#endif /* #ifndef COMPRESSED_UBOOT */
 
 /*
  * Perform a memory test. A more complete alternative test can be
@@ -1098,6 +1106,9 @@
 	return 0;
 }
 
+
+
+#ifndef COMPRESSED_UBOOT
 #ifndef CONFIG_CRC32_VERIFY
 
 int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
@@ -1185,40 +1196,6 @@
 }
 #endif	/* CONFIG_CRC32_VERIFY */
 
-/**************************************************/
-#if (CONFIG_COMMANDS & CFG_CMD_MEMORY)
-U_BOOT_CMD(
-	md,     3,     1,      do_mem_md,
-	"md      - memory display\n",
-	"[.b, .w, .l] address [# of objects]\n    - memory display\n"
-);
-
-
-U_BOOT_CMD(
-	mm,     2,      1,       do_mem_mm,
-	"mm      - memory modify (auto-incrementing)\n",
-	"[.b, .w, .l] address\n" "    - memory modify, auto increment address\n"
-);
-
-
-U_BOOT_CMD(
-	nm,     2,	    1,     	do_mem_nm,
-	"nm      - memory modify (constant address)\n",
-	"[.b, .w, .l] address\n    - memory modify, read and keep address\n"
-);
-
-U_BOOT_CMD(
-	mw,    4,    1,     do_mem_mw,
-	"mw      - memory write (fill)\n",
-	"[.b, .w, .l] address value [count]\n    - write memory\n"
-);
-
-U_BOOT_CMD(
-	cp,    4,    1,    do_mem_cp,
-	"cp      - memory copy\n",
-	"[.b, .w, .l] source target count\n    - copy memory\n"
-);
-
 U_BOOT_CMD(
 	cmp,    4,     1,     do_mem_cmp,
 	"cmp     - memory compare\n",
@@ -1267,12 +1244,6 @@
 );
 #endif /* CONFIG_LOOPW */
 
-U_BOOT_CMD(
-	mtest,    4,    1,     do_mem_mtest,
-	"mtest   - simple RAM test\n",
-	"[start [end [pattern]]]\n"
-	"    - simple RAM read/write test\n"
-);
 
 #ifdef CONFIG_MX_CYCLIC
 U_BOOT_CMD(
@@ -1288,5 +1259,373 @@
 );
 #endif /* CONFIG_MX_CYCLIC */
 
-#endif
+#endif /* #ifndef COMPRESSED_UBOOT */
+#define AR7240_DDR_SIZE_INCR    (4*1024*1024)
+
+/*
+ * Function Prototype
+ */
+int test_algorithm_t   (unsigned int mem_type, unsigned int pattern);
+
+/*
+ * Local Variables in this file
+ */
+static unsigned int init_state = 1;
+
+static unsigned int TEST_SIZE;
+static unsigned int START_M_ADDR, START_C_ADDR;
+static unsigned int END_M_ADDR,   END_C_ADDR;
+
+/* Test Patterns */
+static unsigned int base_pattern[DATA_PATTERN_NUM];
+
+/* Variables for random pattern */
+static unsigned int dword_random_seed, dword_random_inc, hword_random_seed, hword_random_inc, byte_random_seed, byte_random_inc;
+
+/* Variables for statistics */
+static unsigned int curr_round;
+static unsigned int fail_round, mt_fail_round, ct_fail_round;
+
+/* Variables Per round */
+static unsigned int fail_status, mt_fail_status, ct_fail_status;
+
+/* Temporary Variables */
+static unsigned int START_ADDR, END_ADDR;
+
+int do_mem_mct (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{                                     
+	unsigned char   *p = (unsigned char *)KSEG1, pat = 0x77;
+	unsigned int    i;
+	unsigned long	*size;
+	
+	if (argc > 1) {
+		size = simple_strtoul(argv[1], NULL, 16);
+	} 
+	
+	/* Clean all information memory locations */
+	for (i = 0; i < 0xb0; i+=4) {
+		*(unsigned int *)(INFO_BASE_ADDR +i) = 0x0;
+	}
+
+    /* Determine the size of DDR/DDR2/SDRAM */
+    *p = pat;
+
+    /*
+     * For x32 mode(2 DDR devices on board), Scorpion can support 2 128MB DDR and maximum memory size is 256MB(Wasp can support 2 64MB DDR and maximum memory size is 128MB).
+     * In chip design, only 256MB address space can be used by DDR
+     * Therefore, max. size of DDR is 256MB
+     */
+    for (i = 1; i < 64; i++) {
+        *(p + i * AR7240_DDR_SIZE_INCR) = (unsigned char)(i);
+        if (*p != pat) {
+            break;
+        }
+    }
+	
+    TEST_SIZE    = size;
+    START_M_ADDR = KSEG1 + 0x50000;
+    END_M_ADDR   = START_M_ADDR + TEST_SIZE;
+    START_C_ADDR = KSEG0 + 0x50000;
+    END_C_ADDR   = START_C_ADDR + TEST_SIZE;
+
+    /* Record general information */
+    *(unsigned int *)(INFO_SIZE_ADDR)       = TEST_SIZE;
+    *(unsigned int *)(INFO_MEM_START_ADDR)  = START_M_ADDR;
+    *(unsigned int *)(INFO_MEM_END_ADDR)    = END_M_ADDR;
+    *(unsigned int *)(INFO_CACHE_START_ADDR)= START_C_ADDR;
+    *(unsigned int *)(INFO_CACHE_END_ADDR)  = END_C_ADDR;
+
+    /* Initialize variables before test begins */
+    curr_round = 0;
+    fail_round = mt_fail_round = ct_fail_round = 0;
+
+    for (i = 0; i < DATA_PATTERN_NUM; i++)
+        base_pattern[i] = 0x0;
+
+    /* Pattern 1 : Random     */
+    /* Pattern 2 : Address    */
+    /* Pattern 3 : 0xffffffff */
+    base_pattern[0] = 1; /* Random  */
+    base_pattern[1] = 2; /* Address */
+    base_pattern[2] = 0xffffffff;
+
+    /* Initialize variables for random pattern */
+    dword_random_seed   = 0xa83f0365;
+    dword_random_inc    = 0x185fe2d1;
+
+    hword_random_seed   = 0x4f9516e3;
+    hword_random_inc    = 0x143c2b7d;
+
+    byte_random_seed    = 0xa83f0365;
+    byte_random_inc     = 0x185fe2d1;
+	
+    while (1) {
+        /* Initialize variables before current round begins */
+        mt_fail_status = ct_fail_status = 0;
+
+        *(unsigned int *)(INFO_MT_ADDR)    = 0;
+        *(unsigned int *)(INFO_CT_ADDR)    = 0;
+
+        curr_round++;
+
+        printf("***Round %d***\n", curr_round);
+
+        /* +++ MT    +++ */
+        printf("2. Memory Test <MT>\n");
+		
+        *(unsigned int *)(INFO_MT_ADDR) = 1;
+
+        for (i = 0; i < DATA_PATTERN_NUM; i++) {
+            if (base_pattern[i] == 0x0)
+                break;
+
+            if (base_pattern[i] == 0x1) {
+                if (!DISABLE_UART) {
+                    printf("~Pattern 1 : Random(seed 0x%08x)\n", dword_random_seed);
+                }
+            }
+            else if (base_pattern[i] == 0x2) {
+                if (!DISABLE_UART) {
+                    printf("~Pattern 2 : Address\n");
+                }
+            }
+            else {
+                if (!DISABLE_UART) {
+                    printf("~Pattern %d : 0x%08x\n", i+1, base_pattern[i]);
+                }
+            }
+            *(unsigned int *)(INFO_MT_PAT_ADDR) = i+1;
+
+            if(test_algorithm_t(0, base_pattern[i]))
+			return 1;
+        }
+        /* --- MT    --- */
+
+        /* +++ CT    +++ */
+        printf("4. Cache Test <CT>\n");
+		
+        *(unsigned int *)(INFO_CT_ADDR) = 1;
+
+        for (i = 0; i < DATA_PATTERN_NUM; i++) {
+            if (base_pattern[i] == 0x0)
+                break;
+
+            if (base_pattern[i] == 0x1) {
+                printf("~Pattern 1 : Random(seed 0x%08x)\n", dword_random_seed);
+            }
+            else if (base_pattern[i] == 0x2) {
+                printf("~Pattern 2 : Address\n");
+            }
+            else {
+                printf("~Pattern %d : 0x%08x\n", i+1, base_pattern[i]);
+            }
+
+            *(unsigned int *)(INFO_CT_PAT_ADDR) = i+1;
+
+            if(test_algorithm_t(1, base_pattern[i]))
+			return 1;
+        }
+        /* --- CT    --- */
+
+        /* Update Statistics*/
+        *(unsigned int *)(INFO_GEN_ADDR) = curr_round;
+
+        if (mt_fail_status || ct_fail_status) {
+            if (mt_fail_status) {
+                mt_fail_round++;
+                *(unsigned int *)(INFO_FAIL_MT_ADDR) = mt_fail_round;
+            }
+            if (ct_fail_status) {
+                ct_fail_round++;
+                *(unsigned int *)(INFO_FAIL_CT_ADDR) = ct_fail_round;
+            }
+            fail_round++;
+            *(unsigned int *)(INFO_FAIL_ADDR) = fail_round;
+        }
+	flush_cache(START_C_ADDR, TEST_SIZE);
+    } /* End of while (1) */
+}
+
+/*
+ * mem_type : 0 for memory, 1 for cache
+ */
+int test_algorithm_t(unsigned int mem_type, unsigned int pattern)
+{
+    unsigned int i;
+    unsigned int stride, offset;
+    unsigned int check_addr, check_data, check_pattern;
+    unsigned int add_as_data;
+
+    fail_status = 0;
+
+    if (!mem_type) {
+        START_ADDR = START_M_ADDR;
+        END_ADDR   = END_M_ADDR;
+    }
+    else {
+        START_ADDR = START_C_ADDR;
+        END_ADDR   = END_C_ADDR;
+    }
+
+    if (pattern == 2) {
+        add_as_data = 1;
+        pattern     = 0;
+    }
+    else {
+        add_as_data = 0;
+        if (pattern == 1) {
+            pattern = dword_random_seed;
+        }
+    }
+
+    for (i = 0; i < TEST_SIZE; i += 4) {
+        *(unsigned int *)(START_ADDR+i) = add_as_data ? (pattern ^ (START_ADDR + i)) : pattern;
+    }
+
+    for (stride = 4; stride < TEST_SIZE; stride *= 2) {
+        for (offset = 0; offset < stride; offset += 4) {
+            for (i = offset; i < TEST_SIZE; i += stride) {
+		if (ctrlc()) {
+			puts ("Stop MCT\n");
+			return 1;
+		}
+                check_addr = START_ADDR + i;
+                check_data = *(unsigned int *)check_addr;
+                check_pattern = (add_as_data ? (pattern ^ check_addr) : pattern);
+
+                if (check_data != check_pattern) {
+                    if (!mem_type)
+                        mt_fail_status = 1;
+                    else
+                        ct_fail_status = 1;
+
+                    fail_status = 1;
+
+                    *(unsigned int *)(INFO_ERROR_T_ADDR)         = 1;
+                    *(unsigned int *)(INFO_ERROR_T_INVERSE_ADDR) = 0;
+                    *(unsigned int *)(INFO_ERROR_T_STRIDE_ADDR)  = stride;
+                    *(unsigned int *)(INFO_ERROR_T_OFFSET_ADDR)  = offset;
+                    *(unsigned int *)(INFO_ERROR_T_ADR_ADDR)     = check_addr;
+                    *(unsigned int *)(INFO_ERROR_T_DATA_ADDR)    = check_data;
+                    *(unsigned int *)(INFO_ERROR_T_EDATA_ADDR)   = check_pattern;
+
+                    printf("Fail! --> addr 0x%08x, data 0x%08x(should be 0x%08x), stride 0x%08x\n", check_addr, check_data, check_pattern, stride);
+                    
+                    #if DISCARD_ERROR
+                    *(unsigned int *)check_addr = check_pattern;
+                    #else
+                    while (1) {
+				if (ctrlc()) {
+					puts ("Stop MCT\n");
+					return 1;
+				}
+                    }   //asm("nop");
+                    #endif
+                }
+
+                *(unsigned int *)check_addr = ~check_pattern;
+            } /* End of "for (i = offset; i < TEST_SIZE; i += stride)" */
+        } /* End of "for (offset = 0; offset < stride; offset += 4)" */
+
+        pattern = ~pattern;
+
+        for (offset = 0; offset < stride; offset += 4) {
+            for (i = offset; i < TEST_SIZE; i += stride) {
+                check_addr = START_ADDR + i; //check_addr = START_ADDR + TEST_SIZE - i - 4;
+                check_pattern = (add_as_data ? (pattern ^ check_addr) : pattern);
+                check_data = *(unsigned int *)check_addr;
+
+                if (check_data != check_pattern) {
+                    if (!mem_type)
+                        mt_fail_status = 1;
+                    else
+                        ct_fail_status = 1;
+
+                    fail_status = 1;
+
+                    *(unsigned int *)(INFO_ERROR_T_ADDR)         = 1;
+                    *(unsigned int *)(INFO_ERROR_T_INVERSE_ADDR) = 1;
+                    *(unsigned int *)(INFO_ERROR_T_STRIDE_ADDR)  = stride;
+                    *(unsigned int *)(INFO_ERROR_T_OFFSET_ADDR)  = offset;
+                    *(unsigned int *)(INFO_ERROR_T_ADR_ADDR)     = check_addr;
+                    *(unsigned int *)(INFO_ERROR_T_DATA_ADDR)    = check_data;
+                    *(unsigned int *)(INFO_ERROR_T_EDATA_ADDR)   = check_pattern;
+
+                    printf("Inverse Fail! --> addr 0x%08x, data 0x%08x(should be 0x%08x), stride 0x%08x\n", check_addr, check_data, check_pattern, stride);
+                    
+                    #if DISCARD_ERROR
+                    *(unsigned int *)check_addr = check_pattern;
+                    #else
+                    while (1) {
+				if (ctrlc()) {
+					puts ("Stop MCT\n");
+					return 1;
+				}
+                    }   //asm("nop");
+                    #endif
+                }
+                *(unsigned int *)check_addr = ~check_pattern;
+            } /* End if "for (i = offset; i < TEST_SIZE; i += stride)" */
+        } /* End of "for (offset = 0; offset < stride; offset += 4)" */
+
+        pattern = ~pattern;
+    } /* End of "for (stride = 4; stride < TEST_SIZE; stride *= 2)" */
+
+    if (!fail_status) {
+        printf("Pass\n");
+    }
+
+    /* Random seed changes */
+    dword_random_seed += 0x01010101;
+    dword_random_seed += dword_random_inc;
+	return 0;
+}
+
+/**************************************************/
+U_BOOT_CMD(
+	md,     3,     1,      do_mem_md,
+	"md      - memory display\n",
+	"[.b, .w, .l] address [# of objects]\n    - memory display\n"
+);
+
+
+U_BOOT_CMD(
+	mm,     2,      1,       do_mem_mm,
+	"mm      - memory modify (auto-incrementing)\n",
+	"[.b, .w, .l] address\n" "    - memory modify, auto increment address\n"
+);
+
+
+U_BOOT_CMD(
+	nm,     2,	    1,     	do_mem_nm,
+	"nm      - memory modify (constant address)\n",
+	"[.b, .w, .l] address\n    - memory modify, read and keep address\n"
+);
+
+U_BOOT_CMD(
+	mw,    4,    1,     do_mem_mw,
+	"mw      - memory write (fill)\n",
+	"[.b, .w, .l] address value [count]\n    - write memory\n"
+);
+
+U_BOOT_CMD(
+	mtest,    4,    1,     do_mem_mtest,
+	"mtest   - simple RAM test\n",
+	"[start [end [pattern]]]\n"
+	"    - simple RAM read/write test\n"
+);
+
+U_BOOT_CMD(
+	cp,    4,    1,    do_mem_cp,
+	"cp      - memory copy\n",
+	"[.b, .w, .l] source target count\n    - copy memory\n"
+);
+
+U_BOOT_CMD(
+	mct,    2,    1,     do_mem_mct,
+	"mct   - simple RAM test\n",
+	"\n"
+	"\n"
+);
+
 #endif	/* CFG_CMD_MEMORY */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/cmd_mii.c u-boot_1.1//common/cmd_mii.c
--- u-boot//common/cmd_mii.c	2014-02-18 01:46:22.499049309 -0800
+++ u-boot_1.1//common/cmd_mii.c	2014-02-18 01:46:26.507052108 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2001
  * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -28,6 +30,11 @@
 #include <common.h>
 #include <command.h>
 
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#ifndef COMPRESSED_UBOOT
 #if (CONFIG_COMMANDS & CFG_CMD_MII)
 #include <miiphy.h>
 
@@ -117,7 +124,7 @@
 			}
 		}
 	} else if (op == 'r') {
-		if (miiphy_read (devname, addr, reg, &data) != 0) {
+		if (miiphy_read (devname, addr, reg, &data) < 0) {
 			puts ("Error reading from the PHY\n");
 			rcode = 1;
 		} else {
@@ -506,7 +513,7 @@
 		for (addr = addrlo; addr <= addrhi; addr++) {
 			for (reg = reglo; reg <= reghi; reg++) {
 				data = 0xffff;
-				if (miiphy_read (devname, addr, reg, &data) != 0) {
+				if (miiphy_read (devname, addr, reg, &data) < 0) {
 					printf(
 					"Error reading from the PHY addr=%02x reg=%02x\n",
 						addr, reg);
@@ -542,7 +549,7 @@
 		}
 		for (addr = addrlo; addr <= addrhi; addr++) {
 			for (reg = reglo; reg < reghi + 1; reg++) {
-				if (miiphy_read(devname, addr, reg, &regs[reg]) != 0) {
+				if (miiphy_read(devname, addr, reg, &regs[reg]) < 0) {
 					ok = 0;
 					printf(
 					"Error reading from the PHY addr=%02x reg=%02x\n",
@@ -593,5 +600,451 @@
 );
 
 #endif /* CONFIG_TERSE_MII */
-
 #endif /* CFG_CMD_MII */
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef BOARDCAL
+extern flash_info_t flash_info[];	/* info for FLASH chips */
+
+/**********************************************************************************
+** do_mac_setting
+**
+** This is the executable portion of the progmac command.  This will process the
+** MAC address strings, and program them into the appropriate flash sector..
+**
+*/
+#ifdef CONFIG_ATH_NAND_BR
+
+#define ATH_NAND_NAND_PART              "ath-nand"
+
+
+unsigned long long
+ath_nand_get_cal_offset(const char *ba)
+{
+        char *mtdparts, ch, *pn, *end;
+        unsigned long long off = 0, size;
+
+        mtdparts = strstr(ba, ATH_NAND_NAND_PART);
+        if (!mtdparts) {
+                goto bad;
+        }
+        mtdparts = strstr(mtdparts, ":");
+        if (!mtdparts) {
+                goto bad;
+        }
+        end = strstr(mtdparts, " ");
+        if (!end) {
+                end = mtdparts + strlen(mtdparts);
+        }
+
+        for (;mtdparts && mtdparts < end;) {
+                mtdparts ++;
+                size = simple_strtoul(mtdparts, &mtdparts, 0);
+                ch = *mtdparts;
+                switch (ch) {
+                case 'g': case 'G': size = size * 1024;
+                case 'm': case 'M': size = size * 1024;
+                case 'k': case 'K': size = size * 1024;
+                }
+                pn = mtdparts + 2;
+                if (strncmp(pn, ATH_CAL_NAND_PARTITION,
+                        sizeof(ATH_CAL_NAND_PARTITION) - 1) == 0) {
+                        return off;
+                }
+                off += size;
+                mtdparts = strstr(mtdparts, ",");
+        }
+
+bad:
+        return ATH_CAL_OFF_INVAL;
+}
+
+/**********************************************************************************
+** do_mac_setting
+**
+** This is the executable portion of the progmac command.  This will process the
+** MAC address strings, and program them into the appropriate flash sector..
+**
+*/
+
+int do_mac (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	char    sectorBuff[256*1024];
+	int     serno;
+	int     product_id;
+	int     ret;
+	ulong   off, size;
+	nand_info_t *nand;
+		
+	/* 
+	 * caldata partition is of 128k 
+	 *
+	 */
+	nand = &nand_info[nand_curr_device];
+	size = nand->erasesize;
+	/*
+	 * Argv[1] contains the value string.  Convert to binary, and
+	 * program the values in flash
+	 */
+
+	serno = simple_strtoul(argv[1],0,10);
+
+	/*
+	 * If the serial number is less than 0, or greater than
+	 * 0x1fff, it's out of range
+	 */
+
+	if(serno < 0 || serno > 0x1fff) {
+		printf("Serno out of range\n",serno);
+		return 1;
+	}
+
+    if (argc > 2) {
+        product_id = simple_strtoul(argv[2], 0, 10);
+    } else {
+        product_id = ATHEROS_PRODUCT_ID;
+    } 
+
+	if(product_id < 0 || product_id > 0x7ff) {
+		printf("product id out of range %d\n", product_id);
+		return 1;
+	}
+
+	/*
+	 * Create the 24 bit number that composes the lower 3 bytes of
+	 * the MAC address
+	 */
+
+	serno = 0xFFFFFF & ( (product_id << 13) | (serno & 0x1fff));
+
+	/*
+	 * Get the Offset of Caldata partition
+	 */
+	off = ath_nand_get_cal_offset(getenv("bootargs"));
+	if(off == ATH_CAL_OFF_INVAL) {
+		printf("Invalid CAL offset \n");
+		return 1;
+	}
+	
+         
+	/*
+	 * Get the values from flash, and program into the MAC address
+	 * registers
+	 */
+	ret = nand_read(nand, (loff_t)off, &size, (u_char *)sectorBuff);
+	printf(" %d bytes %s: %s\n", size,
+		       "read", ret ? "ERROR" : "OK");
+	if(ret != 0 ) {
+		return 1;
+	}
+	
+	/*
+	 * Set the first and second values
+	 */
+
+	sectorBuff[0] = 0x00;
+	sectorBuff[1] = 0x03;
+	sectorBuff[2] = 0x7f;
+
+	sectorBuff[3] = 0xFF & (serno >> 16);
+	sectorBuff[4] = 0xFF & (serno >> 8);
+	sectorBuff[5] = 0xFF &  serno;
+
+	/*
+	 * Increment by 1 for the second MAC address
+	 */
+
+	serno++;
+	memcpy(&sectorBuff[6],&sectorBuff[0],3);
+	sectorBuff[9]  = 0xFF & (serno >> 16);
+	sectorBuff[10] = 0xFF & (serno >> 8);
+	sectorBuff[11] = 0xFF &  serno;
+	
+	ret = nand_erase(nand,(loff_t)off, size);
+	printf(" %d bytes %s: %s\n", size,
+		       "erase", ret ? "ERROR" : "OK");
+
+	if(ret != 0 ) {
+		return 1;
+	}
+
+	ret = nand_write(nand, (loff_t)off, &size, (u_char *)sectorBuff);
+	printf(" %d bytes %s: %s\n", size,
+		       "write", ret ? "ERROR" : "OK");
+	if(ret != 0 ) {
+		return 1;
+	}
+
+	return 0;
+}
+#else /*CONFIG_ATH_NAND_BR */
+
+int do_mac (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	char    sectorBuff[CFG_FLASH_SECTOR_SIZE];
+	int     serno;
+	int     product_id;
+
+	/*
+	 * Argv[1] contains the value string.  Convert to binary, and
+	 * program the values in flash
+	 */
+
+	serno = simple_strtoul(argv[1],0,10);
+
+	/*
+	 * If the serial number is less than 0, or greater than
+	 * 0x1fff, it's out of range
+	 */
+
+	if(serno < 0 || serno > 0x1fff) {
+		printf("Serno out of range\n",serno);
+		return 1;
+	}
+
+    if (argc > 2) {
+        product_id = simple_strtoul(argv[2], 0, 10);
+    } else {
+        product_id = ATHEROS_PRODUCT_ID;
+    } 
+
+	if(product_id < 0 || product_id > 0x7ff) {
+		printf("product id out of range %d\n", product_id);
+		return 1;
+	}
+
+	/*
+	 * Create the 24 bit number that composes the lower 3 bytes of
+	 * the MAC address
+	 */
+
+	serno = 0xFFFFFF & ( (product_id << 13) | (serno & 0x1fff));
+
+	/*
+	 * Get the values from flash, and program into the MAC address
+	 * registers
+	 */
+
+	memcpy(sectorBuff,(void *)BOARDCAL, CFG_FLASH_SECTOR_SIZE);
+
+	/*
+	 * Set the first and second values
+	 */
+
+	sectorBuff[0] = 0x00;
+	sectorBuff[1] = 0x03;
+	sectorBuff[2] = 0x7f;
+
+	sectorBuff[3] = 0xFF & (serno >> 16);
+	sectorBuff[4] = 0xFF & (serno >> 8);
+	sectorBuff[5] = 0xFF &  serno;
+
+	/*
+	 * Increment by 1 for the second MAC address
+	 */
+
+	serno++;
+	memcpy(&sectorBuff[6],&sectorBuff[0],3);
+	sectorBuff[9]  = 0xFF & (serno >> 16);
+	sectorBuff[10] = 0xFF & (serno >> 8);
+	sectorBuff[11] = 0xFF &  serno;
+
+	flash_erase(flash_info,CAL_SECTOR,CAL_SECTOR);
+	write_buff(flash_info,sectorBuff, BOARDCAL, CFG_FLASH_SECTOR_SIZE);
+
+	return 0;
+}
+#endif /*CONFIG_ATH_NAND_BR */
+
+U_BOOT_CMD(
+    progmac, 3, 0, do_mac,
+    "progmac - Set ethernet MAC addresses\n",
+    "progmac <serno> [<product_id>] - Program the MAC addresses\n"
+    "                <serno> is the value of the last\n"
+    "                4 digits (decimal) of the serial number.\n"
+    "                Optional parameter <product_id> specifies\n"
+    "                the board's product ID (decimal)\n"
+);
+
+#ifdef CONFIG_ATH_NAND_BR
+#define SECTOR_BUFF_SIZE 256*1024
+#else
+#define SECTOR_BUFF_SIZE CFG_FLASH_SECTOR_SIZE
+#endif
+
+static int process(char **s, u_char *val)
+{
+	char *p = *s;
+	u_char x;
+
+	if (*p == ':')
+		p ++;
+
+	if (*p >= '0' && *p <= '9')
+		x = *p - '0';
+	else if (*p >= 'a' && *p <= 'f')
+		x = *p - 'a' + 10;
+	else if (*p >= 'A' && *p <= 'F')
+		x = *p - 'A' + 10;
+	else return -1;
+
+	x = x << 4;
+	p ++;
+
+	if (*p >= '0' && *p <= '9')
+		x |= *p - '0';
+	else if (*p >= 'a' && *p <= 'f')
+		x |= *p - 'a' + 10;
+	else if (*p >= 'A' && *p <= 'F')
+		x |= *p - 'A' + 10;
+	else return -1;
+
+	*s = (p + 1);
+	*val = x;
+
+	return 0;
+}
+
+typedef union {
+	uint8_t		b[6];
+	uint64_t	m;
+	uint32_t	w[2];
+} ath_mac_addr_t;
+
+static int str_to_mac(char *s, ath_mac_addr_t *m)
+{
+	ath_mac_addr_t mac;
+	int i;
+
+	mac.m = 0;
+
+	for (i = 0; i < sizeof(mac.b) && *s; i++) {
+		if (process(&s, &mac.b[i])) {
+			return -1;
+		}
+	}
+
+	if (i != sizeof(mac.b)) {
+		return -1;
+	}
+
+	printf("%02x:%02x:%02x:%02x:%02x:%02x\n", mac.b[0], mac.b[1], mac.b[2], mac.b[3], mac.b[4], mac.b[5]);
+	printf("%x %x\n", mac.w[0], mac.w[1]);
+
+	*m = mac;
+
+	return 0;
+}
+
+/**********************************************************************************
+** do_mac_setting
+**
+** This is the executable portion of the progmac command.  This will process the
+** MAC address strings, and program them into the appropriate flash sector..
+**
+*/
+
+int do_mac2 (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	char    sectorBuff[SECTOR_BUFF_SIZE];
+	ath_mac_addr_t mac0, mac1;
+#ifdef CONFIG_ATH_NAND_BR
+	int     ret;
+	ulong   off, size;
+	nand_info_t *nand;
+		
+	/* 
+	 * caldata partition is of 128k 
+	 *
+	 */
+	nand = &nand_info[nand_curr_device];
+	size = nand->erasesize;
+#endif
+
+	if (argc < 3) {
+		printf ("Usage:\n%s\n", cmdtp->usage);
+		printf ("progmac2 <eth0 mac> <eth1 mac>\n");
+		return 1;
+	}
+
+	if (str_to_mac(argv[1], &mac0)) {
+		printf("eth0 mac is invalid\n");
+		return 1;
+	}
+
+	if (str_to_mac(argv[2], &mac1)) {
+		printf("eth1 mac is invalid\n");
+		return 1;
+	}
+	
+#ifdef CONFIG_ATH_NAND_BR
+	/*
+	 * Get the Offset of Caldata partition
+	 */
+	off = ath_nand_get_cal_offset(getenv("bootargs"));
+	if(off == ATH_CAL_OFF_INVAL) {
+		printf("Invalid CAL offset \n");
+		return 1;
+	}
+	
+         
+	/*
+	 * Get the values from flash, and program into the MAC address
+	 * registers
+	 */
+	ret = nand_read(nand, (loff_t)off, &size, (u_char *)sectorBuff);
+	printf(" %d bytes %s: %s\n", size,
+		       "read", ret ? "ERROR" : "OK");
+	if(ret != 0 ) {
+		return 1;
+	}
+#else
+	memcpy(sectorBuff,(void *)BOARDCAL, CFG_FLASH_SECTOR_SIZE);
+#endif
+	
+	/*
+	 * Set the MAC0 value
+	 */
+	
+	memcpy(&sectorBuff[0],&mac0.b[0],6);
+
+	/*
+	 * Set the MAC1 value
+	 */
+
+	memcpy(&sectorBuff[6],&mac1.b[0],6);
+	
+#ifdef CONFIG_ATH_NAND_BR
+	ret = nand_erase(nand,(loff_t)off, size);
+	printf(" %d bytes %s: %s\n", size,
+		       "erase", ret ? "ERROR" : "OK");
+
+	if(ret != 0 ) {
+		return 1;
+	}
+
+	ret = nand_write(nand, (loff_t)off, &size, (u_char *)sectorBuff);
+	printf(" %d bytes %s: %s\n", size,
+		       "write", ret ? "ERROR" : "OK");
+	if(ret != 0 ) {
+		return 1;
+	}
+#else
+	flash_erase(flash_info,CAL_SECTOR,CAL_SECTOR);
+	write_buff(flash_info,sectorBuff, BOARDCAL, CFG_FLASH_SECTOR_SIZE);
+#endif
+
+	return 0;
+}
+
+U_BOOT_CMD(
+    progmac2, 3, 0, do_mac2,
+    "progmac2 - Set ethernet MAC addresses\n",
+    "progmac2 <eth0 mac> <eth1 mac> - Program the MAC addresses\n"
+    "                  <eth0 mac> is the eth0 MAC address\n"
+    "                  <eth1 mac> is the eth1 MAC address\n"
+    "                  MAC address can be in the format\n"
+    "                  <aa:bb:cc:dd:ee:ff> or <aabbccddeeff>\n"
+);
+#endif /* BOARDCAL */
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/cmd_nand.c u-boot_1.1//common/cmd_nand.c
--- u-boot//common/cmd_nand.c	2014-02-18 01:46:22.499049309 -0800
+++ u-boot_1.1//common/cmd_nand.c	2014-02-18 01:46:26.511052111 -0800
@@ -6,6 +6,7 @@
  *
  * Added 16-bit nand support
  * (C) 2004 Texas Instruments
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
  */
 
 #include <common.h>
@@ -38,12 +39,7 @@
 
 extern nand_info_t nand_info[];       /* info for NAND chips */
 
-static int nand_dump_oob(nand_info_t *nand, ulong off)
-{
-	return 0;
-}
-
-static int nand_dump(nand_info_t *nand, ulong off)
+static int nand_raw_dump(nand_info_t *nand, ulong off, int page)
 {
 	int i;
 	u_char *buf, *p;
@@ -63,10 +59,12 @@
 	printf("Page %08x dump:\n", off);
 	i = nand->oobblock >> 4; p = buf;
 	while (i--) {
-		printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x"
-			"  %02x %02x %02x %02x %02x %02x %02x %02x\n",
-			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
-			p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+		if (page) {
+			printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x"
+				"  %02x %02x %02x %02x %02x %02x %02x %02x\n",
+				p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+				p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+		}
 		p += 16;
 	}
 	puts("OOB:\n");
@@ -81,6 +79,16 @@
 	return 0;
 }
 
+static int nand_dump_oob(nand_info_t *nand, ulong off)
+{
+	return nand_raw_dump(nand, off, 0);
+}
+
+static int nand_dump(nand_info_t *nand, ulong off)
+{
+	return nand_raw_dump(nand, off, 1);
+}
+
 /* ------------------------------------------------------------------------- */
 
 static void
@@ -205,7 +213,7 @@
 		printf("\nNAND erase: device %d offset 0x%x, size 0x%x ",
 		       nand_curr_device, off, size);
 		ret = nand_erase(nand, off, size);
-		printf("%s\n", ret ? "ERROR" : "OK");
+		printf("\n%s\n", ret ? "ERROR" : "OK");
 
 		return ret == 0 ? 0 : 1;
 	}
@@ -246,13 +254,13 @@
 			return 1;
 
 		i = strncmp(cmd, "read", 4) == 0;	/* 1 = read, 0 = write */
-		printf("\nNAND %s: device %d offset %u, size %u ... ",
+		printf("\nNAND %s: device %d offset 0x%x, size %u ... ",
 		       i ? "read" : "write", nand_curr_device, off, size);
 
 		if (i)
-			ret = nand_read(nand, off, &size, (u_char *)addr);
+			ret = nand_read(nand, (loff_t)off, &size, (u_char *)addr);
 		else
-			ret = nand_write(nand, off, &size, (u_char *)addr);
+			ret = nand_write(nand, (loff_t)off, &size, (u_char *)addr);
 
 		printf(" %d bytes %s: %s\n", size,
 		       i ? "read" : "written", ret ? "ERROR" : "OK");
@@ -361,20 +369,25 @@
 	/* Loading ok, update default load address */
 
 	load_addr = addr;
-
+#ifndef CONFIG_ATH_NAND_SUPPORT
 	/* Check if we should attempt an auto-start */
 	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep, "yes") == 0)) {
+#endif
 		char *local_args[2];
 		extern int do_bootm(cmd_tbl_t *, int, int, char *[]);
 
 		local_args[0] = argv[0];
 		local_args[1] = NULL;
 
+#ifndef CONFIG_ATH_NAND_SUPPORT
 		printf("Automatic boot of image at addr 0x%08lx ...\n", addr);
+#endif
 
 		do_bootm(cmdtp, 0, 1, local_args);
 		return 1;
+#ifndef CONFIG_ATH_NAND_SUPPORT
 	}
+#endif
 	return 0;
 }
 
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/cmd_net.c u-boot_1.1//common/cmd_net.c
--- u-boot//common/cmd_net.c	2014-02-18 01:46:22.499049309 -0800
+++ u-boot_1.1//common/cmd_net.c	2014-02-18 01:46:26.511052111 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2000
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -34,7 +36,7 @@
 extern int do_bootm (cmd_tbl_t *, int, int, char *[]);
 
 static int netboot_common (proto_t, cmd_tbl_t *, int , char *[]);
-
+#ifndef COMPRESSED_UBOOT
 int do_bootp (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	return netboot_common (BOOTP, cmdtp, argc, argv);
@@ -46,25 +48,25 @@
 	"[loadAddress] [bootfilename]\n"
 );
 
-int do_tftpb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+int do_rarpb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	return netboot_common (TFTP, cmdtp, argc, argv);
+	return netboot_common (RARP, cmdtp, argc, argv);
 }
 
 U_BOOT_CMD(
-	tftpboot,	3,	1,	do_tftpb,
-	"tftpboot- boot image via network using TFTP protocol\n",
+	rarpboot,	3,	1,	do_rarpb,
+	"rarpboot- boot image via network using RARP/TFTP protocol\n",
 	"[loadAddress] [bootfilename]\n"
 );
-
-int do_rarpb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+#endif /* #ifndef COMPRESSED_UBOOT */
+int do_tftpb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	return netboot_common (RARP, cmdtp, argc, argv);
+	return netboot_common (TFTP, cmdtp, argc, argv);
 }
 
 U_BOOT_CMD(
-	rarpboot,	3,	1,	do_rarpb,
-	"rarpboot- boot image via network using RARP/TFTP protocol\n",
+	tftpboot,	3,	1,	do_tftpb,
+	"tftpboot- boot image via network using TFTP protocol\n",
 	"[loadAddress] [bootfilename]\n"
 );
 
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/cmd_pll.c u-boot_1.1//common/cmd_pll.c
--- u-boot//common/cmd_pll.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//common/cmd_pll.c	2014-02-18 01:46:26.515052114 -0800
@@ -0,0 +1,308 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <environment.h>
+#include <command.h>
+#include <config.h>
+#ifndef CONFIG_ATHEROS
+#include <ar7240_soc.h>
+#endif
+
+#ifndef CONFIG_ATH_EMULATION
+#if (CONFIG_COMMANDS & CFG_CMD_PLL)
+#if defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x) || defined(CONFIG_MACH_QCA956x)
+int do_pll (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	extern env_t	*env_ptr;
+	extern int saveenv(void);
+	extern void env_crc_update (void);
+
+	unsigned	*val;
+
+	if (argc != 2 && argc != 5) {
+		printf(cmdtp->usage);
+		return -1;
+	}
+
+	val = (unsigned *)env_ptr->data +
+		(sizeof(env_ptr->data) / sizeof(*val)) - (32 / sizeof(*val));
+
+	if (strcmp(argv[1], "erase") == 0) {
+		printf("Erasing flash setting\n");
+		val[0] = val[1] =
+		val[2] = val[3] =
+		val[4] = val[5] = 0xffffffffu;
+	} else if (strcmp(argv[1], "get") == 0) {
+		printf("pll 0x%x 0x%x 0x%x 0x%x\n", val[1], val[2], val[3], val[4]);
+		return 0;
+	} else if (argc > 2) {
+		val[0] = PLL_MAGIC;
+
+		val[1] = simple_strtoul(argv[1], NULL, 16);
+		val[2] = simple_strtoul(argv[2], NULL, 16);
+		val[3] = simple_strtoul(argv[3], NULL, 16);
+		val[4] = simple_strtoul(argv[4], NULL, 16);
+		printf("Setting 0x%x 0x%x 0x%x 0x%x\n", val[1], val[2], val[3], val[4]);
+	} else {
+		printf(cmdtp->usage);
+		return -1;
+	}
+
+	env_crc_update();
+	saveenv();
+
+	return 0;
+
+}
+
+U_BOOT_CMD(
+	pll,	5,	0,	do_pll,
+#ifdef COMPRESSED_UBOOT
+	NULL, NULL
+#else
+	"pll cpu-pll dither ddr-pll dither - Set to change CPU & DDR speed\npll erase\npll get\n", NULL
+#endif
+);
+
+#elif defined(CONFIG_WASP_SUPPORT)
+#include <asm/addrspace.h>
+
+int do_srifpll (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	extern env_t	*env_ptr;
+	extern int saveenv(void);
+	extern void env_crc_update (void);
+
+	unsigned	*val;
+
+	if (argc != 2 && argc != 3) {
+		printf(cmdtp->usage);
+		return -1;
+	}
+
+	val = env_ptr->data + sizeof(env_ptr->data) - 0x20 - 0xc;
+
+	if (strcmp(argv[1], "erase") == 0) {
+		printf("Erasing flash setting\n");
+		val[0] = val[1] = val[2] = 0xffffffffu;
+	} else if (strcmp(argv[1], "get") == 0) {
+		printf("srifpll 0x%x 0x%x\n", val[1], val[2]);
+		return 0;
+	} else if (argc > 2) {
+		val[0] = SRIF_PLL_MAGIC;
+
+		val[1] = simple_strtoul(argv[1], NULL, 16);
+		val[2] = simple_strtoul(argv[2], NULL, 16);
+		printf("Setting 0x%x 0x%x\n", val[1], val[2]);
+	} else {
+		printf(cmdtp->usage);
+		return -1;
+	}
+
+	env_crc_update();
+	saveenv();
+
+	return 0;
+
+}
+
+int do_pll (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	extern env_t	*env_ptr;
+	extern int saveenv(void);
+	extern void env_crc_update (void);
+
+	unsigned	*val;
+
+	if (argc != 2 && argc != 6) {
+		printf(cmdtp->usage);
+		return -1;
+	}
+
+	val = (unsigned *)env_ptr->data +
+		(sizeof(env_ptr->data) / sizeof(*val)) - (32 / sizeof(*val));
+
+	if (strcmp(argv[1], "erase") == 0) {
+		printf("Erasing flash setting\n");
+		val[0] = val[1] =
+		val[2] = val[3] =
+		val[4] = val[5] = 0xffffffffu;
+	} else if (strcmp(argv[1], "get") == 0) {
+		printf("pll 0x%x 0x%x 0x%x 0x%x 0x%x\n", val[1], val[2], val[3], val[4], val[5]);
+		return 0;
+	} else if (argc > 2) {
+		val[0] = PLL_MAGIC;
+
+		val[1] = simple_strtoul(argv[1], NULL, 16);
+		val[2] = simple_strtoul(argv[2], NULL, 16);
+		val[3] = simple_strtoul(argv[3], NULL, 16);
+		val[4] = simple_strtoul(argv[4], NULL, 16);
+		val[5] = simple_strtoul(argv[5], NULL, 16);
+		printf("Setting 0x%x 0x%x 0x%x 0x%x 0x%x\n", val[1], val[2], val[3], val[4], val[5]);
+	} else {
+		printf(cmdtp->usage);
+		return -1;
+	}
+
+	env_crc_update();
+	saveenv();
+
+	return 0;
+
+}
+
+U_BOOT_CMD(
+	pll,	6,	0,	do_pll,
+#ifdef COMPRESSED_UBOOT
+	NULL, NULL
+#else
+	"pll cpu-pll dither ddr-pll dither - Set to change CPU & DDR speed\npll erase\npll get\n", NULL
+#endif
+);
+
+U_BOOT_CMD(
+	srifpll,	3,	0,	do_srifpll,
+#ifdef COMPRESSED_UBOOT
+	NULL, NULL
+#else
+	"srifpll cpu-pll ddr-pll - To change CPU & DDR speed through srif\nsrifpll erase\nsrifpll get\n", NULL
+#endif
+);
+#else	/* CONFIG_WASP_SUPPORT */
+typedef struct {
+	char		*freq;
+	unsigned	ddr,
+			ahb,
+			pll,
+			ref;
+} plldef_t;
+
+static plldef_t plldef[] = {
+	{ "400_400_200", 0x0u, 0x0u, 0x28u, 0x2u },
+	{ "400_400_100", 0x0u, 0x1u, 0x28u, 0x2u },
+	{ "360_360_180", 0x0u, 0x0u, 0x24u, 0x2u },
+	{ "350_350_175", 0x0u, 0x0u, 0x23u, 0x2u },
+	{ "340_340_170", 0x0u, 0x0u, 0x22u, 0x2u },
+	{ "320_320_160", 0x0u, 0x0u, 0x20u, 0x2u },
+	{ "320_320_80",  0x0u, 0x1u, 0x20u, 0x2u },
+	{ "300_300_150", 0x0u, 0x0u, 0x1eu, 0x2u },
+	{ "300_300_75",  0x0u, 0x1u, 0x1eu, 0x2u },
+	{ "200_200_100", 0x0u, 0x0u, 0x14u, 0x2u },
+	{ "370_370_185", 0x0u, 0x0u, 0x25u, 0x2u },
+	{ "380_380_190", 0x0u, 0x0u, 0x26u, 0x2u },
+	{ "390_390_195", 0x0u, 0x0u, 0x27u, 0x2u },
+	{ "410_410_205", 0x0u, 0x0u, 0x29u, 0x2u },
+	{ "420_420_210", 0x0u, 0x0u, 0x2au, 0x2u },
+	{ "430_430_215", 0x0u, 0x0u, 0x2bu, 0x2u },
+	{ NULL, 0x0u, 0x0u, 0x0u, 0x0u }	/* Terminator */
+};
+
+int do_pll (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	extern env_t	*env_ptr;
+	extern int saveenv(void);
+	extern void env_crc_update (void);
+
+	plldef_t	*p;
+	unsigned	*val;
+
+#ifndef COMPRESSED_UBOOT
+	if (argc == 1) {
+		/* list known frequencies */
+		printf("List of known frequencies:\n");
+		for (p = plldef; p->freq; p ++) {
+			printf("\t%s\n", p->freq);
+		}
+		return 0;
+	}
+#endif
+
+	if (argc != 2) {
+		printf(cmdtp->usage);
+		return -1;
+	}
+
+	val = (unsigned *)env_ptr->data;
+
+	/*
+	 * We use the last 16 bytes of envmt data.
+	 * Position the pointer appropriately.
+	 */
+	val += (sizeof(env_ptr->data) / sizeof(*val))
+		- (16 / sizeof(*val));
+
+	val[0] = PLL_MAGIC;
+
+	/*
+	 * XXX XXX XXX WARNING XXX XXX XXX
+	 * Doesn't detect arguments like aaa_bbb_ccc that
+	 * are not present in the above table. They will
+	 * get processed in strtoul, and an incorrect
+	 * value will be set, instead of flagging an error
+	 *
+	 * This does not take care of redefining CFG_HZ
+	 */
+	for (p = plldef; p->freq; p ++) {
+		if (strcmp(argv[1], p->freq) == 0) {
+			val[1] = (unsigned)(
+					(p->ddr << PLL_CONFIG_DDR_DIV_SHIFT) |
+					(p->ahb << PLL_CONFIG_AHB_DIV_SHIFT) |
+					(p->pll << PLL_CONFIG_PLL_DIV_SHIFT) |
+					(p->ref << PLL_CONFIG_PLL_REF_DIV_SHIFT));
+			break;
+		}
+	}
+	if (!p->freq) {
+		if (strcmp(argv[1], "erase") == 0) {
+			val[0] = 0xffffffffu;
+			val[1] = 0xffffffffu;
+		} else {
+			val[1] = simple_strtoul(argv[1], NULL, 10);
+		}
+	}
+
+#ifndef COMPRESSED_UBOOT
+	printf("magic: 0x%08x	value: 0x%08x\n", val[0], val[1]);
+#endif
+
+	env_crc_update();
+	saveenv();
+
+	return 0;
+}
+
+/***************************************************/
+
+U_BOOT_CMD(
+	pll,	2,	0,	do_pll,
+#ifdef COMPRESSED_UBOOT
+	NULL, NULL
+#else
+	"pll [<val>] - Set to change CPU/AHB/DDR speeds\n",
+	"<val> - 300_300_150\n"
+#endif
+);
+#endif /* CONFIG_WASP_SUPPORT */
+
+#endif	/* CONFIG_COMMANDS & CFG_CMD_PLL */
+#endif // CONFIG_ATH_EMULATION
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/command.c u-boot_1.1//common/command.c
--- u-boot//common/command.c	2014-02-18 01:46:22.511049318 -0800
+++ u-boot_1.1//common/command.c	2014-02-18 01:46:26.527052121 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2000-2003
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ * 
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -78,6 +80,7 @@
 
 #endif	/*  CFG_CMD_ECHO */
 
+#ifndef COMPRESSED_UBOOT
 #ifdef CFG_HUSH_PARSER
 
 int
@@ -230,6 +233,7 @@
 
 
 #endif
+#endif /* #ifdef COMPRESSED_UBOOT */
 
 /*
  * Use puts() instead of printf() to avoid printf buffer overflow
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/env_common.c u-boot_1.1//common/env_common.c
--- u-boot//common/env_common.c	2014-02-18 01:46:22.519049322 -0800
+++ u-boot_1.1//common/env_common.c	2014-02-18 01:46:26.539052130 -0800
@@ -1,10 +1,12 @@
 /*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * (C) Copyright 2000-2002
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
  * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
  * Andreas Heppel <aheppel@sysgo.de>
-
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -207,7 +209,7 @@
 	enable_nvram();
 #endif
 
-#ifdef ENV_IS_EMBEDDED
+#if defined(ENV_IS_EMBEDDED)
 	/*
 	 * The environment buffer is embedded with the text segment,
 	 * just relocate the environment pointer
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/main.c u-boot_1.1//common/main.c
--- u-boot//common/main.c	2014-02-18 01:46:22.527049328 -0800
+++ u-boot_1.1//common/main.c	2014-02-18 01:46:26.551052139 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2000
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -40,6 +42,10 @@
 DECLARE_GLOBAL_DATA_PTR;
 #endif
 
+#ifdef CONFIG_DUALIMAGE_SUPPORT
+extern unsigned findbdr(unsigned int flashaddr);
+#endif
+
 #if defined(CONFIG_BOOT_RETRY_TIME) && defined(CONFIG_RESET_TO_RETRY)
 extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);		/* for do_reset() prototype */
 #endif
@@ -382,7 +388,7 @@
 	s = getenv ("bootdelay");
 	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
 
-	debug ("### main_loop entered: bootdelay=%d\n\n", bootdelay);
+//	debug ("### main_loop entered: bootdelay=%d\n\n", bootdelay);
 
 # ifdef CONFIG_BOOT_RETRY_TIME
 	init_cmd_timeout ();
@@ -397,8 +403,25 @@
 	else
 #endif /* CONFIG_BOOTCOUNT_LIMIT */
 		s = getenv ("bootcmd");
+       if (!s) {
+#ifdef CONFIG_ROOTFS_FLASH
+           /* XXX if rootfs is in flash, expect uImage to be in flash */
+#ifdef CONFIG_AR7100
+           setenv ("bootcmd", "bootm 0xbf200000");
+#else
+           setenv ("bootcmd", "bootm 0xbf450000");
+#endif /* CONFIG_AR7100 */
+#else
+           setenv ("bootcmd", "tftpboot 0x8022c090 uImage; bootm 0x8022c090");
+#endif
+       }
+
+#ifdef CONFIG_DUALIMAGE_SUPPORT
+		findbdr(0);
+#endif
+		s = getenv ("bootcmd");
 
-	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");
+//	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");
 
 	if (bootdelay >= 0 && s && !abortboot (bootdelay)) {
 # ifdef CONFIG_AUTOBOOT_KEYED
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//common/Makefile u-boot_1.1//common/Makefile
--- u-boot//common/Makefile	2014-02-18 01:46:22.479049294 -0800
+++ u-boot_1.1//common/Makefile	2014-02-18 01:46:26.479052086 -0800
@@ -2,6 +2,8 @@
 # (C) Copyright 2004
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
 # See file CREDITS for list of people who contributed to this
 # project.
 #
@@ -27,6 +29,26 @@
 
 AOBJS	=
 
+ifeq ($(COMPRESSED_UBOOT),1)
+COBJS	= main.o circbuf.o \
+	  cmd_boot.o cmd_bootm.o \
+	  cmd_cache.o cmd_console.o \
+	  cmd_date.o cmd_dcr.o cmd_display.o cmd_doc.o \
+	  cmd_eeprom.o \
+	  cmd_flash.o \
+	  cmd_immap.o cmd_itest.o \
+	  cmd_mem.o \
+	  cmd_mii.o cmd_misc.o \
+	  cmd_nand.o cmd_net.o cmd_nvedit.o \
+	  cmd_reginfo.o cmd_spi.o \
+	  command.o console.o devices.o dlmalloc.o docecc.o \
+	  environment.o env_common.o \
+	  env_nowhere.o \
+	  exports.o \
+	  hush.o lcd.o lists.o \
+	  memsize.o miiphybb.o miiphyutil.o \
+	  serial.o crc16.o
+else
 COBJS	= main.o ACEX1K.o altera.o bedbug.o circbuf.o \
 	  cmd_ace.o cmd_autoscript.o \
 	  cmd_bdinfo.o cmd_bedbug.o cmd_bmp.o cmd_boot.o cmd_bootm.o \
@@ -40,23 +62,37 @@
 	  cmd_nand.o cmd_net.o cmd_nvedit.o \
 	  cmd_pci.o cmd_pcmcia.o cmd_portio.o \
 	  cmd_reginfo.o cmd_reiser.o cmd_scsi.o cmd_spi.o cmd_universe.o \
-	  cmd_usb.o cmd_vfd.o \
+	  cmd_usb.o cmd_vfd.o cmd_ethreg.o cmd_pll.o \
 	  command.o console.o devices.o dlmalloc.o docecc.o \
 	  environment.o env_common.o \
 	  env_nand.o env_dataflash.o env_flash.o env_eeprom.o \
 	  env_nvram.o env_nowhere.o \
 	  exports.o \
-	  flash.o fpga.o ft_build.o \
+	  fpga.o ft_build.o \
 	  hush.o kgdb.o lcd.o lists.o lynxkdi.o \
 	  memsize.o miiphybb.o miiphyutil.o \
 	  s_record.o serial.o soft_i2c.o soft_spi.o spartan2.o spartan3.o \
 	  usb.o usb_kbd.o usb_storage.o \
 	  virtex2.o xilinx.o crc16.o xyzModem.o
+endif
+
+ifndef BOOT_FROM_NAND
+COBJS	+= flash.o
+endif
+
+ifeq ($(VXWORKS_UBOOT),1)
+COBJS	+=  cmd_elf.o
+endif
 
 OBJS	= $(AOBJS) $(COBJS)
 
 CPPFLAGS += -I..
 
+ifeq ($(DUAL_FIRMWAREIMAGE_SUPPORT),1)
+CFLAGS += -DCONFIG_DUALIMAGE_SUPPORT
+OBJS += cmd_bdr.o
+endif
+
 all:	$(LIB) $(AOBJS)
 
 $(LIB): .depend $(OBJS)
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//config.mk u-boot_1.1//config.mk
--- u-boot//config.mk	2014-02-18 01:46:22.543049340 -0800
+++ u-boot_1.1//config.mk	2014-02-18 01:46:26.575052155 -0800
@@ -2,6 +2,8 @@
 # (C) Copyright 2000
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
 # See file CREDITS for list of people who contributed to this
 # project.
 #
@@ -89,6 +91,7 @@
 HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
 HOSTSTRIP	= strip
 
+COMPRESS    = lzma
 #########################################################################
 #
 # Option checker (courtesy linux kernel) to ensure
@@ -111,6 +114,8 @@
 OBJDUMP = $(CROSS_COMPILE)objdump
 RANLIB	= $(CROSS_COMPILE)RANLIB
 
+.depend : CC = @$(CROSS_COMPILE)gcc
+
 RELFLAGS= $(PLATFORM_RELFLAGS)
 DBGFLAGS= -g #-DDEBUG
 OPTFLAGS= -Os #-fomit-frame-pointer
@@ -120,6 +125,8 @@
 endif
 OBJCFLAGS += --gap-fill=0xff
 
+LDSCRIPT_BOOTSTRAP := $(TOPDIR)/board/$(BOARDDIR)/u-boot-bootstrap.lds
+
 gccincdir := $(shell $(CC) -print-file-name=include)
 
 CPPFLAGS := $(DBGFLAGS) $(OPTFLAGS) $(RELFLAGS)		\
@@ -132,7 +139,26 @@
 CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes \
 	-DBUILD_TAG='"$(BUILD_TAG)"'
 else
-CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes
+CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes 
+ifeq ($(COMPRESSED_UBOOT),1)
+CFLAGS += -DCOMPRESSED_UBOOT=1
+endif
+
+ifeq ($(BUILD_OPTIMIZED),y)
+CFLAGS += -Os -funit-at-a-time -mips32r2 -mtune=mips32r2
+endif
+endif
+
+ifeq ($(BUILD_TYPE),jffs2)
+CFLAGS += -DROOTFS=1
+else
+ifeq ($(BUILD_TYPE),squashfs)
+CFLAGS += -DROOTFS=2
+endif
+endif
+
+ifdef ATH_SST_FLASH
+CFLAGS += -DATH_SST_FLASH=1
 endif
 
 # avoid trigraph warnings while parsing pci.h (produced by NIOS gcc-2.9)
@@ -144,10 +170,19 @@
 endif
 
 AFLAGS_DEBUG := -Wa,-gstabs
+
 AFLAGS := $(AFLAGS_DEBUG) -D__ASSEMBLY__ $(CPPFLAGS)
 
+ifeq ($(COMPRESSED_UBOOT),1)
+AFLAGS += -DCOMPRESSED_UBOOT=1
+endif
+
 LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE) $(PLATFORM_LDFLAGS)
 
+ifeq ($(COMPRESSED_UBOOT), 1)
+LDFLAGS_BOOTSTRAP += -Bstatic -T $(LDSCRIPT_BOOTSTRAP) -Ttext $(BOOTSTRAP_TEXT_BASE) $(PLATFORM_LDFLAGS)
+endif
+
 # Location of a usable BFD library, where we define "usable" as
 # "built for ${HOST}, supports ${TARGET}".  Sensible values are
 # - When cross-compiling: the root of the cross-environment
@@ -175,6 +210,8 @@
 CFLAGS := $(CFLAGS) -DPCI_66M
 endif
 
+CFLAGS += $(UBOOT_GCC_4_3_3_EXTRA_CFLAGS) -g
+
 #########################################################################
 
 export	CONFIG_SHELL HPATH HOSTCC HOSTCFLAGS CROSS_COMPILE \
@@ -182,13 +219,32 @@
 	MAKE
 export	TEXT_BASE PLATFORM_CPPFLAGS PLATFORM_RELFLAGS CPPFLAGS CFLAGS AFLAGS
 
+ifeq ($(V),1)
+  Q =
+else
+  Q = @
+endif
+
+export quiet Q V
+
 #########################################################################
 
 %.s:	%.S
-	$(CPP) $(AFLAGS) -o $@ $(CURDIR)/$<
+ifneq ($(V),1)
+	@echo [CPP] $(abspath $(CURDIR)/$<)
+endif
+	$(Q)$(CPP) $(AFLAGS) -o $@ $(CURDIR)/$<
+
 %.o:	%.S
-	$(CC) $(AFLAGS) -c -o $@ $(CURDIR)/$<
+ifneq ($(V),1)
+	@echo [CC] $(abspath $(CURDIR)/$<)
+endif
+	$(Q)$(CC) $(AFLAGS) -c -o $@ $(CURDIR)/$<
+
 %.o:	%.c
-	$(CC) $(CFLAGS) -c -o $@ $<
+ifneq ($(V),1)
+	@echo [CC] $(abspath $(CURDIR)/$<)
+endif
+	$(Q)$(CC) $(CFLAGS) -c -o $@ $<
 
 #########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/ar7240/ag7240.c u-boot_1.1//cpu/mips/ar7240/ag7240.c
--- u-boot//cpu/mips/ar7240/ag7240.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//cpu/mips/ar7240/ag7240.c	2014-02-18 01:46:26.663052209 -0800
@@ -0,0 +1,722 @@
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7240_soc.h"
+#include "ag7240.h"
+#include "ag7240_phy.h"
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ag7240_unit2mac(_unit)     ag7240_macs[(_unit)]
+#define ag7240_name2mac(name)	   strcmp(name,"eth0") ? ag7240_unit2mac(1) : ag7240_unit2mac(0)
+
+uint16_t ag7240_miiphy_read(char *devname, uint32_t phaddr,
+	       uint8_t reg);
+void  ag7240_miiphy_write(char *devname, uint32_t phaddr,
+	        uint8_t reg, uint16_t data);
+
+ag7240_mac_t *ag7240_macs[CFG_AG7240_NMACS];
+extern void ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq);
+
+#ifdef CFG_ATHRS26_PHY
+extern int athrs26_phy_setup(int unit);
+extern int athrs26_phy_is_up(int unit);
+extern int athrs26_phy_is_fdx(int unit);
+extern int athrs26_phy_speed(int unit);
+extern void athrs26_reg_init(void);
+extern void athrs26_reg_init_lan(void);
+extern int athrs26_mdc_check(void);
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+extern int athrs27_phy_setup(int unit);
+extern int athrs27_phy_is_up(int unit);
+extern int athrs27_phy_is_fdx(int unit);
+extern int athrs27_phy_speed(int unit);
+extern void athrs27_reg_init(void);
+extern void athrs27_reg_init_lan(void);
+extern int athrs27_mdc_check(void);
+#endif
+
+#ifdef CONFIG_F1E_PHY
+extern int athr_phy_setup(int unit);
+extern int athr_phy_is_up(int unit);
+extern int athr_phy_is_fdx(int unit);
+extern int athr_phy_speed(int unit);
+extern void athr_reg_init(void);
+#endif
+
+static int
+ag7240_send(struct eth_device *dev, volatile void *packet, int length)
+{
+    int i;
+
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+
+    ag7240_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+    f->pkt_size = length;
+    f->res1 = 0;
+    f->pkt_start_addr = virt_to_phys(packet);
+
+    ag7240_tx_give_to_dma(f);
+    flush_cache((u32) packet, length);
+    ag7240_reg_wr(mac, AG7240_DMA_TX_DESC, virt_to_phys(f));
+    ag7240_reg_wr(mac, AG7240_DMA_TX_CTRL, AG7240_TXE);
+
+    for (i = 0; i < MAX_WAIT; i++) {
+        udelay(10);
+        if (!ag7240_tx_owned_by_dma(f))
+            break;
+    }
+    if (i == MAX_WAIT)
+        printf("Tx Timed out\n");
+
+    f->pkt_start_addr = 0;
+    f->pkt_size = 0;
+
+    if (++mac->next_tx >= NO_OF_TX_FIFOS)
+        mac->next_tx = 0;
+
+    return (0);
+}
+
+static int ag7240_recv(struct eth_device *dev)
+{
+    int length;
+    ag7240_desc_t *f;
+    ag7240_mac_t *mac;
+ 
+    mac = (ag7240_mac_t *)dev->priv;
+
+    for (;;) {
+        f = mac->fifo_rx[mac->next_rx];
+        if (ag7240_rx_owned_by_dma(f))
+            break;
+
+        length = f->pkt_size;
+
+        NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+        flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+        ag7240_rx_give_to_dma(f);
+
+        if (++mac->next_rx >= NO_OF_RX_FIFOS)
+            mac->next_rx = 0;
+    }
+
+    if (!(ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL))) {
+        ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(f));
+        ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 1);
+    }
+
+    return (0);
+}
+
+void ag7240_mii_setup(ag7240_mac_t *mac)
+{
+    u32 mgmt_cfg_val;
+    u32 cpu_freq,ddr_freq,ahb_freq;
+    u32 check_cnt,revid_val;
+#ifdef CFG_ATHRS27_PHY
+    if (is_wasp()) {
+        printf("WASP ----> S27 PHY \n");
+        mgmt_cfg_val = 2;
+        ar7240_reg_wr(0xb8050024, 0x271);	// 25MHz ref clock
+        //ar7240_reg_wr(0xb8050024, 0x570);	// 40MHz ref clock
+        ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        return;
+    }
+#endif
+#ifdef CONFIG_AR7242_S16_PHY
+    if (is_wasp()) {
+        printf("WASP  ----> S16 PHY *\n");
+        mgmt_cfg_val = 4;
+        if(mac->mac_unit == 0)
+            ar7240_reg_wr(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+
+        ar7240_reg_rmw_clear(AG7240_ETH_SWITCH_CLK_SPARE, (1 << 6));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+#ifdef CONFIG_F1E_PHY
+    if (is_wasp()) {
+        printf("WASP  ----> F1 PHY *\n");
+        mgmt_cfg_val = 6;
+        if(mac->mac_unit == 0)
+            ar7240_reg_wr(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+
+    if ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_2) {
+        mgmt_cfg_val = 0x2;
+        if (mac->mac_unit == 0) {
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        }
+    }
+    else {
+        ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);
+        switch (ahb_freq/1000000) {
+            case 150:
+                     mgmt_cfg_val = 0x7;
+                     break;
+            case 175:
+                     mgmt_cfg_val = 0x5;
+                     break;
+            case 200:
+                     mgmt_cfg_val = 0x4;
+                     break;
+            case 210:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            case 220:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            default:
+                     mgmt_cfg_val = 0x7;
+        }
+        if ((is_ar7241() || is_ar7242())) {
+
+            /* External MII mode */
+            if (mac->mac_unit == 0 && is_ar7242()) {
+                 mgmt_cfg_val = 0x6;
+                 ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+                 ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                 ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            }
+            /* Virian */
+            mgmt_cfg_val = 0x4;
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            printf("Virian MDC CFG Value ==> %x\n",mgmt_cfg_val);
+
+        }
+      else if(is_ar933x()){
+                //GE0 receives Rx/Tx clock, and use S26 phy
+                ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_MII_GE0_SLAVE);
+                mgmt_cfg_val = 0xF;
+                if (mac->mac_unit == 1) {
+                        check_cnt = 0;
+                        while (check_cnt++ < 10) {
+                                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+#ifdef CFG_ATHRS26_PHY
+                                if(athrs26_mdc_check() == 0)
+                                        break;
+#endif
+                        }
+                        if(check_cnt == 11)
+                                printf("%s: MDC check failed\n", __func__);
+                }
+      }
+        else { /* Python 1.0 & 1.1 */
+             if (mac->mac_unit == 0) {
+                     check_cnt = 0;
+                     while (check_cnt++ < 10) {
+                             ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                             ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+#ifdef CFG_ATHRS26_PHY
+                             if(athrs26_mdc_check() == 0)
+                                     break;
+#endif
+                     }
+                     if(check_cnt == 11)
+                             printf("%s: MDC check failed\n", __func__);
+             }
+        }
+ 
+    }
+}
+
+static void ag7240_hw_start(ag7240_mac_t *mac)
+{
+
+    if(mac->mac_unit)
+    {
+        ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+            AG7240_MAC_CFG1_TX_EN));
+        ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+            AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_1000));
+    }
+    else {
+
+    ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+		    AG7240_MAC_CFG1_TX_EN));
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+		         AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_10_100));
+   }
+   ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_0, 0x1f00);
+
+   ag7240_mii_setup(mac);
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0x10ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0xAAA0555);
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_4, 0x3ffff);
+    /* 
+     * Setting Drop CRC Errors, Pause Frames,Length Error frames 
+     * and Multi/Broad cast frames. 
+     */
+#ifdef AG7240_BROADCAST_ENABLE
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0xe6be2);
+#else
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0x7eccf);
+#endif
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_3, 0x1f00140);
+
+    printf(": cfg1 %#x cfg2 %#x\n", ag7240_reg_rd(mac, AG7240_MAC_CFG1),
+        ag7240_reg_rd(mac, AG7240_MAC_CFG2));
+
+}
+
+static int ag7240_check_link(ag7240_mac_t *mac)
+{
+    u32 link, duplex, speed, fdx;
+
+    ag7240_phy_link(mac->mac_unit, &link);
+    ag7240_phy_duplex(mac->mac_unit, &duplex);
+    ag7240_phy_speed(mac->mac_unit, &speed);
+
+    mac->link = link;
+#ifdef SUPPORT_PLC
+    if(strcmp(mac->dev->name, "eth0") == 0) {
+        printf("ag7240_check_link: %s link forced down\n",mac->dev->name);
+        return 0;
+    }
+#endif
+
+    if(!mac->link) {
+        printf("%s link down\n",mac->dev->name);
+        return 0;
+    }
+
+    switch (speed)
+    {
+       case _1000BASET:
+           ag7240_set_mac_if(mac, 1);
+           ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if (is_ar7242() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1c000000);
+	   }
+#ifdef CONFIG_F1E_PHY
+           if (is_wasp() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0e000000);
+	   }
+#else      
+           if (is_wasp() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x06000000);
+           }
+#endif
+           break;
+
+       case _100BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 1);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if ((is_ar7242() || is_wasp()) && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0101);
+           break;
+
+       case _10BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 0);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if ((is_ar7242() || is_wasp()) && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1616);
+           break;
+
+       default:
+          printf("Invalid speed detected\n");
+          return 0;
+    }
+
+   if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+        return 1; 
+
+    mac->duplex = duplex;
+    mac->speed = speed;
+
+    printf("dup %d speed %d\n", duplex, speed);
+
+    ag7240_set_mac_duplex(mac,duplex);
+
+    return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ag7240_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+    int i;
+    ag7240_desc_t *fr;
+    ag7240_mac_t *mac = (ag7240_mac_t*)dev->priv;
+
+    if (!ag7240_check_link(mac))
+        return 0;
+
+    mac->next_rx = 0;
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        fr = mac->fifo_rx[i];
+        fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+        flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+        ag7240_rx_give_to_dma(fr);
+    }
+
+    ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, AG7240_RXE);	/* rx start */
+    if(!is_ar933x())
+        udelay(1000 * 1000);
+
+
+    return 1;
+
+}
+
+static int ag7240_alloc_fifo(int ndesc, ag7240_desc_t ** fifo)
+{
+    int i;
+    u32 size;
+    uchar *p = NULL;
+
+    size = sizeof(ag7240_desc_t) * ndesc;
+    size += CFG_CACHELINE_SIZE - 1;
+
+    if ((p = malloc(size)) == NULL) {
+        printf("Cant allocate fifos\n");
+        return -1;
+    }
+
+    p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+	   ~(CFG_CACHELINE_SIZE - 1));
+    p = UNCACHED_SDRAM(p);
+
+    for (i = 0; i < ndesc; i++)
+        fifo[i] = (ag7240_desc_t *) p + i;
+
+    return 0;
+}
+
+static int ag7240_setup_fifos(ag7240_mac_t *mac)
+{
+    int i;
+
+    if (ag7240_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+        return 1;
+
+    for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+        mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+        ag7240_tx_own(mac->fifo_tx[i]);
+    }
+
+    if (ag7240_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+        return 1;
+
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+    }
+
+    return (1);
+}
+
+static void ag7240_halt(struct eth_device *dev)
+{
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 0);
+    while (ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL));
+}
+
+unsigned char *
+ag7240_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+    /*
+    ** BOARDCAL environmental variable has the address of the cal sector
+    */
+    
+    return ((unsigned char *)BOARDCAL);
+    
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+		(KSEG1ADDR(AR7240_SPI_BASE) + (4 * 1024) +
+		flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+static void ag7240_get_ethaddr(struct eth_device *dev)
+{
+    unsigned char *eeprom;
+    unsigned char *mac = dev->enetaddr;
+#ifndef CONFIG_AR7240_EMU
+    eeprom = ag7240_mac_addr_loc();
+
+    if (strcmp(dev->name, "eth0") == 0) {
+        memcpy(mac, eeprom, 6);
+    } else if (strcmp(dev->name, "eth1") == 0) {
+        eeprom += 6;
+        memcpy(mac, eeprom, 6);
+    } else {
+        printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+        return;
+    }
+    /* Use fixed address if the above address is invalid */
+    if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff)) {
+#else
+    if (1) {
+#endif 
+        mac[0] = 0x00;
+        mac[1] = 0x03;
+        mac[2] = 0x7f;
+        mac[3] = 0x09;
+        mac[4] = 0x0b;
+        mac[5] = 0xad;
+        printf("No valid address in Flash. Using fixed address\n");
+    } else {
+        printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+    }
+}
+
+
+int ag7240_enet_initialize(bd_t * bis)
+{
+    struct eth_device *dev[CFG_AG7240_NMACS];
+    u32 mask, mac_h, mac_l;
+    int i;
+
+    printf("ag7240_enet_initialize...\n");
+
+    if(is_ar933x() ) {
+        u32 rd = 0x0;
+
+        /* 
+         * To get s26 out of reset, we have to...
+         * bit0~bit3: has to be deasserted
+         * bit4:      has to be asserted
+         */
+        rd = ar7240_reg_rd(AR7240_S26_CLK_CTRL_OFFSET) & ~(0x1f);
+        rd |= 0x10;
+        ar7240_reg_wr(AR7240_S26_CLK_CTRL_OFFSET, rd);
+
+        if(ar7240_reg_rd(AR7240_RESET)!=0)
+            ar7240_reg_wr(AR7240_RESET,0);
+    }
+
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+
+    if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+	
+    if ((ag7240_macs[i] = (ag7240_mac_t *) malloc(sizeof (ag7240_mac_t))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+
+    memset(ag7240_macs[i], 0, sizeof(ag7240_macs[i]));
+    memset(dev[i], 0, sizeof(dev[i]));
+
+    sprintf(dev[i]->name, "eth%d", i);
+    ag7240_get_ethaddr(dev[i]);
+    
+    ag7240_macs[i]->mac_unit = i;
+    ag7240_macs[i]->mac_base = i ? AR7240_GE1_BASE : AR7240_GE0_BASE ;
+    ag7240_macs[i]->dev = dev[i];
+
+    dev[i]->iobase = 0;
+    dev[i]->init = ag7240_clean_rx;
+    dev[i]->halt = ag7240_halt;
+    dev[i]->send = ag7240_send;
+    dev[i]->recv = ag7240_recv;
+    dev[i]->priv = (void *)ag7240_macs[i];
+    }
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+        eth_register(dev[i]);
+#if(CONFIG_COMMANDS & CFG_CMD_MII)
+        miiphy_register(dev[i]->name, ag7240_miiphy_read, ag7240_miiphy_write);
+#endif
+
+         ag7240_reg_rmw_set(ag7240_macs[i], AG7240_MAC_CFG1, AG7240_MAC_CFG1_SOFT_RST
+                | AG7240_MAC_CFG1_RX_RST | AG7240_MAC_CFG1_TX_RST);
+
+        if(!i) {
+           mask = (AR7240_RESET_GE0_MAC | AR7240_RESET_GE0_PHY |
+                    AR7240_RESET_GE1_MAC | AR7240_RESET_GE1_PHY);
+
+           if (is_ar7241() || is_ar7242() ||  is_wasp()) {
+                mask = mask | AR7240_RESET_GE0_MDIO | AR7240_RESET_GE1_MDIO;
+                printf(" wasp  reset mask:%x \n",mask);
+           }
+
+
+           ar7240_reg_rmw_set(AR7240_RESET, mask);
+           if(!is_ar933x())
+               udelay(1000 * 100);
+
+           ar7240_reg_rmw_clear(AR7240_RESET, mask);
+           if(!is_ar933x())
+               udelay(1000 * 100);
+
+           if(!is_ar933x())
+               udelay(10 * 1000);
+        }
+
+        ag7240_hw_start(ag7240_macs[i]);
+        ag7240_setup_fifos(ag7240_macs[i]);
+
+        if(!is_ar933x())
+            udelay(100 * 1000);
+
+        {
+            unsigned char *mac = dev[i]->enetaddr;
+
+            printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+                   mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+                   mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+        }
+        mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+        mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+            (dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+        ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR1, mac_l);
+        ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR2, mac_h);
+
+        /* if using header for register configuration, we have to     */
+        /* configure s26 register after frame transmission is enabled */
+
+        if (ag7240_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef CONFIG_AR7242_S16_PHY
+            if (is_ar7242() || is_wasp()) {
+                athrs16_reg_init();
+            } else
+#endif
+            {
+#ifdef CFG_ATHRS26_PHY
+                athrs26_reg_init();
+#endif
+#ifdef CFG_ATHRS27_PHY
+                printf("s27 reg init \n");
+                athrs27_reg_init();
+#endif
+#ifdef CONFIG_F1E_PHY
+               printf("F1Phy reg init \n");
+               athr_reg_init();
+#endif
+            }
+        } else {
+#ifdef CFG_ATHRS26_PHY
+                printf("athrs26_reg_init_lan\n");
+                athrs26_reg_init_lan();
+#endif
+#ifdef CFG_ATHRS27_PHY
+            printf("s27 reg init lan \n");
+            athrs27_reg_init_lan();
+#endif
+        }
+
+        ag7240_phy_setup(ag7240_macs[i]->mac_unit);
+        printf("%s up\n",dev[i]->name);
+    }
+
+    return 1;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+uint16_t
+ag7240_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg)
+{
+    ag7240_mac_t *mac   = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg, val;
+    volatile int           rddata;
+    uint16_t      ii = 0xFFFF;
+
+
+    /*
+     * Check for previous transactions are complete. Added to avoid
+     * race condition while running at higher frequencies.
+     */
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if (ii == 0)
+        printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, AG7240_MGMT_CMD_READ);
+
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+   if(ii==0)
+      printf("Error!!! Leave ag7240_miiphy_read without polling correct status!\n");
+
+    val = ag7240_reg_rd(mac, AG7240_MII_MGMT_STATUS);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+
+    return val;
+}
+
+void
+ag7240_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+    ag7240_mac_t *mac = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    uint16_t      ii = 0xFFFF;
+
+     /*
+     * Check for previous transactions are complete. Added to avoid
+     * race condition while running at higher frequencies.
+     */
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if (ii == 0)
+        printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CTRL, data);
+
+    do
+    {
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if(ii==0)
+        printf("Error!!! Leave ag7240_miiphy_write without polling correct status!\n");
+}
+#endif		/* CONFIG_COMMANDS & CFG_CMD_MII */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/ar7240/ag7240.h u-boot_1.1//cpu/mips/ar7240/ag7240.h
--- u-boot//cpu/mips/ar7240/ag7240.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//cpu/mips/ar7240/ag7240.h	2014-02-18 01:46:26.663052209 -0800
@@ -0,0 +1,237 @@
+#ifndef _AG7240_H
+#define _AG7240_H
+
+#include <linux/types.h>
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+    uint32_t    pkt_start_addr;
+
+    uint32_t    is_empty       :  1;
+    uint32_t    res1           : 10;
+    uint32_t    ftpp_override  :  5;
+    uint32_t    res2           :  4;
+    uint32_t    pkt_size       : 12;
+
+    uint32_t    next_desc      ;
+}ag7240_desc_t;
+
+#define NO_OF_TX_FIFOS  8
+#define NO_OF_RX_FIFOS  8
+
+typedef struct {
+    ag7240_desc_t *fifo_tx[NO_OF_TX_FIFOS];
+    ag7240_desc_t *fifo_rx[NO_OF_RX_FIFOS];
+    struct eth_device *dev;
+    u32            next_tx;
+    u32            next_rx;
+    u32            link;
+    u32            duplex;
+    u32            speed;
+    u32		   mac_unit;
+    u32 	   mac_base;
+    
+}ag7240_mac_t;
+
+#define ag7240_reg_wr(_mac, _x, _y)   ar7240_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ag7240_reg_rd(_mac, _x)       ar7240_reg_rd(((_x) + _mac->mac_base))
+
+#define ag7240_reg_rmw_set(_mac, _x, _y)   \
+    ar7240_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ag7240_reg_rmw_clear(_mac, _x, _y)    \
+    ar7240_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+#ifdef COMPRESSED_UBOOT
+#define _1000BASET 1000
+#define _100BASET 100
+#define _10BASET 10
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+#define mii_reg(_mac)   (AR7240_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)    (((_mac)->mac_unit == 0) ? mii0_if : mii1_if)
+
+#define ag7240_set_mii_ctrl_speed(_mac, _spd)   do {                        \
+    ar7240_reg_rmw_clear(mii_reg(_mac), (3 << 4));                          \
+    ar7240_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));                       \
+}while(0);
+
+#if defined (CFG_MII0_GMII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_MII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_RGMII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_RMII)
+#define ag7240_get_mii_if()             0
+#endif
+        
+#define MAX_WAIT        1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define AG7240_MAC_CFG1             0x00
+#define AG7240_MAC_CFG2             0x04
+#define AG7240_MAC_IFCTL            0x38
+
+/*
+ * fifo control registers
+ */
+#define AG7240_MAC_FIFO_CFG_0      0x48
+#define AG7240_MAC_FIFO_CFG_1      0x4c
+#define AG7240_MAC_FIFO_CFG_2      0x50
+#define AG7240_MAC_FIFO_CFG_3      0x54
+#define AG7240_MAC_FIFO_CFG_4      0x58
+
+#define AG7240_MAC_FIFO_CFG_5      0x5c
+#define AG7240_BYTE_PER_CLK_EN     (1 << 19)
+
+#define AG7240_MAC_FIFO_RAM_0      0x60
+#define AG7240_MAC_FIFO_RAM_1      0x64
+#define AG7240_MAC_FIFO_RAM_2      0x68
+#define AG7240_MAC_FIFO_RAM_3      0x6c
+#define AG7240_MAC_FIFO_RAM_4      0x70
+#define AG7240_MAC_FIFO_RAM_5      0x74
+#define AG7240_MAC_FIFO_RAM_6      0x78
+#define AG7240_MAC_FIFO_RAM_7      0x7c
+
+/*
+ * fields
+ */
+#define AG7240_MAC_CFG1_SOFT_RST       (1 << 31)
+#define AG7240_MAC_CFG1_RX_RST         (1 << 19)
+#define AG7240_MAC_CFG1_TX_RST         (1 << 18)
+#define AG7240_MAC_CFG1_LOOPBACK       (1 << 8)
+#define AG7240_MAC_CFG1_RX_EN          (1 << 2)
+#define AG7240_MAC_CFG1_TX_EN          (1 << 0)
+
+#define AG7240_MAC_CFG2_FDX            (1 << 0)
+#define AG7240_MAC_CFG2_PAD_CRC_EN     (1 << 2)
+#define AG7240_MAC_CFG2_LEN_CHECK      (1 << 4)
+#define AG7240_MAC_CFG2_HUGE_FRAME_EN  (1 << 5)
+#define AG7240_MAC_CFG2_IF_1000        (1 << 9)
+#define AG7240_MAC_CFG2_IF_10_100      (1 << 8)
+
+#define AG7240_MAC_IFCTL_SPEED         (1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define AG7240_DMA_TX_CTRL              0x180
+#define AG7240_DMA_TX_DESC              0x184
+#define AG7240_DMA_TX_STATUS            0x188
+#define AG7240_DMA_RX_CTRL              0x18c
+#define AG7240_DMA_RX_DESC              0x190
+#define AG7240_DMA_RX_STATUS            0x194
+#define AG7240_DMA_INTR_MASK            0x198
+#define AG7240_DMA_INTR                 0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define AG7240_TXE                      (1 << 0)
+#define AG7240_TX_STATUS_PKTCNT_SHIFT   16
+#define AG7240_TX_STATUS_PKT_SENT       0x1
+#define AG7240_TX_STATUS_URN            0x2
+#define AG7240_TX_STATUS_BUS_ERROR      0x8
+
+#define AG7240_RXE                      (1 << 0)
+
+#define AG7240_RX_STATUS_PKTCNT_MASK    0xff0000
+#define AG7240_RX_STATUS_PKT_RCVD       (1 << 0)
+#define AG7240_RX_STATUS_OVF            (1 << 2)
+#define AG7240_RX_STATUS_BUS_ERROR      (1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define AG7240_INTR_TX                  (1 << 0)
+#define AG7240_INTR_TX_URN              (1 << 1)
+#define AG7240_INTR_TX_BUS_ERROR        (1 << 3)
+#define AG7240_INTR_RX                  (1 << 4)
+#define AG7240_INTR_RX_OVF              (1 << 6)
+#define AG7240_INTR_RX_BUS_ERROR        (1 << 7)
+
+/*
+ * MII registers
+ */
+#define AG7240_MAC_MII_MGMT_CFG         0x20
+#define AG7240_MGMT_CFG_CLK_DIV_20      0x07
+
+#define AG7240_MII_MGMT_CMD             0x24
+#define AG7240_MGMT_CMD_READ            0x1
+
+#define AG7240_MII_MGMT_ADDRESS         0x28
+#define AG7240_ADDR_SHIFT               8
+
+#define AG7240_MII_MGMT_CTRL            0x2c
+#define AG7240_MII_MGMT_STATUS          0x30
+
+#define AG7240_MII_MGMT_IND             0x34
+#define AG7240_MGMT_IND_BUSY            (1 << 0)
+#define AG7240_MGMT_IND_INVALID         (1 << 2)
+
+#define AG7240_GE_MAC_ADDR1             0x40
+#define AG7240_GE_MAC_ADDR2             0x44
+
+/*
+ * Ethernet config registers
+ */
+#define AG7240_ETH_CFG                  0x18070000
+#define AG7240_ETH_CFG_RGMII_GE0        (1<<0)
+#define AG7240_ETH_CFG_MII_GE0          (1<<1)
+#define AG7240_ETH_CFG_GMII_GE0         (1<<2)
+#define AG7240_ETH_CFG_MII_GE0_MASTER   (1<<3)
+#define AG7240_ETH_CFG_MII_GE0_SLAVE    (1<<4)
+#define AG7240_ETH_CFG_GE0_ERR_EN       (1<<5)
+#define AG7240_ETH_CFG_SW_ONLY_MODE     (1<<6)
+#define AG7240_ETH_CFG_SW_PHY_SWAP      (1<<7)
+#define AG7240_ETH_CFG_SW_PHY_ADDR_SWAP (1<<8)
+#define AG7240_ETH_SWITCH_CLK_SPARE     0x18050024
+
+
+/*
+ *  * ownership of descriptors between DMA and cpu
+ *   */
+#define ag7240_rx_owned_by_dma(_ds)     ((_ds)->is_empty == 1)
+#define ag7240_rx_give_to_dma(_ds)      ((_ds)->is_empty = 1)
+#define ag7240_tx_owned_by_dma(_ds)     ((_ds)->is_empty == 0)
+#define ag7240_tx_give_to_dma(_ds)      ((_ds)->is_empty = 0)
+#define ag7240_tx_own(_ds)              ((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ag7240_set_mac_duplex(_mac, _fdx)       do {                         \
+    if ((_fdx))                                                              \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_FDX)     \
+    else                                                                     \
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_FDX)   \
+}while(0)
+
+#define ag7240_set_mac_if(_mac, _isXGMII)    do {                              \
+    ag7240_reg_rmw_clear(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_1000|      \
+                                          AG7240_MAC_CFG2_IF_10_100);   \
+    if ((_isXGMII)) {                                            \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_1000)  \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_FIFO_CFG_5, AG7240_BYTE_PER_CLK_EN);\
+    }                                                                       \
+    else {                                                              \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_10_100)\
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_FIFO_CFG_5, AG7240_BYTE_PER_CLK_EN);\
+    }                                                                       \
+}while(0)
+
+#define ag7240_set_mac_speed(_mac, _is100)   do {                             \
+    if ((_is100))                                                             \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_IFCTL, AG7240_MAC_IFCTL_SPEED)  \
+    else                                                                      \
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_IFCTL, AG7240_MAC_IFCTL_SPEED)\
+}while(0)
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/ar7240/ag7240_phy.h u-boot_1.1//cpu/mips/ar7240/ag7240_phy.h
--- u-boot//cpu/mips/ar7240/ag7240_phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//cpu/mips/ar7240/ag7240_phy.h	2014-02-18 01:46:26.663052209 -0800
@@ -0,0 +1,69 @@
+#ifndef _AG7240_PHY_H
+#define _AG7240_PHY_H
+
+static inline void ag7240_phy_setup(int unit)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        athrs16_phy_setup(unit);
+    } else
+#endif
+    {
+        athrs26_phy_setup(unit);
+#ifdef CONFIG_F1E_PHY
+        athr_phy_setup(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_link(int unit, int *link)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+         *link = athrs16_phy_is_up(unit);
+    } else
+#endif
+    {
+#ifdef CFG_ATHRS27_PHY
+         *link = athrs27_phy_is_up(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+         *link = athrs26_phy_is_up(unit);
+#endif
+#ifdef CONFIG_F1E_PHY
+         *link = athr_phy_is_up(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_duplex(int unit, int *duplex)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        *duplex = athrs16_phy_is_fdx(unit);
+    } else
+#endif
+    {
+        *duplex = athrs26_phy_is_fdx(unit);
+#ifdef CONFIG_F1E_PHY
+        *duplex = athr_phy_is_fdx(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_speed(int unit, int *speed)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        *speed = athrs16_phy_speed(unit);
+    } else
+#endif
+    {
+        *speed = athrs26_phy_speed(unit);
+#ifdef CONFIG_F1E_PHY
+        *speed = athr_phy_speed(unit);
+#endif
+    }
+}
+
+#endif /*_AG7240_PHY_H*/
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/ar7240/ag934x.c u-boot_1.1//cpu/mips/ar7240/ag934x.c
--- u-boot//cpu/mips/ar7240/ag934x.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//cpu/mips/ar7240/ag934x.c	2014-02-18 01:46:26.695052234 -0800
@@ -0,0 +1,904 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#include "ar7240_soc.h"
+#include "ag934x.h"
+#include "ag934x_phy.h"
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ag7240_unit2mac(_unit)     ag7240_macs[(_unit)]
+#define ag7240_name2mac(name)	   strcmp(name,"eth0") ? ag7240_unit2mac(1) : ag7240_unit2mac(0)
+
+int ag7240_miiphy_read(char *devname, uint32_t phaddr,
+	       uint8_t reg, uint16_t *data);
+int ag7240_miiphy_write(char *devname, uint32_t phaddr,
+	        uint8_t reg, uint16_t data);
+
+ag7240_mac_t *ag7240_macs[CFG_AG7240_NMACS];
+extern void ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq);
+
+#ifdef CFG_ATHRS26_PHY
+extern int athrs26_phy_setup(int unit);
+extern int athrs26_phy_is_up(int unit);
+extern int athrs26_phy_is_fdx(int unit);
+extern int athrs26_phy_speed(int unit);
+extern void athrs26_reg_init(void);
+extern void athrs26_reg_init_lan(void);
+extern int athrs26_mdc_check(void);
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+extern int athrs27_phy_setup(int unit);
+extern int athrs27_phy_is_up(int unit);
+extern int athrs27_phy_is_fdx(int unit);
+extern int athrs27_phy_speed(int unit);
+extern void athrs27_reg_init(void);
+extern void athrs27_reg_init_lan(void);
+extern int athrs27_mdc_check(void);
+#endif
+
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+extern int athr_phy_setup(int unit);
+extern int athr_phy_is_up(int unit);
+extern int athr_phy_is_fdx(int unit);
+extern int athr_phy_speed(int unit);
+extern void athr_reg_init(void);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+extern int athr_vir_phy_setup(int unit);
+extern int athr_vir_phy_is_up(int unit);
+extern int athr_vir_phy_is_fdx(int unit);
+extern int athr_vir_phy_speed(int unit);
+extern void athr_vir_reg_init(void);
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+
+#define ATH_ETH_MAC_READ_SIZE 4096
+extern unsigned long long 
+ath_nand_get_cal_offset(const char *ba);
+#endif
+
+static int
+ag7240_send(struct eth_device *dev, volatile void *packet, int length)
+{
+    int i;
+
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+
+    ag7240_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+    f->pkt_size = length;
+    f->res1 = 0;
+    f->pkt_start_addr = virt_to_phys(packet);
+
+    ag7240_tx_give_to_dma(f);
+    flush_cache((u32) packet, length);
+    ag7240_reg_wr(mac, AG7240_DMA_TX_DESC, virt_to_phys(f));
+    ag7240_reg_wr(mac, AG7240_DMA_TX_CTRL, AG7240_TXE);
+
+    for (i = 0; i < MAX_WAIT; i++) {
+        udelay(10);
+        if (!ag7240_tx_owned_by_dma(f))
+            break;
+    }
+    if (i == MAX_WAIT)
+        printf("Tx Timed out\n");
+
+    f->pkt_start_addr = 0;
+    f->pkt_size = 0;
+
+    if (++mac->next_tx >= NO_OF_TX_FIFOS)
+        mac->next_tx = 0;
+
+    return (0);
+}
+
+static int ag7240_recv(struct eth_device *dev)
+{
+    int length;
+    ag7240_desc_t *f;
+    ag7240_mac_t *mac;
+ 
+    mac = (ag7240_mac_t *)dev->priv;
+
+    for (;;) {
+        f = mac->fifo_rx[mac->next_rx];
+        if (ag7240_rx_owned_by_dma(f))
+            break;
+
+        length = f->pkt_size;
+
+        NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+        flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+        ag7240_rx_give_to_dma(f);
+
+        if (++mac->next_rx >= NO_OF_RX_FIFOS)
+            mac->next_rx = 0;
+    }
+
+    if (!(ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL))) {
+        ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(f));
+        ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 1);
+    }
+
+    return (0);
+}
+
+void ag7240_mii_setup(ag7240_mac_t *mac)
+{
+    u32 mgmt_cfg_val;
+    u32 cpu_freq,ddr_freq,ahb_freq;
+    u32 check_cnt,revid_val;
+
+    if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+#ifndef CFG_DUAL_PHY_SUPPORT
+        ar7240_reg_wr(AR934X_SWITCH_CLOCK_SPARE, 0x271);
+#endif
+    } else {
+        ar7240_reg_wr(AR934X_SWITCH_CLOCK_SPARE, 0x570);
+    }
+
+#if defined(CONFIG_AR7242_S16_PHY) || defined(CONFIG_ATHRS17_PHY)
+    if (is_wasp() && mac->mac_unit == 0) {
+#ifdef CONFIG_AR7242_S16_PHY
+        printf("WASP  ----> S16 PHY *\n");
+#else
+        printf("WASP  ----> S17 PHY *\n");
+#endif
+        mgmt_cfg_val = 4;
+        if(mac->mac_unit == 0)
+            ar7240_reg_wr(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+
+        udelay(1000);
+
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+    if (is_wasp()) {
+        printf("WASP ----> S27 PHY \n");
+        mgmt_cfg_val = 2;
+        ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        return;
+    }
+#endif
+
+#ifdef CONFIG_F2E_PHY
+    if (is_wasp()) {
+        printf("WASP  ----> F2 PHY *\n");
+        ar7240_reg_wr(AG7240_ETH_CFG, (AG7240_ETH_CFG_RMII_MASTER_MODE | AG7240_ETH_CFG_RMII_GE0 
+                      | AG7240_ETH_CFG_RMII_HISPD_GE0));
+
+        mgmt_cfg_val = 6;
+
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+
+
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_VIR_PHY)
+    if (is_wasp()) {
+#ifdef CONFIG_VIR_PHY
+        printf("WASP  ----> VIR PHY *\n");
+#else
+        printf("WASP  ----> F1 PHY *\n");
+#endif
+        if(mac->mac_unit == 0)
+            ar7240_reg_wr(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+
+        mgmt_cfg_val = 6;
+
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+
+    if ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_2) {
+        mgmt_cfg_val = 0x2;
+        if (mac->mac_unit == 0) {
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        }
+    }
+    else {
+        ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);
+        switch (ahb_freq/1000000) {
+            case 150:
+                     mgmt_cfg_val = 0x7;
+                     break;
+            case 175:
+                     mgmt_cfg_val = 0x5;
+                     break;
+            case 200:
+                     mgmt_cfg_val = 0x4;
+                     break;
+            case 210:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            case 220:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            default:
+                     mgmt_cfg_val = 0x7;
+        }
+        if ((is_ar7241() || is_ar7242())) {
+
+            /* External MII mode */
+            if (mac->mac_unit == 0 && is_ar7242()) {
+                 mgmt_cfg_val = 0x6;
+                 ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+                 ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                 ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            }
+            /* Virian */
+            mgmt_cfg_val = 0x4;
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            printf("Virian MDC CFG Value ==> %x\n",mgmt_cfg_val);
+
+        }
+      else if(is_ar933x()){
+                //GE0 receives Rx/Tx clock, and use S26 phy
+                ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_MII_GE0_SLAVE);
+                mgmt_cfg_val = 0xF;
+                if (mac->mac_unit == 1) {
+                        check_cnt = 0;
+                        while (check_cnt++ < 10) {
+                                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+#ifdef CFG_ATHRS26_PHY
+                                if(athrs26_mdc_check() == 0)
+                                        break;
+#endif
+                        }
+                        if(check_cnt == 11)
+                                printf("%s: MDC check failed\n", __func__);
+                }
+      }
+        else { /* Python 1.0 & 1.1 */
+             if (mac->mac_unit == 0) {
+                     check_cnt = 0;
+                     while (check_cnt++ < 10) {
+                             ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                             ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+#ifdef CFG_ATHRS26_PHY
+                             if(athrs26_mdc_check() == 0)
+                                     break;
+#endif
+                     }
+                     if(check_cnt == 11)
+                             printf("%s: MDC check failed\n", __func__);
+             }
+        }
+ 
+    }
+}
+
+static void ag7240_hw_start(ag7240_mac_t *mac)
+{
+
+    if(mac->mac_unit)
+    {
+        ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+            AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_1000));
+    }
+    else {
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+		         AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_10_100));
+   }
+   ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_0, 0x1f00);
+
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0x10ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0xAAA0555);
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_4, 0x3ffff);
+    /* 
+     * Setting Drop CRC Errors, Pause Frames,Length Error frames 
+     * and Multi/Broad cast frames. 
+     */
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0x7eccf);
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_3, 0x1f00140);
+
+    printf(": cfg1 %#x cfg2 %#x\n", ag7240_reg_rd(mac, AG7240_MAC_CFG1),
+        ag7240_reg_rd(mac, AG7240_MAC_CFG2));
+
+}
+
+static int ag7240_check_link(ag7240_mac_t *mac)
+{
+    u32 link, duplex, speed, fdx;
+
+    ag7240_phy_link(mac->mac_unit, &link);
+    ag7240_phy_duplex(mac->mac_unit, &duplex);
+    ag7240_phy_speed(mac->mac_unit, &speed);
+
+    mac->link = link;
+#ifdef SUPPORT_PLC
+    if(strcmp(mac->dev->name, "eth0") == 0) {
+        printf("ag7240_check_link: %s link forced down\n",mac->dev->name);
+        return 0;
+    }
+#endif
+
+    if(!mac->link) {
+        printf("%s link down\n",mac->dev->name);
+        return 0;
+    }
+
+    switch (speed)
+    {
+       case _1000BASET:
+           ag7240_set_mac_if(mac, 1);
+           ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if (is_ar7242() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1c000000);
+	   }
+#ifdef CONFIG_F1E_PHY
+           if (is_wasp() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0e000000);
+	   }
+#elif CONFIG_VIR_PHY
+           if (is_wasp() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x82000000);
+               ar7240_reg_wr(AG7240_ETH_CFG,0x000c0001);
+	   }
+#else      
+           if (is_wasp() && (mac->mac_unit == 0) && !is_f2e()) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x06000000);
+	   }
+#endif
+          if (is_wasp() && mac->mac_unit == 0 && is_f1e() ) {
+              ar7240_reg_rmw_set(AG7240_ETH_CFG,AG7240_ETH_CFG_RXD_DELAY);
+              ar7240_reg_rmw_set(AG7240_ETH_CFG,AG7240_ETH_CFG_RDV_DELAY);
+          }
+
+          break;
+
+       case _100BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 1);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if ((is_ar7242() || is_wasp()) && (mac->mac_unit == 0) && !is_f2e())
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0101);
+	
+           if (is_wasp() && mac->mac_unit == 0 && is_f1e()) {
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG,AG7240_ETH_CFG_RXD_DELAY);
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG,AG7240_ETH_CFG_RDV_DELAY);
+           }
+           break;
+
+       case _10BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 0);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+
+           if ((is_ar7242() || is_wasp()) && (mac->mac_unit == 0) && !is_f2e())
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1616);
+
+           if (is_wasp() && mac->mac_unit == 0 && is_f1e()) {
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG,AG7240_ETH_CFG_RXD_DELAY);
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG,AG7240_ETH_CFG_RDV_DELAY);
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1313);
+           }
+	   if (is_f2e()) {
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG, AG7240_ETH_CFG_RMII_HISPD_GE0);
+           }
+           break;
+
+       default:
+          printf("Invalid speed detected\n");
+          return 0;
+    }
+
+   if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+        return 1; 
+
+    mac->duplex = duplex;
+    mac->speed = speed;
+
+    printf("dup %d speed %d\n", duplex, speed);
+
+    ag7240_set_mac_duplex(mac,duplex);
+
+    return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ag7240_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+    int i;
+    ag7240_desc_t *fr;
+    ag7240_mac_t *mac = (ag7240_mac_t*)dev->priv;
+
+    if (!ag7240_check_link(mac))
+        return 0;
+
+    mac->next_rx = 0;
+
+/** 
+ * @ when executing TFTP transfers at -10C
+ * @ time taken for auto negotiation and link to settled down
+ * @ is quite high. provide 3 Sec delay for s17 link to settle
+ * @ down. Works fine at room temparature, 0C -3C
+   @ Suggested by systems team.
+ */
+    
+#ifdef  CONFIG_ATHRS17_PHY 
+    udelay(1000 * 3000);
+#endif
+    ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+		    AG7240_MAC_CFG1_TX_EN));
+   
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        fr = mac->fifo_rx[i];
+        fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+        flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+        ag7240_rx_give_to_dma(fr);
+    }
+
+    ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, AG7240_RXE);	/* rx start */
+    udelay(1000 * 1000);
+
+
+    return 1;
+
+}
+
+static int ag7240_alloc_fifo(int ndesc, ag7240_desc_t ** fifo)
+{
+    int i;
+    u32 size;
+    uchar *p = NULL;
+
+    size = sizeof(ag7240_desc_t) * ndesc;
+    size += CFG_CACHELINE_SIZE - 1;
+
+    if ((p = malloc(size)) == NULL) {
+        printf("Cant allocate fifos\n");
+        return -1;
+    }
+
+    p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+	   ~(CFG_CACHELINE_SIZE - 1));
+    p = UNCACHED_SDRAM(p);
+
+    for (i = 0; i < ndesc; i++)
+        fifo[i] = (ag7240_desc_t *) p + i;
+
+    return 0;
+}
+
+static int ag7240_setup_fifos(ag7240_mac_t *mac)
+{
+    int i;
+
+    if (ag7240_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+        return 1;
+
+    for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+        mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+        ag7240_tx_own(mac->fifo_tx[i]);
+    }
+
+    if (ag7240_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+        return 1;
+
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+    }
+
+    return (1);
+}
+
+static void ag7240_halt(struct eth_device *dev)
+{
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 0);
+    while (ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL));
+}
+
+#ifdef CONFIG_ATH_NAND_BR
+
+unsigned char *
+ath_eth_mac_addr(unsigned char *sectorBuff)
+{
+    ulong   off, size;
+    nand_info_t *nand;
+    unsigned char ret;
+    	
+    /* 
+     * caldata partition is of 128k 
+     *
+     */
+    nand = &nand_info[nand_curr_device];
+    size = ATH_ETH_MAC_READ_SIZE; /* To read 4k setting size as 4k */
+    
+    /*
+     * Get the Offset of Caldata partition
+     */
+    off = ath_nand_get_cal_offset(getenv("bootargs"));
+    if(off == ATH_CAL_OFF_INVAL) {
+    	printf("Invalid CAL offset \n");
+    	return NULL;
+    }
+    /*
+     * Get the values from flash, and program into the MAC address
+     * registers
+     */
+    ret = nand_read(nand, (loff_t)off, &size, (u_char *)sectorBuff);
+    printf(" %d bytes %s: %s\n", size,
+    	       "read", ret ? "ERROR" : "OK");
+    if(ret != 0 ) {
+    	return NULL;
+    }
+
+    return sectorBuff;
+}
+
+#else  /* CONFIG_ATH_NAND_BR */
+
+unsigned char *
+ag7240_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+    /*
+    ** BOARDCAL environmental variable has the address of the cal sector
+    */
+    
+    return ((unsigned char *)BOARDCAL);
+    
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+		(KSEG1ADDR(AR7240_SPI_BASE) + (4 * 1024) +
+		flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+#endif  /* CONFIG_ATH_NAND_BR */
+
+static void ag7240_get_ethaddr(struct eth_device *dev)
+{
+    unsigned char *eeprom;
+    unsigned char *mac = dev->enetaddr;
+#ifndef CONFIG_AR7240_EMU
+
+#ifdef CONFIG_ATH_NAND_BR
+    unsigned char sectorBuff[ATH_ETH_MAC_READ_SIZE];
+
+    eeprom = ath_eth_mac_addr(sectorBuff);
+    if(eeprom == NULL) {
+        /* mac address will be set to default mac address */
+        mac[0] = 0xff;
+    }
+    else {
+#else  /* CONFIG_ATH_NAND_BR */
+        eeprom = ag7240_mac_addr_loc();
+#endif  /* CONFIG_ATH_NAND_BR */
+
+        if (strcmp(dev->name, "eth0") == 0) {
+            memcpy(mac, eeprom, 6);
+        } else if (strcmp(dev->name, "eth1") == 0) {
+            eeprom += 6;
+            memcpy(mac, eeprom, 6);
+        } else {
+            printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+            return;
+        }
+#ifdef CONFIG_ATH_NAND_BR
+    }
+#endif  /* CONFIG_ATH_NAND_BR */
+    /* Use fixed address if the above address is invalid */
+    if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff)) {
+#else
+    if (1) {
+#endif 
+        mac[0] = 0x00;
+        mac[1] = 0x03;
+        mac[2] = 0x7f;
+        mac[3] = 0x09;
+        mac[4] = 0x0b;
+        mac[5] = 0xad;
+        printf("No valid address in Flash. Using fixed address\n");
+    } else {
+        printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+    }
+}
+
+
+int ag7240_enet_initialize(bd_t * bis)
+{
+    struct eth_device *dev[CFG_AG7240_NMACS];
+    u32 mask, mac_h, mac_l;
+    int i;
+
+    printf("ag934x_enet_initialize...\n");
+
+    if(is_ar933x() && (ar7240_reg_rd(AR7240_RESET)!=0))
+         ar7240_reg_wr(AR7240_RESET,0);
+   
+    if(is_ar933x())  //Turn on LED
+        ar7240_reg_wr(AR7240_GPIO_BASE + 0x28 , ar7240_reg_rd(AR7240_GPIO_BASE + 0x28)  | (0xF8));
+
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+
+    if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+	
+    if ((ag7240_macs[i] = (ag7240_mac_t *) malloc(sizeof (ag7240_mac_t))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+
+    memset(ag7240_macs[i], 0, sizeof(ag7240_macs[i]));
+    memset(dev[i], 0, sizeof(dev[i]));
+
+    sprintf(dev[i]->name, "eth%d", i);
+    ag7240_get_ethaddr(dev[i]);
+
+    ag7240_macs[i]->mac_unit = i;
+    ag7240_macs[i]->mac_base = i ? AR7240_GE1_BASE : AR7240_GE0_BASE ;
+    ag7240_macs[i]->dev = dev[i];
+
+    dev[i]->iobase = 0;
+    dev[i]->init = ag7240_clean_rx;
+    dev[i]->halt = ag7240_halt;
+    dev[i]->send = ag7240_send;
+    dev[i]->recv = ag7240_recv;
+    dev[i]->priv = (void *)ag7240_macs[i];
+    }
+#if !defined(CONFIG_ATH_NAND_BR)
+    mask = AR7240_RESET_GE1_PHY;
+    ar7240_reg_rmw_set(AR7240_RESET, mask);
+    udelay(1000 * 100);
+    ar7240_reg_rmw_clear(AR7240_RESET, mask);
+    udelay(100);
+#endif
+    mask = AR7240_RESET_GE0_PHY;
+    ar7240_reg_rmw_set(AR7240_RESET, mask);
+    udelay(1000 * 100);
+    ar7240_reg_rmw_clear(AR7240_RESET, mask);
+    udelay(100);
+    
+    
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+        eth_register(dev[i]);
+#if(CONFIG_COMMANDS & CFG_CMD_MII)
+        miiphy_register(dev[i]->name, ag7240_miiphy_read, ag7240_miiphy_write);
+#endif
+
+         ag7240_reg_rmw_set(ag7240_macs[i], AG7240_MAC_CFG1, AG7240_MAC_CFG1_SOFT_RST
+                | AG7240_MAC_CFG1_RX_RST | AG7240_MAC_CFG1_TX_RST);
+
+        if(!i) {
+           mask = (AR7240_RESET_GE0_MAC  | AR7240_RESET_GE1_MAC);
+
+           if (is_ar7241() || is_ar7242() ||  is_wasp())
+               mask = mask | AR7240_RESET_GE0_MDIO | AR7240_RESET_GE1_MDIO;
+
+    	   printf(" wasp  reset mask:%x \n",mask);
+
+           ar7240_reg_rmw_set(AR7240_RESET, mask);
+           udelay(1000 * 100);
+
+           ar7240_reg_rmw_clear(AR7240_RESET, mask);
+           udelay(1000 * 100);
+
+           udelay(10 * 1000);
+        }
+
+	ag7240_mii_setup(ag7240_macs[i]);
+
+        /* if using header for register configuration, we have to     */
+        /* configure s26 register after frame transmission is enabled */
+
+        if (ag7240_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef CONFIG_AR7242_S16_PHY
+            if (is_ar7242() || is_wasp()) {
+                athrs16_reg_init();
+            } else
+#endif
+            {
+#ifdef  CONFIG_ATHRS17_PHY
+                athrs17_reg_init();
+#endif
+
+#ifdef CFG_ATHRS26_PHY
+                athrs26_reg_init();
+#endif
+#ifdef CFG_ATHRS27_PHY
+                printf("s27 reg init \n");
+                athrs27_reg_init();
+#endif
+#ifdef CONFIG_F1E_PHY
+               printf("F1Phy reg init \n");
+               athr_reg_init();
+#endif
+#ifdef CONFIG_VIR_PHY
+               printf("VIRPhy reg init \n");
+               athr_vir_reg_init();
+#endif
+#ifdef CONFIG_F2E_PHY
+               printf("F2Phy reg init \n");
+               athr_reg_init();
+#endif
+
+            }
+        } else {
+#ifdef CFG_ATHRS26_PHY
+                athrs26_reg_init_lan();
+#endif
+#ifdef CFG_ATHRS27_PHY
+            printf("s27 reg init lan \n");
+            athrs27_reg_init_lan();
+#endif
+        }
+        ag7240_hw_start(ag7240_macs[i]);
+        ag7240_setup_fifos(ag7240_macs[i]);
+
+        udelay(100 * 1000);
+
+        {
+            unsigned char *mac = dev[i]->enetaddr;
+
+            printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+                   mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+                   mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+        }
+        mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+        mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+            (dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+        ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR1, mac_l);
+        ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR2, mac_h);
+
+
+        ag7240_phy_setup(ag7240_macs[i]->mac_unit);
+        printf("%s up\n",dev[i]->name);
+    }
+
+    return 1;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+int
+ag7240_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t *data)
+{
+    ag7240_mac_t *mac   = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg, val;
+    volatile int           rddata;
+    uint16_t      ii = 0xFFFF;
+
+
+    /*
+     * Check for previous transactions are complete. Added to avoid
+     * race condition while running at higher frequencies.
+     */
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if (ii == 0)
+        printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, AG7240_MGMT_CMD_READ);
+
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+   if(ii==0)
+      printf("Error!!! Leave ag7240_miiphy_read without polling correct status!\n");
+
+    val = ag7240_reg_rd(mac, AG7240_MII_MGMT_STATUS);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+
+    if(data != NULL)
+        *data = val; 
+
+    return val;
+}
+
+int
+ag7240_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+    ag7240_mac_t *mac = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    uint16_t      ii = 0xFFFF;
+
+     /*
+     * Check for previous transactions are complete. Added to avoid
+     * race condition while running at higher frequencies.
+     */
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if (ii == 0)
+        printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CTRL, data);
+
+    do
+    {
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if(ii==0)
+        printf("Error!!! Leave ag7240_miiphy_write without polling correct status!\n");
+    
+    return 0; 
+}
+#endif		/* CONFIG_COMMANDS & CFG_CMD_MII */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/ar7240/ag934x.h u-boot_1.1//cpu/mips/ar7240/ag934x.h
--- u-boot//cpu/mips/ar7240/ag934x.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//cpu/mips/ar7240/ag934x.h	2014-02-18 01:46:26.695052234 -0800
@@ -0,0 +1,264 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _AG7240_H
+#define _AG7240_H
+
+#include <linux/types.h>
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+    uint32_t    pkt_start_addr;
+
+    uint32_t    is_empty       :  1;
+    uint32_t    res1           : 10;
+    uint32_t    ftpp_override  :  5;
+    uint32_t    res2           :  4;
+    uint32_t    pkt_size       : 12;
+
+    uint32_t    next_desc      ;
+}ag7240_desc_t;
+
+#define NO_OF_TX_FIFOS  8
+#define NO_OF_RX_FIFOS  8
+
+typedef struct {
+    ag7240_desc_t *fifo_tx[NO_OF_TX_FIFOS];
+    ag7240_desc_t *fifo_rx[NO_OF_RX_FIFOS];
+    struct eth_device *dev;
+    u32            next_tx;
+    u32            next_rx;
+    u32            link;
+    u32            duplex;
+    u32            speed;
+    u32		   mac_unit;
+    u32 	   mac_base;
+    
+}ag7240_mac_t;
+
+#define ag7240_reg_wr(_mac, _x, _y)   ar7240_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ag7240_reg_rd(_mac, _x)       ar7240_reg_rd(((_x) + _mac->mac_base))
+
+#define ag7240_reg_rmw_set(_mac, _x, _y)   \
+    ar7240_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ag7240_reg_rmw_clear(_mac, _x, _y)    \
+    ar7240_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+#ifdef COMPRESSED_UBOOT
+#define _1000BASET 1000
+#define _100BASET 100
+#define _10BASET 10
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+#define mii_reg(_mac)   (AR7240_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)    (((_mac)->mac_unit == 0) ? mii0_if : mii1_if)
+
+#define ag7240_set_mii_ctrl_speed(_mac, _spd)   do {                        \
+    ar7240_reg_rmw_clear(mii_reg(_mac), (3 << 4));                          \
+    ar7240_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));                       \
+}while(0);
+
+#if defined (CFG_MII0_GMII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_MII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_RGMII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_RMII)
+#define ag7240_get_mii_if()             0
+#endif
+        
+#define MAX_WAIT        1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define AG7240_MAC_CFG1             0x00
+#define AG7240_MAC_CFG2             0x04
+#define AG7240_MAC_IFCTL            0x38
+
+/*
+ * fifo control registers
+ */
+#define AG7240_MAC_FIFO_CFG_0      0x48
+#define AG7240_MAC_FIFO_CFG_1      0x4c
+#define AG7240_MAC_FIFO_CFG_2      0x50
+#define AG7240_MAC_FIFO_CFG_3      0x54
+#define AG7240_MAC_FIFO_CFG_4      0x58
+
+#define AG7240_MAC_FIFO_CFG_5      0x5c
+#define AG7240_BYTE_PER_CLK_EN     (1 << 19)
+
+#define AG7240_MAC_FIFO_RAM_0      0x60
+#define AG7240_MAC_FIFO_RAM_1      0x64
+#define AG7240_MAC_FIFO_RAM_2      0x68
+#define AG7240_MAC_FIFO_RAM_3      0x6c
+#define AG7240_MAC_FIFO_RAM_4      0x70
+#define AG7240_MAC_FIFO_RAM_5      0x74
+#define AG7240_MAC_FIFO_RAM_6      0x78
+#define AG7240_MAC_FIFO_RAM_7      0x7c
+
+/*
+ * fields
+ */
+#define AG7240_MAC_CFG1_SOFT_RST       (1 << 31)
+#define AG7240_MAC_CFG1_RX_RST         (1 << 19)
+#define AG7240_MAC_CFG1_TX_RST         (1 << 18)
+#define AG7240_MAC_CFG1_LOOPBACK       (1 << 8)
+#define AG7240_MAC_CFG1_RX_EN          (1 << 2)
+#define AG7240_MAC_CFG1_TX_EN          (1 << 0)
+
+#define AG7240_MAC_CFG2_FDX            (1 << 0)
+#define AG7240_MAC_CFG2_PAD_CRC_EN     (1 << 2)
+#define AG7240_MAC_CFG2_LEN_CHECK      (1 << 4)
+#define AG7240_MAC_CFG2_HUGE_FRAME_EN  (1 << 5)
+#define AG7240_MAC_CFG2_IF_1000        (1 << 9)
+#define AG7240_MAC_CFG2_IF_10_100      (1 << 8)
+
+#define AG7240_MAC_IFCTL_SPEED         (1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define AG7240_DMA_TX_CTRL              0x180
+#define AG7240_DMA_TX_DESC              0x184
+#define AG7240_DMA_TX_STATUS            0x188
+#define AG7240_DMA_RX_CTRL              0x18c
+#define AG7240_DMA_RX_DESC              0x190
+#define AG7240_DMA_RX_STATUS            0x194
+#define AG7240_DMA_INTR_MASK            0x198
+#define AG7240_DMA_INTR                 0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define AG7240_TXE                      (1 << 0)
+#define AG7240_TX_STATUS_PKTCNT_SHIFT   16
+#define AG7240_TX_STATUS_PKT_SENT       0x1
+#define AG7240_TX_STATUS_URN            0x2
+#define AG7240_TX_STATUS_BUS_ERROR      0x8
+
+#define AG7240_RXE                      (1 << 0)
+
+#define AG7240_RX_STATUS_PKTCNT_MASK    0xff0000
+#define AG7240_RX_STATUS_PKT_RCVD       (1 << 0)
+#define AG7240_RX_STATUS_OVF            (1 << 2)
+#define AG7240_RX_STATUS_BUS_ERROR      (1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define AG7240_INTR_TX                  (1 << 0)
+#define AG7240_INTR_TX_URN              (1 << 1)
+#define AG7240_INTR_TX_BUS_ERROR        (1 << 3)
+#define AG7240_INTR_RX                  (1 << 4)
+#define AG7240_INTR_RX_OVF              (1 << 6)
+#define AG7240_INTR_RX_BUS_ERROR        (1 << 7)
+
+/*
+ * MII registers
+ */
+#define AG7240_MAC_MII_MGMT_CFG         0x20
+#define AG7240_MGMT_CFG_CLK_DIV_20      0x07
+
+#define AG7240_MII_MGMT_CMD             0x24
+#define AG7240_MGMT_CMD_READ            0x1
+
+#define AG7240_MII_MGMT_ADDRESS         0x28
+#define AG7240_ADDR_SHIFT               8
+
+#define AG7240_MII_MGMT_CTRL            0x2c
+#define AG7240_MII_MGMT_STATUS          0x30
+
+#define AG7240_MII_MGMT_IND             0x34
+#define AG7240_MGMT_IND_BUSY            (1 << 0)
+#define AG7240_MGMT_IND_INVALID         (1 << 2)
+
+#define AG7240_GE_MAC_ADDR1             0x40
+#define AG7240_GE_MAC_ADDR2             0x44
+
+/*
+ * Ethernet config registers
+ */
+#define AG7240_ETH_CFG                  0x18070000
+#define AG7240_ETH_CFG_RGMII_GE0        (1<<0)
+#define AG7240_ETH_CFG_MII_GE0          (1<<1)
+#define AG7240_ETH_CFG_GMII_GE0         (1<<2)
+#define AG7240_ETH_CFG_RMII_GE0         (1<<10)
+#define AG7240_ETH_CFG_RMII_HISPD_GE0   (1<<11)
+#define AG7240_ETH_CFG_RMII_MASTER_MODE (1<<12)
+#define AG7240_ETH_CFG_MII_GE0_MASTER   (1<<3)
+#define AG7240_ETH_CFG_MII_GE0_SLAVE    (1<<4)
+#define AG7240_ETH_CFG_GE0_ERR_EN       (1<<5)
+#define AG7240_ETH_CFG_SW_ONLY_MODE     (1<<6)
+#define AG7240_ETH_CFG_SW_PHY_SWAP      (1<<7)
+#define AG7240_ETH_CFG_SW_PHY_ADDR_SWAP (1<<8)
+#define AG7240_ETH_CFG_RXD_DELAY	(1 << 14)
+#define AG7240_ETH_CFG_RDV_DELAY        (1 << 16)
+#define AG7240_ETH_SWITCH_CLK_SPARE     0x18050024
+
+
+/*
+ *  * ownership of descriptors between DMA and cpu
+ *   */
+#define ag7240_rx_owned_by_dma(_ds)     ((_ds)->is_empty == 1)
+#define ag7240_rx_give_to_dma(_ds)      ((_ds)->is_empty = 1)
+#define ag7240_tx_owned_by_dma(_ds)     ((_ds)->is_empty == 0)
+#define ag7240_tx_give_to_dma(_ds)      ((_ds)->is_empty = 0)
+#define ag7240_tx_own(_ds)              ((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ag7240_set_mac_duplex(_mac, _fdx)       do {                         \
+    if ((_fdx))                                                              \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_FDX)     \
+    else                                                                     \
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_FDX)   \
+}while(0)
+
+#define ag7240_set_mac_if(_mac, _isXGMII)    do {                              \
+    ag7240_reg_rmw_clear(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_1000|      \
+                                          AG7240_MAC_CFG2_IF_10_100);   \
+    if ((_isXGMII)) {                                            \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_1000)  \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_FIFO_CFG_5, AG7240_BYTE_PER_CLK_EN);\
+    }                                                                       \
+    else {                                                              \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_10_100)\
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_FIFO_CFG_5, AG7240_BYTE_PER_CLK_EN);\
+    }                                                                       \
+}while(0)
+
+#define ag7240_set_mac_speed(_mac, _is100)   do {                             \
+    if ((_is100))                                                             \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_IFCTL, AG7240_MAC_IFCTL_SPEED)  \
+    else                                                                      \
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_IFCTL, AG7240_MAC_IFCTL_SPEED)\
+}while(0)
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/ar7240/ag934x_phy.h u-boot_1.1//cpu/mips/ar7240/ag934x_phy.h
--- u-boot//cpu/mips/ar7240/ag934x_phy.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//cpu/mips/ar7240/ag934x_phy.h	2014-02-18 01:46:26.695052234 -0800
@@ -0,0 +1,139 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _AG7240_PHY_H
+#define _AG7240_PHY_H
+
+static inline void ag7240_phy_setup(int unit)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        athrs16_phy_setup(unit);
+    } else
+#endif
+#ifdef CONFIG_ATHRS17_PHY
+    if (unit == 0) {
+        athrs17_phy_setup(unit);
+    } else
+#endif
+    {
+#ifdef CFG_ATHRS27_PHY
+        athrs27_phy_setup(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+        athrs26_phy_setup(unit);
+#endif
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+        athr_phy_setup(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+        athr_vir_phy_setup(unit);
+#endif
+
+    }
+}
+
+static inline void ag7240_phy_link(int unit, int *link)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+         *link = athrs16_phy_is_up(unit);
+    } else
+#endif
+#ifdef CONFIG_ATHRS17_PHY
+    if (unit == 0) {
+         *link = athrs17_phy_is_up(unit);
+    } else
+#endif
+    {
+#ifdef CFG_ATHRS27_PHY
+         *link = athrs27_phy_is_up(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+         *link = athrs26_phy_is_up(unit);
+#endif
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+         *link = athr_phy_is_up(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+         *link = athr_vir_phy_is_up(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_duplex(int unit, int *duplex)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        *duplex = athrs16_phy_is_fdx(unit);
+    } else
+#endif
+#ifdef CONFIG_ATHRS17_PHY
+    if (unit == 0) {
+        *duplex = athrs17_phy_is_fdx(unit);
+    } else
+#endif
+   {
+#ifdef CFG_ATHRS27_PHY
+        *duplex = athrs27_phy_is_fdx(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+        *duplex = athrs26_phy_is_fdx(unit);
+#endif
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+        *duplex = athr_phy_is_fdx(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+        *duplex = athr_vir_phy_is_fdx(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_speed(int unit, int *speed)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        *speed = athrs16_phy_speed(unit);
+    } else
+#endif
+#ifdef CONFIG_ATHRS17_PHY
+    if (unit == 0) {
+        *speed = athrs17_phy_speed(unit);
+    } else
+#endif
+    {
+#ifdef CFG_ATHRS27_PHY
+        *speed = athrs27_phy_speed(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+        *speed = athrs26_phy_speed(unit);
+#endif
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+        *speed = athr_phy_speed(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+        *speed = athr_vir_phy_speed(unit);
+#endif
+    }
+}
+
+#endif /*_AG7240_PHY_H*/
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/ar7240/ar7240_serial.c u-boot_1.1//cpu/mips/ar7240/ar7240_serial.c
--- u-boot//cpu/mips/ar7240/ar7240_serial.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//cpu/mips/ar7240/ar7240_serial.c	2014-02-18 01:46:26.695052234 -0800
@@ -0,0 +1,164 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <config.h>
+#include <ar7240_soc.h>
+
+#define		REG_OFFSET		4
+
+/* === END OF CONFIG === */
+
+/* register offset */
+#define         OFS_RCV_BUFFER          (0*REG_OFFSET)
+#define         OFS_TRANS_HOLD          (0*REG_OFFSET)
+#define         OFS_SEND_BUFFER         (0*REG_OFFSET)
+#define         OFS_INTR_ENABLE         (1*REG_OFFSET)
+#define         OFS_INTR_ID             (2*REG_OFFSET)
+#define         OFS_DATA_FORMAT         (3*REG_OFFSET)
+#define         OFS_LINE_CONTROL        (3*REG_OFFSET)
+#define         OFS_MODEM_CONTROL       (4*REG_OFFSET)
+#define         OFS_RS232_OUTPUT        (4*REG_OFFSET)
+#define         OFS_LINE_STATUS         (5*REG_OFFSET)
+#define         OFS_MODEM_STATUS        (6*REG_OFFSET)
+#define         OFS_RS232_INPUT         (6*REG_OFFSET)
+#define         OFS_SCRATCH_PAD         (7*REG_OFFSET)
+
+#define         OFS_DIVISOR_LSB         (0*REG_OFFSET)
+#define         OFS_DIVISOR_MSB         (1*REG_OFFSET)
+
+#define         MY_WRITE(y, z)  ((*((volatile u32*)(y))) = z)
+#define         UART16550_READ(y)   ar7240_reg_rd((AR7240_UART_BASE+y))
+#define         UART16550_WRITE(x, z)  ar7240_reg_wr((AR7240_UART_BASE+x), z)
+
+void
+ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq)
+{
+    u32 pll, pll_div, ref_div, ahb_div, ddr_div, freq;
+
+    pll = ar7240_reg_rd(AR7240_CPU_PLL_CONFIG);
+
+    pll_div =
+        ((pll & PLL_CONFIG_PLL_DIV_MASK) >> PLL_CONFIG_PLL_DIV_SHIFT);
+
+    ref_div =
+        ((pll & PLL_CONFIG_PLL_REF_DIV_MASK) >> PLL_CONFIG_PLL_REF_DIV_SHIFT);
+
+    ddr_div =
+        ((pll & PLL_CONFIG_DDR_DIV_MASK) >> PLL_CONFIG_DDR_DIV_SHIFT) + 1;
+
+    ahb_div =
+       (((pll & PLL_CONFIG_AHB_DIV_MASK) >> PLL_CONFIG_AHB_DIV_SHIFT) + 1)*2;
+
+    freq = pll_div * ref_div * 5000000;
+
+    if (cpu_freq)
+        *cpu_freq = freq;
+
+    if (ddr_freq)
+        *ddr_freq = freq/ddr_div;
+
+    if (ahb_freq)
+        *ahb_freq = freq/ahb_div;
+}
+
+int serial_init(void)
+{
+    u32 div,val;
+    u32 ahb_freq, ddr_freq, cpu_freq;
+
+#ifdef CONFIG_WASP
+    val = ar7240_reg_rd(WASP_BOOTSTRAP_REG);
+
+    if ((val & WASP_REF_CLK_25) == 0) {
+        div = (25 * 1000000) / (16 * CONFIG_BAUDRATE);
+    } else {
+        div = (40 * 1000000) / (16 * CONFIG_BAUDRATE);
+    }
+#else
+
+    ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);
+
+    div  = ahb_freq/(16 * CONFIG_BAUDRATE);
+
+    MY_WRITE(0xb8040000, 0xcff);
+    MY_WRITE(0xb8040008, 0x3b);
+
+    val = ar7240_reg_rd(0xb8040028);
+    MY_WRITE(0xb8040028,(val | 0x8002));
+
+    MY_WRITE(0xb8040008, 0x2f);
+#endif
+
+    /*
+     * set DIAB bit
+     */
+    UART16550_WRITE(OFS_LINE_CONTROL, 0x80);
+
+    /* set divisor */
+    UART16550_WRITE(OFS_DIVISOR_LSB, (div & 0xff));
+    UART16550_WRITE(OFS_DIVISOR_MSB, ((div >> 8) & 0xff));
+
+    /* clear DIAB bit*/
+    UART16550_WRITE(OFS_LINE_CONTROL, 0x00);
+
+    /* set data format */
+    UART16550_WRITE(OFS_DATA_FORMAT, 0x3);
+
+    UART16550_WRITE(OFS_INTR_ENABLE, 0);
+
+    return 0;
+}
+
+int serial_tstc (void)
+{
+    return(UART16550_READ(OFS_LINE_STATUS) & 0x1);
+}
+
+u8 serial_getc(void)
+{
+    while(!serial_tstc());
+
+    return UART16550_READ(OFS_RCV_BUFFER);
+}
+
+
+void serial_putc(u8 byte)
+{
+    if (byte == '\n') serial_putc ('\r');
+
+    while (((UART16550_READ(OFS_LINE_STATUS)) & 0x20) == 0x0);
+    UART16550_WRITE(OFS_SEND_BUFFER, byte);
+}
+
+void serial_setbrg (void)
+{
+}
+
+void serial_puts (const char *s)
+{
+	while (*s)
+	{
+		serial_putc (*s++);
+	}
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/ar7240/hornet_ag7240.c u-boot_1.1//cpu/mips/ar7240/hornet_ag7240.c
--- u-boot//cpu/mips/ar7240/hornet_ag7240.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//cpu/mips/ar7240/hornet_ag7240.c	2014-02-18 01:46:26.695052234 -0800
@@ -0,0 +1,662 @@
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7240_soc.h"
+#include "ag7240.h"
+#include "ag7240_phy.h"
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ag7240_unit2mac(_unit)     ag7240_macs[(_unit)]
+#define ag7240_name2mac(name)	   strcmp(name,"eth0") ? ag7240_unit2mac(1) : ag7240_unit2mac(0)
+
+uint16_t ag7240_miiphy_read(char *devname, uint32_t phaddr,
+	       uint8_t reg);
+void  ag7240_miiphy_write(char *devname, uint32_t phaddr,
+	        uint8_t reg, uint16_t data);
+
+ag7240_mac_t *ag7240_macs[CFG_AG7240_NMACS];
+
+extern int athrs26_phy_setup(int unit);
+extern int athrs26_phy_is_up(int unit);
+extern int athrs26_phy_is_fdx(int unit);
+extern int athrs26_phy_speed(int unit);
+extern void athrs26_reg_init(void);
+extern void athrs26_reg_init_lan(void);
+extern void ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq);
+extern int athrs26_mdc_check(void);
+
+#ifdef CONFIG_HORNET_EMU
+#include "hornet.h"
+
+void ar8021_phy_setup(u32 ethUnit, u32 phyUnit);
+uint32_t ar8021_phy_is_link_alive(u32 ethUnit, u32 phyUnit);
+uint32_t ar8021_phy_is_fdx(u32 ethUnit, u32 phyUnit);
+uint32_t ar8021_phy_speed(u32 ethUnit, u32 phyUnit);
+#endif /* CONFIG_HORNET_EMU */
+
+static int
+ag7240_send(struct eth_device *dev, volatile void *packet, int length)
+{
+    int i;
+
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+
+    ag7240_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+    f->pkt_size = length;
+    f->res1 = 0;
+    f->pkt_start_addr = virt_to_phys(packet);
+
+    ag7240_tx_give_to_dma(f);
+    flush_cache((u32) packet, length);
+    ag7240_reg_wr(mac, AG7240_DMA_TX_DESC, virt_to_phys(f));
+    ag7240_reg_wr(mac, AG7240_DMA_TX_CTRL, AG7240_TXE);
+
+    for (i = 0; i < MAX_WAIT; i++) {
+        udelay(10);
+        if (!ag7240_tx_owned_by_dma(f))
+            break;
+    }
+    if (i == MAX_WAIT)
+        printf("Tx Timed out\n");
+
+    f->pkt_start_addr = 0;
+    f->pkt_size = 0;
+
+    if (++mac->next_tx >= NO_OF_TX_FIFOS)
+        mac->next_tx = 0;
+
+    return (0);
+}
+
+static int ag7240_recv(struct eth_device *dev)
+{
+    int length;
+    ag7240_desc_t *f;
+    ag7240_mac_t *mac;
+
+    mac = (ag7240_mac_t *)dev->priv;
+
+    for (;;) {
+        f = mac->fifo_rx[mac->next_rx];
+        if (ag7240_rx_owned_by_dma(f))
+            break;
+
+        length = f->pkt_size;
+
+        NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+        flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+        ag7240_rx_give_to_dma(f);
+
+        if (++mac->next_rx >= NO_OF_RX_FIFOS)
+            mac->next_rx = 0;
+    }
+
+    if (!(ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL))) {
+        ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(f));
+        ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 1);
+    }
+
+    return (0);
+}
+
+static void ag7240_hw_start(ag7240_mac_t *mac)
+{
+    u32 cpu_freq,ddr_freq,ahb_freq;
+    u32 mgmt_cfg_val;
+    u32 check_cnt,revid_val;
+
+    if(mac->mac_unit)
+    {
+        ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+            AG7240_MAC_CFG1_TX_EN));
+        ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+            AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_1000));
+    }
+    else {
+
+    ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+		    AG7240_MAC_CFG1_TX_EN));
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+		         AG7240_MAC_CFG2_LEN_CHECK));
+   }
+
+#ifdef AR7240_EMU
+    printf("AG7240_MAC_FIFO_CFG_4\n");
+    ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_4, 0x3ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0x10ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0xAAA0555);
+#else
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0xfff0000);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0x1fff);
+#endif
+if ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_2) {
+        mgmt_cfg_val = 0x2;
+        if (mac->mac_unit == 0) {
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        }
+    }
+    else {
+        ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);
+        switch (ahb_freq/1000000) {
+            case 150:
+                     mgmt_cfg_val = 0x7;
+                     break;
+            case 175:
+                     mgmt_cfg_val = 0x5;
+                     break;
+            case 200:
+                     mgmt_cfg_val = 0x4;
+                     break;
+            case 210:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            case 220:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            default:
+                     mgmt_cfg_val = 0x7;
+        }
+        if ((is_ar7241() || is_ar7242())) {
+
+            /* External MII mode */
+            if (mac->mac_unit == 0 && is_ar7242()) {
+                mgmt_cfg_val = 0x6;
+                ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            }
+#ifndef CONFIG_HORNET_EMU
+            /* Virian */
+            mgmt_cfg_val = 0x4;
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            printf("Virian MDC CFG Value ==> %x\n",mgmt_cfg_val);
+#endif
+
+        }
+        else { /* Python 1.0 & 1.1 */
+            if (mac->mac_unit == 0) {
+                check_cnt = 0;
+                while (check_cnt++ < 10) {
+                    ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                    ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+                    if(athrs26_mdc_check() == 0)
+                        break;
+                }
+                if(check_cnt == 11)
+                    printf("%s: MDC check failed\n", __func__);
+            }
+        }
+    }
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_0, 0x1f00);
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_4, 0x3ffff);
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0x10ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0xAAA0555);
+
+    /* 
+     * Setting Drop CRC Errors, Pause Frames,Length Error frames 
+     * and Multi/Broad cast frames. 
+     */
+
+#ifdef CONFIG_HORNET_EMU
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0xbefff);
+#else
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0x7eccf);
+#endif
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_3, 0x1f00140);
+
+    printf(": cfg1 %#x cfg2 %#x\n", ag7240_reg_rd(mac, AG7240_MAC_CFG1),
+        ag7240_reg_rd(mac, AG7240_MAC_CFG2));
+
+}
+
+static int ag7240_check_link(ag7240_mac_t *mac)
+{
+    u32 link, duplex, speed, fdx;
+
+#ifdef CONFIG_HORNET_EMU
+    link   = ar8021_phy_is_link_alive(0, GE0_AR8021_PHY_ADDR);
+    duplex = ar8021_phy_is_fdx(0, GE0_AR8021_PHY_ADDR);
+    speed  = ar8021_phy_speed(0, GE0_AR8021_PHY_ADDR);
+#else
+    ag7240_phy_link(mac->mac_unit, &link);
+    ag7240_phy_duplex(mac->mac_unit, &duplex);
+    ag7240_phy_speed(mac->mac_unit, &speed);
+#endif
+
+    mac->link = link;
+#ifdef SUPPORT_PLC
+    if(strcmp(mac->dev->name, "eth0") == 0) {
+        printf("ag7240_check_link: %s link forced down\n",mac->dev->name);
+        return 0;
+    }
+#endif
+
+    if(!mac->link) {
+        printf("%s link down\n",mac->dev->name);
+        return 0;
+    }
+
+    switch (speed)
+    {
+       case _1000BASET:
+           ag7240_set_mac_if(mac, 1);
+           ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if (is_ar7242() && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1c000000);
+           break;
+
+       case _100BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 1);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+#ifndef CONFIG_HORNET_EMU
+           if (is_ar7242() && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0101);
+#endif
+           break;
+
+       case _10BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 0);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if (is_ar7242() && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1616);
+           break;
+
+       default:
+          printf("Invalid speed detected\n");
+          return 0;
+    }
+
+   if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+        return 1; 
+
+    mac->duplex = duplex;
+    mac->speed = speed;
+
+    printf("dup %d speed %d\n", duplex, speed);
+
+    ag7240_set_mac_duplex(mac,duplex);
+
+    return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ag7240_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+    int i;
+    ag7240_desc_t *fr;
+    ag7240_mac_t *mac = (ag7240_mac_t*)dev->priv;
+
+    if (!ag7240_check_link(mac))
+        return 0;
+
+    mac->next_rx = 0;
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        fr = mac->fifo_rx[i];
+        fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+        flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+        ag7240_rx_give_to_dma(fr);
+    }
+
+    ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, AG7240_RXE);	/* rx start */
+    udelay(1000 * 1000);
+
+
+    return 1;
+
+}
+
+static int ag7240_alloc_fifo(int ndesc, ag7240_desc_t ** fifo)
+{
+    int i;
+    u32 size;
+    uchar *p = NULL;
+
+    size = sizeof(ag7240_desc_t) * ndesc;
+    size += CFG_CACHELINE_SIZE - 1;
+
+    if ((p = malloc(size)) == NULL) {
+        printf("Cant allocate fifos\n");
+        return -1;
+    }
+
+    p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+	   ~(CFG_CACHELINE_SIZE - 1));
+    p = UNCACHED_SDRAM(p);
+
+    for (i = 0; i < ndesc; i++)
+        fifo[i] = (ag7240_desc_t *) p + i;
+
+    return 0;
+}
+
+static int ag7240_setup_fifos(ag7240_mac_t *mac)
+{
+    int i;
+
+    if (ag7240_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+        return 1;
+
+    for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+        mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+        ag7240_tx_own(mac->fifo_tx[i]);
+    }
+
+    if (ag7240_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+        return 1;
+
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+    }
+
+    return (1);
+}
+
+static void ag7240_halt(struct eth_device *dev)
+{
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 0);
+    while (ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL));
+}
+
+unsigned char *
+ag7240_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+    /*
+    ** BOARDCAL environmental variable has the address of the cal sector
+    */
+    
+    return ((unsigned char *)BOARDCAL);
+    
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+		(KSEG1ADDR(AR7240_SPI_BASE) + (4 * 1024) +
+		flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+static void ag7240_get_ethaddr(struct eth_device *dev)
+{
+    unsigned char *eeprom;
+    unsigned char *mac = dev->enetaddr;
+
+    eeprom = ag7240_mac_addr_loc();
+
+    if (strcmp(dev->name, "eth0") == 0) {
+        memcpy(mac, eeprom, 6);
+    } else if (strcmp(dev->name, "eth1") == 0) {
+        eeprom += 6;
+        memcpy(mac, eeprom, 6);
+    } else {
+        printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+        return;
+    }
+
+    /* Use fixed address if the above address is invalid */
+    if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff)) {
+        mac[0] = 0x00;
+        mac[1] = 0x03;
+        mac[2] = 0x7f;
+        mac[3] = 0x09;
+        mac[4] = 0x0b;
+        mac[5] = 0xad;
+        printf("No valid address in Flash. Using fixed address\n");
+    } else {
+        printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+    }
+}
+
+
+int ag7240_enet_initialize(bd_t * bis)
+{
+    struct eth_device *dev[CFG_AG7240_NMACS];
+    u32 mask, mac_h, mac_l;
+    int i;
+
+    printf("ag7240_enet_initialize...\n");
+
+#ifdef CONFIG_MACH_HORNET
+    ar7240_reg_wr(HORNET_BOOTSTRAP_STATUS, ar7240_reg_rd(HORNET_BOOTSTRAP_STATUS) & ~HORNET_BOOTSTRAP_MDIO_SLAVE_MASK);
+#endif
+
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+
+    if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+	
+    if ((ag7240_macs[i] = (ag7240_mac_t *) malloc(sizeof (ag7240_mac_t))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+
+    memset(ag7240_macs[i], 0, sizeof(ag7240_macs[i]));
+    memset(dev[i], 0, sizeof(dev[i]));
+
+    sprintf(dev[i]->name, "eth%d", i);
+    ag7240_get_ethaddr(dev[i]);
+    
+    ag7240_macs[i]->mac_unit = i;
+    ag7240_macs[i]->mac_base = i ? AR7240_GE1_BASE : AR7240_GE0_BASE ;
+    ag7240_macs[i]->dev = dev[i];
+
+    dev[i]->iobase = 0;
+    dev[i]->init = ag7240_clean_rx;
+    dev[i]->halt = ag7240_halt;
+    dev[i]->send = ag7240_send;
+    dev[i]->recv = ag7240_recv;
+    dev[i]->priv = (void *)ag7240_macs[i];
+    }
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+
+    eth_register(dev[i]);
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+    miiphy_register(dev[i]->name, ag7240_miiphy_read, ag7240_miiphy_write);
+#endif
+    if(!i) {
+        mask = (AR7240_RESET_GE0_MAC | AR7240_RESET_GE0_PHY |
+                AR7240_RESET_GE1_MAC | AR7240_RESET_GE1_PHY);
+
+    if ((is_ar7241() || is_ar7242())) 
+	mask = mask | AR7240_RESET_GE0_MDIO | AR7240_RESET_GE1_MDIO;
+
+
+        ar7240_reg_rmw_set(AR7240_RESET, mask);
+        udelay(1000 * 100);
+
+        ar7240_reg_rmw_clear(AR7240_RESET, mask);
+        udelay(1000 * 100);
+
+    udelay(10 * 1000);
+    }
+    ag7240_hw_start(ag7240_macs[i]);
+    ag7240_setup_fifos(ag7240_macs[i]);
+
+    udelay(100 * 1000);
+
+    {
+        unsigned char *mac = dev[i]->enetaddr;
+
+        printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+               mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+               mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+    }
+    mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+    mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+        (dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+    ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR1, mac_l);
+    ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR2, mac_h);
+
+    /* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+
+#ifdef CONFIG_HORNET_EMU
+    ar8021_phy_setup(0, GE0_AR8021_PHY_ADDR);
+#else
+    if (ag7240_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef CONFIG_AR7242_S16_PHY
+        if (is_ar7242()) {
+            athrs16_reg_init();
+        } else
+#endif
+        {
+            athrs26_reg_init();
+        }
+    } else {
+        athrs26_reg_init_lan();
+    }
+
+    ag7240_phy_setup(ag7240_macs[i]->mac_unit);
+#endif
+    printf("%s up\n",dev[i]->name);
+    }
+
+    return 1;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+uint16_t
+ag7240_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg)
+{
+    ag7240_mac_t *mac   = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg, val;
+    volatile int           rddata;
+    uint16_t      ii = 0x1000;
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, AG7240_MGMT_CMD_READ);
+
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    val = ag7240_reg_rd(mac, AG7240_MII_MGMT_STATUS);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+
+    return val;
+}
+
+void
+ag7240_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+    ag7240_mac_t *mac = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    uint16_t      ii = 0x1000;
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CTRL, data);
+
+    do
+    {
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+}
+#endif		/* CONFIG_COMMANDS & CFG_CMD_MII */
+
+#ifdef CONFIG_HORNET_EMU
+void
+ar8021_phy_setup(u32 ethUnit, u32 phyUnit)
+{
+    uint32_t phyid1, phyid2;
+
+    phyid1 = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x2);
+    phyid2 = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x3);
+
+    printf("%s Phy ID %x:%x\n", __FUNCTION__, phyid1, phyid2);
+
+    udelay(1000*1000);
+
+    ar7240_reg_rmw_set(AR7240_GPIO_BASE, 0x20);
+    ar7240_reg_rmw_set(AR7240_GPIO_BASE + 0x8, 0x20);
+
+    udelay(1000*1000);
+    ar7240_reg_rmw_clear(AR7240_GPIO_BASE + 0x8, 0x20);
+
+    udelay(1000*1000);
+}
+
+uint32_t
+ar8021_phy_is_link_alive(u32 ethUnit, u32 phyUnit)
+{
+    uint32_t phyHwStatus;
+
+    phyHwStatus = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x11);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+       return 1;
+
+    return 0;
+}
+
+uint32_t
+ar8021_phy_speed(uint32_t ethUnit, uint32_t phyUnit)
+{
+    uint32_t phyHwStatus;
+
+    phyHwStatus = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x11);
+
+    {
+        phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                       ATHER_STATUS_LINK_SHIFT);
+
+        switch(phyHwStatus) {
+        case 0:
+            return _10BASET;
+        case 1:
+            return _100BASET;
+        case 2:
+            return _1000BASET;
+        default:
+            printf("Unkown speed read!\n");
+        }
+    }
+
+    return _10BASET;
+}
+
+uint32_t
+ar8021_phy_is_fdx(u32 ethUnit, u32 phyUnit)
+{
+    uint32_t phyHwStatus;
+
+    phyHwStatus = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x11);
+
+    if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+       return 1;
+
+    return 0;
+}
+#endif /* CONFIG_HORNET_EMU */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/ar7240/hornet_ddr_init.S u-boot_1.1//cpu/mips/ar7240/hornet_ddr_init.S
--- u-boot//cpu/mips/ar7240/hornet_ddr_init.S	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//cpu/mips/ar7240/hornet_ddr_init.S	2014-02-18 01:46:26.695052234 -0800
@@ -0,0 +1,4690 @@
+/*
+ *  Startup Code for MIPS32 CPU-core
+ *
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+
+	.globl hornet_ddr_init
+	.text
+	.align 4
+
+#define set_mem(_mem, _val)                         \
+    li  t9, _mem;                                   \
+    sw  _val, 0(t9);
+
+//============================================
+//   init DDR1 parameter before rel_start
+//===========================================
+hornet_ddr_init:
+
+    //--------DDR_Config_1--------   D.S 0xB8000000 %LONG 0x7fbc8cd0 
+    li t8, CFG_DDR_CONFIG_VAL;
+    set_mem(0xB8000000,t8);
+
+    //--------DDR_Config_2--------  D.S 0xB8000004 %LONG 0x99d0e6a8 
+    li t8, CFG_DDR_CONFIG2_VAL;
+    set_mem(0xB8000004,t8);
+
+    // DDR1 Paramters
+
+    //D.S 0xB8000010 %LONG 0x8           ;      // precharge
+    li t8,0x8;
+    set_mem(0xB8000010,t8);
+
+    //D.S 0xB8000008 %LONG 0x133         ;
+    li t8,CFG_DDR_MODE_VAL_INIT;
+    set_mem(0xB8000008,t8);
+
+    //D.S 0xB8000010 %LONG 0x1           ;      // Write Mode Word in DDR
+    li t8, 0x1;
+    set_mem( 0xB8000010, t8);
+    
+    //D.S 0xB800000C %LONG 0x2           ;      // Enable DLL, High drive strength from DDR
+    li t8, 0x2;
+    set_mem( 0xB800000C , t8);
+
+    //D.S 0xB8000010 %LONG 0x2           ;      // Write Extended Mode Word of DDR
+    li t8, 0x2;
+    set_mem( 0xB8000010, t8);
+
+    //D.S 0xB8000010 %LONG 0x8           ;      // precharge enabled
+    li t8, 0x8;
+    set_mem( 0xB8000010, t8);
+
+    // D.S 0xB8000008 %LONG 0x33          ;      // dll out of reset CAS Latency 3
+    li t8, CFG_DDR_MODE_VAL;
+    set_mem( 0xB8000008, t8);
+
+    //D.S 0xB8000010 %LONG 0x1           ;      // write mode word
+    li t8, 0x1;
+    set_mem( 0xB8000010, t8);
+
+    //D.S 0xB8000014 %LONG 0x4186/0x4270 ;      // Refresh control. Bit 14 is enable. Bits<13:0> Refresh time
+    li t8, CFG_DDR_REFRESH_VAL;
+    set_mem( 0xB8000014, t8);
+
+    //D.S 0xB800001C %LONG 0x08          ;       // DQS 0 Tap Control (needs tuning)
+    li t8, CFG_DDR_TAP0_VAL;
+    set_mem( 0xB800001C, t8);
+
+    //D.S 0xB8000020 %LONG 0x09          ;       // DQS 1 Tap Control (needs tuning)
+    li t8, CFG_DDR_TAP1_VAL;
+    set_mem( 0xB8000020, t8);
+
+    //D.S 0xB8000018 %LONG 0x00ff        ;      // For 16-bit DDR
+    li t8, 0x00ff;
+    set_mem( 0xB8000018, t8);
+
+	nop
+	jr 	ra
+    
+/*
+ * void hornet_ddr_tap_init(void)
+ *
+ * This "function" is used to find the tap settings for the DDR
+ */
+	.globl	hornet_ddr_tap_init
+	.ent	hornet_ddr_tap_init
+hornet_ddr_tap_init: /* { */
+
+#if NEW_DDR_TAP_CAL
+	li	t1,0x80500000 
+	li	t0,0xffffffff 
+	 
+	sw	t0,0x0(t1) 
+	sw	t0,0x4(t1) 
+	sw	t0,0x8(t1) 
+	sw	t0,0xc(t1) 
+	 
+	nop 
+	nop
+
+ddr_pat_init:
+	li 	t8, 0xa0002000
+	li	t0, 0x00
+	li	t1, 0x100	
+write_loop_start:
+	andi    t2, t0, 0x03
+pat_000:
+	li	t3, 0x00
+	bne	t2, t3,pat_001
+	li 	t9, 0x00000000
+	sw	t9, 0x0 (t8)
+	b	pat_004
+
+pat_001:
+	li	t3, 0x01
+	bne	t2, t3,pat_002
+	li 	t9, 0x0000ffff
+	sw	t9, 0x0 (t8)
+	b	pat_004
+
+pat_002:
+	li	t3, 0x02
+	bne	t2, t3,pat_003
+	li 	t9, 0xffff0000
+	sw	t9, 0x0 (t8)
+	b	pat_004
+
+pat_003:
+	li	t3, 0x03
+	bne	t2, t3,pat_004
+	li 	t9, 0xffffffff
+	sw	t9, 0x0 (t8)
+
+pat_004:
+	andi    t2, t0, 0x0c
+	li	t3, 0x00
+	bne	t2, t3,pat_005
+	li 	t9, 0x00000000
+	sw	t9, 0x4 (t8)
+	b	pat_008
+
+pat_005:
+	li	t3, 0x04
+	bne	t2, t3,pat_006
+	li 	t9, 0x0000ffff
+	sw	t9, 0x4 (t8)
+	b	pat_008
+
+pat_006:
+	li	t3, 0x08
+	bne	t2, t3,pat_007
+	li 	t9, 0xffff0000
+	sw	t9, 0x4 (t8)
+	b	pat_008
+
+pat_007:
+	li	t3, 0x0c
+	bne	t2, t3,pat_008
+	li 	t9, 0xffffffff
+	sw	t9, 0x4 (t8)
+
+pat_008:
+	andi    t2, t0, 0x30
+	li	t3, 0x00
+	bne	t2, t3,pat_009
+	li 	t9, 0x00000000
+	sw	t9, 0x8 (t8)
+	b	pat_00c
+
+pat_009:
+	li	t3, 0x10
+	bne	t2, t3,pat_00a
+	li 	t9, 0x0000ffff
+	sw	t9, 0x8 (t8)
+	b	pat_00c
+
+pat_00a:
+	li	t3, 0x20
+	bne	t2, t3,pat_00b
+	li 	t9, 0xffff0000
+	sw	t9, 0x8 (t8)
+	b	pat_00c
+
+pat_00b:
+	li	t3, 0x30
+	bne	t2, t3,pat_00c
+	li 	t9, 0xffffffff
+	sw	t9, 0x8 (t8)
+
+pat_00c:
+	andi    t2, t0, 0xc0
+	li	t3, 0x00
+	bne	t2, t3,pat_00d
+	li 	t9, 0x00000000
+	sw	t9, 0xc (t8)
+	b	pat_done
+
+pat_00d:
+	li	t3, 0x40
+	bne	t2, t3,pat_00e
+	li 	t9, 0x0000ffff
+	sw	t9, 0xc (t8)
+	b	pat_done
+
+pat_00e:
+	li	t3, 0x80
+	bne	t2, t3,pat_00f
+	li 	t9, 0xffff0000
+	sw	t9, 0xc (t8)
+	b	pat_done
+
+pat_00f:
+	li	t3, 0xc0
+	bne	t2, t3,pat_done
+	li 	t9, 0xffffffff
+	sw	t9, 0xc (t8)
+
+pat_done:
+
+	addiu	t0, t0, 0x1
+	addiu	t8, t8, 0x10
+	bne	t0, t1, write_loop_start
+	
+
+
+
+###### ddr init over #########
+
+	li	a0, 0xa0002000
+	li	a1, 0x80002000	     ### Start address of the pattern   200
+	li	a2, 0x80003000	     ### End Address of the pattern     220
+	li	t0, 0xb800001c	     ## Tap settings addr
+	lw	a3, 0x0(t0)	     ## loading default tap value
+	nop
+	ori	t0, a3, 0x0
+	nop
+	li	t1, 0x1	     ## $t1=1 indicates increasing tap value, 0 = decreasing
+
+load_tap:
+
+	li	t7, 0x2#li	$t7, 0x200	## No. of times read has to happen for 1 tap setting
+	li	t8, 0xb8000000	#### Loading Tap Setting
+	sw	t0, 0x1c(t8)
+	nop
+	sw	t0, 0x20(t8)
+	nop
+    #if 0 /* Hornet doesn't have DQS2, DQS3*/
+	sw	t0, 0x24(t8)
+	nop
+	sw	t0, 0x28(t8)
+	nop
+    #endif	
+
+###### t0 stores current tap setting under test
+###### t1 indicates increment or decrement of tap 
+
+pat_read:
+	ori	t2, a0, 0x0	
+	nop
+	ori	t3, a1, 0x0
+	nop
+	ori	t4, a2, 0x0
+	nop
+
+tap_addr_loop:
+	lw	t5, 0x0(t2)
+	nop
+	lw	t6, 0x0(t3)
+	nop
+	nop
+	
+	bne	t5, t6, tap_fail  # jump to fail if not equal
+	nop
+	nop
+	nop
+
+	addiu	t2, t2, 0x4  #incrementing addr
+	addiu	t3, t3, 0x4
+	nop
+	nop
+	
+	bne	t3, t4, tap_addr_loop # compare new addr if end addr not reached
+	nop	
+	
+	addiu	t7, t7, -1     # read passed for all locations once hence decrement t7
+	nop
+	bnez	t7, pat_read    # t7 = 0 represents passing of all locations for given tap
+	nop
+	nop
+	
+	bnez	t1, tap_incr     # increment tap if t1 = 1
+	nop
+	nop
+	
+	bnez	t0, tap_decr	  ## $t0=0 implies tap=0 works
+	nop		          ## so low limit=0, else decrement tap value
+	nop
+	li	t8, 0x80500000   ## assigning lower limit = 0
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0     ##adding lower limit to upper limit (used to calc mid value)
+	nop
+	nop
+	
+	b tap_calc
+	nop
+	nop
+
+tap_decr: 			# decrement t0 by 1 and move to loading this new tap
+	addiu	t0, t0 , -1
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_incr:
+	addiu	t0, t0 , 0x1
+	nop
+	xori	v1, t0, 0x20	# limiting upper limit to 0x20
+	nop
+	bnez	v1, load_tap
+	nop
+	nop
+	b up_limit
+	nop
+	nop
+
+tap_fail:
+	bnez	t1, up_limit 	# t1=0 means lower limit detected @ fail else upper limit
+	nop
+	nop
+	nop
+	addiu	t0, t0, 0x1
+	nop
+	li	t8, 0x80500000	# storing lower limit
+	nop
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0	# storing lower limit# adding lower limit and upper limit
+	nop
+	nop
+	nop
+	
+	b tap_calc
+	nop
+	nop
+
+up_limit:
+	addiu	t0, t0, -1 
+	li	t1, 0x0	 ## changing to decreasing tap mode	
+	li	t8, 0x80500000 ## storing upper limit
+	sw	t0, 0x4(t8)	
+	ori	t9, t0, 0x0	
+	nop
+	nop
+	nop
+	
+	ori	t0, a3, 0x0 	# loading default tap value 
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_calc:  ## calculating mid value of the tap, storing DQS0, DQS1 in 0x80500008, 0x8050000c resp.
+	li	t7, 0x2
+	nop
+	div	t9, t7
+	nop
+	mfhi	t6
+	mflo	t5
+	nop
+	nop
+	add	t6, t6, t5
+	li	t8, 0x80500000
+	nop
+	sw	t5, 0x8(t8)
+	nop
+	sw	t6, 0xc(t8)
+	nop
+	nop
+	li      t8, 0xb8000000  #### Loading Tap Setting
+	nop
+	sw      t5, 0x1c(t8)
+	nop
+	sw      t6, 0x20(t8)
+	nop
+    #if 0 /* Hornet doesn't have DQS2, DQS3*/	
+	sw      t5, 0x24(t8)
+	nop
+	sw      t6, 0x28(t8)
+	nop
+    #endif	
+	nop
+	nop
+#else /* NEW_DDR_TAP_CAL */
+	li	t1,0x80500000 
+	li	t0,0xffffffff 
+	 
+	sw	t0,0x0(t1) 
+	sw	t0,0x4(t1) 
+	sw	t0,0x8(t1) 
+	sw	t0,0xc(t1) 
+	 
+	nop 
+	nop
+
+ddr_pat_init:
+	li 	t0, 0xa0002000
+	
+	li 	t1, 0x00000000
+	sw 	t1, 0x0(t0)
+	nop
+	
+	li 	t1, 0x00000000
+	sw 	t1, 0x4(t0)
+	nop
+	
+	li 	t1, 0x00000000
+	sw	t1, 0x8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x14(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x18(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x24(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x28(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x34(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x38(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x44(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x48(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x54(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x58(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x64(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x68(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x74(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x78(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x84(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x88(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x94(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x98(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xdc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xfc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x100(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x104(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x108(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x10c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x110(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x114(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x118(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x11c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x120(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x124(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x128(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x12c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x130(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x134(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x138(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x13c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x140(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x144(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x148(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x14c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x150(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x154(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x158(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x15c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x160(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x164(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x168(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x16c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x170(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x174(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x178(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x17c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x180(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x184(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x188(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x18c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x190(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x194(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x198(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x19c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x1a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x1a4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1a8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x1b4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1b8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1c4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1c8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1d4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1d8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x1e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1e4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1e8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1f4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1f8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x200(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x204(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x208(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x20c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x210(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x214(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x218(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x21c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x220(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x224(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x228(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x22c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x230(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x234(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x238(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x23c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x240(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x244(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x248(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x24c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x250(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x254(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x258(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x25c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x260(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x264(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x268(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x26c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x270(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x274(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x278(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x27c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x280(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x284(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x288(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x28c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x290(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x294(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x298(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x29c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2a4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2a8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2b4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2b8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2c4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2c8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x2d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2d4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2d8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2e4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2e8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2f4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2f8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x300(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x304(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x308(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x30c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x310(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x314(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x318(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x31c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x320(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x324(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x328(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x32c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x330(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x334(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x338(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x33c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x340(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x344(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x348(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x34c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x350(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x354(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x358(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x35c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x360(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x364(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x368(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x36c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x370(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x374(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x378(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x37c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x380(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x384(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x388(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x38c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x390(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x394(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x398(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x39c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x3a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x3a4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3a8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x3b4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3b8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3c4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3c8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x3d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3d4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3d8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x3e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3e4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3e8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3f4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3f8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x400(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x404(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x408(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x40c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x410(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x414(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x418(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x41c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x420(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x424(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x428(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x42c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x430(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x434(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x438(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x43c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x440(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x444(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x448(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x44c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x450(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x454(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x458(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x45c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x460(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x464(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x468(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x46c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x470(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x474(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x478(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x47c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x480(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x484(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x488(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x48c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x490(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x494(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x498(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x49c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x4a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x4a4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4a8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x4b4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4b8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4c4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4c8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4d4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4d8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x4e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4e4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4e8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4f4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4f8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x500(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x504(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x508(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x50c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x510(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x514(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x518(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x51c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x520(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x524(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x528(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x52c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x530(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x534(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x538(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x53c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x540(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x544(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x548(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x54c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x550(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x554(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x558(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x55c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x560(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x564(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x568(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x56c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x570(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x574(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x578(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x57c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x580(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x584(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x588(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x58c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x590(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x594(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x598(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x59c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x5a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x5a4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5a8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x5b4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5b8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x5c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5c4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5c8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5d4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5d8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x5e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5e4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5e8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5f4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5f8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x600(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x604(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x608(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x60c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x610(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x614(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x618(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x61c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x620(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x624(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x628(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x62c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x630(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x634(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x638(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x63c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x640(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x644(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x648(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x64c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x650(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x654(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x658(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x65c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x660(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x664(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x668(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x66c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x670(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x674(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x678(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x67c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x680(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x684(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x688(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x68c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x690(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x694(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x698(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x69c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6a4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6a8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6b4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6b8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x6c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6c4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6c8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6d4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6d8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6e4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6e8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6f4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6f8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x700(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x704(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x708(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x70c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x710(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x714(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x718(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x71c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x720(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x724(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x728(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x72c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x730(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x734(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x738(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x73c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x740(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x744(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x748(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x74c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x750(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x754(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x758(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x75c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x760(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x764(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x768(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x76c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x770(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x774(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x778(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x77c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x780(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x784(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x788(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x78c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x790(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x794(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x798(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x79c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x7a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x7a4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7a8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x7b4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7b8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x7c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7c4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7c8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7d4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7d8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x7e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7e4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7e8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7f4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7f8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x800(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x804(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x808(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x80c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x810(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x814(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x818(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x81c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x820(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x824(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x828(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x82c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x830(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x834(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x838(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x83c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x840(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x844(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x848(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x84c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x850(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x854(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x858(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x85c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x860(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x864(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x868(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x86c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x870(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x874(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x878(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x87c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x880(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x884(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x888(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x88c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x890(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x894(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x898(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x89c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8a4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8a8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8b4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8b8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8c4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8c8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x8d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8d4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8d8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8e4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8e8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8f4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8f8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x900(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x904(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x908(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x90c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x910(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x914(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x918(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x91c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x920(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x924(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x928(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x92c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x930(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x934(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x938(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x93c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x940(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x944(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x948(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x94c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x950(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x954(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x958(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x95c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x960(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x964(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x968(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x96c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x970(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x974(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x978(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x97c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x980(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x984(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x988(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x98c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x990(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x994(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x998(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x99c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9a4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9a8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9b4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9b8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x9c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9c4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9c8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9d4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9d8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9e4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9e8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9f4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9f8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa04(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa08(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa14(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa18(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa24(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa28(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xa30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa34(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa38(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa44(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa48(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa54(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa58(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa64(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa68(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xa70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa74(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa78(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa84(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa88(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa94(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa98(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaa0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaa4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaa8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xab0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xab4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xab8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xabc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xac0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xac4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xac8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xacc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xad0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xad4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xad8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xadc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xae0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xae4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xae8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xaf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xaf4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaf8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xafc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb04(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb08(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb14(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb18(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb24(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb28(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb34(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb38(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb44(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb48(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb54(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb58(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb64(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb68(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb74(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb78(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb84(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb88(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb94(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb98(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xba0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xba4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xba8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbb4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbb8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xbc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbc4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbc8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbcc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xbd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbd4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbd8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbdc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbe0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbe4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbe8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbf4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbf8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbfc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc04(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc08(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc14(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc18(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xc20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc24(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc28(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc34(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc38(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc44(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc48(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc54(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc58(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xc60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc64(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc68(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc74(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc78(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xc84(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc88(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xc94(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc98(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xca0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xca4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xca8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xcb4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcb8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcc4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcc8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xccc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xcd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcd4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcd8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcdc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xce0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xce4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xce8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcf4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcf8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcfc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd04(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd08(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd14(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd18(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xd20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd24(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd28(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd34(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd38(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd44(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd48(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd54(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd58(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xd60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd64(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd68(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd74(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd78(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xd84(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd88(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xd94(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd98(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xda0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xda4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xda8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xdb4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdb8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xdc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdc4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdc8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdcc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdd4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdd8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xddc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xde0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xde4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xde8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdf4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdf8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdfc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe04(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe08(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe14(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe18(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe24(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe28(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe34(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe38(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe44(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe48(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe54(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe58(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe64(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe68(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe74(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe78(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe84(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe88(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe94(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe98(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xea0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xea4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xea8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xeac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xeb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xeb4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xeb8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xebc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xec0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xec4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xec8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xecc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xed0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xed4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xed8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xedc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xee0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xee4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xee8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xeec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xef0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xef4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xef8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xefc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf04(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf08(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf14(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf18(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xf20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf24(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf28(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf34(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf38(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf44(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf48(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf54(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf58(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xf60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf64(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf68(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf74(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf78(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xf84(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf88(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xf94(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf98(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xfa0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xfa4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfa8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xfb4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfb8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xfc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfc4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfc8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfcc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xfd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfd4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfd8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfdc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xfe0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfe4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfe8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xff0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xff4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xff8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xffc(t0)
+	nop
+
+
+//###### ddr init over #########
+
+	li	a0, 0xa0002000
+	li	a1, 0x80002000	     //### Start address of the pattern   200
+	li	a2, 0x80003000	     //### End Address of the pattern     220
+	li	t0, 0xb800001c	//## Tap settings addr
+	lw	a3, 0x0(t0)		//## loading default tap value
+	nop
+	ori	t0, a3, 0x0
+	nop
+	li	t1, 0x1		//# t1=1 indicates increasing tap value, 0 = decreasing
+
+load_tap:
+
+	li	t7, 0x200	//## No. of times read has to happen for 1 tap setting
+	li	t8, 0xb8000000	//#### Loading Tap Setting
+	sw	t0, 0x1c(t8)
+	nop
+	sw	t0, 0x20(t8)
+	nop
+
+pat_read:
+	ori	t2, a0, 0x0	
+	nop
+	ori	t3, a1, 0x0
+	nop
+	ori	t4, a2, 0x0
+	nop
+
+tap_addr_loop:
+	lw	t5, 0x0(t2)
+	nop
+	lw	t6, 0x0(t3)
+	nop
+	nop
+	
+	bne	t5, t6, tap_fail
+	nop
+	nop
+	nop
+
+	addiu	t2, t2, 0x4  //#incrementing addr
+	addiu	t3, t3, 0x4
+	nop
+	nop
+	
+	bne	t3, t4, tap_addr_loop
+	nop	
+	
+	addiu	t7, t7, -1
+	nop
+	bnez	t7, pat_read
+	nop
+	nop
+	
+	bnez	t1, tap_incr
+	nop
+	nop
+	
+	bnez	t0, tap_decr	//# t0=0 implies tap=0 works
+	nop		 //# so low limit=0, else decrement tap value
+	nop
+	li	t8, 0x80500000
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0 //#adding lower limit to upper limit (used to calc mid value)
+	nop
+	nop
+	
+	b tap_calc
+	nop
+	nop
+
+tap_decr:
+	addiu	t0, t0 , -1
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_incr:
+	addiu	t0, t0 , 0x1
+	nop
+	xori	v1, t0, 0x20
+	nop
+	bnez	v1, load_tap
+	nop
+	nop
+	b up_limit
+	nop
+	nop
+
+tap_fail:
+	bnez	t1, up_limit 
+	nop
+	nop
+	nop
+	addiu	t0, t0, 0x1
+	nop
+	li	t8, 0x80500000
+	nop
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0
+	nop
+	nop
+	nop
+	
+	b tap_calc
+	nop
+	nop
+
+up_limit:
+	addiu	t0, t0, -1 
+	li	t1, 0x0	 //## changing to decreasing tap mode	
+	li	t8, 0x80500000 //## storing upper limit
+	sw	t0, 0x4(t8)	
+	ori	t9, t0, 0x0	
+	nop
+	nop
+	nop
+	
+	ori	t0, a3, 0x0 	//# loading default tap value 
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_calc:  //## calculating mid value of the tap, storing DQS0, DQS1 in 0x80500008, 0x8050000c resp.
+	li	t7, 0x2
+	nop
+	div	t9, t7
+	nop
+	mfhi	t6
+	mflo	t5
+	nop
+	nop
+	add	t6, t6, t5
+	li	t8, 0x80500000
+	nop
+	sw	t5, 0x8(t8)
+	nop
+	sw	t6, 0xc(t8)
+	nop
+	nop
+        li      t8, 0xb8000000  //#### Loading Tap Setting
+	nop
+        sw      t5, 0x1c(t8)
+        nop
+        sw      t6, 0x20(t8)
+        nop
+	nop
+	nop
+#endif /* SIMPLE_DDR_TAP_CAL */
+
+end:
+	nop
+	nop
+	nop
+	jr 	ra
+
+	.end	hornet_ddr_tap_init
+/* } */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/ar7240/hornet.h u-boot_1.1//cpu/mips/ar7240/hornet.h
--- u-boot//cpu/mips/ar7240/hornet.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//cpu/mips/ar7240/hornet.h	2014-02-18 01:46:26.695052234 -0800
@@ -0,0 +1,34 @@
+#ifndef _HORNET_H
+#define _HORNET_H
+
+/*
+ * GE0 AR8021 phy address
+ */
+#define GE0_AR8021_PHY_ADDR             0x0
+
+/*
+ * Ethernet config registers
+ */
+#define AG7240_ETH_CFG                  0x18070000
+#define AG7240_ETH_CFG_RGMII_GE0        (1<<0)
+#define AG7240_ETH_CFG_MII_GE0          (1<<1)
+#define AG7240_ETH_CFG_GMII_GE0         (1<<2)
+#define AG7240_ETH_CFG_MII_GE0_MASTER   (1<<3)
+#define AG7240_ETH_CFG_MII_GE0_SLAVE    (1<<4)
+#define AG7240_ETH_CFG_GE0_ERR_EN       (1<<5)
+#define AG7240_ETH_CFG_SW_ONLY_MODE     (1<<6)
+#define AG7240_ETH_CFG_SW_PHY_SWAP      (1<<7)
+#define AG7240_ETH_CFG_SW_PHY_ADDR_SWAP (1<<8)
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_LATCH_LINK_PASS                  0x0004
+
+#ifndef ag7240_unit2name
+#define ag7240_unit2name(_unit) _unit ?  "eth1" : "eth0"
+#endif
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/ar7240/hornet_serial.c u-boot_1.1//cpu/mips/ar7240/hornet_serial.c
--- u-boot//cpu/mips/ar7240/hornet_serial.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//cpu/mips/ar7240/hornet_serial.c	2014-02-18 01:46:26.695052234 -0800
@@ -0,0 +1,216 @@
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <config.h>
+#include <hornet_soc.h>
+
+#define uart_reg_read(x)        ar7240_reg_rd( (AR7240_UART_BASE+x) )
+#define uart_reg_write(x, y)    ar7240_reg_wr( (AR7240_UART_BASE+x), y)
+
+static int
+AthrUartGet(char *__ch_data)
+{
+    u32    rdata;    
+    
+    rdata = uart_reg_read(UARTDATA_ADDRESS);
+
+    if (UARTDATA_UARTRXCSR_GET(rdata)) {
+        *__ch_data = (char)UARTDATA_UARTTXRXDATA_GET(rdata);
+        rdata = UARTDATA_UARTRXCSR_SET(1);
+        uart_reg_write(UARTDATA_ADDRESS, rdata); 
+        return 1;
+    }
+    else {
+        return 0;        
+    }
+}
+
+static void
+AthrUartPut(char __ch_data)
+{
+    u32 rdata;
+
+    do {
+        rdata = uart_reg_read(UARTDATA_ADDRESS);
+    } while (UARTDATA_UARTTXCSR_GET(rdata) == 0);
+    
+    rdata = UARTDATA_UARTTXRXDATA_SET((u32)__ch_data);
+    rdata |= UARTDATA_UARTTXCSR_SET(1);
+
+    uart_reg_write(UARTDATA_ADDRESS, rdata);
+}
+
+void
+ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq)
+{
+#ifdef CONFIG_HORNET_EMU
+    #ifdef CONFIG_HORNET_EMU_HARDI_WLAN
+    *cpu_freq = 48 * 1000000;
+    *ddr_freq = 48 * 1000000;
+    *ahb_freq = 24 * 1000000;    
+    #else
+    *cpu_freq = 80 * 1000000;
+    *ddr_freq = 80 * 1000000;
+    *ahb_freq = 40 * 1000000;
+    #endif
+#else
+    u32     ref_clock_rate, pll_freq;
+    u32     pllreg, clockreg;
+    u32     nint, refdiv, outdiv;
+    u32     cpu_div, ahb_div, ddr_div;
+
+    if ( ar7240_reg_rd(HORNET_BOOTSTRAP_STATUS) & HORNET_BOOTSTRAP_SEL_25M_40M_MASK )
+        ref_clock_rate = 40 * 1000000;
+    else
+        ref_clock_rate = 25 * 1000000;
+
+    pllreg   = ar7240_reg_rd(AR7240_CPU_PLL_CONFIG);
+    clockreg = ar7240_reg_rd(AR7240_CPU_CLOCK_CONTROL);    
+    
+    if (clockreg & HORNET_CLOCK_CONTROL_BYPASS_MASK) {
+        /* Bypass PLL */ 
+        pll_freq = ref_clock_rate;
+        cpu_div = ahb_div = ddr_div = 1;
+    }
+    else {
+        nint = (pllreg & HORNET_PLL_CONFIG_NINT_MASK) >> HORNET_PLL_CONFIG_NINT_SHIFT;
+        refdiv = (pllreg & HORNET_PLL_CONFIG_REFDIV_MASK) >> HORNET_PLL_CONFIG_REFDIV_SHIFT;
+        outdiv = (pllreg & HORNET_PLL_CONFIG_OUTDIV_MASK) >> HORNET_PLL_CONFIG_OUTDIV_SHIFT;
+        
+        pll_freq = (ref_clock_rate / refdiv) * nint;
+        
+        if (outdiv == 1)
+            pll_freq /= 2;
+        else if (outdiv == 2)   
+            pll_freq /= 4;                    
+        else if (outdiv == 3)  
+            pll_freq /= 8;             
+        else if (outdiv == 4) 
+            pll_freq /= 16;                
+        else if (outdiv == 5) 
+            pll_freq /= 32;             
+        else if (outdiv == 6)  
+            pll_freq /= 64;              
+        else if (outdiv == 7)  
+            pll_freq /= 128;              
+        else /* outdiv == 0 --> illegal value */                                                                     
+            pll_freq /= 2;   
+            
+        cpu_div = (clockreg & HORNET_CLOCK_CONTROL_CPU_POST_DIV_MASK) >> HORNET_CLOCK_CONTROL_CPU_POST_DIV_SHIFT;
+        ddr_div = (clockreg & HORNET_CLOCK_CONTROL_DDR_POST_DIV_MASK) >> HORNET_CLOCK_CONTROL_DDR_POST_DIV_SFIFT;
+        ahb_div = (clockreg & HORNET_CLOCK_CONTROL_AHB_POST_DIV_MASK) >> HORNET_CLOCK_CONTROL_AHB_POST_DIV_SFIFT;
+        
+        /*
+         * b00 : div by 1, b01 : div by 2, b10 : div by 3, b11 : div by 4
+         */
+        cpu_div++;
+        ddr_div++;
+        ahb_div++;                              
+    }
+    
+    *cpu_freq = pll_freq / cpu_div;
+    *ddr_freq = pll_freq / ddr_div;
+    *ahb_freq = pll_freq / ahb_div;
+#endif
+}
+
+int serial_init(void)
+{
+    u32 rdata;
+    u32 baudRateDivisor, clock_step;
+    u32 fcEnable = 0; 
+    u32 ahb_freq, ddr_freq, cpu_freq;
+
+    ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);    
+
+    /* GPIO Configuration */
+    ar7240_reg_wr(AR7240_GPIO_OE, 0xcff);
+    rdata = ar7240_reg_rd(AR7240_GPIO_OUT);
+    rdata |= 0x400; // GPIO 10 (UART_SOUT) must output 1
+    ar7240_reg_wr(AR7240_GPIO_OUT, rdata);
+
+    rdata = ar7240_reg_rd(AR7240_GPIO_FUNC);
+    /* GPIO_FUN, bit1/UART_EN, bit2/UART_RTS_CTS_EN, bit15(disable_s26_uart) */
+    rdata |= (0x3<<1)|(0x1<<15); 
+    ar7240_reg_wr(AR7240_GPIO_FUNC, rdata);
+    
+    /* Get reference clock rate, then set baud rate to 115200 */
+#ifndef CONFIG_HORNET_EMU
+
+    rdata = ar7240_reg_rd(HORNET_BOOTSTRAP_STATUS);
+    rdata &= HORNET_BOOTSTRAP_SEL_25M_40M_MASK;
+
+    if (rdata)
+        baudRateDivisor = ( 40000000 / (16*115200) ) - 1; // 40 MHz clock is taken as UART clock        
+    else
+        baudRateDivisor = ( 25000000 / (16*115200) ) - 1; // 25 MHz clock is taken as UART clock	        
+#else
+    baudRateDivisor = ( ahb_freq / (16*115200) ) - 1; // 40 MHz clock is taken as UART clock 
+#endif
+ 
+    clock_step = 8192;
+    
+	rdata = UARTCLOCK_UARTCLOCKSCALE_SET(baudRateDivisor) | UARTCLOCK_UARTCLOCKSTEP_SET(clock_step);
+	uart_reg_write(UARTCLOCK_ADDRESS, rdata);    
+    
+    /* Config Uart Controller */
+#if 1 /* No interrupt */
+	rdata = UARTCS_UARTDMAEN_SET(0) | UARTCS_UARTHOSTINTEN_SET(0) | UARTCS_UARTHOSTINT_SET(0)
+	        | UARTCS_UARTSERIATXREADY_SET(0) | UARTCS_UARTTXREADYORIDE_SET(~fcEnable) 
+	        | UARTCS_UARTRXREADYORIDE_SET(~fcEnable) | UARTCS_UARTHOSTINTEN_SET(0);
+#else    
+	rdata = UARTCS_UARTDMAEN_SET(0) | UARTCS_UARTHOSTINTEN_SET(0) | UARTCS_UARTHOSTINT_SET(0)
+	        | UARTCS_UARTSERIATXREADY_SET(0) | UARTCS_UARTTXREADYORIDE_SET(~fcEnable) 
+	        | UARTCS_UARTRXREADYORIDE_SET(~fcEnable) | UARTCS_UARTHOSTINTEN_SET(1);
+#endif	        	        
+	        
+    /* is_dte == 1 */
+    rdata = rdata | UARTCS_UARTINTERFACEMODE_SET(2);   
+    
+	if (fcEnable) {
+	   rdata = rdata | UARTCS_UARTFLOWCONTROLMODE_SET(2); 
+	}
+	
+    /* invert_fc ==0 (Inverted Flow Control) */
+    //rdata = rdata | UARTCS_UARTFLOWCONTROLMODE_SET(3);
+    
+    /* parityEnable == 0 */
+    //rdata = rdata | UARTCS_UARTPARITYMODE_SET(2); -->Parity Odd  
+    //rdata = rdata | UARTCS_UARTPARITYMODE_SET(3); -->Parity Even
+    uart_reg_write(UARTCS_ADDRESS, rdata);
+    
+    return 0;
+}
+
+int serial_tstc (void)
+{
+    return (UARTDATA_UARTRXCSR_GET(uart_reg_read(UARTDATA_ADDRESS)));
+}
+
+u8 serial_getc(void)
+{
+    char    ch_data;
+
+    while (!AthrUartGet(&ch_data))  ;
+
+    return (u8)ch_data;
+}
+
+
+void serial_putc(u8 byte)
+{
+    if (byte == '\n')   AthrUartPut('\r');
+
+    AthrUartPut((char)byte);
+}
+
+void serial_setbrg (void)
+{
+}
+
+void serial_puts (const char *s)
+{
+	while (*s)
+	{
+		serial_putc (*s++);
+	}
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/ar7240/Makefile u-boot_1.1//cpu/mips/ar7240/Makefile
--- u-boot//cpu/mips/ar7240/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//cpu/mips/ar7240/Makefile	2014-02-18 01:46:26.663052209 -0800
@@ -0,0 +1,83 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(SOC).a
+
+START	=
+#OBJS	= ar7240_serial.o ag7240.o ar7240_flash.o meminit.o
+
+OBJS	= meminit.o 
+
+ifeq ($(BOARD), ap121)
+OBJS	+= hornet_serial.o
+SOBJS	+= hornet_ddr_init.o
+else
+OBJS	+= ar7240_serial.o
+endif
+
+ifneq ($(BUILD_EMU), )
+OBJS    += hornet_ag7240.o
+else
+ifneq ($(findstring db12x,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring reh132,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring dhp,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring aph,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring ap123,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring ap120,$(BOARD)),)
+OBJS    += ag934x.o
+else
+OBJS    += ag7240.o
+endif
+endif
+endif
+endif
+endif
+endif
+endif
+
+SOBJS	+= 
+
+all:	.depend $(START) $(LIB)
+
+$(LIB):	$(OBJS) $(SOBJS) $(OBJS-0)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(START:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(START:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/ar7240/meminit.c u-boot_1.1//cpu/mips/ar7240/meminit.c
--- u-boot//cpu/mips/ar7240/meminit.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//cpu/mips/ar7240/meminit.c	2014-02-18 01:46:26.695052234 -0800
@@ -0,0 +1,580 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* 
+ * Memory controller config:
+ * Assumes that the caches are initialized.
+ *
+ * 0) Figah out the Tap controller settings.
+ * 1) Figure out whether the interface is 16bit or 32bit.
+ * 2) Size the DRAM
+ *
+ *  0) Tap controller settings
+ *  --------------------------
+ * The Table below provides all possible values of TAP controllers. We need to
+ * find the extreme left and extreme right of the spectrum (of max_udelay and
+ * min_udelay). We then program the TAP to be in the middle.
+ * Note for this we would need to be able to read and write memory. So, 
+ * initially we assume that a 16bit interface, which will always work unless
+ * there is exactly _1_ 32 bit part...for now we assume this is not the case.
+ * 
+ * The algo:
+ * 0) Program the controller in 16bit mode.
+ * 1) Start with the extreme left of the table
+ * 2) Write 0xa4, 0xb5, 0xc6, 0xd7 to 0, 2, 4, 6
+ * 3) Read 0 - this will fetch the entire cacheline.
+ * 4) If the value at address 4 is good, record this table entry, goto 6
+ * 5) Increment to get the next table entry. Goto 2.
+ * 6) Start with extreme right. Do the same as above.
+ *
+ * 1) 16bit or 32bit
+ * -----------------
+ *  31st bit of reg 0x1800_0000 will  determine the mode. By default, 
+ *  controller is set to 32-bit mode. In 32 bit mode, full data bus DQ [31:0] 
+ *  will be used to write 32 bit data. Suppose you have 16bit DDR memory
+ *  (it will have 16bit wide data bus). If you try to write 16 bit DDR in 32 
+ *  bit mode, you are going to miss upper 16 bits of data. Reading to that 
+ *  location will give you only lower 16 bits correctly, upper 16 bits will 
+ *  have some junk value. E.g.,
+ *
+ *  write to 0x0000_0000 0x12345678
+ *  write to 0x0000_1000 0x00000000 (just to discharge DQ[31:16] )
+ *  read from 0x0000_0000
+ *  if u see something like 0x0000_5678 (or XXXX_5678 but not equal to 
+ *  0x12345678) - its a 16 bit interface
+ *
+ *  2) Size the DRAM
+ *  -------------------
+ *  DDR wraps around. Write a pattern to 0x0000_0000. Write an address 
+ *  pattern at 4M, 8M, 16M etc. and check when 0x0000_0000 gets overwritten.
+ *
+ *
+ *  We can use #define's for all these addresses and patterns but its easier
+ *  to see what's going on without :)
+ */
+#include <common.h>
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+uint8_t     tap_settings[] = 
+            {0x40, 0x41, 0x10, 0x12, 0x13, 0x15, 0x1a, 0x1c, 0x1f, 0x2f, 0x3f};
+
+uint16_t    tap_pattern[] = {0xa5, 0xb6, 0xc7, 0xd8};
+
+void
+ar7240_ddr_tap_set(uint8_t set)
+{
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL0, set);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL1, set);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL2, set);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL3, set);
+}
+
+/*
+ * We check for size in 4M increments
+ */
+#define AR7240_DDR_SIZE_INCR    (4*1024*1024)
+int
+ar7240_ddr_find_size(void)
+{
+    uint8_t  *p = (uint8_t *)KSEG1, pat = 0x77;
+    int i;
+
+    *p = pat;
+
+    for(i = 1; ; i++) {
+        *(p + i * AR7240_DDR_SIZE_INCR) = (uint8_t)(i);
+        if (*p != pat) {
+            break;
+        }
+    }
+
+    return (i*AR7240_DDR_SIZE_INCR);
+}
+
+#ifndef CONFIG_WASP
+void
+ar7240_ddr_initial_config(uint32_t refresh)
+{
+	int ddr2 = 0,ddr_config;
+	int ddr_config2,ext_mod,ddr2_ext_mod;
+	int mod_val,mod_val_init;
+
+	prmsg("\nsri\n");
+#if 0
+	ar7240_reg_wr(AR7240_RESET, AR7240_RESET_DDR);
+	udelay(10);
+#endif
+	ddr2 = ((ar7240_reg_rd(0xb8050020) & 0x1) == 0);
+#ifdef ENABLE_DYNAMIC_CONF
+	if(*(volatile int *)CFG_DDR_MAGIC_F == CFG_DDR_MAGIC){
+		ddr_config = CFG_DDR_CONFIG_VAL_F;
+		ddr_config2 = CFG_DDR_CONFIG2_VAL_F;
+		ext_mod = CFG_DDR_EXT_MODE_VAL_F;
+		ddr2_ext_mod = ext_mod;
+	}
+	else
+#endif
+	{
+#ifdef CONFIG_SUPPORT_AR7241
+		if (is_ar7241() || is_ar7242()) {
+			if (ddr2) {
+				prmsg("%s(%d): virian ddr2 init\n", __func__, __LINE__);
+				ddr_config	= CFG_7241_DDR2_CONFIG_VAL;
+				ddr_config2	= CFG_7241_DDR2_CONFIG2_VAL;
+				ext_mod		= CFG_7241_DDR2_EXT_MODE_VAL;
+				ddr2_ext_mod	= CFG_DDR2_EXT_MODE_VAL;
+				mod_val_init	= CFG_7241_DDR2_MODE_VAL_INIT;
+				mod_val		= CFG_7241_DDR2_MODE_VAL;
+			} else {
+				prmsg("%s(%d): virian ddr1 init\n", __func__, __LINE__);
+				ddr_config	= CFG_7241_DDR1_CONFIG_VAL;
+				ddr_config2	= CFG_7241_DDR1_CONFIG2_VAL;
+				ext_mod		= CFG_7241_DDR1_EXT_MODE_VAL;
+				ddr2_ext_mod	= CFG_DDR2_EXT_MODE_VAL;
+				mod_val_init	= CFG_7241_DDR1_MODE_VAL_INIT;
+				mod_val		= CFG_7241_DDR1_MODE_VAL;
+			}
+		}
+		else
+#endif
+		{
+			prmsg("%s(%d): python ddr init\n", __func__, __LINE__);
+			ddr_config = CFG_DDR_CONFIG_VAL;
+			ddr_config2 = CFG_DDR_CONFIG2_VAL;
+			ext_mod = CFG_DDR_EXT_MODE_VAL;
+#ifndef CONFIG_WASP_EMU
+			ddr2_ext_mod = CFG_DDR2_EXT_MODE_VAL;
+#endif
+			mod_val_init = CFG_DDR_MODE_VAL_INIT;
+			mod_val = CFG_DDR_MODE_VAL;
+		}
+	}
+
+	if (ddr2) {
+		ar7240_reg_wr_nf(0xb800008c, 0xA59);
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x10);
+		udelay(10);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x20);
+		udelay(10);
+	}
+
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG, ddr_config);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, ddr_config2 | 0x80);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);
+	udelay(10);
+
+	ar7240_reg_wr_nf(AR7240_DDR_MODE, mod_val_init);
+	udelay(1000);
+
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);
+	udelay(10);
+
+	if (ddr2) {
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, ddr2_ext_mod);
+	} else {
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, ext_mod);
+	}
+
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_MODE, mod_val);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_REFRESH, refresh);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_RD_DATA_THIS_CYCLE,
+				CFG_DDR_RD_DATA_THIS_CYCLE_VAL);
+	udelay(100);
+}
+#else
+int /* ram type */
+wasp_ddr_initial_config(uint32_t refresh)
+{
+#if !defined(CONFIG_ATH_NAND_BR)
+	int		ddr_config, ddr_config2, ext_mod, mod_val,
+			mod_val_init, cycle_val, tap_val, type;
+	uint32_t	*pll = (unsigned *)PLL_CONFIG_VAL_F;
+
+	prmsg("\nsri\n");
+	prmsg("Wasp 1.%d\n", ar7240_reg_rd(AR7240_REV_ID) & 0xf);
+
+	switch(WASP_RAM_TYPE(ar7240_reg_rd(WASP_BOOTSTRAP_REG))) {
+	case 0:
+	case 1:	// SDRAM
+		/*
+		XXX XXX XXX XXX XXX XXX XXX XXX XXX
+		Boot strap select is not working. In some boards,
+		ddr2 shows up as sdram. Hence ignoring the foll.
+		break statement.
+		XXX XXX XXX XXX XXX XXX XXX XXX XXX
+		break;
+		*/
+		prmsg("%s(%d): Wasp sdram\n", __func__, __LINE__);
+		ddr_config	= CFG_934X_SDRAM_CONFIG_VAL;
+		ddr_config2	= CFG_934X_SDRAM_CONFIG2_VAL;
+		mod_val_init	= CFG_934X_SDRAM_MODE_VAL_INIT;
+		mod_val		= CFG_934X_SDRAM_MODE_VAL;
+		cycle_val	= CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL;
+		tap_val		= CFG_934X_SDRAM_TAP_VAL;
+
+		ar7240_reg_wr_nf(AR7240_DDR_CTL_CONFIG, 0x13b);
+		udelay(100);
+
+		ar7240_reg_wr_nf(AR7240_DDR_DEBUG_RD_CNTL, 0x3000001f);
+		udelay(100);
+
+		type = 0;
+
+		break;
+	case 2: // ddr2
+		ddr_config	= CFG_934X_DDR2_CONFIG_VAL;
+		ddr_config2	= CFG_934X_DDR2_CONFIG2_VAL;
+		ext_mod		= CFG_934X_DDR2_EXT_MODE_VAL;
+		mod_val_init	= CFG_934X_DDR2_MODE_VAL_INIT;
+		mod_val		= CFG_934X_DDR2_MODE_VAL;
+		cycle_val	= CFG_DDR2_RD_DATA_THIS_CYCLE_VAL;
+		tap_val		= CFG_934X_DDR2_TAP_VAL;
+
+		prmsg("%s(%d): (", __func__, __LINE__);
+		if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+							/* NAND Clear */
+			if (ar7240_reg_rd(WASP_BOOTSTRAP_REG) & (1 << 3)) {
+				prmsg("32");
+				cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32;
+				ar7240_reg_wr_nf(AR7240_DDR_CTL_CONFIG, (1 << 6));
+			} else {
+				prmsg("16");
+				cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16;
+				ar7240_reg_rmw_set(AR7240_DDR_CTL_CONFIG, (1 << 6));
+				ar7240_reg_rmw_clear(AR7240_DDR_CTL_CONFIG, (0xf << 2));
+			}
+		} else {
+#if DDR2_32BIT_SUPPORT
+			prmsg("32");
+			ar7240_reg_wr_nf(AR7240_DDR_CTL_CONFIG, 0);
+#else
+			prmsg("16");
+#endif
+		}
+		prmsg("bit) ddr2 init\n");
+		udelay(10);
+		type = 1;
+
+		break;
+	case 3: // ddr1
+		prmsg("%s(%d): Wasp (16bit) ddr1 init\n", __func__, __LINE__);
+		ddr_config	= CFG_934X_DDR1_CONFIG_VAL;
+		ddr_config2	= CFG_934X_DDR1_CONFIG2_VAL;
+		ext_mod		= CFG_934X_DDR1_EXT_MODE_VAL;
+		mod_val_init	= CFG_934X_DDR1_MODE_VAL_INIT;
+		mod_val		= CFG_934X_DDR1_MODE_VAL;
+		cycle_val	= CFG_DDR1_RD_DATA_THIS_CYCLE_VAL;
+		tap_val		= CFG_934X_DDR1_TAP_VAL;
+		type = 2;
+		break;
+	}
+#if 0
+	if (*pll == PLL_MAGIC) {
+		uint32_t cas = pll[5];
+		if (cas == 3 || cas == 4) {
+			cas = (cas * 2) + 1;
+			ddr_config &= ~(DDR_CONFIG_CAS_LATENCY_MSB_MASK |
+					DDR_CONFIG_CAS_LATENCY_MASK);
+			ddr_config |= DDR_CONFIG_CAS_LATENCY_SET(cas & 0x7) |
+				DDR_CONFIG_CAS_LATENCY_MSB_SET((cas >> 3) & 1);
+
+			cas = pll[5];
+
+			ddr_config2 &= ~DDR_CONFIG2_GATE_OPEN_LATENCY_MASK;
+			ddr_config2 |= DDR_CONFIG2_GATE_OPEN_LATENCY_SET(2 * cas);
+
+			if (type == 1) {
+				uint32_t tmp;
+				tmp = ar7240_reg_rd(AR7240_DDR_DDR2_CONFIG);
+				tmp &= ~DDR2_CONFIG_DDR2_TWL_MASK;
+				tmp |= DDR2_CONFIG_DDR2_TWL_SET(cas == 3 ? 3 : 5);
+				ar7240_reg_wr_nf(AR7240_DDR_DDR2_CONFIG, tmp);
+			}
+
+			mod_val = (cas == 3 ? 0x33 : 0x43);
+			mod_val_init = 0x100 | mod_val;
+		}
+	}
+#else
+	if (*pll == PLL_MAGIC) {
+		uint32_t cas = pll[5];
+		if (cas == 3 || cas == 4) {
+			cas = (cas * 2) + 2;
+			ddr_config &= ~(DDR_CONFIG_CAS_LATENCY_MSB_MASK |
+					DDR_CONFIG_CAS_LATENCY_MASK);
+			ddr_config |= DDR_CONFIG_CAS_LATENCY_SET(cas & 0x7) |
+				DDR_CONFIG_CAS_LATENCY_MSB_SET((cas >> 3) & 1);
+
+			cas = pll[5];
+
+			ddr_config2 &= ~DDR_CONFIG2_GATE_OPEN_LATENCY_MASK;
+			ddr_config2 |= DDR_CONFIG2_GATE_OPEN_LATENCY_SET((2 * cas) + 1);
+
+			if (type == 1) {
+				uint32_t tmp;
+				tmp = ar7240_reg_rd(AR7240_DDR_DDR2_CONFIG);
+				tmp &= ~DDR2_CONFIG_DDR2_TWL_MASK;
+				tmp |= DDR2_CONFIG_DDR2_TWL_SET(cas == 3 ? 3 : 5);
+				ar7240_reg_wr_nf(AR7240_DDR_DDR2_CONFIG, tmp);
+			}
+
+			mod_val = (cas == 3 ? 0x33 : 0x43);
+			mod_val_init = 0x100 | mod_val;
+		}
+	}
+#endif
+
+	ar7240_reg_wr_nf(AR7240_DDR_RD_DATA_THIS_CYCLE, cycle_val);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_BURST, 0x74444444);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_BURST2, 0x222);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_AHB_MASTER_TIMEOUT, 0xfffff);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG, ddr_config);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, ddr_config2);
+	udelay(100);
+	if (type == 1) {
+		ar7240_reg_wr_nf(AR7240_DDR_DDR2_CONFIG, CFG_934X_DDR2_EN_TWL_VAL);
+		udelay(100);
+	}
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, ddr_config2 | 0x80); // CKE enable
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8); // Precharge
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8); // Precharge
+	udelay(10);
+
+	if (type == 1) {
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x10); // EMR2
+		udelay(10);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x20); // EMR3
+		udelay(10);
+	}
+	if (type != 0) {
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x2);
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2); // EMR DLL enable
+		udelay(10);
+	}
+	ar7240_reg_wr_nf(AR7240_DDR_MODE, mod_val_init);
+	udelay(1000);
+
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1); // MR Write
+	udelay(10);
+
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8); // Precharge
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8); // Precharge
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4); // Auto Refresh
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4); // Auto Refresh
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_MODE, mod_val);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1); // MR Write
+	udelay(10);
+	if (type == 1) {
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, CFG_934X_DDR2_EXT_MODE_VAL_INIT);
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2); // EMR write
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, CFG_934X_DDR2_EXT_MODE_VAL);
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2); // EMR write
+		udelay(100);
+	}
+
+	ar7240_reg_wr_nf(AR7240_DDR_REFRESH, refresh);
+	udelay(100);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, tap_val);
+	ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, tap_val);
+
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+						/* NAND Clear */
+		if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & (1 << 3)) && type) {
+			ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, tap_val);
+			ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, tap_val);
+		}
+	} else {
+#if DDR2_32BIT_SUPPORT
+		if (type != 0) {
+			ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, tap_val);
+			ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, tap_val);
+		}
+#endif
+	}
+		prmsg("%s(%d): Wasp ddr init done\n", __func__, __LINE__);
+
+#if (CFG_PLL_FREQ == CFG_PLL_600_500_250) || \
+    (CFG_PLL_FREQ == CFG_PLL_500_500_250)
+	// PMU2 ddr ldo tune
+	ar7240_reg_rmw_set(0xb8116c44, (0x3 << 19));
+	udelay(100);
+#endif
+	return type;
+#else
+	return 0;
+#endif
+}
+#endif
+
+#ifdef CONFIG_HORNET_EMU
+void
+ar7240_ddr_initial_config_for_fpga(void)
+{
+ #ifdef CONFIG_HORNET_EMU_HARDI
+    /* HARDI FPGA board */
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4);          /* Auto-Refresh */
+    udelay(10);      
+    ar7240_reg_wr_nf(AR7240_DDR_REFRESH, 0x4100);
+    udelay(10);  
+        
+    ar7240_reg_wr_nf(AR7240_DDR_CONFIG, 0x7fd68cd0);    /* Cas Latency 7 */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, 0x959ec6a8);   /* Gate Open 5 */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_DDR2_CONFIG, 0x858);    /* Disable DDR2, set Write Latency */
+    udelay(10);    
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);          /* precharge all */
+    udelay(10);       
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);          /* precharge all */
+    udelay(10);       
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);          /* MR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x133);           /* Mode Word Settings  */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x0);         /* Extended Mode Word Settings */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_RD_DATA_THIS_CYCLE, 0xff);  /* DDR read data capture bit mask */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);          /* MR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);          /* EMR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);          /* precharge all */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);          /* precharge all */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4);          /* Auto-Refresh */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4);          /* Auto-Refresh */
+    udelay(10);        
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x133);           /* Mode Word Settings  */
+    udelay(10);    
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);          /* MR update */    
+    udelay(10); 
+    ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x382);       /* Extended Mode Word Settings */     
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);          /* EMR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x402);       /* Extended Mode Word Settings */     
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);          /* EMR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x33);            /* Mode Word Settings  */
+    udelay(10);    
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);          /* MR update */    
+    udelay(10);
+    #ifdef CONFIG_HORNET_EMU_HARDI_WLAN
+    /* 
+     * Emulation board reference clock is 48 MHz(20.833ns)
+     * DDR request 64ms has 8192 refresh
+     * So each refresh interval is 64ms/8192 = 7812.5 ns
+     * i.e ddr have to refresh in 7812.5/20.833 = 375 = 0x177 clock cycles     
+     */
+    ar7240_reg_wr_nf(AR7240_DDR_REFRESH, 0x4177);
+    #else
+    /* 
+     * Emulation board reference clock is 80 MHz(12.5ns)
+     * DDR request 64ms has 8192 refresh
+     * So each refresh interval is 64ms/8192 = 7812.5 ns
+     * i.e ddr have to refresh in 7812.5/12.5 = 625 = 0x271 clock cycles
+     */
+    ar7240_reg_wr_nf(AR7240_DDR_REFRESH, 0x4271);
+    #endif
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL0, 0x0);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL1, 0x0);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL2, 0x0);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL3, 0x0);
+    udelay(10);
+ #else
+    /* EBU FPGA board */
+    ar7240_reg_wr_nf(AR7240_DDR_CONFIG, 0xc7bc8cd0); /* Cas Latency 8 */
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, 0x95d0e6a8); /* Gate Open 5 */
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x123);
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x1);
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x23);
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);
+    udelay(10);
+    /* 
+     * Emulation board reference clock is 80 MHz(12.5ns)
+     * DDR request 64ms has 8192 refresh
+     * So each refresh interval is 64ms/8192 = 7812.5 ns
+     * i.e ddr have to refresh in 7812.5/12.5 = 625 = 0x271 clock cycles     
+     */
+    ar7240_reg_wr_nf(AR7240_DDR_REFRESH, 0x4271);
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_RD_DATA_THIS_CYCLE, 0x00ff);
+    udelay(100);
+ #endif
+}
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/cache.S u-boot_1.1//cpu/mips/cache.S
--- u-boot//cpu/mips/cache.S	2014-02-18 01:46:22.595049375 -0800
+++ u-boot_1.1//cpu/mips/cache.S	2014-02-18 01:46:26.699052241 -0800
@@ -3,6 +3,8 @@
  *
  *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
  *
+ *  Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -31,10 +33,10 @@
 #include <asm/cacheops.h>
 
 
-	/* 16KB is the maximum size of instruction and data caches on
-	 * MIPS 4K.
+	/* 64K is the maximum size of instruction and data caches on
+	 * MIPS 24K.
 	 */
-#define MIPS_MAX_CACHE_SIZE	0x4000
+#define MIPS_MAX_CACHE_SIZE	65536
 
 
 /*
@@ -106,6 +108,41 @@
 #define icacheop(kva, n, cacheSize, cacheLineSize, op) \
    icacheopn(kva, n, cacheSize, cacheLineSize, 1, (op))
 
+
+.globl simple_mips_cache_reset
+.ent   simple_mips_cache_reset
+
+simple_mips_cache_reset:
+        li      t2, CFG_ICACHE_SIZE
+        li      t3, CFG_DCACHE_SIZE
+        li      t4, CFG_CACHELINE_SIZE
+
+        mtc0    zero, CP0_TAGLO
+#if defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA956x)
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+
+        li      t0, K0BASE
+    	add     t2, t2, t0
+
+_arai_icache_loop:
+    	cache   Index_Store_Tag_I, 0(t0)
+    	add     t0, t0, t4
+    	bne     t0, t2, _arai_icache_loop
+
+        li      t0, K0BASE
+    	add     t3, t3, t0
+_arai_dcache_loop:
+    	cache   Index_Store_Tag_D, 0(t0)
+    	add     t0, t0, t4
+    	bne     t0, t3, _arai_dcache_loop
+	
+	j  ra
+	.end  simple_mips_cache_reset
+	
+
 /*******************************************************************************
 *
 * mips_cache_reset - low level initialisation of the primary caches
@@ -154,7 +191,14 @@
 	/* Set invalid tag.
 	 */
 
+
 	mtc0	zero, CP0_TAGLO
+#if defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA956x)
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+
 
    /*
     * The caches are probably in an indeterminate state,
@@ -183,6 +227,7 @@
 	move	a1, a2
 	icacheop(a0,a1,a2,a3,Index_Store_Tag_D)
 
+
 	/* 2: fill dcache.
 	 */
 
@@ -192,6 +237,7 @@
 	move	a1, a2
 	icacheopn(a0,a1,a2,a3,1lw,(dummy))
 
+
 	/* 3: clear dcache tags.
 	 */
 
@@ -201,6 +247,7 @@
 	move	a1, a2
 	icacheop(a0,a1,a2,a3,Index_Store_Tag_D)
 
+
 	j  ra
 	.end  mips_cache_reset
 
@@ -267,3 +314,130 @@
 
 	j	ra
 	.end	mips_cache_lock
+
+/*****************************************************************************
+ * flushes a range in dcache
+ * a0 = start
+ * a1 = end
+ */
+    .globl  dcache_flush_range
+    .ent    dcache_flush_range
+dcache_flush_range:
+    move    t0, a0
+    li      t1, CFG_CACHELINE_SIZE
+    move    t2, a1
+cache_loop_d_flush_range:
+    cache   Hit_Writeback_Inv_D, 0(t0)
+    addu    t0, t1
+    bne     t0, t2, cache_loop_d_flush_range
+    nop
+	j  ra
+    .end    dcache_flush_range
+
+/****************************************************************************
+ *
+ * mips_cache_flush_all - flushes entire I and D caches.
+ */
+
+    .globl  mips_cache_flush
+    .ent    mips_cache_flush
+mips_cache_flush:
+	/* Flush caches...
+	 */
+    li      t0, (CFG_ICACHE_SIZE)
+    li      t1, CFG_CACHELINE_SIZE
+    li      t2, KSEG0
+    addu    t3, t0, t2
+    mtc0    zero, CP0_TAGLO
+#if defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA956x)
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+cache_loop_flush:
+    cache   Hit_Invalidate_I, 0(t2)
+    addu    t2, t1
+    bne     t2, t3, cache_loop_flush
+    nop
+
+    li      t0, (CFG_DCACHE_SIZE)
+    li      t1, CFG_CACHELINE_SIZE
+    li      t2, KSEG0
+    addu    t3, t0, t2
+cache_loop_d_flush:
+    cache   Hit_Writeback_Inv_D, 0(t2)
+    addu    t2, t1
+    bne     t2, t3, cache_loop_d_flush
+    nop
+	j  ra
+	.end  mips_cache_flush
+
+/*
+ * Invalidate the I-Cache.
+ * Note:If this is executed from cached address space,
+ *      the cache would still have the addresses of this
+ *      function.
+ */
+	.globl	mips_icache_flush_ix
+	.ent	mips_icache_flush_ix
+
+mips_icache_flush_ix:	/* Flush caches Index Invalidate */
+	li	t0,	(CFG_ICACHE_SIZE)
+	li	t1,	CFG_CACHELINE_SIZE
+	li	t2,	KUSEG
+	addu	t3,	t0,	t2
+	mtc0	zero,	CP0_TAGLO
+#if defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA956x)
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+icache_loop_flush_ix:
+	cache	Index_Invalidate_I,	0(t2)
+	addu	t2,	t1
+	bne	t2,	t3,	icache_loop_flush_ix
+	nop
+
+	j	ra
+	.end	mips_icache_flush_ix
+
+
+
+/*********************************************************
+ * mips_cache_lock_24k
+ */
+
+    .globl  mips_cache_lock_24k
+    .ent    mips_cache_lock_24k
+
+mips_cache_lock_24k:
+    li      t0, 7936 
+    li      t1, CFG_CACHELINE_SIZE
+    li      t2, KSEG0
+    addu    t3, t0, t2
+    mtc0    zero, CP0_TAGLO
+#if defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA956x)
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+cache_loop_lock:
+
+    li      t5, 0xfffff000
+    and     t4, t2, t5
+    ori     t4, t4, (1 << 7)
+    mtc0    t4, CP0_TAGLO
+#if defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA956x)
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+
+    cache   Index_Load_Tag_D, 0(t2)
+    cache   0x1d, 0(t2)
+    addu    t2, t1
+    bne     t2, t3, cache_loop_lock
+    nop
+	j  ra
+    .end    mips_cache_lock_24k
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/config.mk u-boot_1.1//cpu/mips/config.mk
--- u-boot//cpu/mips/config.mk	2014-02-18 01:46:22.595049375 -0800
+++ u-boot_1.1//cpu/mips/config.mk	2014-02-18 01:46:26.699052241 -0800
@@ -2,6 +2,8 @@
 # (C) Copyright 2003
 # Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
 #
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
 # See file CREDITS for list of people who contributed to this
 # project.
 #
@@ -22,7 +24,7 @@
 #
 v=$(shell \
 mips-linux-as --version|grep "GNU assembler"|awk '{print $$3}'|awk -F . '{print $$2}')
-MIPSFLAGS=$(shell \
+#MIPSFLAGS=$(shell \
 if [ "$v" -lt "14" ]; then \
 	echo "-mcpu=4kc"; \
 else \
@@ -31,10 +33,10 @@
 
 ifneq (,$(findstring 4KCle,$(CROSS_COMPILE)))
 ENDIANNESS = -EL
-else
-ENDIANNESS = -EB
+#else
+#ENDIANNESS = -EB
 endif
 
-MIPSFLAGS += $(ENDIANNESS) -mabicalls
+MIPSFLAGS += $(ENDIANNESS) -mabicalls -march=mips32r2
 
 PLATFORM_CPPFLAGS += $(MIPSFLAGS)
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/cpu.c u-boot_1.1//cpu/mips/cpu.c
--- u-boot//cpu/mips/cpu.c	2014-02-18 01:46:22.595049375 -0800
+++ u-boot_1.1//cpu/mips/cpu.c	2014-02-18 01:46:26.699052241 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2003
  * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -26,22 +28,81 @@
 #include <asm/inca-ip.h>
 #include <asm/mipsregs.h>
 
+#if defined(CONFIG_AR7100)
+#include <asm/addrspace.h>
+#include <ar7100_soc.h>
+#endif
+
+#if defined(CONFIG_AR7240)
+#include <asm/addrspace.h>
+#include <ar7240_soc.h>
+#endif
+
+#if defined(CONFIG_ATHEROS)
+#include <asm/addrspace.h>
+#include <atheros.h>
+#endif
+
+
 int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-#if defined(CONFIG_INCA_IP)
+#if defined(CONFIG_ATHEROS)
+	while (1) {
+		ath_reg_wr(RST_RESET_ADDRESS, RST_RESET_FULL_CHIP_RESET_SET(1));
+	}
+#elif defined(CONFIG_INCA_IP)
 	*INCA_IP_WDT_RST_REQ = 0x3f;
 #elif defined(CONFIG_PURPLE) || defined(CONFIG_TB0229)
 	void (*f)(void) = (void *) 0xbfc00000;
 
 	f();
+#elif defined(CONFIG_AR7100)
+#ifndef COMPRESSED_UBOOT
+	fprintf(stdout, "\nResetting...\n");
+#endif  /* #ifndef COMPRESSED_UBOOT */
+	for (;;) {
+		ar7100_reg_wr(AR7100_RESET,
+			(AR7100_RESET_FULL_CHIP | AR7100_RESET_DDR));
+	}
+#elif defined(CONFIG_AR7240)
+#ifndef COMPRESSED_UBOOT
+	fprintf(stdout, "\nResetting...\n");
+#endif  /* #ifndef COMPRESSED_UBOOT */
+	for (;;) {
+#ifdef CONFIG_WASP
+		if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+			ar7240_reg_wr(AR7240_RESET,
+				(AR7240_RESET_FULL_CHIP | AR7240_RESET_DDR));
+		} else {
+			/*
+			 * WAR for full chip reset spi vs. boot-rom selection
+			 * bug in wasp 1.0
+			 */
+			ar7240_reg_wr (AR7240_GPIO_OE,
+				ar7240_reg_rd(AR7240_GPIO_OE) & (~(1 << 17)));
+		}
+#else
+		ar7240_reg_wr(AR7240_RESET,
+			(AR7240_RESET_FULL_CHIP | AR7240_RESET_DDR));
 #endif
+	}
+#endif
+#ifndef COMPRESSED_UBOOT
 	fprintf(stderr, "*** reset failed ***\n");
+#endif  /* #ifndef COMPRESSED_UBOOT */
 	return 0;
 }
 
 void flush_cache (ulong start_addr, ulong size)
 {
+	u32 end, a;
+    int i;
+
+    a = start_addr & ~(CFG_CACHELINE_SIZE - 1);
+    size = (size + CFG_CACHELINE_SIZE - 1) & ~(CFG_CACHELINE_SIZE - 1);
+    end = a + size;
 
+    dcache_flush_range(a, end);
 }
 
 void write_one_tlb( int index, u32 pagemask, u32 hi, u32 low0, u32 low1 ){
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/Makefile u-boot_1.1//cpu/mips/Makefile
--- u-boot//cpu/mips/Makefile	2014-02-18 01:46:22.595049375 -0800
+++ u-boot_1.1//cpu/mips/Makefile	2014-02-18 01:46:26.663052209 -0800
@@ -2,6 +2,8 @@
 # (C) Copyright 2003
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
 # See file CREDITS for list of people who contributed to this
 # project.
 #
@@ -25,10 +27,14 @@
 
 LIB	= lib$(CPU).a
 
+ifeq ($(COMRESSED_UBOOT),1)
+START	= start.o start_bootstrap.o
+else
 START	= start.o
-OBJS	= asc_serial.o au1x00_serial.o au1x00_eth.o au1x00_usb_ohci.o \
-	  cpu.o interrupts.o incaip_clock.o
-SOBJS	= incaip_wdt.o cache.o
+endif
+
+OBJS	= cpu.o interrupts.o
+SOBJS	= cache.o
 
 all:	.depend $(START) $(LIB)
 
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/start_bootstrap.S u-boot_1.1//cpu/mips/start_bootstrap.S
--- u-boot//cpu/mips/start_bootstrap.S	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//cpu/mips/start_bootstrap.S	2014-02-18 01:46:26.703052246 -0800
@@ -0,0 +1,700 @@
+/*
+ *  Startup Code for MIPS32 CPU-core
+ *
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *  Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+
+#define AR7100_SPI_CLOCK  0xbf000004
+
+#define RVECENT(f,n) \
+   b f; nop
+
+#define XVECENT(f,bev) \
+   b f     ;           \
+   li k0,bev
+
+	.set noreorder
+
+	.globl _start_bootstrap
+	.text
+_start_bootstrap:
+	RVECENT(reset,0)	/* U-boot entry point */
+	RVECENT(reset,1)	/* software reboot */
+	RVECENT(romReserved,2)
+	RVECENT(romReserved,3)
+	RVECENT(romReserved,4)
+	RVECENT(romReserved,5)
+	RVECENT(romReserved,6)
+	RVECENT(romReserved,7)
+	RVECENT(romReserved,8)
+	RVECENT(romReserved,9)
+	RVECENT(romReserved,10)
+	RVECENT(romReserved,11)
+	RVECENT(romReserved,12)
+	RVECENT(romReserved,13)
+	RVECENT(romReserved,14)
+	RVECENT(romReserved,15)
+	RVECENT(romReserved,16)
+	RVECENT(romReserved,17)
+	RVECENT(romReserved,18)
+	RVECENT(romReserved,19)
+	RVECENT(romReserved,20)
+	RVECENT(romReserved,21)
+	RVECENT(romReserved,22)
+	RVECENT(romReserved,23)
+	RVECENT(romReserved,24)
+	RVECENT(romReserved,25)
+	RVECENT(romReserved,26)
+	RVECENT(romReserved,27)
+	RVECENT(romReserved,28)
+	RVECENT(romReserved,29)
+	RVECENT(romReserved,30)
+	RVECENT(romReserved,31)
+	RVECENT(romReserved,32)
+	RVECENT(romReserved,33)
+	RVECENT(romReserved,34)
+	RVECENT(romReserved,35)
+	RVECENT(romReserved,36)
+	RVECENT(romReserved,37)
+	RVECENT(romReserved,38)
+	RVECENT(romReserved,39)
+	RVECENT(romReserved,40)
+	RVECENT(romReserved,41)
+	RVECENT(romReserved,42)
+	RVECENT(romReserved,43)
+	RVECENT(romReserved,44)
+	RVECENT(romReserved,45)
+	RVECENT(romReserved,46)
+	RVECENT(romReserved,47)
+	RVECENT(romReserved,48)
+	RVECENT(romReserved,49)
+	RVECENT(romReserved,50)
+	RVECENT(romReserved,51)
+	RVECENT(romReserved,52)
+	RVECENT(romReserved,53)
+	RVECENT(romReserved,54)
+	RVECENT(romReserved,55)
+	RVECENT(romReserved,56)
+	RVECENT(romReserved,57)
+	RVECENT(romReserved,58)
+	RVECENT(romReserved,59)
+	RVECENT(romReserved,60)
+	RVECENT(romReserved,61)
+	RVECENT(romReserved,62)
+	RVECENT(romReserved,63)
+	XVECENT(romExcHandle,0x200)	/* bfc00200: R4000 tlbmiss vector */
+	RVECENT(romReserved,65)
+	RVECENT(romReserved,66)
+	RVECENT(romReserved,67)
+	RVECENT(romReserved,68)
+	RVECENT(romReserved,69)
+	RVECENT(romReserved,70)
+	RVECENT(romReserved,71)
+	RVECENT(romReserved,72)
+	RVECENT(romReserved,73)
+	RVECENT(romReserved,74)
+	RVECENT(romReserved,75)
+	RVECENT(romReserved,76)
+	RVECENT(romReserved,77)
+	RVECENT(romReserved,78)
+	RVECENT(romReserved,79)
+	XVECENT(romExcHandle,0x280)	/* bfc00280: R4000 xtlbmiss vector */
+	RVECENT(romReserved,81)
+	RVECENT(romReserved,82)
+	RVECENT(romReserved,83)
+	RVECENT(romReserved,84)
+	RVECENT(romReserved,85)
+	RVECENT(romReserved,86)
+	RVECENT(romReserved,87)
+	RVECENT(romReserved,88)
+	RVECENT(romReserved,89)
+	RVECENT(romReserved,90)
+	RVECENT(romReserved,91)
+	RVECENT(romReserved,92)
+	RVECENT(romReserved,93)
+	RVECENT(romReserved,94)
+	RVECENT(romReserved,95)
+	XVECENT(romExcHandle,0x300)	/* bfc00300: R4000 cache vector */
+	RVECENT(romReserved,97)
+	RVECENT(romReserved,98)
+	RVECENT(romReserved,99)
+	RVECENT(romReserved,100)
+	RVECENT(romReserved,101)
+	RVECENT(romReserved,102)
+	RVECENT(romReserved,103)
+	RVECENT(romReserved,104)
+	RVECENT(romReserved,105)
+	RVECENT(romReserved,106)
+	RVECENT(romReserved,107)
+	RVECENT(romReserved,108)
+	RVECENT(romReserved,109)
+	RVECENT(romReserved,110)
+	RVECENT(romReserved,111)
+	XVECENT(romExcHandle,0x380)	/* bfc00380: R4000 general vector */
+	RVECENT(romReserved,113)
+	RVECENT(romReserved,114)
+	RVECENT(romReserved,115)
+	RVECENT(romReserved,116)
+	RVECENT(romReserved,116)
+	RVECENT(romReserved,118)
+	RVECENT(romReserved,119)
+	RVECENT(romReserved,120)
+	RVECENT(romReserved,121)
+	RVECENT(romReserved,122)
+	RVECENT(romReserved,123)
+	RVECENT(romReserved,124)
+	RVECENT(romReserved,125)
+	RVECENT(romReserved,126)
+	RVECENT(romReserved,127)
+
+	/* We hope there are no more reserved vectors!
+	 * 128 * 8 == 1024 == 0x400
+	 * so this is address R_VEC+0x400 == 0xbfc00400
+	 */
+	.align 4
+reset:
+	/*
+	 * Clearing CP0 registers - This is generally required for the MIPS-24k
+     * core used by Atheros.
+	 */
+	mtc0	zero, $0
+	mtc0	zero, $1
+	mtc0	zero, $2
+	mtc0	zero, $3
+	mtc0	zero, $4
+	mtc0	zero, $5
+	mtc0	zero, $6
+	mtc0	zero, $7
+	mtc0	zero, $8
+	mtc0	zero, $9
+	mtc0	zero, $10
+	mtc0	zero, $11
+	li	t0, 0x10000004
+	mtc0	t0, $12
+	mtc0	zero, $13
+	mtc0	zero, $14
+	mtc0	zero, $15
+	mtc0	zero, $16
+	mtc0	zero, $17
+	mtc0	zero, $18
+	mtc0	zero, $19
+	mtc0	zero, $20
+	mtc0	zero, $21
+	mtc0	zero, $22
+#ifndef CONFIG_HORNET_EMU
+	mtc0	zero, $23
+#endif
+	mtc0	zero, $24
+	mtc0	zero, $25
+	mtc0	zero, $26
+	mtc0	zero, $27
+	mtc0	zero, $28
+#if defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x) || defined(CONFIG_MACH_QCA956x)
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+
+	/*
+	 * Clear watch registers.
+	 */
+
+	mtc0	zero, CP0_WATCHLO
+	mtc0	zero, CP0_WATCHHI
+
+	/* STATUS register */
+	mfc0	k0, CP0_STATUS
+	li	k1, ~ST0_IE
+	and	k0, k1
+        mtc0	zero, CP0_CAUSE
+	mtc0	k0, CP0_STATUS
+
+	/* CAUSE register */
+	mtc0	zero, CP0_CAUSE
+
+	/* Init Timer */
+	mtc0	zero, CP0_COUNT
+	mtc0	zero, CP0_COMPARE
+
+	/* CONFIG0 register */
+	li	t0, CONF_CM_UNCACHED
+	mtc0	t0, CP0_CONFIG
+
+
+    /* Initialize GOT pointer.*/
+	bal     1f
+	nop
+	.word   _GLOBAL_OFFSET_TABLE_
+	1:
+	move    gp, ra
+	lw      t1, 0(ra)
+	move	gp, t1
+
+#if (defined(CONFIG_MACH_HORNET) && defined(CONFIG_HORNET_1_1_WAR)) || defined(CONFIG_MACH_QCA956x)
+/**************************************************************************/
+/*
+ * WAR: Hornet 1.1 currently need a reset once we boot to let the resetb has
+ *      enough time to stable, so that trigger reset at 1st boot, system team
+ *      is investigaing the issue, will remove in short
+ */
+
+do_reset_normal:
+
+    li  t7, 0xbd000000
+    lw  t8, 0(t7)            // t8 : value of 0xbd000000
+    li  t9, 0x12345678
+    bne t8, t9, do_reset     // if value of 0xbd000000 != 0x12345678 , go to do_reset
+    nop
+    li  t9, 0xffffffff
+    sw  t9, 0(t7) 
+    b   normal_path
+    nop
+
+do_reset:
+    sw  t9, 0(t7)
+    li  t7, 0xb806001c       // load reset register 0x1806001c
+    lw  t8, 0(t7)
+    li  t9, 0x1000000        // bit24, fullchip reset
+    or  t8, t8, t9
+    sw  t8, 0(t7)
+do_reset_loop:    
+    b   do_reset_loop
+    nop
+
+normal_path:
+#endif /* CONFIG_MACH_HORNET */
+
+/**************************************************************************/
+
+	/* Initialize any external memory.
+	 */
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x) || defined(CONFIG_MACH_QCA956x)
+	la      t9, lowlevel_init
+	jalr    t9
+	nop
+	nop
+
+#if defined(CONFIG_MACH_HORNET)
+	la      t9, hornet_ddr_init
+	jalr    t9
+	nop
+	nop
+
+#if 0
+	la      t9, hornet_ddr_tap_init
+	jalr    t9
+	nop
+#endif
+
+#endif
+
+	la	t0, rel_start
+	j	t0
+	nop
+#endif
+
+rel_start:
+
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x)
+	/* REMAP_DISABLE */
+	li	a0, AR7100_SPI_CLOCK
+	li	t0, 0x43
+	sw	t0, 0(a0)
+#elif defined(CONFIG_MACH_QCA956x)
+	/* REMAP_DISABLE */
+	li	a0, AR7100_SPI_CLOCK
+	li	t0, 0x46
+	sw	t0, 0(a0)
+#endif
+
+#if defined(CONFIG_AR9100) && defined(CFG_HOWL_1_2)
+    /* Disable remap for parallel flash */
+    li  t7, AR9100_FLASH_CONFIG;
+    lw  t8, 0(t7);
+    li  t9, 0xffbf0000;
+    and t8, t8, t9;
+    li  t9, 0x22fc;
+    or  t8, t8, t9;
+    li  t9, 0xffcfffff; /* scale = 0 */
+    and t8, t8, t9;
+    sw  t8, 0(t7);
+
+#endif
+
+	/* Initialize caches...
+	 */
+	la      t9, simple_mips_cache_reset
+	jalr    t9
+	nop
+
+	/* ... and enable them.
+	 */
+	li	t0, CONF_CM_CACHABLE_NONCOHERENT
+	mtc0	t0, CP0_CONFIG
+
+#if !defined(CFG_INIT_STACK_IN_SRAM)
+#if !defined(CONFIG_AR7100) && !defined(CONFIG_AR7240)
+	/* Set up temporary stack.
+	 */
+	li	a0, CFG_INIT_SP_OFFSET
+	la      t9, mips_cache_lock
+	jalr    t9
+	nop
+#endif
+
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240)
+	la	t9, mips_cache_lock_24k
+	jalr	t9
+	nop
+#endif
+#endif /* CFG_INIT_STACK_IN_SRAM */
+
+	li	t0, CFG_SDRAM_BASE + CFG_INIT_SP_OFFSET
+#ifdef CFG_INIT_STACK_IN_SRAM
+	li	t0, CFG_INIT_SRAM_SP_OFFSET	/* Setup stack in SRAM */
+#endif
+	la	sp, 0(t0)
+
+	la	t9, bootstrap_board_init_f
+	j	t9
+	nop
+
+
+/*
+ * void bootstrap_relocate_code (addr_sp, gd, addr_moni)
+ *
+ * This "function" does not return, instead it continues in RAM
+ * after relocating the monitor code.
+ *
+ * a0 = addr_sp
+ * a1 = gd
+ * a2 = destination address
+ */
+	.globl	bootstrap_relocate_code
+	.ent	bootstrap_relocate_code
+bootstrap_relocate_code:
+	move	sp, a0		/* Set new stack pointer		*/
+
+	li	t0, BOOTSTRAP_CFG_MONITOR_BASE
+	la	t3, in_ram
+	lw	t2, -12(t3)	/* t2 <-- uboot_end_data_bootsrap	*/
+
+	/*
+	 * Ideally, following line is not needed. However,
+	 * the behaviour is flaky without it. U-boot boots on
+	 * some boards, and doesn't on some boards. Even on the
+	 * boards it boots, it doesn't boot all the time.
+	 *
+	 * Adding 256k to what needs to be read in actually.
+	 * This introduces some delay that seems to help boot.
+	 */
+	li	t3, (256 << 10)
+
+	add	t2, t3
+	move	t1, a2
+
+	/*
+	 * Fix GOT pointer:
+	 *
+	 * New GOT-PTR = (old GOT-PTR - BOOTSTRAP_CFG_MONITOR_BASE) + Destination Address
+	 */
+	move	t6, gp
+	sub	gp, BOOTSTRAP_CFG_MONITOR_BASE
+	add	gp, a2			/* gp now adjusted		*/
+	sub	t6, gp, t6		/* t6 <-- relocation offset	*/
+
+	/*
+	 * t0 = source address
+	 * t1 = target address
+	 * t2 = source end address
+	 */
+1:
+	lw	t3, 0(t0)
+	sw	t3, 0(t1)
+	addu	t0, 4
+	ble	t0, t2, 1b
+	addu	t1, 4			/* delay slot			*/
+
+	/* If caches were enabled, we would have to flush them here.
+	 */
+
+	/* Jump to where we've relocated ourselves.
+	 */
+	addi	t0, a2, in_ram - _start_bootstrap
+	j	t0
+	nop
+
+	.word	uboot_end_data_bootstrap
+	.word	uboot_end_bootstrap
+	.word	num_got_entries
+
+in_ram:
+	/* Now we want to update GOT.
+	 */
+	lw	t3, -4(t0)	/* t3 <-- num_got_entries	*/
+	addi	t4, gp, 8	/* Skipping first two entries.	*/
+	li	t2, 2
+1:
+	lw	t1, 0(t4)
+	beqz	t1, 2f
+	add	t1, t6
+	sw	t1, 0(t4)
+2:
+	addi	t2, 1
+	blt	t2, t3, 1b
+	addi	t4, 4		/* delay slot			*/
+
+	/* Clear BSS.
+	 */
+	lw	t1, -12(t0)	/* t1 <-- uboot_end_data_bootstrap	*/
+	lw	t2, -8(t0)	/* t2 <-- uboot_end_bootstrap		*/
+	add	t1, t6		/* adjust pointers		*/
+	add	t2, t6
+
+	sub	t1, 4
+1:	addi	t1, 4
+	bltl	t1, t2, 1b
+	sw	zero, 0(t1)	/* delay slot			*/
+
+	move	a0, a1
+	la	t9, bootstrap_board_init_r
+	j	t9
+	move	a1, a2		/* delay slot			*/
+
+	.end	bootstrap_relocate_code
+
+
+
+.globl	ath_ddr_tap_cal
+.type   ath_ddr_tap_cal, @function
+
+ath_ddr_tap_cal:
+	li	a0,	0xbd001f00
+	sw	zero,	0x0(a0)			// Place where the tap values are saved and used for SWEEP
+	sw	zero,	0x4(a0)			// Place where the number of passing taps are saved.
+	sw	zero,	0x14(a0)		// Place where the last pass tap value is stored
+	li	a1,	0xaa55aa55		// Indicates that the First pass tap value is not found
+	sw	a1,	0x10(a0)		// Place where the First pass tap value is stored
+	nop
+
+	li	a0,	0xb8060000		// RESET_BASE_ADDRESS
+	lw	a1,	0x1c(a0)		// Reading the RST_RESET_ADDRESS
+	li	a2,	0x08000000		// Setting the RST_RESET_RTC_RESET
+	or	a1,	a1,	a2
+	sw	a1,	0x1c(a0)
+
+	li	a3,	0xffffffff
+	xor	a2,	a2,	a3
+	and	a1,	a1,	a2
+	sw	a1,	0x1c(a0)		// Taking the RTC out of RESET
+	nop
+
+	li	a0,	0xb8107000		// RTC_BASE_ADDRESS
+	li	a1,	0x1
+	sw	a1,	0x0040(a0)		// RTC_SYNC_RESET_ADDRESS
+
+	li	a2,	0x2
+
+_poll_for_RTC_ON:
+	lw	a1,	0x0044(a0)		// RTC_SYNC_STATUS_ADDRESS
+	and	a1,	a2,	a1
+	bne	a1,	a2,	_poll_for_RTC_ON
+
+
+_CHANGE_TAPS:
+
+	li	t0,	0xbd001f00		// Read the current value of the TAP for programming
+	lw	t1,	0x0(t0)
+	li	t2,	0x00000000
+	or	t3,	t1,	t2
+
+
+	li	t0,	0xb8000000		// DDR_BASE_ADDRESS
+
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	li	t1,	0x00000010		// Running the test 8 times
+	sw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+
+	li	t1,	0xfa5de83f		// 4 Row Address Bits, 4 Column Address Bits, 2 BA bits
+	sw	t1,	0x002c(t0)		// PERF_MASK_ADDR_0_ADDRESS
+
+#ifdef CONFIG_MACH_QCA953x
+	li	t1,	0x0000ffff
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+#else // Wasp & Scorpion ...
+	li	t1,	0x545fc332
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+#endif
+
+	li	t1,	0x00000001
+	sw	t1,	0x011c(t0)		// DDR_BIST_ADDRESS
+
+	li	t2,	0x1
+_bist_done_poll:
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	and	t1,	t1,	t2
+	bne	t1,	t2,	_bist_done_poll
+
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	li	t4,	0x000001fe
+	and	t2,	t1,	t4
+	srl	t2,	t2,	0x1		// no. of Pass Runs
+
+	li	t5,	0x00000000
+	sw	t5,	0x011c(t0)		//DDR_BIST_ADDRESS	- Stop the DDR BIST test
+
+	li	t5,	0x0001fe00
+	and	t5,	t5,	t1
+	bnez	t5,	_iterate_tap		// This is a redundant compare but nevertheless - Comparing the FAILS
+
+	lw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+	li	t3,	0x000001fe
+	and	t3,	t3,	t1
+	srl	t3,	t3,	0x1		// No. of runs in the config register.
+
+	bne	t3,	t2,	_iterate_tap
+
+pass_tap:
+	li	t0,	0xbd001f00
+	lw	t1,	0x4(t0)
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x4(t0)
+
+	li	t0,	0xbd001f10
+	lw	t1,	0x0(t0)
+	li	t2,	0xaa55aa55
+	beq	t1,	t2,	_first_pass
+	nop
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd001f10
+	sw	t1,	0x4(t0)
+	nop
+	b	_iterate_tap
+	nop
+
+_first_pass:
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd001f10
+	sw	t1,	0x0(t0)
+	sw	t1,	0x4(t0)
+	nop
+
+_iterate_tap:
+
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t2,	0x3f
+	beq	t1,	t2,	_STOP_TEST
+	nop
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x0(t0)
+	nop
+	b	_CHANGE_TAPS
+
+_STOP_TEST:
+	li	t0,	0xbd001f00
+	lw	t1,	0x4(t0)
+	bnez	t1,	_load_center_tap
+	nop
+	li	t3,	0x8			// Default Tap to be used
+	b	_load_tap_into_reg
+
+_load_center_tap:
+	li	t0,	0xbd001f10
+	lw	t1,	0x0(t0)
+	lw	t2,	0x4(t0)
+	add	t3,	t1,	t2
+	srl	t3,	t3,	0x1
+	li	t4,	0x3f
+	and	t3,	t3,	t4
+_load_tap_into_reg:
+	li	t0,	0xb8000000
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+	jr	ra
+	nop
+
+
+
+	/* Exception handlers.
+	 */
+romReserved:
+	b romReserved
+
+romExcHandle:
+	b romExcHandle
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//cpu/mips/start.S u-boot_1.1//cpu/mips/start.S
--- u-boot//cpu/mips/start.S	2014-02-18 01:46:22.599049378 -0800
+++ u-boot_1.1//cpu/mips/start.S	2014-02-18 01:46:26.699052241 -0800
@@ -2,7 +2,8 @@
  *  Startup Code for MIPS32 CPU-core
  *
  *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
- *
+ *  Copyright (c) 2013 Qualcomm Atheros, Inc.
+ * 
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -27,30 +28,34 @@
 #include <version.h>
 #include <asm/regdef.h>
 #include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#ifdef CONFIG_ATHEROS
+#	include <atheros.h>
+#else
+#	include <ar7240_soc.h>
+#	define ATH_SPI_CLOCK	0xbf000004
+#endif
+
 
+#define RVECENT(f,n)		\
+	b	f;	nop
 
-#define RVECENT(f,n) \
-   b f; nop
-#define XVECENT(f,bev) \
-   b f     ;           \
-   li k0,bev
+#define XVECENT(f,bev)		\
+	b	f;		\
+	li	k0,	bev
 
 	.set noreorder
+#ifdef COMPRESSED_UBOOT
+	.align 4
+#endif
 
 	.globl _start
 	.text
 _start:
+#ifndef COMPRESSED_UBOOT
 	RVECENT(reset,0)	/* U-boot entry point */
 	RVECENT(reset,1)	/* software reboot */
-#if defined(CONFIG_INCA_IP)
-	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
-	.word 0x00000000           /* phase of the flash                    */
-#elif defined(CONFIG_PURPLE)
-	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
-	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
-#else
 	RVECENT(romReserved,2)
-#endif
 	RVECENT(romReserved,3)
 	RVECENT(romReserved,4)
 	RVECENT(romReserved,5)
@@ -181,46 +186,119 @@
 	 * 128 * 8 == 1024 == 0x400
 	 * so this is address R_VEC+0x400 == 0xbfc00400
 	 */
-#ifdef CONFIG_PURPLE
-/* 0xbfc00400 */
-	.word	0xdc870000
-	.word	0xfca70000
-	.word	0x20840008
-	.word	0x20a50008
-	.word	0x20c6ffff
-	.word	0x14c0fffa
-	.word	0x00000000
-	.word	0x03e00008
-	.word	0x00000000
-	.word   0x00000000
-/* 0xbfc00428 */
-	.word	0xdc870000
-	.word	0xfca70000
-	.word	0x20840008
-	.word	0x20a50008
-	.word	0x20c6ffff
-	.word	0x14c0fffa
-	.word	0x00000000
-	.word	0x03e00008
-	.word	0x00000000
-	.word   0x00000000
-#endif /* CONFIG_PURPLE */
+
 	.align 4
 reset:
+#if !defined(CONFIG_ATH_NAND_BR)
+	/*
+	 * Clearing CP0 registers - This is generally required for the MIPS-24k
+	 * core used by Atheros.
+	 */
+	mtc0	zero, $0
+	mtc0	zero, $1
+	mtc0	zero, $2
+	mtc0	zero, $3
+	mtc0	zero, $4
+	mtc0	zero, $5
+	mtc0	zero, $6
+	mtc0	zero, $7
+	mtc0	zero, $8
+	mtc0	zero, $9
+	mtc0	zero, $10
+	mtc0	zero, $11
+	li	t0, 0x10000004
+	mtc0	t0, $12
+	mtc0	zero, $13
+	mtc0	zero, $14
+	mtc0	zero, $15
+	mtc0	zero, $16
+
+#if defined(CONFIG_MACH_QCA955x)
+/*
+ * Workaround recommnded by MIPS for the Scorpion Freeze issue
+ */
+#define CONFIG_SCO_JRCD		1
+#define CONFIG_SCO_IAGN		!CONFIG_SCO_JRCD
+
+#if CONFIG_SCO_IAGN && CONFIG_SCO_JRCD
+#error Both CONFIG_SCO_IAGN and CONFIG_SCO_JRCD set
+#endif
+
+#if CONFIG_SCO_JRCD
+	/*
+	 * JR Cache Prediction Disable. Disables JR target address prediction.
+	 * Bit [0], CP0 Register 16, Select 6
+	 *	0 - JR cache target address prediction is enabled.
+	 *	1 - JR cache target address prediction is not enabled.
+	 */
+	mfc0	t0,	$16,	6
+	li	t1,	(1 << 0)
+	or	t0,	t0,	t1
+	mtc0	t0,	$16,	6
+#endif
+
+#if CONFIG_SCO_IAGN
+	/*
+	 * Bit [25], CP0 Register 16, Select 7
+	 * Selective control of out-of-order behavior: issue ALU-side or
+	 * load/store-side instructions (respectively) in program order.
+	 */
+	mfc0	t0,	$16,	7
+	li	t1,	(1 << 25)
+	or	t0,	t0,	t1
+	mtc0	t0,	$16,	7
+#endif
+#endif /* CONFIG_MACH_QCA955x */
+
+#define pref_on		0
+
+#if pref_on
+#define prefetch_val	3
+	mfc0	t0,	$16,	7
+	li	t1,	~(3 << 11)
+	and	t0,	t0,	t1
+	li	t1,	(prefetch_val << 11)
+	or	t0,	t0,	t1
+	mtc0	t0,	$16,	7
+#endif
+
+#if !defined(CONFIG_WASP_SUPPORT)
+	mtc0	zero, $17
+#endif
+	mtc0	zero, $18
+	mtc0	zero, $19
+#if !defined(CONFIG_WASP_SUPPORT)
+	mtc0	zero, $20
+	mtc0	zero, $21
+	mtc0	zero, $22
+#endif
+#ifndef CONFIG_HORNET_EMU
+	mtc0	zero, $23
+#endif
+	mtc0	zero, $24
+	mtc0	zero, $25
+	mtc0	zero, $26
+	mtc0	zero, $27
+	mtc0	zero, $28
+#if defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x) || defined(CONFIG_MACH_QCA956x)
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
 
-	/* Clear watch registers.
+
+	/*
+	 * Clear watch registers.
 	 */
+
 	mtc0	zero, CP0_WATCHLO
 	mtc0	zero, CP0_WATCHHI
 
 	/* STATUS register */
-#ifdef  CONFIG_TB0229
-	li	k0, ST0_CU0
-#else
 	mfc0	k0, CP0_STATUS
-#endif
 	li	k1, ~ST0_IE
 	and	k0, k1
+        mtc0	zero, CP0_CAUSE
 	mtc0	k0, CP0_STATUS
 
 	/* CAUSE register */
@@ -233,9 +311,19 @@
 	/* CONFIG0 register */
 	li	t0, CONF_CM_UNCACHED
 	mtc0	t0, CP0_CONFIG
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_BR
+	/*
+	 * Clear WDT that was setup in first stage for
+	 * NAND Boot-ROM
+	 */
+	li	t0,	0xb8060008
+	sw	zero,	0(t0)
+#endif /* CONFIG_ATH_NAND_BR */
 
-	/* Initialize GOT pointer.
-	*/
+    /* Initialize GOT pointer.*/
 	bal     1f
 	nop
 	.word   _GLOBAL_OFFSET_TABLE_
@@ -244,47 +332,160 @@
 	lw      t1, 0(ra)
 	move	gp, t1
 
-#ifdef CONFIG_INCA_IP
-	/* Disable INCA-IP Watchdog.
-	 */
-	la      t9, disable_incaip_wdt
-	jalr    t9
+#define DCACHE_16K	0
+#if DCACHE_16K && defined(CONFIG_WASP_SUPPORT)
+	mfc0	t2,	CP0_CONFIG
+	or	t2,	t2, 0x80000
+	mtc0	t2,	CP0_CONFIG
 	nop
-#endif
+
+	mfc0	t2,	CP0_CONFIG,	1
+	and	t2,	t2, ~(0xe000)
+	or	t2,	t2, 0x3000
+	mtc0	t2,	CP0_CONFIG,	1
+	nop
+
+	mfc0	t2,	CP0_CONFIG
+	and	t2,	t2, ~(0x80000)
+	mtc0	t2,	CP0_CONFIG
+
+#endif	/* DCACHE_16K */
+
+#ifndef COMPRESSED_UBOOT
+
+#if (defined(CONFIG_MACH_HORNET) && defined(CONFIG_HORNET_1_1_WAR)) || defined(CONFIG_MACH_QCA956x)
+/**************************************************************************/
+/*
+ * WAR: Hornet 1.1 currently need a reset once we boot to let the resetb has
+ *      enough time to stable, so that trigger reset at 1st boot, system team
+ *      is investigaing the issue, will remove in short
+ */
+
+do_reset_normal:
+
+    li  t7, 0xbd000000
+    lw  t8, 0(t7)            // t8 : value of 0xb8050024
+    li  t9, 0x12345678
+    sw  t9, 0(t7)
+    bne t8, t9, do_reset      // if 0xb8050024 == 0x19 , go to do_cpld
+    nop
+    b normal_path
+
+do_reset:
+    li t7, 0xb806001c       // load reset register 0x1806001c
+    lw t8, 0(t7)
+    li t9, 0x1000000        // bit24, fullchip reset
+    or t8, t8, t9         // t8:  set bit 18
+    sw t8, 0(t7)
+do_reset_loop:
+    b   do_reset_loop
+    nop
+normal_path:
+#endif /* CONFIG_MACH_HORNET */
+
+/**************************************************************************/
 
 	/* Initialize any external memory.
 	 */
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
 	la      t9, lowlevel_init
 	jalr    t9
 	nop
+	nop
+
+#if defined(CONFIG_MACH_HORNET)
+	la      t9, hornet_ddr_init
+	jalr    t9
+	nop
+	nop
+#endif
+
+	la	t0, rel_start
+	j	t0
+	nop
+#endif
+
+rel_start:
+
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+	/* REMAP_DISABLE */
+	li	a0,	KSEG1ADDR(ATH_SPI_CLOCK)
+#if defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x) || defined(CONFIG_MACH_QCA956x)
+	li	t0,	0x246
+#elif defined(CONFIG_WASP_SUPPORT)
+	li	t0,	0x243
+#else
+	li	t0,	0x43
+#endif
+	sw	t0,	0(a0)
+#endif
+
+
+#if defined(CONFIG_AR9100) && defined(CFG_HOWL_1_2)
+	/* Disable remap for parallel flash */
+	li	t7, AR9100_FLASH_CONFIG;
+	lw	t8, 0(t7);
+	li	t9, 0xffbf0000;
+	and	t8, t8, t9;
+	li	t9, 0x22fc;
+	or	t8, t8, t9;
+	li	t9, 0xffcfffff; /* scale = 0 */
+	and	t8, t8, t9;
+	sw	t8, 0(t7);
+#endif
 
 	/* Initialize caches...
 	 */
-	la      t9, mips_cache_reset
+	la      t9, simple_mips_cache_reset
 	jalr    t9
 	nop
 
 	/* ... and enable them.
 	 */
-	li	t0, CONF_CM_CACHABLE_NONCOHERENT
-	mtc0	t0, CP0_CONFIG
+#if defined(CONFIG_WASP_SUPPORT) && !defined(CONFIG_ATH_NAND_BR)
+	li	t7,	KSEG1ADDR(AR7240_REV_ID)
+	lw	t7,	0(t7)
+	andi	t9,	t7,	0xf
+	bne	zero,	t9,	1f
+	nop
+
+	li	t0,	CONF_CM_UNCACHED
+	j	2f
+	nop
+#endif
 
+1:	li	t0,	CONF_CM_CACHABLE_NONCOHERENT
+2:	mtc0	t0,	CP0_CONFIG
 
+#if !defined(CFG_INIT_STACK_IN_SRAM)
+#if !defined(CONFIG_AR7100) && !defined(CONFIG_AR7240)
 	/* Set up temporary stack.
 	 */
 	li	a0, CFG_INIT_SP_OFFSET
 	la      t9, mips_cache_lock
 	jalr    t9
 	nop
+#endif
+
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240)
+	la	t9, mips_cache_lock_24k
+	jalr	t9
+	nop
+#endif
+#endif /* !CFG_INIT_STACK_IN_SRAM */
+#endif /* #ifndef COMPRESSED_UBOOT */
 
+#if defined(CONFIG_WASP_SUPPORT) || defined(CFG_INIT_STACK_IN_SRAM)
+	li	t0, CFG_INIT_SRAM_SP_OFFSET	/* Setup stack in SRAM */
+#else
 	li	t0, CFG_SDRAM_BASE + CFG_INIT_SP_OFFSET
+#endif
 	la	sp, 0(t0)
 
 	la	t9, board_init_f
 	j	t9
 	nop
 
-
 /*
  * void relocate_code (addr_sp, gd, addr_moni)
  *
@@ -320,17 +521,12 @@
 	 * t1 = target address
 	 * t2 = source end address
 	 */
-	/* On the purple board we copy the code earlier in a special way
-	 * in order to solve flash problems
-	 */
-#ifndef CONFIG_PURPLE
 1:
 	lw	t3, 0(t0)
 	sw	t3, 0(t1)
 	addu	t0, 4
 	ble	t0, t2, 1b
 	addu	t1, 4			/* delay slot			*/
-#endif
 
 	/* If caches were enabled, we would have to flush them here.
 	 */
@@ -380,7 +576,4470 @@
 
 	.end	relocate_code
 
+#if !defined(CONFIG_MACH_QCA955x) && !defined(CONFIG_MACH_QCA953x) && !defined(CONFIG_MACH_QCA956x)
+#if !defined(CONFIG_WASP_SUPPORT) && defined(CONFIG_AR7240)
+/*
+ * void ar7240_ddr_tap_init(void)
+ *
+ * This "function" is used to find the tap settings for the DDR
+ */
+	.globl	ar7240_ddr_tap_init
+	.ent	ar7240_ddr_tap_init
+ar7240_ddr_tap_init: /* { */
+	li	t1,0x80500000
+	li	t0,0xffffffff
+
+	sw	t0,0x0(t1)
+	sw	t0,0x4(t1)
+	sw	t0,0x8(t1)
+	sw	t0,0xc(t1)
+
+	nop
+	nop
+
+ddr_pat_init:
+	li 	t0, 0xa0002000
+
+	li 	t1, 0x00000000
+	sw 	t1, 0x0(t0)
+	nop
+
+	li 	t1, 0x00000000
+	sw 	t1, 0x4(t0)
+	nop
+
+	li 	t1, 0x00000000
+	sw	t1, 0x8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x10(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x14(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x18(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x20(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x24(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x28(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x30(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x34(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x38(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x40(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x44(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x48(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x50(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x54(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x58(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x5c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x60(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x64(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x68(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x6c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x70(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x74(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x78(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x7c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x80(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x84(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x88(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x90(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x94(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x98(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x9c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xbc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xcc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xdc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xfc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x100(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x104(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x108(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x10c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x110(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x114(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x118(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x11c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x120(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x124(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x128(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x12c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x130(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x134(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x138(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x13c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x140(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x144(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x148(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x14c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x150(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x154(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x158(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x15c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x160(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x164(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x168(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x16c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x170(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x174(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x178(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x17c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x180(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x184(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x188(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x18c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x190(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x194(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x198(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x19c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x1a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x1a4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x1a8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x1b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x1b4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x1b8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x1c4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x1c8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x1d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x1d4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x1d8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x1e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x1e4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x1e8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x1f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x1f4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x1f8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x200(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x204(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x208(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x20c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x210(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x214(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x218(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x21c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x220(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x224(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x228(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x22c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x230(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x234(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x238(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x23c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x240(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x244(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x248(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x24c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x250(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x254(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x258(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x25c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x260(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x264(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x268(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x26c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x270(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x274(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x278(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x27c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x280(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x284(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x288(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x28c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x290(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x294(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x298(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x29c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2a4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2a8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x2b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2b4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2b8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x2c4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2c8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x2d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x2d4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2d8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x2e4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2e8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x2f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x2f4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2f8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x300(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x304(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x308(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x30c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x310(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x314(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x318(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x31c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x320(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x324(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x328(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x32c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x330(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x334(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x338(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x33c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x340(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x344(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x348(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x34c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x350(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x354(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x358(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x35c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x360(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x364(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x368(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x36c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x370(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x374(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x378(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x37c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x380(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x384(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x388(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x38c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x390(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x394(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x398(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x39c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x3a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x3a4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3a8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x3b4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3b8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3c4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3c8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x3d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3d4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3d8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x3e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3e4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3e8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3f4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3f8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x400(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x404(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x408(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x40c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x410(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x414(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x418(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x41c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x420(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x424(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x428(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x42c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x430(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x434(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x438(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x43c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x440(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x444(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x448(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x44c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x450(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x454(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x458(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x45c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x460(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x464(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x468(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x46c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x470(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x474(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x478(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x47c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x480(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x484(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x488(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x48c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x490(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x494(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x498(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x49c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x4a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x4a4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4a8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x4ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x4b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x4b4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4b8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x4bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x4c4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4c8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x4cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x4d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x4d4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4d8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x4dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x4e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x4e4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4e8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x4ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x4f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x4f4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4f8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x4fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x500(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x504(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x508(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x50c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x510(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x514(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x518(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x51c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x520(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x524(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x528(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x52c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x530(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x534(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x538(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x53c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x540(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x544(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x548(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x54c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x550(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x554(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x558(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x55c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x560(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x564(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x568(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x56c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x570(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x574(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x578(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x57c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x580(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x584(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x588(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x58c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x590(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x594(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x598(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x59c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x5a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x5a4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5a8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x5b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x5b4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5b8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x5c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x5c4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5c8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x5d4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5d8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x5e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x5e4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5e8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x5f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x5f4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5f8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x600(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x604(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x608(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x60c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x610(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x614(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x618(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x61c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x620(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x624(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x628(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x62c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x630(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x634(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x638(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x63c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x640(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x644(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x648(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x64c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x650(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x654(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x658(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x65c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x660(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x664(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x668(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x66c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x670(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x674(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x678(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x67c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x680(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x684(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x688(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x68c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x690(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x694(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x698(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x69c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6a4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6a8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x6ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x6b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6b4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6b8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x6bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x6c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x6c4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6c8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x6cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x6d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x6d4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6d8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x6dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x6e4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6e8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x6ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x6f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x6f4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6f8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x6fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x700(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x704(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x708(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x70c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x710(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x714(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x718(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x71c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x720(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x724(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x728(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x72c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x730(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x734(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x738(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x73c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x740(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x744(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x748(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x74c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x750(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x754(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x758(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x75c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x760(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x764(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x768(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x76c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x770(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x774(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x778(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x77c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x780(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x784(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x788(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x78c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x790(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x794(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x798(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x79c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x7a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x7a4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7a8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x7ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x7b4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7b8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x7bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x7c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7c4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7c8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x7cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x7d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7d4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7d8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x7dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x7e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7e4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7e8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x7ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7f4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7f8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x7fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x800(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x804(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x808(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x80c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x810(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x814(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x818(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x81c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x820(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x824(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x828(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x82c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x830(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x834(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x838(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x83c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x840(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x844(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x848(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x84c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x850(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x854(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x858(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x85c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x860(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x864(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x868(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x86c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x870(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x874(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x878(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x87c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x880(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x884(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x888(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x88c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x890(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x894(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x898(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x89c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8a4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8a8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x8b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8b4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8b8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x8c4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8c8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x8d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x8d4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8d8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x8e4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8e8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x8f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x8f4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8f8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x900(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x904(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x908(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x90c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x910(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x914(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x918(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x91c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x920(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x924(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x928(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x92c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x930(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x934(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x938(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x93c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x940(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x944(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x948(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x94c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x950(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x954(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x958(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x95c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x960(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x964(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x968(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x96c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x970(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x974(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x978(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x97c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x980(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x984(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x988(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x98c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x990(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x994(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x998(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x99c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9a4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x9a8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x9b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9b4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x9b8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x9c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x9c4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x9c8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x9d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x9d4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x9d8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x9e4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x9e8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x9f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x9f4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x9f8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa00(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa04(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa08(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa0c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xa10(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa14(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa18(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa1c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa20(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa24(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa28(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa2c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xa30(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa34(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa38(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa3c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa40(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xa44(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa48(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa4c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xa50(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xa54(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa58(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa5c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa60(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xa64(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa68(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa6c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xa70(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xa74(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa78(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa7c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa80(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa84(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa88(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa8c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xa90(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa94(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa98(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa9c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xaa0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xaa4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xaa8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xaac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xab0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xab4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xab8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xabc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xac0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xac4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xac8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xacc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xad0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xad4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xad8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xadc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xae0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xae4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xae8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xaec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xaf0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xaf4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xaf8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xafc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb00(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb04(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb08(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb0c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xb10(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb14(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb18(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb1c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb20(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb24(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb28(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb2c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb30(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb34(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb38(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb3c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb40(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xb44(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb48(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb4c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xb50(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xb54(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb58(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb5c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb60(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xb64(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb68(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb6c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb70(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xb74(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb78(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb7c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb80(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb84(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb88(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb8c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xb90(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb94(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb98(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb9c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xba0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xba4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xba8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbb0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbb4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbb8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbbc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xbc0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbc4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbc8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbcc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xbd0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbd4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbd8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbdc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbe0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbe4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbe8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbf0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbf4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbf8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbfc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc00(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc04(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc08(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc0c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xc10(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc14(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc18(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc1c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xc20(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc24(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc28(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc2c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc30(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc34(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc38(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc3c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc40(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xc44(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc48(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc4c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xc50(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xc54(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc58(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc5c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xc60(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xc64(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc68(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc6c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc70(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xc74(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc78(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc7c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc80(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xc84(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc88(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc8c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xc90(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xc94(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc98(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc9c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xca0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xca4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xca8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcb0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xcb4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xcb8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcbc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xcc0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcc4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xcc8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xccc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xcd0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcd4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xcd8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcdc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xce0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xce4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xce8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcf0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcf4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xcf8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcfc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd00(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd04(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd08(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd0c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd10(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd14(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd18(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd1c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xd20(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd24(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd28(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd2c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd30(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd34(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd38(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd3c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd40(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd44(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd48(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd4c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd50(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd54(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd58(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd5c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xd60(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd64(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd68(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd6c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd70(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd74(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd78(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd7c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd80(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xd84(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd88(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd8c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd90(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xd94(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd98(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd9c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xda0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xda4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xda8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdb0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xdb4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xdb8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdbc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xdc0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdc4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xdc8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdcc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xdd0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdd4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xdd8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xddc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xde0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xde4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xde8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdf0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdf4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xdf8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdfc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe00(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe04(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe08(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe0c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xe10(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe14(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe18(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe1c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe20(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe24(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe28(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe2c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe30(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe34(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe38(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe3c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe40(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xe44(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe48(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe4c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xe50(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xe54(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe58(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe5c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe60(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xe64(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe68(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe6c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe70(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xe74(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe78(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe7c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe80(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe84(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe88(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe8c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xe90(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe94(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe98(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe9c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xea0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xea4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xea8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xeac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xeb0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xeb4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xeb8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xebc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xec0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xec4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xec8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xecc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xed0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xed4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xed8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xedc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xee0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xee4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xee8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xeec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xef0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xef4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xef8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xefc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf00(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf04(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf08(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf0c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xf10(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf14(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf18(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf1c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xf20(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf24(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf28(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf2c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf30(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf34(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf38(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf3c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf40(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xf44(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf48(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf4c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xf50(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xf54(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf58(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf5c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xf60(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xf64(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf68(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf6c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf70(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xf74(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf78(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf7c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf80(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xf84(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf88(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf8c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xf90(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xf94(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf98(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf9c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xfa0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xfa4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfa8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfb0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xfb4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfb8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfbc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xfc0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfc4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfc8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfcc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xfd0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfd4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfd8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfdc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xfe0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfe4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfe8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xff0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xff4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xff8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xffc(t0)
+	nop
+
+
+//###### ddr init over #########
+
+	li	a0, 0xa0002000
+	li	a1, 0x80002000	     //### Start address of the pattern   200
+	li	a2, 0x80003000	     //### End Address of the pattern     220
+	li	t0, 0xb800001c	//## Tap settings addr
+	lw	a3, 0x0(t0)		//## loading default tap value
+	nop
+	ori	t0, a3, 0x0
+	nop
+	li	t1, 0x1		//# t1=1 indicates increasing tap value, 0 = decreasing
+
+load_tap:
+
+	li	t7, 0x200	//## No. of times read has to happen for 1 tap setting
+	li	t8, 0xb8000000	//#### Loading Tap Setting
+	sw	t0, 0x1c(t8)
+	nop
+	sw	t0, 0x20(t8)
+	nop
+
+pat_read:
+	ori	t2, a0, 0x0
+	nop
+	ori	t3, a1, 0x0
+	nop
+	ori	t4, a2, 0x0
+	nop
+
+tap_addr_loop:
+	lw	t5, 0x0(t2)
+	nop
+	lw	t6, 0x0(t3)
+	nop
+	nop
+
+	bne	t5, t6, tap_fail
+	nop
+	nop
+	nop
+
+	addiu	t2, t2, 0x4  //#incrementing addr
+	addiu	t3, t3, 0x4
+	nop
+	nop
+
+	bne	t3, t4, tap_addr_loop
+	nop
+
+	addiu	t7, t7, -1
+	nop
+	bnez	t7, pat_read
+	nop
+	nop
+
+	bnez	t1, tap_incr
+	nop
+	nop
+
+	bnez	t0, tap_decr	//# t0=0 implies tap=0 works
+	nop		 //# so low limit=0, else decrement tap value
+	nop
+	li	t8, 0x80500000
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0 //#adding lower limit to upper limit (used to calc mid value)
+	nop
+	nop
+
+	b tap_calc
+	nop
+	nop
+
+tap_decr:
+	addiu	t0, t0 , -1
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_incr:
+	addiu	t0, t0 , 0x1
+	nop
+	xori	v1, t0, 0x20
+	nop
+	bnez	v1, load_tap
+	nop
+	nop
+	b up_limit
+	nop
+	nop
+
+tap_fail:
+	bnez	t1, up_limit
+	nop
+	nop
+	nop
+	addiu	t0, t0, 0x1
+	nop
+	li	t8, 0x80500000
+	nop
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0
+	nop
+	nop
+	nop
+
+	b tap_calc
+	nop
+	nop
+
+up_limit:
+	addiu	t0, t0, -1
+	li	t1, 0x0	 //## changing to decreasing tap mode
+	li	t8, 0x80500000 //## storing upper limit
+	sw	t0, 0x4(t8)
+	ori	t9, t0, 0x0
+	nop
+	nop
+	nop
+
+	ori	t0, a3, 0x0 	//# loading default tap value
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_calc:  //## calculating mid value of the tap, storing DQS0, DQS1 in 0x80500008, 0x8050000c resp.
+	li	t7, 0x2
+	nop
+	div	t9, t7
+	nop
+	mfhi	t6
+	mflo	t5
+	nop
+	nop
+	add	t6, t6, t5
+	li	t8, 0x80500000
+	nop
+	sw	t5, 0x8(t8)
+	nop
+	sw	t6, 0xc(t8)
+	nop
+	nop
+        li      t8, 0xb8000000  //#### Loading Tap Setting
+	nop
+        sw      t5, 0x1c(t8)
+        nop
+        sw      t6, 0x20(t8)
+        nop
+	nop
+	nop
+
+end:
+	nop
+	nop
+	nop
+	jr 	ra
+
+	.end	ar7240_ddr_tap_init
+/* } */
+#else
+
+.globl	ath_ddr_tap_cal
+.type   ath_ddr_tap_cal, @function
+
+ath_ddr_tap_cal:
+
+	li	a0,	0xbd007f00
+	sw	zero,	0x0(a0)			// Place where the tap values are saved and used for SWEEP
+	sw	zero,	0x4(a0)			// Place where the number of passing taps are saved.
+	sw	zero,	0x14(a0)		// Place where the last pass tap value is stored
+	li	a1,	0xaa55aa55		// Indicates that the First pass tap value is not found
+	sw	a1,	0x10(a0)		// Place where the First pass tap value is stored
+	nop
+
+	li	a0,	0xb8060000		// RESET_BASE_ADDRESS
+	lw	a1,	0x1c(a0)		// Reading the RST_RESET_ADDRESS
+	li	a2,	0x08000000		// Setting the RST_RESET_RTC_RESET
+	or	a1,	a1,	a2
+	sw	a1,	0x1c(a0)
+
+	li	a3,	0xffffffff
+	xor	a2,	a2,	a3
+	and	a1,	a1,	a2
+	sw	a1,	0x1c(a0)		// Taking the RTC out of RESET
+	nop
+
+	li	a0,	0xb8107000		// RTC_BASE_ADDRESS
+	li	a1,	0x1
+	sw	a1,	0x0040(a0)		// RTC_SYNC_RESET_ADDRESS
+
+	li	a2,	0x2
+
+_poll_for_RTC_ON:
+	lw	a1,	0x0044(a0)		// RTC_SYNC_STATUS_ADDRESS
+	and	a1,	a2,	a1
+	bne	a1,	a2,	_poll_for_RTC_ON
+
+
+_CHANGE_TAPS:
+
+	li	t0,	0xbd007f00		// Read the current value of the TAP for programming
+	lw	t1,	0x0(t0)
+	li	t2,	0x00000000
+	or	t3,	t1,	t2
+
+
+	li	t0,	0xb8000000		// DDR_BASE_ADDRESS
+
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	li	t1,	0x00000010		// Running the test 8 times
+	sw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+
+	li	t1,	0xfa5de83f		// 4 Row Address Bits, 4 Column Address Bits, 2 BA bits
+	sw	t1,	0x002c(t0)		// PERF_MASK_ADDR_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x00000001
+	sw	t1,	0x011c(t0)		// DDR_BIST_ADDRESS
+
+	li	t2,	0x1
+_bist_done_poll:
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	and	t1,	t1,	t2
+	bne	t1,	t2,	_bist_done_poll
+
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	li	t4,	0x000001fe
+	and	t2,	t1,	t4
+	srl	t2,	t2,	0x1		// no. of Pass Runs
+
+	li	t5,	0x00000000
+	sw	t5,	0x011c(t0)		//DDR_BIST_ADDRESS	- Stop the DDR BIST test
+
+	li	t5,	0x0001fe00
+	and	t5,	t5,	t1
+	bnez	t5,	_iterate_tap		// This is a redundant compare but nevertheless - Comparing the FAILS
+
+	lw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+	li	t3,	0x000001fe
+	and	t3,	t3,	t1
+	srl	t3,	t3,	0x1		// No. of runs in the config register.
+
+	bne	t3,	t2,	_iterate_tap
+
+pass_tap:
+	li	t0,	0xbd007f00
+	lw	t1,	0x4(t0)
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x4(t0)
+
+	li	t0,	0xbd007f10
+	lw	t1,	0x0(t0)
+	li	t2,	0xaa55aa55
+	beq	t1,	t2,	_first_pass
+	nop
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd007f10
+	sw	t1,	0x4(t0)
+	nop
+	b	_iterate_tap
+	nop
+
+_first_pass:
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd007f10
+	sw	t1,	0x0(t0)
+	sw	t1,	0x4(t0)
+	nop
+
+_iterate_tap:
+
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t2,	0x1f
+	beq	t1,	t2,	_STOP_TEST
+	nop
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x0(t0)
+	nop
+	b	_CHANGE_TAPS
+
+_STOP_TEST:
+	li	t0,	0xbd007f00
+	lw	t1,	0x4(t0)
+	bnez	t1,	_load_center_tap
+	nop
+	li	t3,	0x8			// Default Tap to be used
+	b	_load_tap_into_reg
+
+_load_center_tap:
+	li	t0,	0xbd007f10
+	lw	t1,	0x0(t0)
+	lw	t2,	0x4(t0)
+	add	t3,	t1,	t2
+	srl	t3,	t3,	0x1
+	li	t4,	0x1f
+	and	t3,	t3,	t4
+
+_load_tap_into_reg:
+	li	t0,	0xb8000000
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	jr	ra
+	nop
+
+
+#endif
+#endif /* !defined(CONFIG_MACH_QCA955x) && !defined(CONFIG_MACH_QCA953x) */
 
+#ifndef COMPRESSED_UBOOT
 	/* Exception handlers.
 	 */
 romReserved:
@@ -388,3 +5047,4 @@
 
 romExcHandle:
 	b romExcHandle
+#endif /* #ifndef COMPRESSED_UBOOT */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//drivers/Makefile u-boot_1.1//drivers/Makefile
--- u-boot//drivers/Makefile	2014-02-18 01:46:22.743049480 -0800
+++ u-boot_1.1//drivers/Makefile	2014-02-18 01:46:26.947052415 -0800
@@ -2,6 +2,8 @@
 # (C) Copyright 2000-2004
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
 # See file CREDITS for list of people who contributed to this
 # project.
 #
@@ -27,7 +29,7 @@
 
 LIB	= libdrivers.a
 
-OBJS	= 3c589.o 5701rls.o ali512x.o \
+#OBJS	= 3c589.o 5701rls.o ali512x.o \
 	  bcm570x.o bcm570x_autoneg.o cfb_console.o cfi_flash.o \
 	  cs8900.o ct69000.o dataflash.o dc2114x.o dm9000x.o \
 	  e1000.o eepro100.o \
@@ -50,6 +52,8 @@
 	  videomodes.o w83c553f.o \
 	  ks8695eth.o
 
+OBJS	=	pci.o
+
 all:	$(LIB)
 
 $(LIB): $(OBJS)
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//drivers/nand/nand_ids.c u-boot_1.1//drivers/nand/nand_ids.c
--- u-boot//drivers/nand/nand_ids.c	2014-02-18 01:46:22.775049502 -0800
+++ u-boot_1.1//drivers/nand/nand_ids.c	2014-02-18 01:46:27.027052470 -0800
@@ -2,8 +2,9 @@
  *  drivers/mtd/nandids.c
  *
  *  Copyright (C) 2002 Thomas Gleixner (tglx@linutronix.de)
-  *
- * $Id: nand_ids.c,v 1.10 2004/05/26 13:40:12 gleixner Exp $
+ *  Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * $Id: //depot/sw/qca_main/components/bootloaders/u-boot-1.1.4/1.1/drivers/nand/nand_ids.c#3 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -127,6 +128,9 @@
 	{NAND_MFR_NATIONAL, "National"},
 	{NAND_MFR_RENESAS, "Renesas"},
 	{NAND_MFR_STMICRO, "ST Micro"},
+	{NAND_MFR_HYNIX, "Hynix"},
+	{NAND_MFR_MICRON, "Micron"},
+	{NAND_MFR_AMD, "AMD"},
 	{0x0, "Unknown"}
 };
 #endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/953x.h u-boot_1.1//include/953x.h
--- u-boot//include/953x.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/953x.h	2014-02-18 01:46:27.515052798 -0800
@@ -0,0 +1,4461 @@
+/*
+ * QCA 953x series processor SOC registers
+ *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _QCA953X_H
+#define _QCA953X_H
+
+#ifndef __ASSEMBLY__
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <linux/types.h>
+#endif /* __ASSEMBLY__ */
+
+#undef is_qca953x
+#undef is_hb
+
+#define is_qca953x()	(1)
+#define is_hb()		(1)
+
+
+#define CPU_PLL_CONFIG_UPDATING_MSB                                  31
+#define CPU_PLL_CONFIG_UPDATING_LSB                                  31
+#define CPU_PLL_CONFIG_UPDATING_MASK                                 0x80000000
+#define CPU_PLL_CONFIG_UPDATING_GET(x)                               (((x) & CPU_PLL_CONFIG_UPDATING_MASK) >> CPU_PLL_CONFIG_UPDATING_LSB)
+#define CPU_PLL_CONFIG_UPDATING_SET(x)                               (((x) << CPU_PLL_CONFIG_UPDATING_LSB) & CPU_PLL_CONFIG_UPDATING_MASK)
+#define CPU_PLL_CONFIG_UPDATING_RESET                                0x1 // 1
+#define CPU_PLL_CONFIG_PLLPWD_MSB                                    30
+#define CPU_PLL_CONFIG_PLLPWD_LSB                                    30
+#define CPU_PLL_CONFIG_PLLPWD_MASK                                   0x40000000
+#define CPU_PLL_CONFIG_PLLPWD_GET(x)                                 (((x) & CPU_PLL_CONFIG_PLLPWD_MASK) >> CPU_PLL_CONFIG_PLLPWD_LSB)
+#define CPU_PLL_CONFIG_PLLPWD_SET(x)                                 (((x) << CPU_PLL_CONFIG_PLLPWD_LSB) & CPU_PLL_CONFIG_PLLPWD_MASK)
+#define CPU_PLL_CONFIG_PLLPWD_RESET                                  0x1 // 1
+#define CPU_PLL_CONFIG_SPARE_MSB                                     29
+#define CPU_PLL_CONFIG_SPARE_LSB                                     22
+#define CPU_PLL_CONFIG_SPARE_MASK                                    0x3fc00000
+#define CPU_PLL_CONFIG_SPARE_GET(x)                                  (((x) & CPU_PLL_CONFIG_SPARE_MASK) >> CPU_PLL_CONFIG_SPARE_LSB)
+#define CPU_PLL_CONFIG_SPARE_SET(x)                                  (((x) << CPU_PLL_CONFIG_SPARE_LSB) & CPU_PLL_CONFIG_SPARE_MASK)
+#define CPU_PLL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define CPU_PLL_CONFIG_OUTDIV_MSB                                    21
+#define CPU_PLL_CONFIG_OUTDIV_LSB                                    19
+#define CPU_PLL_CONFIG_OUTDIV_MASK                                   0x00380000
+#define CPU_PLL_CONFIG_OUTDIV_GET(x)                                 (((x) & CPU_PLL_CONFIG_OUTDIV_MASK) >> CPU_PLL_CONFIG_OUTDIV_LSB)
+#define CPU_PLL_CONFIG_OUTDIV_SET(x)                                 (((x) << CPU_PLL_CONFIG_OUTDIV_LSB) & CPU_PLL_CONFIG_OUTDIV_MASK)
+#define CPU_PLL_CONFIG_OUTDIV_RESET                                  0x0 // 0
+#define CPU_PLL_CONFIG_RANGE_MSB                                     18
+#define CPU_PLL_CONFIG_RANGE_LSB                                     17
+#define CPU_PLL_CONFIG_RANGE_MASK                                    0x00060000
+#define CPU_PLL_CONFIG_RANGE_GET(x)                                  (((x) & CPU_PLL_CONFIG_RANGE_MASK) >> CPU_PLL_CONFIG_RANGE_LSB)
+#define CPU_PLL_CONFIG_RANGE_SET(x)                                  (((x) << CPU_PLL_CONFIG_RANGE_LSB) & CPU_PLL_CONFIG_RANGE_MASK)
+#define CPU_PLL_CONFIG_RANGE_RESET                                   0x3 // 3
+#define CPU_PLL_CONFIG_REFDIV_MSB                                    16
+#define CPU_PLL_CONFIG_REFDIV_LSB                                    12
+#define CPU_PLL_CONFIG_REFDIV_MASK                                   0x0001f000
+#define CPU_PLL_CONFIG_REFDIV_GET(x)                                 (((x) & CPU_PLL_CONFIG_REFDIV_MASK) >> CPU_PLL_CONFIG_REFDIV_LSB)
+#define CPU_PLL_CONFIG_REFDIV_SET(x)                                 (((x) << CPU_PLL_CONFIG_REFDIV_LSB) & CPU_PLL_CONFIG_REFDIV_MASK)
+#define CPU_PLL_CONFIG_REFDIV_RESET                                  0x2 // 2
+#define CPU_PLL_CONFIG_NINT_MSB                                      11
+#define CPU_PLL_CONFIG_NINT_LSB                                      6
+#define CPU_PLL_CONFIG_NINT_MASK                                     0x00000fc0
+#define CPU_PLL_CONFIG_NINT_GET(x)                                   (((x) & CPU_PLL_CONFIG_NINT_MASK) >> CPU_PLL_CONFIG_NINT_LSB)
+#define CPU_PLL_CONFIG_NINT_SET(x)                                   (((x) << CPU_PLL_CONFIG_NINT_LSB) & CPU_PLL_CONFIG_NINT_MASK)
+#define CPU_PLL_CONFIG_NINT_RESET                                    0x14 // 20
+#define CPU_PLL_CONFIG_NFRAC_MSB                                     5
+#define CPU_PLL_CONFIG_NFRAC_LSB                                     0
+#define CPU_PLL_CONFIG_NFRAC_MASK                                    0x0000003f
+#define CPU_PLL_CONFIG_NFRAC_GET(x)                                  (((x) & CPU_PLL_CONFIG_NFRAC_MASK) >> CPU_PLL_CONFIG_NFRAC_LSB)
+#define CPU_PLL_CONFIG_NFRAC_SET(x)                                  (((x) << CPU_PLL_CONFIG_NFRAC_LSB) & CPU_PLL_CONFIG_NFRAC_MASK)
+#define CPU_PLL_CONFIG_NFRAC_RESET                                   0x10 // 16
+#define CPU_PLL_CONFIG_ADDRESS                                       0x18050000
+#define DDR_PLL_CONFIG_UPDATING_MSB                                  31
+#define DDR_PLL_CONFIG_UPDATING_LSB                                  31
+#define DDR_PLL_CONFIG_UPDATING_MASK                                 0x80000000
+#define DDR_PLL_CONFIG_UPDATING_GET(x)                               (((x) & DDR_PLL_CONFIG_UPDATING_MASK) >> DDR_PLL_CONFIG_UPDATING_LSB)
+#define DDR_PLL_CONFIG_UPDATING_SET(x)                               (((x) << DDR_PLL_CONFIG_UPDATING_LSB) & DDR_PLL_CONFIG_UPDATING_MASK)
+#define DDR_PLL_CONFIG_UPDATING_RESET                                0x1 // 1
+#define DDR_PLL_CONFIG_PLLPWD_MSB                                    30
+#define DDR_PLL_CONFIG_PLLPWD_LSB                                    30
+#define DDR_PLL_CONFIG_PLLPWD_MASK                                   0x40000000
+#define DDR_PLL_CONFIG_PLLPWD_GET(x)                                 (((x) & DDR_PLL_CONFIG_PLLPWD_MASK) >> DDR_PLL_CONFIG_PLLPWD_LSB)
+#define DDR_PLL_CONFIG_PLLPWD_SET(x)                                 (((x) << DDR_PLL_CONFIG_PLLPWD_LSB) & DDR_PLL_CONFIG_PLLPWD_MASK)
+#define DDR_PLL_CONFIG_PLLPWD_RESET                                  0x1 // 1
+#define DDR_PLL_CONFIG_SPARE_MSB                                     29
+#define DDR_PLL_CONFIG_SPARE_LSB                                     26
+#define DDR_PLL_CONFIG_SPARE_MASK                                    0x3c000000
+#define DDR_PLL_CONFIG_SPARE_GET(x)                                  (((x) & DDR_PLL_CONFIG_SPARE_MASK) >> DDR_PLL_CONFIG_SPARE_LSB)
+#define DDR_PLL_CONFIG_SPARE_SET(x)                                  (((x) << DDR_PLL_CONFIG_SPARE_LSB) & DDR_PLL_CONFIG_SPARE_MASK)
+#define DDR_PLL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define DDR_PLL_CONFIG_OUTDIV_MSB                                    25
+#define DDR_PLL_CONFIG_OUTDIV_LSB                                    23
+#define DDR_PLL_CONFIG_OUTDIV_MASK                                   0x03800000
+#define DDR_PLL_CONFIG_OUTDIV_GET(x)                                 (((x) & DDR_PLL_CONFIG_OUTDIV_MASK) >> DDR_PLL_CONFIG_OUTDIV_LSB)
+#define DDR_PLL_CONFIG_OUTDIV_SET(x)                                 (((x) << DDR_PLL_CONFIG_OUTDIV_LSB) & DDR_PLL_CONFIG_OUTDIV_MASK)
+#define DDR_PLL_CONFIG_OUTDIV_RESET                                  0x0 // 0
+#define DDR_PLL_CONFIG_RANGE_MSB                                     22
+#define DDR_PLL_CONFIG_RANGE_LSB                                     21
+#define DDR_PLL_CONFIG_RANGE_MASK                                    0x00600000
+#define DDR_PLL_CONFIG_RANGE_GET(x)                                  (((x) & DDR_PLL_CONFIG_RANGE_MASK) >> DDR_PLL_CONFIG_RANGE_LSB)
+#define DDR_PLL_CONFIG_RANGE_SET(x)                                  (((x) << DDR_PLL_CONFIG_RANGE_LSB) & DDR_PLL_CONFIG_RANGE_MASK)
+#define DDR_PLL_CONFIG_RANGE_RESET                                   0x3 // 3
+#define DDR_PLL_CONFIG_REFDIV_MSB                                    20
+#define DDR_PLL_CONFIG_REFDIV_LSB                                    16
+#define DDR_PLL_CONFIG_REFDIV_MASK                                   0x001f0000
+#define DDR_PLL_CONFIG_REFDIV_GET(x)                                 (((x) & DDR_PLL_CONFIG_REFDIV_MASK) >> DDR_PLL_CONFIG_REFDIV_LSB)
+#define DDR_PLL_CONFIG_REFDIV_SET(x)                                 (((x) << DDR_PLL_CONFIG_REFDIV_LSB) & DDR_PLL_CONFIG_REFDIV_MASK)
+#define DDR_PLL_CONFIG_REFDIV_RESET                                  0x2 // 2
+#define DDR_PLL_CONFIG_NINT_MSB                                      15
+#define DDR_PLL_CONFIG_NINT_LSB                                      10
+#define DDR_PLL_CONFIG_NINT_MASK                                     0x0000fc00
+#define DDR_PLL_CONFIG_NINT_GET(x)                                   (((x) & DDR_PLL_CONFIG_NINT_MASK) >> DDR_PLL_CONFIG_NINT_LSB)
+#define DDR_PLL_CONFIG_NINT_SET(x)                                   (((x) << DDR_PLL_CONFIG_NINT_LSB) & DDR_PLL_CONFIG_NINT_MASK)
+#define DDR_PLL_CONFIG_NINT_RESET                                    0x14 // 20
+#define DDR_PLL_CONFIG_NFRAC_MSB                                     9
+#define DDR_PLL_CONFIG_NFRAC_LSB                                     0
+#define DDR_PLL_CONFIG_NFRAC_MASK                                    0x000003ff
+#define DDR_PLL_CONFIG_NFRAC_GET(x)                                  (((x) & DDR_PLL_CONFIG_NFRAC_MASK) >> DDR_PLL_CONFIG_NFRAC_LSB)
+#define DDR_PLL_CONFIG_NFRAC_SET(x)                                  (((x) << DDR_PLL_CONFIG_NFRAC_LSB) & DDR_PLL_CONFIG_NFRAC_MASK)
+#define DDR_PLL_CONFIG_NFRAC_RESET                                   0x200 // 512
+#define DDR_PLL_CONFIG_ADDRESS                                       0x18050004
+
+#define DDR_CTL_CONFIG_SRAM_TSEL_MSB                                 31
+#define DDR_CTL_CONFIG_SRAM_TSEL_LSB                                 30
+#define DDR_CTL_CONFIG_SRAM_TSEL_MASK                                0xc0000000
+#define DDR_CTL_CONFIG_SRAM_TSEL_GET(x)                              (((x) & DDR_CTL_CONFIG_SRAM_TSEL_MASK) >> DDR_CTL_CONFIG_SRAM_TSEL_LSB)
+#define DDR_CTL_CONFIG_SRAM_TSEL_SET(x)                              (((x) << DDR_CTL_CONFIG_SRAM_TSEL_LSB) & DDR_CTL_CONFIG_SRAM_TSEL_MASK)
+#define DDR_CTL_CONFIG_SRAM_TSEL_RESET                               0x1 // 1
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MSB                           29
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB                           21
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK                          0x3fe00000
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_GET(x)                        (((x) & DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK) >> DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB)
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_SET(x)                        (((x) << DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB) & DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK)
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_RESET                         0x0 // 0
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_MSB                             20
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB                             20
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK                            0x00100000
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_MSB                             19
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB                             19
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK                            0x00080000
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_MSB                             18
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB                             18
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK                            0x00040000
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MSB                            17
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB                            17
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK                           0x00020000
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_GET(x)                         (((x) & DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_SET(x)                         (((x) << DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_RESET                          0x1 // 1
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MSB                            16
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB                            16
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK                           0x00010000
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_GET(x)                         (((x) & DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_SET(x)                         (((x) << DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_RESET                          0x1 // 1
+#define DDR_CTL_CONFIG_SPARE_MSB                                     13
+#define DDR_CTL_CONFIG_SPARE_LSB                                     7
+#define DDR_CTL_CONFIG_SPARE_MASK                                    0x00003f80
+#define DDR_CTL_CONFIG_SPARE_GET(x)                                  (((x) & DDR_CTL_CONFIG_SPARE_MASK) >> DDR_CTL_CONFIG_SPARE_LSB)
+#define DDR_CTL_CONFIG_SPARE_SET(x)                                  (((x) << DDR_CTL_CONFIG_SPARE_LSB) & DDR_CTL_CONFIG_SPARE_MASK)
+#define DDR_CTL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_MSB                              6
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB                              6
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK                             0x00000040
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_GET(x)                           (((x) & DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK) >> DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB)
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(x)                           (((x) << DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB) & DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK)
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_MSB                             4
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB                             4
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK                            0x00000010
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_GET(x)                          (((x) & DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK) >> DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB)
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_SET(x)                          (((x) << DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB) & DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK)
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_RESET                           0x0 // 0
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_MSB                              3
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB                              3
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK                             0x00000008
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_GET(x)                           (((x) & DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK) >> DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB)
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_SET(x)                           (((x) << DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB) & DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK)
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_MSB                              2
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB                              2
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK                             0x00000004
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_GET(x)                           (((x) & DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK) >> DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB)
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(x)                           (((x) << DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB) & DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK)
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_HALF_WIDTH_MSB                                1
+#define DDR_CTL_CONFIG_HALF_WIDTH_LSB                                1
+#define DDR_CTL_CONFIG_HALF_WIDTH_MASK                               0x00000002
+#define DDR_CTL_CONFIG_HALF_WIDTH_GET(x)                             (((x) & DDR_CTL_CONFIG_HALF_WIDTH_MASK) >> DDR_CTL_CONFIG_HALF_WIDTH_LSB)
+#define DDR_CTL_CONFIG_HALF_WIDTH_SET(x)                             (((x) << DDR_CTL_CONFIG_HALF_WIDTH_LSB) & DDR_CTL_CONFIG_HALF_WIDTH_MASK)
+#define DDR_CTL_CONFIG_HALF_WIDTH_RESET                              0x1 // 1
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_MSB                             0
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB                             0
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK                            0x00000001
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_GET(x)                          (((x) & DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK) >> DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB)
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_SET(x)                          (((x) << DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB) & DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK)
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_RESET                           0x0 // 0
+#define DDR_CTL_CONFIG_ADDRESS                                       0x18000108
+
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MSB                            31
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB                            31
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK                           0x80000000
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK) >> DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_RESET                          0x0 // 0
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MSB                           30
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB                           30
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK                          0x40000000
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_GET(x)                        (((x) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK) >> DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_SET(x)                        (((x) << DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_RESET                         0x0 // 0
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_MSB                             29
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB                             29
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK                            0x20000000
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_GET(x)                          (((x) & DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK) >> DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB)
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_SET(x)                          (((x) << DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB) & DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK)
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_RESET                           0x0 // 0
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MSB                            28
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB                            28
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK                           0x10000000
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK) >> DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB)
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB) & DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK)
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_RESET                          0x1 // 1
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MSB                            27
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB                            27
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK                           0x08000000
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK) >> DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB)
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB) & DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK)
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_RESET                          0x0 // 0
+#define DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_MSB                          16
+#define DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_LSB                          16
+#define DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_MASK                         0x00010000
+#define DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_GET(x)                       (((x) & DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_MASK) >> DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_LSB)
+#define DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_SET(x)                       (((x) << DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_LSB) & DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_MASK)
+#define DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_RESET                        0x0 // 0
+#define DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_MSB                     15
+#define DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_LSB                     15
+#define DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_MASK                    0x00008000
+#define DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_GET(x)                  (((x) & DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_MASK) >> DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_LSB)
+#define DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_SET(x)                  (((x) << DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_LSB) & DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_MASK)
+#define DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_RESET                   0x0 // 0
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MSB                          14
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB                          13
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK                         0x00006000
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_GET(x)                       (((x) & DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK) >> DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_SET(x)                       (((x) << DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB) & DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_RESET                        0x0 // 0
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_MSB                               12
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_LSB                               8
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_MASK                              0x00001f00
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_GET(x)                            (((x) & DDR_DEBUG_RD_CNTL_GATE_TAP_MASK) >> DDR_DEBUG_RD_CNTL_GATE_TAP_LSB)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_SET(x)                            (((x) << DDR_DEBUG_RD_CNTL_GATE_TAP_LSB) & DDR_DEBUG_RD_CNTL_GATE_TAP_MASK)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_RESET                             0x1 // 1
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MSB                          6
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB                          5
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK                         0x00000060
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_GET(x)                       (((x) & DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK) >> DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_SET(x)                       (((x) << DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB) & DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_RESET                        0x0 // 0
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_MSB                               4
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB                               0
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK                              0x0000001f
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_GET(x)                            (((x) & DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK) >> DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_SET(x)                            (((x) << DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB) & DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_RESET                             0x1 // 1
+#define DDR_DEBUG_RD_CNTL_ADDRESS                                    0x18000118
+
+#define DDR2_CONFIG_DDR2_TWL_MSB                                     13
+#define DDR2_CONFIG_DDR2_TWL_LSB                                     10
+#define DDR2_CONFIG_DDR2_TWL_MASK                                    0x00003c00
+#define DDR2_CONFIG_DDR2_TWL_GET(x)                                  (((x) & DDR2_CONFIG_DDR2_TWL_MASK) >> DDR2_CONFIG_DDR2_TWL_LSB)
+#define DDR2_CONFIG_DDR2_TWL_SET(x)                                  (((x) << DDR2_CONFIG_DDR2_TWL_LSB) & DDR2_CONFIG_DDR2_TWL_MASK)
+#define DDR2_CONFIG_DDR2_TWL_RESET                                   0x1 // 1
+#define DDR2_CONFIG_DDR2_ODT_MSB                                     9
+#define DDR2_CONFIG_DDR2_ODT_LSB                                     9
+#define DDR2_CONFIG_DDR2_ODT_MASK                                    0x00000200
+#define DDR2_CONFIG_DDR2_ODT_GET(x)                                  (((x) & DDR2_CONFIG_DDR2_ODT_MASK) >> DDR2_CONFIG_DDR2_ODT_LSB)
+#define DDR2_CONFIG_DDR2_ODT_SET(x)                                  (((x) << DDR2_CONFIG_DDR2_ODT_LSB) & DDR2_CONFIG_DDR2_ODT_MASK)
+#define DDR2_CONFIG_DDR2_ODT_RESET                                   0x1 // 1
+#define DDR2_CONFIG_TFAW_MSB                                         7
+#define DDR2_CONFIG_TFAW_LSB                                         2
+#define DDR2_CONFIG_TFAW_MASK                                        0x000000fc
+#define DDR2_CONFIG_TFAW_GET(x)                                      (((x) & DDR2_CONFIG_TFAW_MASK) >> DDR2_CONFIG_TFAW_LSB)
+#define DDR2_CONFIG_TFAW_SET(x)                                      (((x) << DDR2_CONFIG_TFAW_LSB) & DDR2_CONFIG_TFAW_MASK)
+#define DDR2_CONFIG_TFAW_RESET                                       0x16 // 22
+#define DDR2_CONFIG_ENABLE_DDR2_MSB                                  0
+#define DDR2_CONFIG_ENABLE_DDR2_LSB                                  0
+#define DDR2_CONFIG_ENABLE_DDR2_MASK                                 0x00000001
+#define DDR2_CONFIG_ENABLE_DDR2_GET(x)                               (((x) & DDR2_CONFIG_ENABLE_DDR2_MASK) >> DDR2_CONFIG_ENABLE_DDR2_LSB)
+#define DDR2_CONFIG_ENABLE_DDR2_SET(x)                               (((x) << DDR2_CONFIG_ENABLE_DDR2_LSB) & DDR2_CONFIG_ENABLE_DDR2_MASK)
+#define DDR2_CONFIG_ENABLE_DDR2_RESET                                0x0 // 0
+#define DDR2_CONFIG_ADDRESS                                          0x180000b8
+
+#define DDR_CONTROL_EMR3S_MSB                                        5
+#define DDR_CONTROL_EMR3S_LSB                                        5
+#define DDR_CONTROL_EMR3S_MASK                                       0x00000020
+#define DDR_CONTROL_EMR3S_GET(x)                                     (((x) & DDR_CONTROL_EMR3S_MASK) >> DDR_CONTROL_EMR3S_LSB)
+#define DDR_CONTROL_EMR3S_SET(x)                                     (((x) << DDR_CONTROL_EMR3S_LSB) & DDR_CONTROL_EMR3S_MASK)
+#define DDR_CONTROL_EMR3S_RESET                                      0x0 // 0
+#define DDR_CONTROL_EMR2S_MSB                                        4
+#define DDR_CONTROL_EMR2S_LSB                                        4
+#define DDR_CONTROL_EMR2S_MASK                                       0x00000010
+#define DDR_CONTROL_EMR2S_GET(x)                                     (((x) & DDR_CONTROL_EMR2S_MASK) >> DDR_CONTROL_EMR2S_LSB)
+#define DDR_CONTROL_EMR2S_SET(x)                                     (((x) << DDR_CONTROL_EMR2S_LSB) & DDR_CONTROL_EMR2S_MASK)
+#define DDR_CONTROL_EMR2S_RESET                                      0x0 // 0
+#define DDR_CONTROL_PREA_MSB                                         3
+#define DDR_CONTROL_PREA_LSB                                         3
+#define DDR_CONTROL_PREA_MASK                                        0x00000008
+#define DDR_CONTROL_PREA_GET(x)                                      (((x) & DDR_CONTROL_PREA_MASK) >> DDR_CONTROL_PREA_LSB)
+#define DDR_CONTROL_PREA_SET(x)                                      (((x) << DDR_CONTROL_PREA_LSB) & DDR_CONTROL_PREA_MASK)
+#define DDR_CONTROL_PREA_RESET                                       0x0 // 0
+#define DDR_CONTROL_REF_MSB                                          2
+#define DDR_CONTROL_REF_LSB                                          2
+#define DDR_CONTROL_REF_MASK                                         0x00000004
+#define DDR_CONTROL_REF_GET(x)                                       (((x) & DDR_CONTROL_REF_MASK) >> DDR_CONTROL_REF_LSB)
+#define DDR_CONTROL_REF_SET(x)                                       (((x) << DDR_CONTROL_REF_LSB) & DDR_CONTROL_REF_MASK)
+#define DDR_CONTROL_REF_RESET                                        0x0 // 0
+#define DDR_CONTROL_EMRS_MSB                                         1
+#define DDR_CONTROL_EMRS_LSB                                         1
+#define DDR_CONTROL_EMRS_MASK                                        0x00000002
+#define DDR_CONTROL_EMRS_GET(x)                                      (((x) & DDR_CONTROL_EMRS_MASK) >> DDR_CONTROL_EMRS_LSB)
+#define DDR_CONTROL_EMRS_SET(x)                                      (((x) << DDR_CONTROL_EMRS_LSB) & DDR_CONTROL_EMRS_MASK)
+#define DDR_CONTROL_EMRS_RESET                                       0x0 // 0
+#define DDR_CONTROL_MRS_MSB                                          0
+#define DDR_CONTROL_MRS_LSB                                          0
+#define DDR_CONTROL_MRS_MASK                                         0x00000001
+#define DDR_CONTROL_MRS_GET(x)                                       (((x) & DDR_CONTROL_MRS_MASK) >> DDR_CONTROL_MRS_LSB)
+#define DDR_CONTROL_MRS_SET(x)                                       (((x) << DDR_CONTROL_MRS_LSB) & DDR_CONTROL_MRS_MASK)
+#define DDR_CONTROL_MRS_RESET                                        0x0 // 0
+#define DDR_CONTROL_ADDRESS                                          0x18000010
+
+#define DDR_CONFIG_CAS_LATENCY_MSB_MSB                               31
+#define DDR_CONFIG_CAS_LATENCY_MSB_LSB                               31
+#define DDR_CONFIG_CAS_LATENCY_MSB_MASK                              0x80000000
+#define DDR_CONFIG_CAS_LATENCY_MSB_GET(x)                            (((x) & DDR_CONFIG_CAS_LATENCY_MSB_MASK) >> DDR_CONFIG_CAS_LATENCY_MSB_LSB)
+#define DDR_CONFIG_CAS_LATENCY_MSB_SET(x)                            (((x) << DDR_CONFIG_CAS_LATENCY_MSB_LSB) & DDR_CONFIG_CAS_LATENCY_MSB_MASK)
+#define DDR_CONFIG_CAS_LATENCY_MSB_RESET                             0x0 // 0
+#define DDR_CONFIG_OPEN_PAGE_MSB                                     30
+#define DDR_CONFIG_OPEN_PAGE_LSB                                     30
+#define DDR_CONFIG_OPEN_PAGE_MASK                                    0x40000000
+#define DDR_CONFIG_OPEN_PAGE_GET(x)                                  (((x) & DDR_CONFIG_OPEN_PAGE_MASK) >> DDR_CONFIG_OPEN_PAGE_LSB)
+#define DDR_CONFIG_OPEN_PAGE_SET(x)                                  (((x) << DDR_CONFIG_OPEN_PAGE_LSB) & DDR_CONFIG_OPEN_PAGE_MASK)
+#define DDR_CONFIG_OPEN_PAGE_RESET                                   0x1 // 1
+#define DDR_CONFIG_CAS_LATENCY_MSB                                   29
+#define DDR_CONFIG_CAS_LATENCY_LSB                                   27
+#define DDR_CONFIG_CAS_LATENCY_MASK                                  0x38000000
+#define DDR_CONFIG_CAS_LATENCY_GET(x)                                (((x) & DDR_CONFIG_CAS_LATENCY_MASK) >> DDR_CONFIG_CAS_LATENCY_LSB)
+#define DDR_CONFIG_CAS_LATENCY_SET(x)                                (((x) << DDR_CONFIG_CAS_LATENCY_LSB) & DDR_CONFIG_CAS_LATENCY_MASK)
+#define DDR_CONFIG_CAS_LATENCY_RESET                                 0x6 // 6
+#define DDR_CONFIG_TMRD_MSB                                          26
+#define DDR_CONFIG_TMRD_LSB                                          23
+#define DDR_CONFIG_TMRD_MASK                                         0x07800000
+#define DDR_CONFIG_TMRD_GET(x)                                       (((x) & DDR_CONFIG_TMRD_MASK) >> DDR_CONFIG_TMRD_LSB)
+#define DDR_CONFIG_TMRD_SET(x)                                       (((x) << DDR_CONFIG_TMRD_LSB) & DDR_CONFIG_TMRD_MASK)
+#define DDR_CONFIG_TMRD_RESET                                        0xf // 15
+#define DDR_CONFIG_TRFC_MSB                                          22
+#define DDR_CONFIG_TRFC_LSB                                          17
+#define DDR_CONFIG_TRFC_MASK                                         0x007e0000
+#define DDR_CONFIG_TRFC_GET(x)                                       (((x) & DDR_CONFIG_TRFC_MASK) >> DDR_CONFIG_TRFC_LSB)
+#define DDR_CONFIG_TRFC_SET(x)                                       (((x) << DDR_CONFIG_TRFC_LSB) & DDR_CONFIG_TRFC_MASK)
+#define DDR_CONFIG_TRFC_RESET                                        0x24 // 36
+#define DDR_CONFIG_TRRD_MSB                                          16
+#define DDR_CONFIG_TRRD_LSB                                          13
+#define DDR_CONFIG_TRRD_MASK                                         0x0001e000
+#define DDR_CONFIG_TRRD_GET(x)                                       (((x) & DDR_CONFIG_TRRD_MASK) >> DDR_CONFIG_TRRD_LSB)
+#define DDR_CONFIG_TRRD_SET(x)                                       (((x) << DDR_CONFIG_TRRD_LSB) & DDR_CONFIG_TRRD_MASK)
+#define DDR_CONFIG_TRRD_RESET                                        0x4 // 4
+#define DDR_CONFIG_TRP_MSB                                           12
+#define DDR_CONFIG_TRP_LSB                                           9
+#define DDR_CONFIG_TRP_MASK                                          0x00001e00
+#define DDR_CONFIG_TRP_GET(x)                                        (((x) & DDR_CONFIG_TRP_MASK) >> DDR_CONFIG_TRP_LSB)
+#define DDR_CONFIG_TRP_SET(x)                                        (((x) << DDR_CONFIG_TRP_LSB) & DDR_CONFIG_TRP_MASK)
+#define DDR_CONFIG_TRP_RESET                                         0x6 // 6
+#define DDR_CONFIG_TRCD_MSB                                          8
+#define DDR_CONFIG_TRCD_LSB                                          5
+#define DDR_CONFIG_TRCD_MASK                                         0x000001e0
+#define DDR_CONFIG_TRCD_GET(x)                                       (((x) & DDR_CONFIG_TRCD_MASK) >> DDR_CONFIG_TRCD_LSB)
+#define DDR_CONFIG_TRCD_SET(x)                                       (((x) << DDR_CONFIG_TRCD_LSB) & DDR_CONFIG_TRCD_MASK)
+#define DDR_CONFIG_TRCD_RESET                                        0x6 // 6
+#define DDR_CONFIG_TRAS_MSB                                          4
+#define DDR_CONFIG_TRAS_LSB                                          0
+#define DDR_CONFIG_TRAS_MASK                                         0x0000001f
+#define DDR_CONFIG_TRAS_GET(x)                                       (((x) & DDR_CONFIG_TRAS_MASK) >> DDR_CONFIG_TRAS_LSB)
+#define DDR_CONFIG_TRAS_SET(x)                                       (((x) << DDR_CONFIG_TRAS_LSB) & DDR_CONFIG_TRAS_MASK)
+#define DDR_CONFIG_TRAS_RESET                                        0x10 // 16
+#define DDR_CONFIG_ADDRESS                                           0x18000000
+
+#define DDR_CONFIG2_HALF_WIDTH_LOW_MSB                               31
+#define DDR_CONFIG2_HALF_WIDTH_LOW_LSB                               31
+#define DDR_CONFIG2_HALF_WIDTH_LOW_MASK                              0x80000000
+#define DDR_CONFIG2_HALF_WIDTH_LOW_GET(x)                            (((x) & DDR_CONFIG2_HALF_WIDTH_LOW_MASK) >> DDR_CONFIG2_HALF_WIDTH_LOW_LSB)
+#define DDR_CONFIG2_HALF_WIDTH_LOW_SET(x)                            (((x) << DDR_CONFIG2_HALF_WIDTH_LOW_LSB) & DDR_CONFIG2_HALF_WIDTH_LOW_MASK)
+#define DDR_CONFIG2_HALF_WIDTH_LOW_RESET                             0x1 // 1
+#define DDR_CONFIG2_SWAP_A26_A27_MSB                                 30
+#define DDR_CONFIG2_SWAP_A26_A27_LSB                                 30
+#define DDR_CONFIG2_SWAP_A26_A27_MASK                                0x40000000
+#define DDR_CONFIG2_SWAP_A26_A27_GET(x)                              (((x) & DDR_CONFIG2_SWAP_A26_A27_MASK) >> DDR_CONFIG2_SWAP_A26_A27_LSB)
+#define DDR_CONFIG2_SWAP_A26_A27_SET(x)                              (((x) << DDR_CONFIG2_SWAP_A26_A27_LSB) & DDR_CONFIG2_SWAP_A26_A27_MASK)
+#define DDR_CONFIG2_SWAP_A26_A27_RESET                               0x0 // 0
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_MSB                            29
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_LSB                            26
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_MASK                           0x3c000000
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_GET(x)                         (((x) & DDR_CONFIG2_GATE_OPEN_LATENCY_MASK) >> DDR_CONFIG2_GATE_OPEN_LATENCY_LSB)
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_SET(x)                         (((x) << DDR_CONFIG2_GATE_OPEN_LATENCY_LSB) & DDR_CONFIG2_GATE_OPEN_LATENCY_MASK)
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_RESET                          0x6 // 6
+#define DDR_CONFIG2_TWTR_MSB                                         25
+#define DDR_CONFIG2_TWTR_LSB                                         21
+#define DDR_CONFIG2_TWTR_MASK                                        0x03e00000
+#define DDR_CONFIG2_TWTR_GET(x)                                      (((x) & DDR_CONFIG2_TWTR_MASK) >> DDR_CONFIG2_TWTR_LSB)
+#define DDR_CONFIG2_TWTR_SET(x)                                      (((x) << DDR_CONFIG2_TWTR_LSB) & DDR_CONFIG2_TWTR_MASK)
+#define DDR_CONFIG2_TWTR_RESET                                       0xe // 14
+#define DDR_CONFIG2_TRTP_MSB                                         20
+#define DDR_CONFIG2_TRTP_LSB                                         17
+#define DDR_CONFIG2_TRTP_MASK                                        0x001e0000
+#define DDR_CONFIG2_TRTP_GET(x)                                      (((x) & DDR_CONFIG2_TRTP_MASK) >> DDR_CONFIG2_TRTP_LSB)
+#define DDR_CONFIG2_TRTP_SET(x)                                      (((x) << DDR_CONFIG2_TRTP_LSB) & DDR_CONFIG2_TRTP_MASK)
+#define DDR_CONFIG2_TRTP_RESET                                       0x8 // 8
+#define DDR_CONFIG2_TRTW_MSB                                         16
+#define DDR_CONFIG2_TRTW_LSB                                         12
+#define DDR_CONFIG2_TRTW_MASK                                        0x0001f000
+#define DDR_CONFIG2_TRTW_GET(x)                                      (((x) & DDR_CONFIG2_TRTW_MASK) >> DDR_CONFIG2_TRTW_LSB)
+#define DDR_CONFIG2_TRTW_SET(x)                                      (((x) << DDR_CONFIG2_TRTW_LSB) & DDR_CONFIG2_TRTW_MASK)
+#define DDR_CONFIG2_TRTW_RESET                                       0x10 // 16
+#define DDR_CONFIG2_TWR_MSB                                          11
+#define DDR_CONFIG2_TWR_LSB                                          8
+#define DDR_CONFIG2_TWR_MASK                                         0x00000f00
+#define DDR_CONFIG2_TWR_GET(x)                                       (((x) & DDR_CONFIG2_TWR_MASK) >> DDR_CONFIG2_TWR_LSB)
+#define DDR_CONFIG2_TWR_SET(x)                                       (((x) << DDR_CONFIG2_TWR_LSB) & DDR_CONFIG2_TWR_MASK)
+#define DDR_CONFIG2_TWR_RESET                                        0x6 // 6
+#define DDR_CONFIG2_CKE_MSB                                          7
+#define DDR_CONFIG2_CKE_LSB                                          7
+#define DDR_CONFIG2_CKE_MASK                                         0x00000080
+#define DDR_CONFIG2_CKE_GET(x)                                       (((x) & DDR_CONFIG2_CKE_MASK) >> DDR_CONFIG2_CKE_LSB)
+#define DDR_CONFIG2_CKE_SET(x)                                       (((x) << DDR_CONFIG2_CKE_LSB) & DDR_CONFIG2_CKE_MASK)
+#define DDR_CONFIG2_CKE_RESET                                        0x0 // 0
+#define DDR_CONFIG2_PHASE_SELECT_MSB                                 6
+#define DDR_CONFIG2_PHASE_SELECT_LSB                                 6
+#define DDR_CONFIG2_PHASE_SELECT_MASK                                0x00000040
+#define DDR_CONFIG2_PHASE_SELECT_GET(x)                              (((x) & DDR_CONFIG2_PHASE_SELECT_MASK) >> DDR_CONFIG2_PHASE_SELECT_LSB)
+#define DDR_CONFIG2_PHASE_SELECT_SET(x)                              (((x) << DDR_CONFIG2_PHASE_SELECT_LSB) & DDR_CONFIG2_PHASE_SELECT_MASK)
+#define DDR_CONFIG2_PHASE_SELECT_RESET                               0x0 // 0
+#define DDR_CONFIG2_CNTL_OE_EN_MSB                                   5
+#define DDR_CONFIG2_CNTL_OE_EN_LSB                                   5
+#define DDR_CONFIG2_CNTL_OE_EN_MASK                                  0x00000020
+#define DDR_CONFIG2_CNTL_OE_EN_GET(x)                                (((x) & DDR_CONFIG2_CNTL_OE_EN_MASK) >> DDR_CONFIG2_CNTL_OE_EN_LSB)
+#define DDR_CONFIG2_CNTL_OE_EN_SET(x)                                (((x) << DDR_CONFIG2_CNTL_OE_EN_LSB) & DDR_CONFIG2_CNTL_OE_EN_MASK)
+#define DDR_CONFIG2_CNTL_OE_EN_RESET                                 0x1 // 1
+#define DDR_CONFIG2_BURST_TYPE_MSB                                   4
+#define DDR_CONFIG2_BURST_TYPE_LSB                                   4
+#define DDR_CONFIG2_BURST_TYPE_MASK                                  0x00000010
+#define DDR_CONFIG2_BURST_TYPE_GET(x)                                (((x) & DDR_CONFIG2_BURST_TYPE_MASK) >> DDR_CONFIG2_BURST_TYPE_LSB)
+#define DDR_CONFIG2_BURST_TYPE_SET(x)                                (((x) << DDR_CONFIG2_BURST_TYPE_LSB) & DDR_CONFIG2_BURST_TYPE_MASK)
+#define DDR_CONFIG2_BURST_TYPE_RESET                                 0x0 // 0
+#define DDR_CONFIG2_BURST_LENGTH_MSB                                 3
+#define DDR_CONFIG2_BURST_LENGTH_LSB                                 0
+#define DDR_CONFIG2_BURST_LENGTH_MASK                                0x0000000f
+#define DDR_CONFIG2_BURST_LENGTH_GET(x)                              (((x) & DDR_CONFIG2_BURST_LENGTH_MASK) >> DDR_CONFIG2_BURST_LENGTH_LSB)
+#define DDR_CONFIG2_BURST_LENGTH_SET(x)                              (((x) << DDR_CONFIG2_BURST_LENGTH_LSB) & DDR_CONFIG2_BURST_LENGTH_MASK)
+#define DDR_CONFIG2_BURST_LENGTH_RESET                               0x8 // 8
+#define DDR_CONFIG2_ADDRESS                                          0x18000004
+
+#define DDR_CONFIG_3_SPARE_MSB                                       31
+#define DDR_CONFIG_3_SPARE_LSB                                       4
+#define DDR_CONFIG_3_SPARE_MASK                                      0xfffffff0
+#define DDR_CONFIG_3_SPARE_GET(x)                                    (((x) & DDR_CONFIG_3_SPARE_MASK) >> DDR_CONFIG_3_SPARE_LSB)
+#define DDR_CONFIG_3_SPARE_SET(x)                                    (((x) << DDR_CONFIG_3_SPARE_LSB) & DDR_CONFIG_3_SPARE_MASK)
+#define DDR_CONFIG_3_SPARE_RESET                                     0x0 // 0
+#define DDR_CONFIG_3_TWR_MSB_MSB                                     3
+#define DDR_CONFIG_3_TWR_MSB_LSB                                     3
+#define DDR_CONFIG_3_TWR_MSB_MASK                                    0x00000008
+#define DDR_CONFIG_3_TWR_MSB_GET(x)                                  (((x) & DDR_CONFIG_3_TWR_MSB_MASK) >> DDR_CONFIG_3_TWR_MSB_LSB)
+#define DDR_CONFIG_3_TWR_MSB_SET(x)                                  (((x) << DDR_CONFIG_3_TWR_MSB_LSB) & DDR_CONFIG_3_TWR_MSB_MASK)
+#define DDR_CONFIG_3_TWR_MSB_RESET                                   0x0 // 0
+#define DDR_CONFIG_3_TRAS_MSB_MSB                                    2
+#define DDR_CONFIG_3_TRAS_MSB_LSB                                    2
+#define DDR_CONFIG_3_TRAS_MSB_MASK                                   0x00000004
+#define DDR_CONFIG_3_TRAS_MSB_GET(x)                                 (((x) & DDR_CONFIG_3_TRAS_MSB_MASK) >> DDR_CONFIG_3_TRAS_MSB_LSB)
+#define DDR_CONFIG_3_TRAS_MSB_SET(x)                                 (((x) << DDR_CONFIG_3_TRAS_MSB_LSB) & DDR_CONFIG_3_TRAS_MSB_MASK)
+#define DDR_CONFIG_3_TRAS_MSB_RESET                                  0x0 // 0
+#define DDR_CONFIG_3_TRFC_LSB_MSB                                    1
+#define DDR_CONFIG_3_TRFC_LSB_LSB                                    0
+#define DDR_CONFIG_3_TRFC_LSB_MASK                                   0x00000003
+#define DDR_CONFIG_3_TRFC_LSB_GET(x)                                 (((x) & DDR_CONFIG_3_TRFC_LSB_MASK) >> DDR_CONFIG_3_TRFC_LSB_LSB)
+#define DDR_CONFIG_3_TRFC_LSB_SET(x)                                 (((x) << DDR_CONFIG_3_TRFC_LSB_LSB) & DDR_CONFIG_3_TRFC_LSB_MASK)
+#define DDR_CONFIG_3_TRFC_LSB_RESET                                  0x0 // 0
+#define DDR_CONFIG_3_ADDRESS                                         0x1800015c
+
+#define DDR_MODE_REGISTER_VALUE_MSB                                  13
+#define DDR_MODE_REGISTER_VALUE_LSB                                  0
+#define DDR_MODE_REGISTER_VALUE_MASK                                 0x00003fff
+#define DDR_MODE_REGISTER_VALUE_GET(x)                               (((x) & DDR_MODE_REGISTER_VALUE_MASK) >> DDR_MODE_REGISTER_VALUE_LSB)
+#define DDR_MODE_REGISTER_VALUE_SET(x)                               (((x) << DDR_MODE_REGISTER_VALUE_LSB) & DDR_MODE_REGISTER_VALUE_MASK)
+#define DDR_MODE_REGISTER_VALUE_RESET                                0x133 // 307
+#define DDR_MODE_REGISTER_ADDRESS                                    0x18000008
+
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_MSB                         13
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_LSB                         0
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_MASK                        0x00003fff
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_GET(x)                      (((x) & DDR_EXTENDED_MODE_REGISTER_VALUE_MASK) >> DDR_EXTENDED_MODE_REGISTER_VALUE_LSB)
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_SET(x)                      (((x) << DDR_EXTENDED_MODE_REGISTER_VALUE_LSB) & DDR_EXTENDED_MODE_REGISTER_VALUE_MASK)
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_RESET                       0x2 // 2
+#define DDR_EXTENDED_MODE_REGISTER_ADDRESS                           0x1800000c
+
+#define DDR_REFRESH_ENABLE_MSB                                       14
+#define DDR_REFRESH_ENABLE_LSB                                       14
+#define DDR_REFRESH_ENABLE_MASK                                      0x00004000
+#define DDR_REFRESH_ENABLE_GET(x)                                    (((x) & DDR_REFRESH_ENABLE_MASK) >> DDR_REFRESH_ENABLE_LSB)
+#define DDR_REFRESH_ENABLE_SET(x)                                    (((x) << DDR_REFRESH_ENABLE_LSB) & DDR_REFRESH_ENABLE_MASK)
+#define DDR_REFRESH_ENABLE_RESET                                     0x0 // 0
+#define DDR_REFRESH_PERIOD_MSB                                       13
+#define DDR_REFRESH_PERIOD_LSB                                       0
+#define DDR_REFRESH_PERIOD_MASK                                      0x00003fff
+#define DDR_REFRESH_PERIOD_GET(x)                                    (((x) & DDR_REFRESH_PERIOD_MASK) >> DDR_REFRESH_PERIOD_LSB)
+#define DDR_REFRESH_PERIOD_SET(x)                                    (((x) << DDR_REFRESH_PERIOD_LSB) & DDR_REFRESH_PERIOD_MASK)
+#define DDR_REFRESH_PERIOD_RESET                                     0x12c // 300
+#define DDR_REFRESH_ADDRESS                                          0x18000014
+
+#define BB_DPLL2_LOCAL_PLL_MSB                                       31
+#define BB_DPLL2_LOCAL_PLL_LSB                                       31
+#define BB_DPLL2_LOCAL_PLL_MASK                                      0x80000000
+#define BB_DPLL2_LOCAL_PLL_GET(x)                                    (((x) & BB_DPLL2_LOCAL_PLL_MASK) >> BB_DPLL2_LOCAL_PLL_LSB)
+#define BB_DPLL2_LOCAL_PLL_SET(x)                                    (((x) << BB_DPLL2_LOCAL_PLL_LSB) & BB_DPLL2_LOCAL_PLL_MASK)
+#define BB_DPLL2_LOCAL_PLL_RESET                                     0x0 // 0
+#define BB_DPLL2_KI_MSB                                              30
+#define BB_DPLL2_KI_LSB                                              29
+#define BB_DPLL2_KI_MASK                                             0x60000000
+#define BB_DPLL2_KI_GET(x)                                           (((x) & BB_DPLL2_KI_MASK) >> BB_DPLL2_KI_LSB)
+#define BB_DPLL2_KI_SET(x)                                           (((x) << BB_DPLL2_KI_LSB) & BB_DPLL2_KI_MASK)
+#define BB_DPLL2_KI_RESET                                            0x2 // 2
+#define BB_DPLL2_KD_MSB                                              28
+#define BB_DPLL2_KD_LSB                                              25
+#define BB_DPLL2_KD_MASK                                             0x1e000000
+#define BB_DPLL2_KD_GET(x)                                           (((x) & BB_DPLL2_KD_MASK) >> BB_DPLL2_KD_LSB)
+#define BB_DPLL2_KD_SET(x)                                           (((x) << BB_DPLL2_KD_LSB) & BB_DPLL2_KD_MASK)
+#define BB_DPLL2_KD_RESET                                            0xa // 10
+#define BB_DPLL2_EN_NEGTRIG_MSB                                      24
+#define BB_DPLL2_EN_NEGTRIG_LSB                                      24
+#define BB_DPLL2_EN_NEGTRIG_MASK                                     0x01000000
+#define BB_DPLL2_EN_NEGTRIG_GET(x)                                   (((x) & BB_DPLL2_EN_NEGTRIG_MASK) >> BB_DPLL2_EN_NEGTRIG_LSB)
+#define BB_DPLL2_EN_NEGTRIG_SET(x)                                   (((x) << BB_DPLL2_EN_NEGTRIG_LSB) & BB_DPLL2_EN_NEGTRIG_MASK)
+#define BB_DPLL2_EN_NEGTRIG_RESET                                    0x0 // 0
+#define BB_DPLL2_SEL_1SDM_MSB                                        23
+#define BB_DPLL2_SEL_1SDM_LSB                                        23
+#define BB_DPLL2_SEL_1SDM_MASK                                       0x00800000
+#define BB_DPLL2_SEL_1SDM_GET(x)                                     (((x) & BB_DPLL2_SEL_1SDM_MASK) >> BB_DPLL2_SEL_1SDM_LSB)
+#define BB_DPLL2_SEL_1SDM_SET(x)                                     (((x) << BB_DPLL2_SEL_1SDM_LSB) & BB_DPLL2_SEL_1SDM_MASK)
+#define BB_DPLL2_SEL_1SDM_RESET                                      0x0 // 0
+#define BB_DPLL2_PLL_PWD_MSB                                         22
+#define BB_DPLL2_PLL_PWD_LSB                                         22
+#define BB_DPLL2_PLL_PWD_MASK                                        0x00400000
+#define BB_DPLL2_PLL_PWD_GET(x)                                      (((x) & BB_DPLL2_PLL_PWD_MASK) >> BB_DPLL2_PLL_PWD_LSB)
+#define BB_DPLL2_PLL_PWD_SET(x)                                      (((x) << BB_DPLL2_PLL_PWD_LSB) & BB_DPLL2_PLL_PWD_MASK)
+#define BB_DPLL2_PLL_PWD_RESET                                       0x1 // 1
+#define BB_DPLL2_OUTDIV_MSB                                          21
+#define BB_DPLL2_OUTDIV_LSB                                          19
+#define BB_DPLL2_OUTDIV_MASK                                         0x00380000
+#define BB_DPLL2_OUTDIV_GET(x)                                       (((x) & BB_DPLL2_OUTDIV_MASK) >> BB_DPLL2_OUTDIV_LSB)
+#define BB_DPLL2_OUTDIV_SET(x)                                       (((x) << BB_DPLL2_OUTDIV_LSB) & BB_DPLL2_OUTDIV_MASK)
+#define BB_DPLL2_OUTDIV_RESET                                        0x1 // 1
+#define BB_DPLL2_PHASE_SHIFT_MSB                                     18
+#define BB_DPLL2_PHASE_SHIFT_LSB                                     12
+#define BB_DPLL2_PHASE_SHIFT_MASK                                    0x0007f000
+#define BB_DPLL2_PHASE_SHIFT_GET(x)                                  (((x) & BB_DPLL2_PHASE_SHIFT_MASK) >> BB_DPLL2_PHASE_SHIFT_LSB)
+#define BB_DPLL2_PHASE_SHIFT_SET(x)                                  (((x) << BB_DPLL2_PHASE_SHIFT_LSB) & BB_DPLL2_PHASE_SHIFT_MASK)
+#define BB_DPLL2_PHASE_SHIFT_RESET                                   0x0 // 0
+#define BB_DPLL2_TESTIN_MSB                                          11
+#define BB_DPLL2_TESTIN_LSB                                          2
+#define BB_DPLL2_TESTIN_MASK                                         0x00000ffc
+#define BB_DPLL2_TESTIN_GET(x)                                       (((x) & BB_DPLL2_TESTIN_MASK) >> BB_DPLL2_TESTIN_LSB)
+#define BB_DPLL2_TESTIN_SET(x)                                       (((x) << BB_DPLL2_TESTIN_LSB) & BB_DPLL2_TESTIN_MASK)
+#define BB_DPLL2_TESTIN_RESET                                        0x0 // 0
+#define BB_DPLL2_SEL_COUNT_MSB                                       1
+#define BB_DPLL2_SEL_COUNT_LSB                                       1
+#define BB_DPLL2_SEL_COUNT_MASK                                      0x00000002
+#define BB_DPLL2_SEL_COUNT_GET(x)                                    (((x) & BB_DPLL2_SEL_COUNT_MASK) >> BB_DPLL2_SEL_COUNT_LSB)
+#define BB_DPLL2_SEL_COUNT_SET(x)                                    (((x) << BB_DPLL2_SEL_COUNT_LSB) & BB_DPLL2_SEL_COUNT_MASK)
+#define BB_DPLL2_SEL_COUNT_RESET                                     0x0 // 0
+#define BB_DPLL2_RESET_TEST_MSB                                      0
+#define BB_DPLL2_RESET_TEST_LSB                                      0
+#define BB_DPLL2_RESET_TEST_MASK                                     0x00000001
+#define BB_DPLL2_RESET_TEST_GET(x)                                   (((x) & BB_DPLL2_RESET_TEST_MASK) >> BB_DPLL2_RESET_TEST_LSB)
+#define BB_DPLL2_RESET_TEST_SET(x)                                   (((x) << BB_DPLL2_RESET_TEST_LSB) & BB_DPLL2_RESET_TEST_MASK)
+#define BB_DPLL2_RESET_TEST_RESET                                    0x0 // 0
+#define BB_DPLL2_ADDRESS                                             0x18116184
+
+#define PCIe_DPLL2_LOCAL_PLL_MSB                                     31
+#define PCIe_DPLL2_LOCAL_PLL_LSB                                     31
+#define PCIe_DPLL2_LOCAL_PLL_MASK                                    0x80000000
+#define PCIe_DPLL2_LOCAL_PLL_GET(x)                                  (((x) & PCIe_DPLL2_LOCAL_PLL_MASK) >> PCIe_DPLL2_LOCAL_PLL_LSB)
+#define PCIe_DPLL2_LOCAL_PLL_SET(x)                                  (((x) << PCIe_DPLL2_LOCAL_PLL_LSB) & PCIe_DPLL2_LOCAL_PLL_MASK)
+#define PCIe_DPLL2_LOCAL_PLL_RESET                                   0x0 // 0
+#define PCIe_DPLL2_KI_MSB                                            30
+#define PCIe_DPLL2_KI_LSB                                            29
+#define PCIe_DPLL2_KI_MASK                                           0x60000000
+#define PCIe_DPLL2_KI_GET(x)                                         (((x) & PCIe_DPLL2_KI_MASK) >> PCIe_DPLL2_KI_LSB)
+#define PCIe_DPLL2_KI_SET(x)                                         (((x) << PCIe_DPLL2_KI_LSB) & PCIe_DPLL2_KI_MASK)
+#define PCIe_DPLL2_KI_RESET                                          0x2 // 2
+#define PCIe_DPLL2_KD_MSB                                            28
+#define PCIe_DPLL2_KD_LSB                                            25
+#define PCIe_DPLL2_KD_MASK                                           0x1e000000
+#define PCIe_DPLL2_KD_GET(x)                                         (((x) & PCIe_DPLL2_KD_MASK) >> PCIe_DPLL2_KD_LSB)
+#define PCIe_DPLL2_KD_SET(x)                                         (((x) << PCIe_DPLL2_KD_LSB) & PCIe_DPLL2_KD_MASK)
+#define PCIe_DPLL2_KD_RESET                                          0xa // 10
+#define PCIe_DPLL2_EN_NEGTRIG_MSB                                    24
+#define PCIe_DPLL2_EN_NEGTRIG_LSB                                    24
+#define PCIe_DPLL2_EN_NEGTRIG_MASK                                   0x01000000
+#define PCIe_DPLL2_EN_NEGTRIG_GET(x)                                 (((x) & PCIe_DPLL2_EN_NEGTRIG_MASK) >> PCIe_DPLL2_EN_NEGTRIG_LSB)
+#define PCIe_DPLL2_EN_NEGTRIG_SET(x)                                 (((x) << PCIe_DPLL2_EN_NEGTRIG_LSB) & PCIe_DPLL2_EN_NEGTRIG_MASK)
+#define PCIe_DPLL2_EN_NEGTRIG_RESET                                  0x0 // 0
+#define PCIe_DPLL2_SEL_1SDM_MSB                                      23
+#define PCIe_DPLL2_SEL_1SDM_LSB                                      23
+#define PCIe_DPLL2_SEL_1SDM_MASK                                     0x00800000
+#define PCIe_DPLL2_SEL_1SDM_GET(x)                                   (((x) & PCIe_DPLL2_SEL_1SDM_MASK) >> PCIe_DPLL2_SEL_1SDM_LSB)
+#define PCIe_DPLL2_SEL_1SDM_SET(x)                                   (((x) << PCIe_DPLL2_SEL_1SDM_LSB) & PCIe_DPLL2_SEL_1SDM_MASK)
+#define PCIe_DPLL2_SEL_1SDM_RESET                                    0x0 // 0
+#define PCIe_DPLL2_PLL_PWD_MSB                                       22
+#define PCIe_DPLL2_PLL_PWD_LSB                                       22
+#define PCIe_DPLL2_PLL_PWD_MASK                                      0x00400000
+#define PCIe_DPLL2_PLL_PWD_GET(x)                                    (((x) & PCIe_DPLL2_PLL_PWD_MASK) >> PCIe_DPLL2_PLL_PWD_LSB)
+#define PCIe_DPLL2_PLL_PWD_SET(x)                                    (((x) << PCIe_DPLL2_PLL_PWD_LSB) & PCIe_DPLL2_PLL_PWD_MASK)
+#define PCIe_DPLL2_PLL_PWD_RESET                                     0x1 // 1
+#define PCIe_DPLL2_OUTDIV_MSB                                        21
+#define PCIe_DPLL2_OUTDIV_LSB                                        19
+#define PCIe_DPLL2_OUTDIV_MASK                                       0x00380000
+#define PCIe_DPLL2_OUTDIV_GET(x)                                     (((x) & PCIe_DPLL2_OUTDIV_MASK) >> PCIe_DPLL2_OUTDIV_LSB)
+#define PCIe_DPLL2_OUTDIV_SET(x)                                     (((x) << PCIe_DPLL2_OUTDIV_LSB) & PCIe_DPLL2_OUTDIV_MASK)
+#define PCIe_DPLL2_OUTDIV_RESET                                      0x1 // 1
+#define PCIe_DPLL2_PHASE_SHIFT_MSB                                   18
+#define PCIe_DPLL2_PHASE_SHIFT_LSB                                   12
+#define PCIe_DPLL2_PHASE_SHIFT_MASK                                  0x0007f000
+#define PCIe_DPLL2_PHASE_SHIFT_GET(x)                                (((x) & PCIe_DPLL2_PHASE_SHIFT_MASK) >> PCIe_DPLL2_PHASE_SHIFT_LSB)
+#define PCIe_DPLL2_PHASE_SHIFT_SET(x)                                (((x) << PCIe_DPLL2_PHASE_SHIFT_LSB) & PCIe_DPLL2_PHASE_SHIFT_MASK)
+#define PCIe_DPLL2_PHASE_SHIFT_RESET                                 0x0 // 0
+#define PCIe_DPLL2_TESTIN_MSB                                        11
+#define PCIe_DPLL2_TESTIN_LSB                                        2
+#define PCIe_DPLL2_TESTIN_MASK                                       0x00000ffc
+#define PCIe_DPLL2_TESTIN_GET(x)                                     (((x) & PCIe_DPLL2_TESTIN_MASK) >> PCIe_DPLL2_TESTIN_LSB)
+#define PCIe_DPLL2_TESTIN_SET(x)                                     (((x) << PCIe_DPLL2_TESTIN_LSB) & PCIe_DPLL2_TESTIN_MASK)
+#define PCIe_DPLL2_TESTIN_RESET                                      0x0 // 0
+#define PCIe_DPLL2_SEL_COUNT_MSB                                     1
+#define PCIe_DPLL2_SEL_COUNT_LSB                                     1
+#define PCIe_DPLL2_SEL_COUNT_MASK                                    0x00000002
+#define PCIe_DPLL2_SEL_COUNT_GET(x)                                  (((x) & PCIe_DPLL2_SEL_COUNT_MASK) >> PCIe_DPLL2_SEL_COUNT_LSB)
+#define PCIe_DPLL2_SEL_COUNT_SET(x)                                  (((x) << PCIe_DPLL2_SEL_COUNT_LSB) & PCIe_DPLL2_SEL_COUNT_MASK)
+#define PCIe_DPLL2_SEL_COUNT_RESET                                   0x0 // 0
+#define PCIe_DPLL2_RESET_TEST_MSB                                    0
+#define PCIe_DPLL2_RESET_TEST_LSB                                    0
+#define PCIe_DPLL2_RESET_TEST_MASK                                   0x00000001
+#define PCIe_DPLL2_RESET_TEST_GET(x)                                 (((x) & PCIe_DPLL2_RESET_TEST_MASK) >> PCIe_DPLL2_RESET_TEST_LSB)
+#define PCIe_DPLL2_RESET_TEST_SET(x)                                 (((x) << PCIe_DPLL2_RESET_TEST_LSB) & PCIe_DPLL2_RESET_TEST_MASK)
+#define PCIe_DPLL2_RESET_TEST_RESET                                  0x0 // 0
+#define PCIe_DPLL2_ADDRESS                                           0x18116c04
+
+#define DDR_DPLL2_LOCAL_PLL_MSB                                      31
+#define DDR_DPLL2_LOCAL_PLL_LSB                                      31
+#define DDR_DPLL2_LOCAL_PLL_MASK                                     0x80000000
+#define DDR_DPLL2_LOCAL_PLL_GET(x)                                   (((x) & DDR_DPLL2_LOCAL_PLL_MASK) >> DDR_DPLL2_LOCAL_PLL_LSB)
+#define DDR_DPLL2_LOCAL_PLL_SET(x)                                   (((x) << DDR_DPLL2_LOCAL_PLL_LSB) & DDR_DPLL2_LOCAL_PLL_MASK)
+#define DDR_DPLL2_LOCAL_PLL_RESET                                    0x0 // 0
+#define DDR_DPLL2_KI_MSB                                             30
+#define DDR_DPLL2_KI_LSB                                             29
+#define DDR_DPLL2_KI_MASK                                            0x60000000
+#define DDR_DPLL2_KI_GET(x)                                          (((x) & DDR_DPLL2_KI_MASK) >> DDR_DPLL2_KI_LSB)
+#define DDR_DPLL2_KI_SET(x)                                          (((x) << DDR_DPLL2_KI_LSB) & DDR_DPLL2_KI_MASK)
+#define DDR_DPLL2_KI_RESET                                           0x2 // 2
+#define DDR_DPLL2_KD_MSB                                             28
+#define DDR_DPLL2_KD_LSB                                             25
+#define DDR_DPLL2_KD_MASK                                            0x1e000000
+#define DDR_DPLL2_KD_GET(x)                                          (((x) & DDR_DPLL2_KD_MASK) >> DDR_DPLL2_KD_LSB)
+#define DDR_DPLL2_KD_SET(x)                                          (((x) << DDR_DPLL2_KD_LSB) & DDR_DPLL2_KD_MASK)
+#define DDR_DPLL2_KD_RESET                                           0xa // 10
+#define DDR_DPLL2_EN_NEGTRIG_MSB                                     24
+#define DDR_DPLL2_EN_NEGTRIG_LSB                                     24
+#define DDR_DPLL2_EN_NEGTRIG_MASK                                    0x01000000
+#define DDR_DPLL2_EN_NEGTRIG_GET(x)                                  (((x) & DDR_DPLL2_EN_NEGTRIG_MASK) >> DDR_DPLL2_EN_NEGTRIG_LSB)
+#define DDR_DPLL2_EN_NEGTRIG_SET(x)                                  (((x) << DDR_DPLL2_EN_NEGTRIG_LSB) & DDR_DPLL2_EN_NEGTRIG_MASK)
+#define DDR_DPLL2_EN_NEGTRIG_RESET                                   0x0 // 0
+#define DDR_DPLL2_SEL_1SDM_MSB                                       23
+#define DDR_DPLL2_SEL_1SDM_LSB                                       23
+#define DDR_DPLL2_SEL_1SDM_MASK                                      0x00800000
+#define DDR_DPLL2_SEL_1SDM_GET(x)                                    (((x) & DDR_DPLL2_SEL_1SDM_MASK) >> DDR_DPLL2_SEL_1SDM_LSB)
+#define DDR_DPLL2_SEL_1SDM_SET(x)                                    (((x) << DDR_DPLL2_SEL_1SDM_LSB) & DDR_DPLL2_SEL_1SDM_MASK)
+#define DDR_DPLL2_SEL_1SDM_RESET                                     0x0 // 0
+#define DDR_DPLL2_PLL_PWD_MSB                                        22
+#define DDR_DPLL2_PLL_PWD_LSB                                        22
+#define DDR_DPLL2_PLL_PWD_MASK                                       0x00400000
+#define DDR_DPLL2_PLL_PWD_GET(x)                                     (((x) & DDR_DPLL2_PLL_PWD_MASK) >> DDR_DPLL2_PLL_PWD_LSB)
+#define DDR_DPLL2_PLL_PWD_SET(x)                                     (((x) << DDR_DPLL2_PLL_PWD_LSB) & DDR_DPLL2_PLL_PWD_MASK)
+#define DDR_DPLL2_PLL_PWD_RESET                                      0x1 // 1
+#define DDR_DPLL2_OUTDIV_MSB                                         21
+#define DDR_DPLL2_OUTDIV_LSB                                         19
+#define DDR_DPLL2_OUTDIV_MASK                                        0x00380000
+#define DDR_DPLL2_OUTDIV_GET(x)                                      (((x) & DDR_DPLL2_OUTDIV_MASK) >> DDR_DPLL2_OUTDIV_LSB)
+#define DDR_DPLL2_OUTDIV_SET(x)                                      (((x) << DDR_DPLL2_OUTDIV_LSB) & DDR_DPLL2_OUTDIV_MASK)
+#define DDR_DPLL2_OUTDIV_RESET                                       0x1 // 1
+#define DDR_DPLL2_PHASE_SHIFT_MSB                                    18
+#define DDR_DPLL2_PHASE_SHIFT_LSB                                    12
+#define DDR_DPLL2_PHASE_SHIFT_MASK                                   0x0007f000
+#define DDR_DPLL2_PHASE_SHIFT_GET(x)                                 (((x) & DDR_DPLL2_PHASE_SHIFT_MASK) >> DDR_DPLL2_PHASE_SHIFT_LSB)
+#define DDR_DPLL2_PHASE_SHIFT_SET(x)                                 (((x) << DDR_DPLL2_PHASE_SHIFT_LSB) & DDR_DPLL2_PHASE_SHIFT_MASK)
+#define DDR_DPLL2_PHASE_SHIFT_RESET                                  0x0 // 0
+#define DDR_DPLL2_TESTIN_MSB                                         11
+#define DDR_DPLL2_TESTIN_LSB                                         2
+#define DDR_DPLL2_TESTIN_MASK                                        0x00000ffc
+#define DDR_DPLL2_TESTIN_GET(x)                                      (((x) & DDR_DPLL2_TESTIN_MASK) >> DDR_DPLL2_TESTIN_LSB)
+#define DDR_DPLL2_TESTIN_SET(x)                                      (((x) << DDR_DPLL2_TESTIN_LSB) & DDR_DPLL2_TESTIN_MASK)
+#define DDR_DPLL2_TESTIN_RESET                                       0x0 // 0
+#define DDR_DPLL2_SEL_COUNT_MSB                                      1
+#define DDR_DPLL2_SEL_COUNT_LSB                                      1
+#define DDR_DPLL2_SEL_COUNT_MASK                                     0x00000002
+#define DDR_DPLL2_SEL_COUNT_GET(x)                                   (((x) & DDR_DPLL2_SEL_COUNT_MASK) >> DDR_DPLL2_SEL_COUNT_LSB)
+#define DDR_DPLL2_SEL_COUNT_SET(x)                                   (((x) << DDR_DPLL2_SEL_COUNT_LSB) & DDR_DPLL2_SEL_COUNT_MASK)
+#define DDR_DPLL2_SEL_COUNT_RESET                                    0x0 // 0
+#define DDR_DPLL2_RESET_TEST_MSB                                     0
+#define DDR_DPLL2_RESET_TEST_LSB                                     0
+#define DDR_DPLL2_RESET_TEST_MASK                                    0x00000001
+#define DDR_DPLL2_RESET_TEST_GET(x)                                  (((x) & DDR_DPLL2_RESET_TEST_MASK) >> DDR_DPLL2_RESET_TEST_LSB)
+#define DDR_DPLL2_RESET_TEST_SET(x)                                  (((x) << DDR_DPLL2_RESET_TEST_LSB) & DDR_DPLL2_RESET_TEST_MASK)
+#define DDR_DPLL2_RESET_TEST_RESET                                   0x0 // 0
+#define DDR_DPLL2_ADDRESS                                            0x18116244
+
+#define CPU_DPLL2_LOCAL_PLL_MSB                                      31
+#define CPU_DPLL2_LOCAL_PLL_LSB                                      31
+#define CPU_DPLL2_LOCAL_PLL_MASK                                     0x80000000
+#define CPU_DPLL2_LOCAL_PLL_GET(x)                                   (((x) & CPU_DPLL2_LOCAL_PLL_MASK) >> CPU_DPLL2_LOCAL_PLL_LSB)
+#define CPU_DPLL2_LOCAL_PLL_SET(x)                                   (((x) << CPU_DPLL2_LOCAL_PLL_LSB) & CPU_DPLL2_LOCAL_PLL_MASK)
+#define CPU_DPLL2_LOCAL_PLL_RESET                                    0x0 // 0
+#define CPU_DPLL2_KI_MSB                                             30
+#define CPU_DPLL2_KI_LSB                                             29
+#define CPU_DPLL2_KI_MASK                                            0x60000000
+#define CPU_DPLL2_KI_GET(x)                                          (((x) & CPU_DPLL2_KI_MASK) >> CPU_DPLL2_KI_LSB)
+#define CPU_DPLL2_KI_SET(x)                                          (((x) << CPU_DPLL2_KI_LSB) & CPU_DPLL2_KI_MASK)
+#define CPU_DPLL2_KI_RESET                                           0x2 // 2
+#define CPU_DPLL2_KD_MSB                                             28
+#define CPU_DPLL2_KD_LSB                                             25
+#define CPU_DPLL2_KD_MASK                                            0x1e000000
+#define CPU_DPLL2_KD_GET(x)                                          (((x) & CPU_DPLL2_KD_MASK) >> CPU_DPLL2_KD_LSB)
+#define CPU_DPLL2_KD_SET(x)                                          (((x) << CPU_DPLL2_KD_LSB) & CPU_DPLL2_KD_MASK)
+#define CPU_DPLL2_KD_RESET                                           0xa // 10
+#define CPU_DPLL2_EN_NEGTRIG_MSB                                     24
+#define CPU_DPLL2_EN_NEGTRIG_LSB                                     24
+#define CPU_DPLL2_EN_NEGTRIG_MASK                                    0x01000000
+#define CPU_DPLL2_EN_NEGTRIG_GET(x)                                  (((x) & CPU_DPLL2_EN_NEGTRIG_MASK) >> CPU_DPLL2_EN_NEGTRIG_LSB)
+#define CPU_DPLL2_EN_NEGTRIG_SET(x)                                  (((x) << CPU_DPLL2_EN_NEGTRIG_LSB) & CPU_DPLL2_EN_NEGTRIG_MASK)
+#define CPU_DPLL2_EN_NEGTRIG_RESET                                   0x0 // 0
+#define CPU_DPLL2_SEL_1SDM_MSB                                       23
+#define CPU_DPLL2_SEL_1SDM_LSB                                       23
+#define CPU_DPLL2_SEL_1SDM_MASK                                      0x00800000
+#define CPU_DPLL2_SEL_1SDM_GET(x)                                    (((x) & CPU_DPLL2_SEL_1SDM_MASK) >> CPU_DPLL2_SEL_1SDM_LSB)
+#define CPU_DPLL2_SEL_1SDM_SET(x)                                    (((x) << CPU_DPLL2_SEL_1SDM_LSB) & CPU_DPLL2_SEL_1SDM_MASK)
+#define CPU_DPLL2_SEL_1SDM_RESET                                     0x0 // 0
+#define CPU_DPLL2_PLL_PWD_MSB                                        22
+#define CPU_DPLL2_PLL_PWD_LSB                                        22
+#define CPU_DPLL2_PLL_PWD_MASK                                       0x00400000
+#define CPU_DPLL2_PLL_PWD_GET(x)                                     (((x) & CPU_DPLL2_PLL_PWD_MASK) >> CPU_DPLL2_PLL_PWD_LSB)
+#define CPU_DPLL2_PLL_PWD_SET(x)                                     (((x) << CPU_DPLL2_PLL_PWD_LSB) & CPU_DPLL2_PLL_PWD_MASK)
+#define CPU_DPLL2_PLL_PWD_RESET                                      0x1 // 1
+#define CPU_DPLL2_OUTDIV_MSB                                         21
+#define CPU_DPLL2_OUTDIV_LSB                                         19
+#define CPU_DPLL2_OUTDIV_MASK                                        0x00380000
+#define CPU_DPLL2_OUTDIV_GET(x)                                      (((x) & CPU_DPLL2_OUTDIV_MASK) >> CPU_DPLL2_OUTDIV_LSB)
+#define CPU_DPLL2_OUTDIV_SET(x)                                      (((x) << CPU_DPLL2_OUTDIV_LSB) & CPU_DPLL2_OUTDIV_MASK)
+#define CPU_DPLL2_OUTDIV_RESET                                       0x1 // 1
+#define CPU_DPLL2_PHASE_SHIFT_MSB                                    18
+#define CPU_DPLL2_PHASE_SHIFT_LSB                                    12
+#define CPU_DPLL2_PHASE_SHIFT_MASK                                   0x0007f000
+#define CPU_DPLL2_PHASE_SHIFT_GET(x)                                 (((x) & CPU_DPLL2_PHASE_SHIFT_MASK) >> CPU_DPLL2_PHASE_SHIFT_LSB)
+#define CPU_DPLL2_PHASE_SHIFT_SET(x)                                 (((x) << CPU_DPLL2_PHASE_SHIFT_LSB) & CPU_DPLL2_PHASE_SHIFT_MASK)
+#define CPU_DPLL2_PHASE_SHIFT_RESET                                  0x0 // 0
+#define CPU_DPLL2_TESTIN_MSB                                         11
+#define CPU_DPLL2_TESTIN_LSB                                         2
+#define CPU_DPLL2_TESTIN_MASK                                        0x00000ffc
+#define CPU_DPLL2_TESTIN_GET(x)                                      (((x) & CPU_DPLL2_TESTIN_MASK) >> CPU_DPLL2_TESTIN_LSB)
+#define CPU_DPLL2_TESTIN_SET(x)                                      (((x) << CPU_DPLL2_TESTIN_LSB) & CPU_DPLL2_TESTIN_MASK)
+#define CPU_DPLL2_TESTIN_RESET                                       0x0 // 0
+#define CPU_DPLL2_SEL_COUNT_MSB                                      1
+#define CPU_DPLL2_SEL_COUNT_LSB                                      1
+#define CPU_DPLL2_SEL_COUNT_MASK                                     0x00000002
+#define CPU_DPLL2_SEL_COUNT_GET(x)                                   (((x) & CPU_DPLL2_SEL_COUNT_MASK) >> CPU_DPLL2_SEL_COUNT_LSB)
+#define CPU_DPLL2_SEL_COUNT_SET(x)                                   (((x) << CPU_DPLL2_SEL_COUNT_LSB) & CPU_DPLL2_SEL_COUNT_MASK)
+#define CPU_DPLL2_SEL_COUNT_RESET                                    0x0 // 0
+#define CPU_DPLL2_RESET_TEST_MSB                                     0
+#define CPU_DPLL2_RESET_TEST_LSB                                     0
+#define CPU_DPLL2_RESET_TEST_MASK                                    0x00000001
+#define CPU_DPLL2_RESET_TEST_GET(x)                                  (((x) & CPU_DPLL2_RESET_TEST_MASK) >> CPU_DPLL2_RESET_TEST_LSB)
+#define CPU_DPLL2_RESET_TEST_SET(x)                                  (((x) << CPU_DPLL2_RESET_TEST_LSB) & CPU_DPLL2_RESET_TEST_MASK)
+#define CPU_DPLL2_RESET_TEST_RESET                                   0x0 // 0
+#define CPU_DPLL2_ADDRESS                                            0x181161c4
+
+#define DDR_RD_DATA_THIS_CYCLE_ADDRESS                               0x18000018
+
+#define TAP_CONTROL_0_ADDRESS                                        0x1800001c
+#define TAP_CONTROL_1_ADDRESS                                        0x18000020
+#define TAP_CONTROL_2_ADDRESS                                        0x18000024
+#define TAP_CONTROL_3_ADDRESS                                        0x18000028
+
+#define DDR_BURST_CPU_PRIORITY_MSB                                   31
+#define DDR_BURST_CPU_PRIORITY_LSB                                   31
+#define DDR_BURST_CPU_PRIORITY_MASK                                  0x80000000
+#define DDR_BURST_CPU_PRIORITY_GET(x)                                (((x) & DDR_BURST_CPU_PRIORITY_MASK) >> DDR_BURST_CPU_PRIORITY_LSB)
+#define DDR_BURST_CPU_PRIORITY_SET(x)                                (((x) << DDR_BURST_CPU_PRIORITY_LSB) & DDR_BURST_CPU_PRIORITY_MASK)
+#define DDR_BURST_CPU_PRIORITY_RESET                                 0x0 // 0
+#define DDR_BURST_CPU_PRIORITY_BE_MSB                                30
+#define DDR_BURST_CPU_PRIORITY_BE_LSB                                30
+#define DDR_BURST_CPU_PRIORITY_BE_MASK                               0x40000000
+#define DDR_BURST_CPU_PRIORITY_BE_GET(x)                             (((x) & DDR_BURST_CPU_PRIORITY_BE_MASK) >> DDR_BURST_CPU_PRIORITY_BE_LSB)
+#define DDR_BURST_CPU_PRIORITY_BE_SET(x)                             (((x) << DDR_BURST_CPU_PRIORITY_BE_LSB) & DDR_BURST_CPU_PRIORITY_BE_MASK)
+#define DDR_BURST_CPU_PRIORITY_BE_RESET                              0x1 // 1
+#define DDR_BURST_ENABLE_RWP_MASK_MSB                                29
+#define DDR_BURST_ENABLE_RWP_MASK_LSB                                28
+#define DDR_BURST_ENABLE_RWP_MASK_MASK                               0x30000000
+#define DDR_BURST_ENABLE_RWP_MASK_GET(x)                             (((x) & DDR_BURST_ENABLE_RWP_MASK_MASK) >> DDR_BURST_ENABLE_RWP_MASK_LSB)
+#define DDR_BURST_ENABLE_RWP_MASK_SET(x)                             (((x) << DDR_BURST_ENABLE_RWP_MASK_LSB) & DDR_BURST_ENABLE_RWP_MASK_MASK)
+#define DDR_BURST_ENABLE_RWP_MASK_RESET                              0x3 // 3
+#define DDR_BURST_MAX_WRITE_BURST_MSB                                27
+#define DDR_BURST_MAX_WRITE_BURST_LSB                                24
+#define DDR_BURST_MAX_WRITE_BURST_MASK                               0x0f000000
+#define DDR_BURST_MAX_WRITE_BURST_GET(x)                             (((x) & DDR_BURST_MAX_WRITE_BURST_MASK) >> DDR_BURST_MAX_WRITE_BURST_LSB)
+#define DDR_BURST_MAX_WRITE_BURST_SET(x)                             (((x) << DDR_BURST_MAX_WRITE_BURST_LSB) & DDR_BURST_MAX_WRITE_BURST_MASK)
+#define DDR_BURST_MAX_WRITE_BURST_RESET                              0x4 // 4
+#define DDR_BURST_MAX_READ_BURST_MSB                                 23
+#define DDR_BURST_MAX_READ_BURST_LSB                                 20
+#define DDR_BURST_MAX_READ_BURST_MASK                                0x00f00000
+#define DDR_BURST_MAX_READ_BURST_GET(x)                              (((x) & DDR_BURST_MAX_READ_BURST_MASK) >> DDR_BURST_MAX_READ_BURST_LSB)
+#define DDR_BURST_MAX_READ_BURST_SET(x)                              (((x) << DDR_BURST_MAX_READ_BURST_LSB) & DDR_BURST_MAX_READ_BURST_MASK)
+#define DDR_BURST_MAX_READ_BURST_RESET                               0x4 // 4
+#define DDR_BURST_CPU_MAX_BL_MSB                                     19
+#define DDR_BURST_CPU_MAX_BL_LSB                                     16
+#define DDR_BURST_CPU_MAX_BL_MASK                                    0x000f0000
+#define DDR_BURST_CPU_MAX_BL_GET(x)                                  (((x) & DDR_BURST_CPU_MAX_BL_MASK) >> DDR_BURST_CPU_MAX_BL_LSB)
+#define DDR_BURST_CPU_MAX_BL_SET(x)                                  (((x) << DDR_BURST_CPU_MAX_BL_LSB) & DDR_BURST_CPU_MAX_BL_MASK)
+#define DDR_BURST_CPU_MAX_BL_RESET                                   0x3 // 3
+#define DDR_BURST_USB_MAX_BL_MSB                                     15
+#define DDR_BURST_USB_MAX_BL_LSB                                     12
+#define DDR_BURST_USB_MAX_BL_MASK                                    0x0000f000
+#define DDR_BURST_USB_MAX_BL_GET(x)                                  (((x) & DDR_BURST_USB_MAX_BL_MASK) >> DDR_BURST_USB_MAX_BL_LSB)
+#define DDR_BURST_USB_MAX_BL_SET(x)                                  (((x) << DDR_BURST_USB_MAX_BL_LSB) & DDR_BURST_USB_MAX_BL_MASK)
+#define DDR_BURST_USB_MAX_BL_RESET                                   0x4 // 4
+#define DDR_BURST_PCIE_MAX_BL_MSB                                    11
+#define DDR_BURST_PCIE_MAX_BL_LSB                                    8
+#define DDR_BURST_PCIE_MAX_BL_MASK                                   0x00000f00
+#define DDR_BURST_PCIE_MAX_BL_GET(x)                                 (((x) & DDR_BURST_PCIE_MAX_BL_MASK) >> DDR_BURST_PCIE_MAX_BL_LSB)
+#define DDR_BURST_PCIE_MAX_BL_SET(x)                                 (((x) << DDR_BURST_PCIE_MAX_BL_LSB) & DDR_BURST_PCIE_MAX_BL_MASK)
+#define DDR_BURST_PCIE_MAX_BL_RESET                                  0x3 // 3
+#define DDR_BURST_GE1_MAX_BL_MSB                                     7
+#define DDR_BURST_GE1_MAX_BL_LSB                                     4
+#define DDR_BURST_GE1_MAX_BL_MASK                                    0x000000f0
+#define DDR_BURST_GE1_MAX_BL_GET(x)                                  (((x) & DDR_BURST_GE1_MAX_BL_MASK) >> DDR_BURST_GE1_MAX_BL_LSB)
+#define DDR_BURST_GE1_MAX_BL_SET(x)                                  (((x) << DDR_BURST_GE1_MAX_BL_LSB) & DDR_BURST_GE1_MAX_BL_MASK)
+#define DDR_BURST_GE1_MAX_BL_RESET                                   0x3 // 3
+#define DDR_BURST_GE0_MAX_BL_MSB                                     3
+#define DDR_BURST_GE0_MAX_BL_LSB                                     0
+#define DDR_BURST_GE0_MAX_BL_MASK                                    0x0000000f
+#define DDR_BURST_GE0_MAX_BL_GET(x)                                  (((x) & DDR_BURST_GE0_MAX_BL_MASK) >> DDR_BURST_GE0_MAX_BL_LSB)
+#define DDR_BURST_GE0_MAX_BL_SET(x)                                  (((x) << DDR_BURST_GE0_MAX_BL_LSB) & DDR_BURST_GE0_MAX_BL_MASK)
+#define DDR_BURST_GE0_MAX_BL_RESET                                   0x3 // 3
+#define DDR_BURST_ADDRESS                                            0x180000c4
+
+#define DDR_BURST2_WMAC_MAX_BL_MSB                                   3
+#define DDR_BURST2_WMAC_MAX_BL_LSB                                   0
+#define DDR_BURST2_WMAC_MAX_BL_MASK                                  0x0000000f
+#define DDR_BURST2_WMAC_MAX_BL_GET(x)                                (((x) & DDR_BURST2_WMAC_MAX_BL_MASK) >> DDR_BURST2_WMAC_MAX_BL_LSB)
+#define DDR_BURST2_WMAC_MAX_BL_SET(x)                                (((x) << DDR_BURST2_WMAC_MAX_BL_LSB) & DDR_BURST2_WMAC_MAX_BL_MASK)
+#define DDR_BURST2_WMAC_MAX_BL_RESET                                 0x3 // 3
+#define DDR_BURST2_ADDRESS                                           0x180000c8
+
+#define DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_MSB                         19
+#define DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_LSB                         0
+#define DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_MASK                        0x000fffff
+#define DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_GET(x)                      (((x) & DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_MASK) >> DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_LSB)
+#define DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_SET(x)                      (((x) << DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_LSB) & DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_MASK)
+#define DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_RESET                       0x8000 // 32768
+#define DDR_AHB_MASTER_TIMEOUT_MAX_ADDRESS                           0x180000cc
+
+#define PMU1_ADDRESS                                                 0x18116c40
+
+#define PMU2_SWREGMSB_MSB                                            31
+#define PMU2_SWREGMSB_LSB                                            22
+#define PMU2_SWREGMSB_MASK                                           0xffc00000
+#define PMU2_SWREGMSB_GET(x)                                         (((x) & PMU2_SWREGMSB_MASK) >> PMU2_SWREGMSB_LSB)
+#define PMU2_SWREGMSB_SET(x)                                         (((x) << PMU2_SWREGMSB_LSB) & PMU2_SWREGMSB_MASK)
+#define PMU2_SWREGMSB_RESET                                          0x0 // 0
+#define PMU2_PGM_MSB                                                 21
+#define PMU2_PGM_LSB                                                 21
+#define PMU2_PGM_MASK                                                0x00200000
+#define PMU2_PGM_GET(x)                                              (((x) & PMU2_PGM_MASK) >> PMU2_PGM_LSB)
+#define PMU2_PGM_SET(x)                                              (((x) << PMU2_PGM_LSB) & PMU2_PGM_MASK)
+#define PMU2_PGM_RESET                                               0x0 // 0
+#define PMU2_LDO_TUNE_MSB                                            20
+#define PMU2_LDO_TUNE_LSB                                            19
+#define PMU2_LDO_TUNE_MASK                                           0x00180000
+#define PMU2_LDO_TUNE_GET(x)                                         (((x) & PMU2_LDO_TUNE_MASK) >> PMU2_LDO_TUNE_LSB)
+#define PMU2_LDO_TUNE_SET(x)                                         (((x) << PMU2_LDO_TUNE_LSB) & PMU2_LDO_TUNE_MASK)
+#define PMU2_LDO_TUNE_RESET                                          0x0 // 0
+#define PMU2_PWDLDO_DDR_MSB                                          18
+#define PMU2_PWDLDO_DDR_LSB                                          18
+#define PMU2_PWDLDO_DDR_MASK                                         0x00040000
+#define PMU2_PWDLDO_DDR_GET(x)                                       (((x) & PMU2_PWDLDO_DDR_MASK) >> PMU2_PWDLDO_DDR_LSB)
+#define PMU2_PWDLDO_DDR_SET(x)                                       (((x) << PMU2_PWDLDO_DDR_LSB) & PMU2_PWDLDO_DDR_MASK)
+#define PMU2_PWDLDO_DDR_RESET                                        0x0 // 0
+#define PMU2_LPOPWD_MSB                                              17
+#define PMU2_LPOPWD_LSB                                              17
+#define PMU2_LPOPWD_MASK                                             0x00020000
+#define PMU2_LPOPWD_GET(x)                                           (((x) & PMU2_LPOPWD_MASK) >> PMU2_LPOPWD_LSB)
+#define PMU2_LPOPWD_SET(x)                                           (((x) << PMU2_LPOPWD_LSB) & PMU2_LPOPWD_MASK)
+#define PMU2_LPOPWD_RESET                                            0x0 // 0
+#define PMU2_SPARE_MSB                                               16
+#define PMU2_SPARE_LSB                                               0
+#define PMU2_SPARE_MASK                                              0x0001ffff
+#define PMU2_SPARE_GET(x)                                            (((x) & PMU2_SPARE_MASK) >> PMU2_SPARE_LSB)
+#define PMU2_SPARE_SET(x)                                            (((x) << PMU2_SPARE_LSB) & PMU2_SPARE_MASK)
+#define PMU2_SPARE_RESET                                             0x0 // 0
+#define PMU2_ADDRESS                                                 0x18116c44
+
+#define PHY_CTRL0_LOOPBACK_ERR_CNT_MSB                               31
+#define PHY_CTRL0_LOOPBACK_ERR_CNT_LSB                               24
+#define PHY_CTRL0_LOOPBACK_ERR_CNT_MASK                              0xff000000
+#define PHY_CTRL0_LOOPBACK_ERR_CNT_GET(x)                            (((x) & PHY_CTRL0_LOOPBACK_ERR_CNT_MASK) >> PHY_CTRL0_LOOPBACK_ERR_CNT_LSB)
+#define PHY_CTRL0_LOOPBACK_ERR_CNT_SET(x)                            (((x) << PHY_CTRL0_LOOPBACK_ERR_CNT_LSB) & PHY_CTRL0_LOOPBACK_ERR_CNT_MASK)
+#define PHY_CTRL0_LOOPBACK_ERR_CNT_RESET                             0x0 // 0
+#define PHY_CTRL0_DIG_LOOPBACK_EN_MSB                                23
+#define PHY_CTRL0_DIG_LOOPBACK_EN_LSB                                23
+#define PHY_CTRL0_DIG_LOOPBACK_EN_MASK                               0x00800000
+#define PHY_CTRL0_DIG_LOOPBACK_EN_GET(x)                             (((x) & PHY_CTRL0_DIG_LOOPBACK_EN_MASK) >> PHY_CTRL0_DIG_LOOPBACK_EN_LSB)
+#define PHY_CTRL0_DIG_LOOPBACK_EN_SET(x)                             (((x) << PHY_CTRL0_DIG_LOOPBACK_EN_LSB) & PHY_CTRL0_DIG_LOOPBACK_EN_MASK)
+#define PHY_CTRL0_DIG_LOOPBACK_EN_RESET                              0x0 // 0
+#define PHY_CTRL0_ANA_LOOPBACK_EN_MSB                                22
+#define PHY_CTRL0_ANA_LOOPBACK_EN_LSB                                22
+#define PHY_CTRL0_ANA_LOOPBACK_EN_MASK                               0x00400000
+#define PHY_CTRL0_ANA_LOOPBACK_EN_GET(x)                             (((x) & PHY_CTRL0_ANA_LOOPBACK_EN_MASK) >> PHY_CTRL0_ANA_LOOPBACK_EN_LSB)
+#define PHY_CTRL0_ANA_LOOPBACK_EN_SET(x)                             (((x) << PHY_CTRL0_ANA_LOOPBACK_EN_LSB) & PHY_CTRL0_ANA_LOOPBACK_EN_MASK)
+#define PHY_CTRL0_ANA_LOOPBACK_EN_RESET                              0x0 // 0
+#define PHY_CTRL0_TX_PATTERN_EN_MSB                                  21
+#define PHY_CTRL0_TX_PATTERN_EN_LSB                                  21
+#define PHY_CTRL0_TX_PATTERN_EN_MASK                                 0x00200000
+#define PHY_CTRL0_TX_PATTERN_EN_GET(x)                               (((x) & PHY_CTRL0_TX_PATTERN_EN_MASK) >> PHY_CTRL0_TX_PATTERN_EN_LSB)
+#define PHY_CTRL0_TX_PATTERN_EN_SET(x)                               (((x) << PHY_CTRL0_TX_PATTERN_EN_LSB) & PHY_CTRL0_TX_PATTERN_EN_MASK)
+#define PHY_CTRL0_TX_PATTERN_EN_RESET                                0x0 // 0
+#define PHY_CTRL0_RX_PATTERN_EN_MSB                                  20
+#define PHY_CTRL0_RX_PATTERN_EN_LSB                                  20
+#define PHY_CTRL0_RX_PATTERN_EN_MASK                                 0x00100000
+#define PHY_CTRL0_RX_PATTERN_EN_GET(x)                               (((x) & PHY_CTRL0_RX_PATTERN_EN_MASK) >> PHY_CTRL0_RX_PATTERN_EN_LSB)
+#define PHY_CTRL0_RX_PATTERN_EN_SET(x)                               (((x) << PHY_CTRL0_RX_PATTERN_EN_LSB) & PHY_CTRL0_RX_PATTERN_EN_MASK)
+#define PHY_CTRL0_RX_PATTERN_EN_RESET                                0x0 // 0
+#define PHY_CTRL0_TEST_SPEED_SELECT_MSB                              19
+#define PHY_CTRL0_TEST_SPEED_SELECT_LSB                              19
+#define PHY_CTRL0_TEST_SPEED_SELECT_MASK                             0x00080000
+#define PHY_CTRL0_TEST_SPEED_SELECT_GET(x)                           (((x) & PHY_CTRL0_TEST_SPEED_SELECT_MASK) >> PHY_CTRL0_TEST_SPEED_SELECT_LSB)
+#define PHY_CTRL0_TEST_SPEED_SELECT_SET(x)                           (((x) << PHY_CTRL0_TEST_SPEED_SELECT_LSB) & PHY_CTRL0_TEST_SPEED_SELECT_MASK)
+#define PHY_CTRL0_TEST_SPEED_SELECT_RESET                            0x0 // 0
+#define PHY_CTRL0_PLL_OVERIDE_MSB                                    18
+#define PHY_CTRL0_PLL_OVERIDE_LSB                                    18
+#define PHY_CTRL0_PLL_OVERIDE_MASK                                   0x00040000
+#define PHY_CTRL0_PLL_OVERIDE_GET(x)                                 (((x) & PHY_CTRL0_PLL_OVERIDE_MASK) >> PHY_CTRL0_PLL_OVERIDE_LSB)
+#define PHY_CTRL0_PLL_OVERIDE_SET(x)                                 (((x) << PHY_CTRL0_PLL_OVERIDE_LSB) & PHY_CTRL0_PLL_OVERIDE_MASK)
+#define PHY_CTRL0_PLL_OVERIDE_RESET                                  0x0 // 0
+#define PHY_CTRL0_PLL_MOD_MSB                                        17
+#define PHY_CTRL0_PLL_MOD_LSB                                        15
+#define PHY_CTRL0_PLL_MOD_MASK                                       0x00038000
+#define PHY_CTRL0_PLL_MOD_GET(x)                                     (((x) & PHY_CTRL0_PLL_MOD_MASK) >> PHY_CTRL0_PLL_MOD_LSB)
+#define PHY_CTRL0_PLL_MOD_SET(x)                                     (((x) << PHY_CTRL0_PLL_MOD_LSB) & PHY_CTRL0_PLL_MOD_MASK)
+#define PHY_CTRL0_PLL_MOD_RESET                                      0x0 // 0
+#define PHY_CTRL0_PLL_DIV_MSB                                        14
+#define PHY_CTRL0_PLL_DIV_LSB                                        6
+#define PHY_CTRL0_PLL_DIV_MASK                                       0x00007fc0
+#define PHY_CTRL0_PLL_DIV_GET(x)                                     (((x) & PHY_CTRL0_PLL_DIV_MASK) >> PHY_CTRL0_PLL_DIV_LSB)
+#define PHY_CTRL0_PLL_DIV_SET(x)                                     (((x) << PHY_CTRL0_PLL_DIV_LSB) & PHY_CTRL0_PLL_DIV_MASK)
+#define PHY_CTRL0_PLL_DIV_RESET                                      0x0 // 0
+#define PHY_CTRL0_PLL_RS_MSB                                         5
+#define PHY_CTRL0_PLL_RS_LSB                                         3
+#define PHY_CTRL0_PLL_RS_MASK                                        0x00000038
+#define PHY_CTRL0_PLL_RS_GET(x)                                      (((x) & PHY_CTRL0_PLL_RS_MASK) >> PHY_CTRL0_PLL_RS_LSB)
+#define PHY_CTRL0_PLL_RS_SET(x)                                      (((x) << PHY_CTRL0_PLL_RS_LSB) & PHY_CTRL0_PLL_RS_MASK)
+#define PHY_CTRL0_PLL_RS_RESET                                       0x2 // 2
+#define PHY_CTRL0_PLL_ICP_MSB                                        2
+#define PHY_CTRL0_PLL_ICP_LSB                                        0
+#define PHY_CTRL0_PLL_ICP_MASK                                       0x00000007
+#define PHY_CTRL0_PLL_ICP_GET(x)                                     (((x) & PHY_CTRL0_PLL_ICP_MASK) >> PHY_CTRL0_PLL_ICP_LSB)
+#define PHY_CTRL0_PLL_ICP_SET(x)                                     (((x) << PHY_CTRL0_PLL_ICP_LSB) & PHY_CTRL0_PLL_ICP_MASK)
+#define PHY_CTRL0_PLL_ICP_RESET                                      0x5 // 5
+#define PHY_CTRL0_ADDRESS                                            0x18116c80
+#define PHY_CTRL0_OFFSET                                             0x0000
+// SW modifiable bits
+#define PHY_CTRL0_SW_MASK                                            0xffffffff
+// bits defined at reset
+#define PHY_CTRL0_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL0_RESET                                              0x00000015
+
+#define PHY_CTRL1_PLL_OBS_MODE_N_MSB                                 31
+#define PHY_CTRL1_PLL_OBS_MODE_N_LSB                                 31
+#define PHY_CTRL1_PLL_OBS_MODE_N_MASK                                0x80000000
+#define PHY_CTRL1_PLL_OBS_MODE_N_GET(x)                              (((x) & PHY_CTRL1_PLL_OBS_MODE_N_MASK) >> PHY_CTRL1_PLL_OBS_MODE_N_LSB)
+#define PHY_CTRL1_PLL_OBS_MODE_N_SET(x)                              (((x) << PHY_CTRL1_PLL_OBS_MODE_N_LSB) & PHY_CTRL1_PLL_OBS_MODE_N_MASK)
+#define PHY_CTRL1_PLL_OBS_MODE_N_RESET                               0x1 // 1
+#define PHY_CTRL1_DISABLE_CLK_GATING_MSB                             27
+#define PHY_CTRL1_DISABLE_CLK_GATING_LSB                             27
+#define PHY_CTRL1_DISABLE_CLK_GATING_MASK                            0x08000000
+#define PHY_CTRL1_DISABLE_CLK_GATING_GET(x)                          (((x) & PHY_CTRL1_DISABLE_CLK_GATING_MASK) >> PHY_CTRL1_DISABLE_CLK_GATING_LSB)
+#define PHY_CTRL1_DISABLE_CLK_GATING_SET(x)                          (((x) << PHY_CTRL1_DISABLE_CLK_GATING_LSB) & PHY_CTRL1_DISABLE_CLK_GATING_MASK)
+#define PHY_CTRL1_DISABLE_CLK_GATING_RESET                           0x0 // 0
+#define PHY_CTRL1_ENABLE_REFCLK_GATE_MSB                             26
+#define PHY_CTRL1_ENABLE_REFCLK_GATE_LSB                             26
+#define PHY_CTRL1_ENABLE_REFCLK_GATE_MASK                            0x04000000
+#define PHY_CTRL1_ENABLE_REFCLK_GATE_GET(x)                          (((x) & PHY_CTRL1_ENABLE_REFCLK_GATE_MASK) >> PHY_CTRL1_ENABLE_REFCLK_GATE_LSB)
+#define PHY_CTRL1_ENABLE_REFCLK_GATE_SET(x)                          (((x) << PHY_CTRL1_ENABLE_REFCLK_GATE_LSB) & PHY_CTRL1_ENABLE_REFCLK_GATE_MASK)
+#define PHY_CTRL1_ENABLE_REFCLK_GATE_RESET                           0x1 // 1
+#define PHY_CTRL1_CLKOBS_SEL_MSB                                     25
+#define PHY_CTRL1_CLKOBS_SEL_LSB                                     23
+#define PHY_CTRL1_CLKOBS_SEL_MASK                                    0x03800000
+#define PHY_CTRL1_CLKOBS_SEL_GET(x)                                  (((x) & PHY_CTRL1_CLKOBS_SEL_MASK) >> PHY_CTRL1_CLKOBS_SEL_LSB)
+#define PHY_CTRL1_CLKOBS_SEL_SET(x)                                  (((x) << PHY_CTRL1_CLKOBS_SEL_LSB) & PHY_CTRL1_CLKOBS_SEL_MASK)
+#define PHY_CTRL1_CLKOBS_SEL_RESET                                   0x0 // 0
+#define PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_MSB                           22
+#define PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_LSB                           21
+#define PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_MASK                          0x00600000
+#define PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_GET(x)                        (((x) & PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_MASK) >> PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_LSB)
+#define PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_SET(x)                        (((x) << PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_LSB) & PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_MASK)
+#define PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_RESET                         0x3 // 3
+#define PHY_CTRL1_USE_PLL_LOCKDETECT_MSB                             20
+#define PHY_CTRL1_USE_PLL_LOCKDETECT_LSB                             20
+#define PHY_CTRL1_USE_PLL_LOCKDETECT_MASK                            0x00100000
+#define PHY_CTRL1_USE_PLL_LOCKDETECT_GET(x)                          (((x) & PHY_CTRL1_USE_PLL_LOCKDETECT_MASK) >> PHY_CTRL1_USE_PLL_LOCKDETECT_LSB)
+#define PHY_CTRL1_USE_PLL_LOCKDETECT_SET(x)                          (((x) << PHY_CTRL1_USE_PLL_LOCKDETECT_LSB) & PHY_CTRL1_USE_PLL_LOCKDETECT_MASK)
+#define PHY_CTRL1_USE_PLL_LOCKDETECT_RESET                           0x0 // 0
+#define PHY_CTRL1_TX_PATTERN_SEL_MSB                                 19
+#define PHY_CTRL1_TX_PATTERN_SEL_LSB                                 18
+#define PHY_CTRL1_TX_PATTERN_SEL_MASK                                0x000c0000
+#define PHY_CTRL1_TX_PATTERN_SEL_GET(x)                              (((x) & PHY_CTRL1_TX_PATTERN_SEL_MASK) >> PHY_CTRL1_TX_PATTERN_SEL_LSB)
+#define PHY_CTRL1_TX_PATTERN_SEL_SET(x)                              (((x) << PHY_CTRL1_TX_PATTERN_SEL_LSB) & PHY_CTRL1_TX_PATTERN_SEL_MASK)
+#define PHY_CTRL1_TX_PATTERN_SEL_RESET                               0x0 // 0
+#define PHY_CTRL1_FORCE_SUSPEND_MSB                                  13
+#define PHY_CTRL1_FORCE_SUSPEND_LSB                                  13
+#define PHY_CTRL1_FORCE_SUSPEND_MASK                                 0x00002000
+#define PHY_CTRL1_FORCE_SUSPEND_GET(x)                               (((x) & PHY_CTRL1_FORCE_SUSPEND_MASK) >> PHY_CTRL1_FORCE_SUSPEND_LSB)
+#define PHY_CTRL1_FORCE_SUSPEND_SET(x)                               (((x) << PHY_CTRL1_FORCE_SUSPEND_LSB) & PHY_CTRL1_FORCE_SUSPEND_MASK)
+#define PHY_CTRL1_FORCE_SUSPEND_RESET                                0x0 // 0
+#define PHY_CTRL1_NO_PLL_PWD_MSB                                     12
+#define PHY_CTRL1_NO_PLL_PWD_LSB                                     12
+#define PHY_CTRL1_NO_PLL_PWD_MASK                                    0x00001000
+#define PHY_CTRL1_NO_PLL_PWD_GET(x)                                  (((x) & PHY_CTRL1_NO_PLL_PWD_MASK) >> PHY_CTRL1_NO_PLL_PWD_LSB)
+#define PHY_CTRL1_NO_PLL_PWD_SET(x)                                  (((x) << PHY_CTRL1_NO_PLL_PWD_LSB) & PHY_CTRL1_NO_PLL_PWD_MASK)
+#define PHY_CTRL1_NO_PLL_PWD_RESET                                   0x0 // 0
+#define PHY_CTRL1_RX_RSVD_MSB                                        11
+#define PHY_CTRL1_RX_RSVD_LSB                                        9
+#define PHY_CTRL1_RX_RSVD_MASK                                       0x00000e00
+#define PHY_CTRL1_RX_RSVD_GET(x)                                     (((x) & PHY_CTRL1_RX_RSVD_MASK) >> PHY_CTRL1_RX_RSVD_LSB)
+#define PHY_CTRL1_RX_RSVD_SET(x)                                     (((x) << PHY_CTRL1_RX_RSVD_LSB) & PHY_CTRL1_RX_RSVD_MASK)
+#define PHY_CTRL1_RX_RSVD_RESET                                      0x0 // 0
+#define PHY_CTRL1_RX_SELVREF0P25_MSB                                 8
+#define PHY_CTRL1_RX_SELVREF0P25_LSB                                 8
+#define PHY_CTRL1_RX_SELVREF0P25_MASK                                0x00000100
+#define PHY_CTRL1_RX_SELVREF0P25_GET(x)                              (((x) & PHY_CTRL1_RX_SELVREF0P25_MASK) >> PHY_CTRL1_RX_SELVREF0P25_LSB)
+#define PHY_CTRL1_RX_SELVREF0P25_SET(x)                              (((x) << PHY_CTRL1_RX_SELVREF0P25_LSB) & PHY_CTRL1_RX_SELVREF0P25_MASK)
+#define PHY_CTRL1_RX_SELVREF0P25_RESET                               0x0 // 0
+#define PHY_CTRL1_RX_SELVREF0P6_MSB                                  7
+#define PHY_CTRL1_RX_SELVREF0P6_LSB                                  7
+#define PHY_CTRL1_RX_SELVREF0P6_MASK                                 0x00000080
+#define PHY_CTRL1_RX_SELVREF0P6_GET(x)                               (((x) & PHY_CTRL1_RX_SELVREF0P6_MASK) >> PHY_CTRL1_RX_SELVREF0P6_LSB)
+#define PHY_CTRL1_RX_SELVREF0P6_SET(x)                               (((x) << PHY_CTRL1_RX_SELVREF0P6_LSB) & PHY_CTRL1_RX_SELVREF0P6_MASK)
+#define PHY_CTRL1_RX_SELVREF0P6_RESET                                0x1 // 1
+#define PHY_CTRL1_RX_SELIR_100M_MSB                                  6
+#define PHY_CTRL1_RX_SELIR_100M_LSB                                  5
+#define PHY_CTRL1_RX_SELIR_100M_MASK                                 0x00000060
+#define PHY_CTRL1_RX_SELIR_100M_GET(x)                               (((x) & PHY_CTRL1_RX_SELIR_100M_MASK) >> PHY_CTRL1_RX_SELIR_100M_LSB)
+#define PHY_CTRL1_RX_SELIR_100M_SET(x)                               (((x) << PHY_CTRL1_RX_SELIR_100M_LSB) & PHY_CTRL1_RX_SELIR_100M_MASK)
+#define PHY_CTRL1_RX_SELIR_100M_RESET                                0x0 // 0
+#define PHY_CTRL1_RX_LOWR_PDET_MSB                                   4
+#define PHY_CTRL1_RX_LOWR_PDET_LSB                                   4
+#define PHY_CTRL1_RX_LOWR_PDET_MASK                                  0x00000010
+#define PHY_CTRL1_RX_LOWR_PDET_GET(x)                                (((x) & PHY_CTRL1_RX_LOWR_PDET_MASK) >> PHY_CTRL1_RX_LOWR_PDET_LSB)
+#define PHY_CTRL1_RX_LOWR_PDET_SET(x)                                (((x) << PHY_CTRL1_RX_LOWR_PDET_LSB) & PHY_CTRL1_RX_LOWR_PDET_MASK)
+#define PHY_CTRL1_RX_LOWR_PDET_RESET                                 0x1 // 1
+#define PHY_CTRL1_RX_BYPASSEQ_MSB                                    3
+#define PHY_CTRL1_RX_BYPASSEQ_LSB                                    3
+#define PHY_CTRL1_RX_BYPASSEQ_MASK                                   0x00000008
+#define PHY_CTRL1_RX_BYPASSEQ_GET(x)                                 (((x) & PHY_CTRL1_RX_BYPASSEQ_MASK) >> PHY_CTRL1_RX_BYPASSEQ_LSB)
+#define PHY_CTRL1_RX_BYPASSEQ_SET(x)                                 (((x) << PHY_CTRL1_RX_BYPASSEQ_LSB) & PHY_CTRL1_RX_BYPASSEQ_MASK)
+#define PHY_CTRL1_RX_BYPASSEQ_RESET                                  0x0 // 0
+#define PHY_CTRL1_RX_FORCERXON_MSB                                   2
+#define PHY_CTRL1_RX_FORCERXON_LSB                                   2
+#define PHY_CTRL1_RX_FORCERXON_MASK                                  0x00000004
+#define PHY_CTRL1_RX_FORCERXON_GET(x)                                (((x) & PHY_CTRL1_RX_FORCERXON_MASK) >> PHY_CTRL1_RX_FORCERXON_LSB)
+#define PHY_CTRL1_RX_FORCERXON_SET(x)                                (((x) << PHY_CTRL1_RX_FORCERXON_LSB) & PHY_CTRL1_RX_FORCERXON_MASK)
+#define PHY_CTRL1_RX_FORCERXON_RESET                                 0x1 // 1
+#define PHY_CTRL1_RX_FILBW_SEL_MSB                                   1
+#define PHY_CTRL1_RX_FILBW_SEL_LSB                                   0
+#define PHY_CTRL1_RX_FILBW_SEL_MASK                                  0x00000003
+#define PHY_CTRL1_RX_FILBW_SEL_GET(x)                                (((x) & PHY_CTRL1_RX_FILBW_SEL_MASK) >> PHY_CTRL1_RX_FILBW_SEL_LSB)
+#define PHY_CTRL1_RX_FILBW_SEL_SET(x)                                (((x) << PHY_CTRL1_RX_FILBW_SEL_LSB) & PHY_CTRL1_RX_FILBW_SEL_MASK)
+#define PHY_CTRL1_RX_FILBW_SEL_RESET                                 0x1 // 1
+#define PHY_CTRL1_ADDRESS                                            0x18116c84
+#define PHY_CTRL1_OFFSET                                             0x0004
+// SW modifiable bits
+#define PHY_CTRL1_SW_MASK                                            0x8ffc3fff
+// bits defined at reset
+#define PHY_CTRL1_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL1_RESET                                              0x84600095
+
+#define PHY_CTRL2_PWD_EXTBIAS_MSB                                    31
+#define PHY_CTRL2_PWD_EXTBIAS_LSB                                    31
+#define PHY_CTRL2_PWD_EXTBIAS_MASK                                   0x80000000
+#define PHY_CTRL2_PWD_EXTBIAS_GET(x)                                 (((x) & PHY_CTRL2_PWD_EXTBIAS_MASK) >> PHY_CTRL2_PWD_EXTBIAS_LSB)
+#define PHY_CTRL2_PWD_EXTBIAS_SET(x)                                 (((x) << PHY_CTRL2_PWD_EXTBIAS_LSB) & PHY_CTRL2_PWD_EXTBIAS_MASK)
+#define PHY_CTRL2_PWD_EXTBIAS_RESET                                  0x0 // 0
+#define PHY_CTRL2_TX_RSVD_MSB                                        30
+#define PHY_CTRL2_TX_RSVD_LSB                                        27
+#define PHY_CTRL2_TX_RSVD_MASK                                       0x78000000
+#define PHY_CTRL2_TX_RSVD_GET(x)                                     (((x) & PHY_CTRL2_TX_RSVD_MASK) >> PHY_CTRL2_TX_RSVD_LSB)
+#define PHY_CTRL2_TX_RSVD_SET(x)                                     (((x) << PHY_CTRL2_TX_RSVD_LSB) & PHY_CTRL2_TX_RSVD_MASK)
+#define PHY_CTRL2_TX_RSVD_RESET                                      0x0 // 0
+#define PHY_CTRL2_TX_LCKDET_OVR_MSB                                  26
+#define PHY_CTRL2_TX_LCKDET_OVR_LSB                                  26
+#define PHY_CTRL2_TX_LCKDET_OVR_MASK                                 0x04000000
+#define PHY_CTRL2_TX_LCKDET_OVR_GET(x)                               (((x) & PHY_CTRL2_TX_LCKDET_OVR_MASK) >> PHY_CTRL2_TX_LCKDET_OVR_LSB)
+#define PHY_CTRL2_TX_LCKDET_OVR_SET(x)                               (((x) << PHY_CTRL2_TX_LCKDET_OVR_LSB) & PHY_CTRL2_TX_LCKDET_OVR_MASK)
+#define PHY_CTRL2_TX_LCKDET_OVR_RESET                                0x0 // 0
+#define PHY_CTRL2_TX_MAN_CAL_MSB                                     25
+#define PHY_CTRL2_TX_MAN_CAL_LSB                                     22
+#define PHY_CTRL2_TX_MAN_CAL_MASK                                    0x03c00000
+#define PHY_CTRL2_TX_MAN_CAL_GET(x)                                  (((x) & PHY_CTRL2_TX_MAN_CAL_MASK) >> PHY_CTRL2_TX_MAN_CAL_LSB)
+#define PHY_CTRL2_TX_MAN_CAL_SET(x)                                  (((x) << PHY_CTRL2_TX_MAN_CAL_LSB) & PHY_CTRL2_TX_MAN_CAL_MASK)
+#define PHY_CTRL2_TX_MAN_CAL_RESET                                   0x3 // 3
+#define PHY_CTRL2_TX_CAL_SEL_MSB                                     21
+#define PHY_CTRL2_TX_CAL_SEL_LSB                                     21
+#define PHY_CTRL2_TX_CAL_SEL_MASK                                    0x00200000
+#define PHY_CTRL2_TX_CAL_SEL_GET(x)                                  (((x) & PHY_CTRL2_TX_CAL_SEL_MASK) >> PHY_CTRL2_TX_CAL_SEL_LSB)
+#define PHY_CTRL2_TX_CAL_SEL_SET(x)                                  (((x) << PHY_CTRL2_TX_CAL_SEL_LSB) & PHY_CTRL2_TX_CAL_SEL_MASK)
+#define PHY_CTRL2_TX_CAL_SEL_RESET                                   0x1 // 1
+#define PHY_CTRL2_TX_CAL_EN_MSB                                      20
+#define PHY_CTRL2_TX_CAL_EN_LSB                                      20
+#define PHY_CTRL2_TX_CAL_EN_MASK                                     0x00100000
+#define PHY_CTRL2_TX_CAL_EN_GET(x)                                   (((x) & PHY_CTRL2_TX_CAL_EN_MASK) >> PHY_CTRL2_TX_CAL_EN_LSB)
+#define PHY_CTRL2_TX_CAL_EN_SET(x)                                   (((x) << PHY_CTRL2_TX_CAL_EN_LSB) & PHY_CTRL2_TX_CAL_EN_MASK)
+#define PHY_CTRL2_TX_CAL_EN_RESET                                    0x1 // 1
+#define PHY_CTRL2_PWD_ISP_MSB                                        13
+#define PHY_CTRL2_PWD_ISP_LSB                                        8
+#define PHY_CTRL2_PWD_ISP_MASK                                       0x00003f00
+#define PHY_CTRL2_PWD_ISP_GET(x)                                     (((x) & PHY_CTRL2_PWD_ISP_MASK) >> PHY_CTRL2_PWD_ISP_LSB)
+#define PHY_CTRL2_PWD_ISP_SET(x)                                     (((x) << PHY_CTRL2_PWD_ISP_LSB) & PHY_CTRL2_PWD_ISP_MASK)
+#define PHY_CTRL2_PWD_ISP_RESET                                      0x1b // 27
+#define PHY_CTRL2_PWD_IPLL_MSB                                       7
+#define PHY_CTRL2_PWD_IPLL_LSB                                       2
+#define PHY_CTRL2_PWD_IPLL_MASK                                      0x000000fc
+#define PHY_CTRL2_PWD_IPLL_GET(x)                                    (((x) & PHY_CTRL2_PWD_IPLL_MASK) >> PHY_CTRL2_PWD_IPLL_LSB)
+#define PHY_CTRL2_PWD_IPLL_SET(x)                                    (((x) << PHY_CTRL2_PWD_IPLL_LSB) & PHY_CTRL2_PWD_IPLL_MASK)
+#define PHY_CTRL2_PWD_IPLL_RESET                                     0x1b // 27
+#define PHY_CTRL2_HSRXPHASE_PS_EN_MSB                                1
+#define PHY_CTRL2_HSRXPHASE_PS_EN_LSB                                1
+#define PHY_CTRL2_HSRXPHASE_PS_EN_MASK                               0x00000002
+#define PHY_CTRL2_HSRXPHASE_PS_EN_GET(x)                             (((x) & PHY_CTRL2_HSRXPHASE_PS_EN_MASK) >> PHY_CTRL2_HSRXPHASE_PS_EN_LSB)
+#define PHY_CTRL2_HSRXPHASE_PS_EN_SET(x)                             (((x) << PHY_CTRL2_HSRXPHASE_PS_EN_LSB) & PHY_CTRL2_HSRXPHASE_PS_EN_MASK)
+#define PHY_CTRL2_HSRXPHASE_PS_EN_RESET                              0x0 // 0
+#define PHY_CTRL2_HSTXBIAS_PS_EN_MSB                                 0
+#define PHY_CTRL2_HSTXBIAS_PS_EN_LSB                                 0
+#define PHY_CTRL2_HSTXBIAS_PS_EN_MASK                                0x00000001
+#define PHY_CTRL2_HSTXBIAS_PS_EN_GET(x)                              (((x) & PHY_CTRL2_HSTXBIAS_PS_EN_MASK) >> PHY_CTRL2_HSTXBIAS_PS_EN_LSB)
+#define PHY_CTRL2_HSTXBIAS_PS_EN_SET(x)                              (((x) << PHY_CTRL2_HSTXBIAS_PS_EN_LSB) & PHY_CTRL2_HSTXBIAS_PS_EN_MASK)
+#define PHY_CTRL2_HSTXBIAS_PS_EN_RESET                               0x0 // 0
+#define PHY_CTRL2_ADDRESS                                            0x18116c88
+#define PHY_CTRL2_OFFSET                                             0x0008
+// SW modifiable bits
+#define PHY_CTRL2_SW_MASK                                            0xfff03fff
+// bits defined at reset
+#define PHY_CTRL2_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL2_RESET                                              0x00f01b6c
+
+#define PHY_CTRL3_SPARE_BITS_MSB                                     31
+#define PHY_CTRL3_SPARE_BITS_LSB                                     27
+#define PHY_CTRL3_SPARE_BITS_MASK                                    0xf8000000
+#define PHY_CTRL3_SPARE_BITS_GET(x)                                  (((x) & PHY_CTRL3_SPARE_BITS_MASK) >> PHY_CTRL3_SPARE_BITS_LSB)
+#define PHY_CTRL3_SPARE_BITS_SET(x)                                  (((x) << PHY_CTRL3_SPARE_BITS_LSB) & PHY_CTRL3_SPARE_BITS_MASK)
+#define PHY_CTRL3_SPARE_BITS_RESET                                   0x0 // 0
+#define PHY_CTRL3_SUS_RES_FIX_DIS_MSB                                26
+#define PHY_CTRL3_SUS_RES_FIX_DIS_LSB                                26
+#define PHY_CTRL3_SUS_RES_FIX_DIS_MASK                               0x04000000
+#define PHY_CTRL3_SUS_RES_FIX_DIS_GET(x)                             (((x) & PHY_CTRL3_SUS_RES_FIX_DIS_MASK) >> PHY_CTRL3_SUS_RES_FIX_DIS_LSB)
+#define PHY_CTRL3_SUS_RES_FIX_DIS_SET(x)                             (((x) << PHY_CTRL3_SUS_RES_FIX_DIS_LSB) & PHY_CTRL3_SUS_RES_FIX_DIS_MASK)
+#define PHY_CTRL3_SUS_RES_FIX_DIS_RESET                              0x0 // 0
+#define PHY_CTRL3_TX_STARTCAL_MSB                                    25
+#define PHY_CTRL3_TX_STARTCAL_LSB                                    25
+#define PHY_CTRL3_TX_STARTCAL_MASK                                   0x02000000
+#define PHY_CTRL3_TX_STARTCAL_GET(x)                                 (((x) & PHY_CTRL3_TX_STARTCAL_MASK) >> PHY_CTRL3_TX_STARTCAL_LSB)
+#define PHY_CTRL3_TX_STARTCAL_SET(x)                                 (((x) << PHY_CTRL3_TX_STARTCAL_LSB) & PHY_CTRL3_TX_STARTCAL_MASK)
+#define PHY_CTRL3_TX_STARTCAL_RESET                                  0x0 // 0
+#define PHY_CTRL3_TX_SELTEST_MSB                                     24
+#define PHY_CTRL3_TX_SELTEST_LSB                                     22
+#define PHY_CTRL3_TX_SELTEST_MASK                                    0x01c00000
+#define PHY_CTRL3_TX_SELTEST_GET(x)                                  (((x) & PHY_CTRL3_TX_SELTEST_MASK) >> PHY_CTRL3_TX_SELTEST_LSB)
+#define PHY_CTRL3_TX_SELTEST_SET(x)                                  (((x) << PHY_CTRL3_TX_SELTEST_LSB) & PHY_CTRL3_TX_SELTEST_MASK)
+#define PHY_CTRL3_TX_SELTEST_RESET                                   0x0 // 0
+#define PHY_CTRL3_TX_DISABLE_SHORT_DET_MSB                           21
+#define PHY_CTRL3_TX_DISABLE_SHORT_DET_LSB                           21
+#define PHY_CTRL3_TX_DISABLE_SHORT_DET_MASK                          0x00200000
+#define PHY_CTRL3_TX_DISABLE_SHORT_DET_GET(x)                        (((x) & PHY_CTRL3_TX_DISABLE_SHORT_DET_MASK) >> PHY_CTRL3_TX_DISABLE_SHORT_DET_LSB)
+#define PHY_CTRL3_TX_DISABLE_SHORT_DET_SET(x)                        (((x) << PHY_CTRL3_TX_DISABLE_SHORT_DET_LSB) & PHY_CTRL3_TX_DISABLE_SHORT_DET_MASK)
+#define PHY_CTRL3_TX_DISABLE_SHORT_DET_RESET                         0x0 // 0
+#define PHY_CTRL3_PWD_ITX_MSB                                        18
+#define PHY_CTRL3_PWD_ITX_LSB                                        0
+#define PHY_CTRL3_PWD_ITX_MASK                                       0x0007ffff
+#define PHY_CTRL3_PWD_ITX_GET(x)                                     (((x) & PHY_CTRL3_PWD_ITX_MASK) >> PHY_CTRL3_PWD_ITX_LSB)
+#define PHY_CTRL3_PWD_ITX_SET(x)                                     (((x) << PHY_CTRL3_PWD_ITX_LSB) & PHY_CTRL3_PWD_ITX_MASK)
+#define PHY_CTRL3_PWD_ITX_RESET                                      0x14765 // 83813
+#define PHY_CTRL3_ADDRESS                                            0x18116c8c
+#define PHY_CTRL3_OFFSET                                             0x000c
+// SW modifiable bits
+#define PHY_CTRL3_SW_MASK                                            0xffe7ffff
+// bits defined at reset
+#define PHY_CTRL3_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL3_RESET                                              0x00014765
+
+#define PHY_CTRL4_PPRBS_ERR_CNT_MSB                                  31
+#define PHY_CTRL4_PPRBS_ERR_CNT_LSB                                  24
+#define PHY_CTRL4_PPRBS_ERR_CNT_MASK                                 0xff000000
+#define PHY_CTRL4_PPRBS_ERR_CNT_GET(x)                               (((x) & PHY_CTRL4_PPRBS_ERR_CNT_MASK) >> PHY_CTRL4_PPRBS_ERR_CNT_LSB)
+#define PHY_CTRL4_PPRBS_ERR_CNT_SET(x)                               (((x) << PHY_CTRL4_PPRBS_ERR_CNT_LSB) & PHY_CTRL4_PPRBS_ERR_CNT_MASK)
+#define PHY_CTRL4_PPRBS_ERR_CNT_RESET                                0x0 // 0
+#define PHY_CTRL4_LS_PRBS_EN_MSB                                     21
+#define PHY_CTRL4_LS_PRBS_EN_LSB                                     21
+#define PHY_CTRL4_LS_PRBS_EN_MASK                                    0x00200000
+#define PHY_CTRL4_LS_PRBS_EN_GET(x)                                  (((x) & PHY_CTRL4_LS_PRBS_EN_MASK) >> PHY_CTRL4_LS_PRBS_EN_LSB)
+#define PHY_CTRL4_LS_PRBS_EN_SET(x)                                  (((x) << PHY_CTRL4_LS_PRBS_EN_LSB) & PHY_CTRL4_LS_PRBS_EN_MASK)
+#define PHY_CTRL4_LS_PRBS_EN_RESET                                   0x0 // 0
+#define PHY_CTRL4_PPRBS_TERM_SEL_MSB                                 20
+#define PHY_CTRL4_PPRBS_TERM_SEL_LSB                                 20
+#define PHY_CTRL4_PPRBS_TERM_SEL_MASK                                0x00100000
+#define PHY_CTRL4_PPRBS_TERM_SEL_GET(x)                              (((x) & PHY_CTRL4_PPRBS_TERM_SEL_MASK) >> PHY_CTRL4_PPRBS_TERM_SEL_LSB)
+#define PHY_CTRL4_PPRBS_TERM_SEL_SET(x)                              (((x) << PHY_CTRL4_PPRBS_TERM_SEL_LSB) & PHY_CTRL4_PPRBS_TERM_SEL_MASK)
+#define PHY_CTRL4_PPRBS_TERM_SEL_RESET                               0x0 // 0
+#define PHY_CTRL4_PPRBS_DIG_LPBK_EN_MSB                              19
+#define PHY_CTRL4_PPRBS_DIG_LPBK_EN_LSB                              19
+#define PHY_CTRL4_PPRBS_DIG_LPBK_EN_MASK                             0x00080000
+#define PHY_CTRL4_PPRBS_DIG_LPBK_EN_GET(x)                           (((x) & PHY_CTRL4_PPRBS_DIG_LPBK_EN_MASK) >> PHY_CTRL4_PPRBS_DIG_LPBK_EN_LSB)
+#define PHY_CTRL4_PPRBS_DIG_LPBK_EN_SET(x)                           (((x) << PHY_CTRL4_PPRBS_DIG_LPBK_EN_LSB) & PHY_CTRL4_PPRBS_DIG_LPBK_EN_MASK)
+#define PHY_CTRL4_PPRBS_DIG_LPBK_EN_RESET                            0x0 // 0
+#define PHY_CTRL4_PPRBS_ANA_LPBK_EN_MSB                              18
+#define PHY_CTRL4_PPRBS_ANA_LPBK_EN_LSB                              18
+#define PHY_CTRL4_PPRBS_ANA_LPBK_EN_MASK                             0x00040000
+#define PHY_CTRL4_PPRBS_ANA_LPBK_EN_GET(x)                           (((x) & PHY_CTRL4_PPRBS_ANA_LPBK_EN_MASK) >> PHY_CTRL4_PPRBS_ANA_LPBK_EN_LSB)
+#define PHY_CTRL4_PPRBS_ANA_LPBK_EN_SET(x)                           (((x) << PHY_CTRL4_PPRBS_ANA_LPBK_EN_LSB) & PHY_CTRL4_PPRBS_ANA_LPBK_EN_MASK)
+#define PHY_CTRL4_PPRBS_ANA_LPBK_EN_RESET                            0x0 // 0
+#define PHY_CTRL4_PPRBS_PAT_SEL_MSB                                  17
+#define PHY_CTRL4_PPRBS_PAT_SEL_LSB                                  16
+#define PHY_CTRL4_PPRBS_PAT_SEL_MASK                                 0x00030000
+#define PHY_CTRL4_PPRBS_PAT_SEL_GET(x)                               (((x) & PHY_CTRL4_PPRBS_PAT_SEL_MASK) >> PHY_CTRL4_PPRBS_PAT_SEL_LSB)
+#define PHY_CTRL4_PPRBS_PAT_SEL_SET(x)                               (((x) << PHY_CTRL4_PPRBS_PAT_SEL_LSB) & PHY_CTRL4_PPRBS_PAT_SEL_MASK)
+#define PHY_CTRL4_PPRBS_PAT_SEL_RESET                                0x0 // 0
+#define PHY_CTRL4_PPRBS_TX_EN_MSB                                    15
+#define PHY_CTRL4_PPRBS_TX_EN_LSB                                    15
+#define PHY_CTRL4_PPRBS_TX_EN_MASK                                   0x00008000
+#define PHY_CTRL4_PPRBS_TX_EN_GET(x)                                 (((x) & PHY_CTRL4_PPRBS_TX_EN_MASK) >> PHY_CTRL4_PPRBS_TX_EN_LSB)
+#define PHY_CTRL4_PPRBS_TX_EN_SET(x)                                 (((x) << PHY_CTRL4_PPRBS_TX_EN_LSB) & PHY_CTRL4_PPRBS_TX_EN_MASK)
+#define PHY_CTRL4_PPRBS_TX_EN_RESET                                  0x0 // 0
+#define PHY_CTRL4_PPRBS_RX_EN_MSB                                    14
+#define PHY_CTRL4_PPRBS_RX_EN_LSB                                    14
+#define PHY_CTRL4_PPRBS_RX_EN_MASK                                   0x00004000
+#define PHY_CTRL4_PPRBS_RX_EN_GET(x)                                 (((x) & PHY_CTRL4_PPRBS_RX_EN_MASK) >> PHY_CTRL4_PPRBS_RX_EN_LSB)
+#define PHY_CTRL4_PPRBS_RX_EN_SET(x)                                 (((x) << PHY_CTRL4_PPRBS_RX_EN_LSB) & PHY_CTRL4_PPRBS_RX_EN_MASK)
+#define PHY_CTRL4_PPRBS_RX_EN_RESET                                  0x0 // 0
+#define PHY_CTRL4_PPRBS_SPEED_SEL_MSB                                13
+#define PHY_CTRL4_PPRBS_SPEED_SEL_LSB                                13
+#define PHY_CTRL4_PPRBS_SPEED_SEL_MASK                               0x00002000
+#define PHY_CTRL4_PPRBS_SPEED_SEL_GET(x)                             (((x) & PHY_CTRL4_PPRBS_SPEED_SEL_MASK) >> PHY_CTRL4_PPRBS_SPEED_SEL_LSB)
+#define PHY_CTRL4_PPRBS_SPEED_SEL_SET(x)                             (((x) << PHY_CTRL4_PPRBS_SPEED_SEL_LSB) & PHY_CTRL4_PPRBS_SPEED_SEL_MASK)
+#define PHY_CTRL4_PPRBS_SPEED_SEL_RESET                              0x0 // 0
+#define PHY_CTRL4_PPRBS_RX_INV_MSB                                   12
+#define PHY_CTRL4_PPRBS_RX_INV_LSB                                   12
+#define PHY_CTRL4_PPRBS_RX_INV_MASK                                  0x00001000
+#define PHY_CTRL4_PPRBS_RX_INV_GET(x)                                (((x) & PHY_CTRL4_PPRBS_RX_INV_MASK) >> PHY_CTRL4_PPRBS_RX_INV_LSB)
+#define PHY_CTRL4_PPRBS_RX_INV_SET(x)                                (((x) << PHY_CTRL4_PPRBS_RX_INV_LSB) & PHY_CTRL4_PPRBS_RX_INV_MASK)
+#define PHY_CTRL4_PPRBS_RX_INV_RESET                                 0x0 // 0
+#define PHY_CTRL4_PWD_IRX_MSB                                        11
+#define PHY_CTRL4_PWD_IRX_LSB                                        0
+#define PHY_CTRL4_PWD_IRX_MASK                                       0x00000fff
+#define PHY_CTRL4_PWD_IRX_GET(x)                                     (((x) & PHY_CTRL4_PWD_IRX_MASK) >> PHY_CTRL4_PWD_IRX_LSB)
+#define PHY_CTRL4_PWD_IRX_SET(x)                                     (((x) << PHY_CTRL4_PWD_IRX_LSB) & PHY_CTRL4_PWD_IRX_MASK)
+#define PHY_CTRL4_PWD_IRX_RESET                                      0x6dd // 1757
+#define PHY_CTRL4_ADDRESS                                            0x18116c90
+#define PHY_CTRL4_OFFSET                                             0x0010
+// SW modifiable bits
+#define PHY_CTRL4_SW_MASK                                            0xff3fffff
+// bits defined at reset
+#define PHY_CTRL4_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL4_RESET                                              0x000006dd
+
+#define PHY_CTRL5_SPARE_BITS_MSB                                     31
+#define PHY_CTRL5_SPARE_BITS_LSB                                     30
+#define PHY_CTRL5_SPARE_BITS_MASK                                    0xc0000000
+#define PHY_CTRL5_SPARE_BITS_GET(x)                                  (((x) & PHY_CTRL5_SPARE_BITS_MASK) >> PHY_CTRL5_SPARE_BITS_LSB)
+#define PHY_CTRL5_SPARE_BITS_SET(x)                                  (((x) << PHY_CTRL5_SPARE_BITS_LSB) & PHY_CTRL5_SPARE_BITS_MASK)
+#define PHY_CTRL5_SPARE_BITS_RESET                                   0x0 // 0
+#define PHY_CTRL5_HOST_RES_FIX_EN_MSB                                29
+#define PHY_CTRL5_HOST_RES_FIX_EN_LSB                                29
+#define PHY_CTRL5_HOST_RES_FIX_EN_MASK                               0x20000000
+#define PHY_CTRL5_HOST_RES_FIX_EN_GET(x)                             (((x) & PHY_CTRL5_HOST_RES_FIX_EN_MASK) >> PHY_CTRL5_HOST_RES_FIX_EN_LSB)
+#define PHY_CTRL5_HOST_RES_FIX_EN_SET(x)                             (((x) << PHY_CTRL5_HOST_RES_FIX_EN_LSB) & PHY_CTRL5_HOST_RES_FIX_EN_MASK)
+#define PHY_CTRL5_HOST_RES_FIX_EN_RESET                              0x1 // 1
+#define PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_MSB                       28
+#define PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_LSB                       26
+#define PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_MASK                      0x1c000000
+#define PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_GET(x)                    (((x) & PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_MASK) >> PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_LSB)
+#define PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_SET(x)                    (((x) << PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_LSB) & PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_MASK)
+#define PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_RESET                     0x6 // 6
+#define PHY_CTRL5_HOST_DISCON_DETECT_ON_MSB                          25
+#define PHY_CTRL5_HOST_DISCON_DETECT_ON_LSB                          25
+#define PHY_CTRL5_HOST_DISCON_DETECT_ON_MASK                         0x02000000
+#define PHY_CTRL5_HOST_DISCON_DETECT_ON_GET(x)                       (((x) & PHY_CTRL5_HOST_DISCON_DETECT_ON_MASK) >> PHY_CTRL5_HOST_DISCON_DETECT_ON_LSB)
+#define PHY_CTRL5_HOST_DISCON_DETECT_ON_SET(x)                       (((x) << PHY_CTRL5_HOST_DISCON_DETECT_ON_LSB) & PHY_CTRL5_HOST_DISCON_DETECT_ON_MASK)
+#define PHY_CTRL5_HOST_DISCON_DETECT_ON_RESET                        0x1 // 1
+#define PHY_CTRL5_HOST_DISCON_FIX_ON_MSB                             24
+#define PHY_CTRL5_HOST_DISCON_FIX_ON_LSB                             24
+#define PHY_CTRL5_HOST_DISCON_FIX_ON_MASK                            0x01000000
+#define PHY_CTRL5_HOST_DISCON_FIX_ON_GET(x)                          (((x) & PHY_CTRL5_HOST_DISCON_FIX_ON_MASK) >> PHY_CTRL5_HOST_DISCON_FIX_ON_LSB)
+#define PHY_CTRL5_HOST_DISCON_FIX_ON_SET(x)                          (((x) << PHY_CTRL5_HOST_DISCON_FIX_ON_LSB) & PHY_CTRL5_HOST_DISCON_FIX_ON_MASK)
+#define PHY_CTRL5_HOST_DISCON_FIX_ON_RESET                           0x1 // 1
+#define PHY_CTRL5_DM_PULLDOWN_MSB                                    23
+#define PHY_CTRL5_DM_PULLDOWN_LSB                                    23
+#define PHY_CTRL5_DM_PULLDOWN_MASK                                   0x00800000
+#define PHY_CTRL5_DM_PULLDOWN_GET(x)                                 (((x) & PHY_CTRL5_DM_PULLDOWN_MASK) >> PHY_CTRL5_DM_PULLDOWN_LSB)
+#define PHY_CTRL5_DM_PULLDOWN_SET(x)                                 (((x) << PHY_CTRL5_DM_PULLDOWN_LSB) & PHY_CTRL5_DM_PULLDOWN_MASK)
+#define PHY_CTRL5_DM_PULLDOWN_RESET                                  0x0 // 0
+#define PHY_CTRL5_DP_PULLDOWN_MSB                                    22
+#define PHY_CTRL5_DP_PULLDOWN_LSB                                    22
+#define PHY_CTRL5_DP_PULLDOWN_MASK                                   0x00400000
+#define PHY_CTRL5_DP_PULLDOWN_GET(x)                                 (((x) & PHY_CTRL5_DP_PULLDOWN_MASK) >> PHY_CTRL5_DP_PULLDOWN_LSB)
+#define PHY_CTRL5_DP_PULLDOWN_SET(x)                                 (((x) << PHY_CTRL5_DP_PULLDOWN_LSB) & PHY_CTRL5_DP_PULLDOWN_MASK)
+#define PHY_CTRL5_DP_PULLDOWN_RESET                                  0x0 // 0
+#define PHY_CTRL5_SUSPEND_N_MSB                                      21
+#define PHY_CTRL5_SUSPEND_N_LSB                                      21
+#define PHY_CTRL5_SUSPEND_N_MASK                                     0x00200000
+#define PHY_CTRL5_SUSPEND_N_GET(x)                                   (((x) & PHY_CTRL5_SUSPEND_N_MASK) >> PHY_CTRL5_SUSPEND_N_LSB)
+#define PHY_CTRL5_SUSPEND_N_SET(x)                                   (((x) << PHY_CTRL5_SUSPEND_N_LSB) & PHY_CTRL5_SUSPEND_N_MASK)
+#define PHY_CTRL5_SUSPEND_N_RESET                                    0x1 // 1
+#define PHY_CTRL5_TERM_SEL_MSB                                       20
+#define PHY_CTRL5_TERM_SEL_LSB                                       20
+#define PHY_CTRL5_TERM_SEL_MASK                                      0x00100000
+#define PHY_CTRL5_TERM_SEL_GET(x)                                    (((x) & PHY_CTRL5_TERM_SEL_MASK) >> PHY_CTRL5_TERM_SEL_LSB)
+#define PHY_CTRL5_TERM_SEL_SET(x)                                    (((x) << PHY_CTRL5_TERM_SEL_LSB) & PHY_CTRL5_TERM_SEL_MASK)
+#define PHY_CTRL5_TERM_SEL_RESET                                     0x0 // 0
+#define PHY_CTRL5_XCVR_SEL_MSB                                       19
+#define PHY_CTRL5_XCVR_SEL_LSB                                       18
+#define PHY_CTRL5_XCVR_SEL_MASK                                      0x000c0000
+#define PHY_CTRL5_XCVR_SEL_GET(x)                                    (((x) & PHY_CTRL5_XCVR_SEL_MASK) >> PHY_CTRL5_XCVR_SEL_LSB)
+#define PHY_CTRL5_XCVR_SEL_SET(x)                                    (((x) << PHY_CTRL5_XCVR_SEL_LSB) & PHY_CTRL5_XCVR_SEL_MASK)
+#define PHY_CTRL5_XCVR_SEL_RESET                                     0x0 // 0
+#define PHY_CTRL5_TEST_JK_OVERRIDE_MSB                               17
+#define PHY_CTRL5_TEST_JK_OVERRIDE_LSB                               17
+#define PHY_CTRL5_TEST_JK_OVERRIDE_MASK                              0x00020000
+#define PHY_CTRL5_TEST_JK_OVERRIDE_GET(x)                            (((x) & PHY_CTRL5_TEST_JK_OVERRIDE_MASK) >> PHY_CTRL5_TEST_JK_OVERRIDE_LSB)
+#define PHY_CTRL5_TEST_JK_OVERRIDE_SET(x)                            (((x) << PHY_CTRL5_TEST_JK_OVERRIDE_LSB) & PHY_CTRL5_TEST_JK_OVERRIDE_MASK)
+#define PHY_CTRL5_TEST_JK_OVERRIDE_RESET                             0x0 // 0
+#define PHY_CTRL5_FORCE_TEST_SE0_NAK_MSB                             16
+#define PHY_CTRL5_FORCE_TEST_SE0_NAK_LSB                             16
+#define PHY_CTRL5_FORCE_TEST_SE0_NAK_MASK                            0x00010000
+#define PHY_CTRL5_FORCE_TEST_SE0_NAK_GET(x)                          (((x) & PHY_CTRL5_FORCE_TEST_SE0_NAK_MASK) >> PHY_CTRL5_FORCE_TEST_SE0_NAK_LSB)
+#define PHY_CTRL5_FORCE_TEST_SE0_NAK_SET(x)                          (((x) << PHY_CTRL5_FORCE_TEST_SE0_NAK_LSB) & PHY_CTRL5_FORCE_TEST_SE0_NAK_MASK)
+#define PHY_CTRL5_FORCE_TEST_SE0_NAK_RESET                           0x0 // 0
+#define PHY_CTRL5_FORCE_TEST_K_MSB                                   15
+#define PHY_CTRL5_FORCE_TEST_K_LSB                                   15
+#define PHY_CTRL5_FORCE_TEST_K_MASK                                  0x00008000
+#define PHY_CTRL5_FORCE_TEST_K_GET(x)                                (((x) & PHY_CTRL5_FORCE_TEST_K_MASK) >> PHY_CTRL5_FORCE_TEST_K_LSB)
+#define PHY_CTRL5_FORCE_TEST_K_SET(x)                                (((x) << PHY_CTRL5_FORCE_TEST_K_LSB) & PHY_CTRL5_FORCE_TEST_K_MASK)
+#define PHY_CTRL5_FORCE_TEST_K_RESET                                 0x0 // 0
+#define PHY_CTRL5_FORCE_TEST_J_MSB                                   14
+#define PHY_CTRL5_FORCE_TEST_J_LSB                                   14
+#define PHY_CTRL5_FORCE_TEST_J_MASK                                  0x00004000
+#define PHY_CTRL5_FORCE_TEST_J_GET(x)                                (((x) & PHY_CTRL5_FORCE_TEST_J_MASK) >> PHY_CTRL5_FORCE_TEST_J_LSB)
+#define PHY_CTRL5_FORCE_TEST_J_SET(x)                                (((x) << PHY_CTRL5_FORCE_TEST_J_LSB) & PHY_CTRL5_FORCE_TEST_J_MASK)
+#define PHY_CTRL5_FORCE_TEST_J_RESET                                 0x0 // 0
+#define PHY_CTRL5_FORCE_IDDQ_MSB                                     13
+#define PHY_CTRL5_FORCE_IDDQ_LSB                                     13
+#define PHY_CTRL5_FORCE_IDDQ_MASK                                    0x00002000
+#define PHY_CTRL5_FORCE_IDDQ_GET(x)                                  (((x) & PHY_CTRL5_FORCE_IDDQ_MASK) >> PHY_CTRL5_FORCE_IDDQ_LSB)
+#define PHY_CTRL5_FORCE_IDDQ_SET(x)                                  (((x) << PHY_CTRL5_FORCE_IDDQ_LSB) & PHY_CTRL5_FORCE_IDDQ_MASK)
+#define PHY_CTRL5_FORCE_IDDQ_RESET                                   0x0 // 0
+#define PHY_CTRL5_EB_WATERMARK_MSB                                   12
+#define PHY_CTRL5_EB_WATERMARK_LSB                                   7
+#define PHY_CTRL5_EB_WATERMARK_MASK                                  0x00001f80
+#define PHY_CTRL5_EB_WATERMARK_GET(x)                                (((x) & PHY_CTRL5_EB_WATERMARK_MASK) >> PHY_CTRL5_EB_WATERMARK_LSB)
+#define PHY_CTRL5_EB_WATERMARK_SET(x)                                (((x) << PHY_CTRL5_EB_WATERMARK_LSB) & PHY_CTRL5_EB_WATERMARK_MASK)
+#define PHY_CTRL5_EB_WATERMARK_RESET                                 0x14 // 20
+#define PHY_CTRL5_TX_BIAS_DELAY_MSB                                  6
+#define PHY_CTRL5_TX_BIAS_DELAY_LSB                                  0
+#define PHY_CTRL5_TX_BIAS_DELAY_MASK                                 0x0000007f
+#define PHY_CTRL5_TX_BIAS_DELAY_GET(x)                               (((x) & PHY_CTRL5_TX_BIAS_DELAY_MASK) >> PHY_CTRL5_TX_BIAS_DELAY_LSB)
+#define PHY_CTRL5_TX_BIAS_DELAY_SET(x)                               (((x) << PHY_CTRL5_TX_BIAS_DELAY_LSB) & PHY_CTRL5_TX_BIAS_DELAY_MASK)
+#define PHY_CTRL5_TX_BIAS_DELAY_RESET                                0x32 // 50
+#define PHY_CTRL5_ADDRESS                                            0x18116c94
+#define PHY_CTRL5_OFFSET                                             0x0014
+// SW modifiable bits
+#define PHY_CTRL5_SW_MASK                                            0xffffffff
+// bits defined at reset
+#define PHY_CTRL5_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL5_RESET                                              0x3b200a32
+#define PHY_CTRL5_RESET_1					     0x3b202a58
+
+#define PHY_CTRL6_SPARE_BITS_MSB                                     31
+#define PHY_CTRL6_SPARE_BITS_LSB                                     9
+#define PHY_CTRL6_SPARE_BITS_MASK                                    0xfffffe00
+#define PHY_CTRL6_SPARE_BITS_GET(x)                                  (((x) & PHY_CTRL6_SPARE_BITS_MASK) >> PHY_CTRL6_SPARE_BITS_LSB)
+#define PHY_CTRL6_SPARE_BITS_SET(x)                                  (((x) << PHY_CTRL6_SPARE_BITS_LSB) & PHY_CTRL6_SPARE_BITS_MASK)
+#define PHY_CTRL6_SPARE_BITS_RESET                                   0x0 // 0
+#define PHY_CTRL6_DIS_SETUP_RETRY_FIX_MSB                            8
+#define PHY_CTRL6_DIS_SETUP_RETRY_FIX_LSB                            8
+#define PHY_CTRL6_DIS_SETUP_RETRY_FIX_MASK                           0x00000100
+#define PHY_CTRL6_DIS_SETUP_RETRY_FIX_GET(x)                         (((x) & PHY_CTRL6_DIS_SETUP_RETRY_FIX_MASK) >> PHY_CTRL6_DIS_SETUP_RETRY_FIX_LSB)
+#define PHY_CTRL6_DIS_SETUP_RETRY_FIX_SET(x)                         (((x) << PHY_CTRL6_DIS_SETUP_RETRY_FIX_LSB) & PHY_CTRL6_DIS_SETUP_RETRY_FIX_MASK)
+#define PHY_CTRL6_DIS_SETUP_RETRY_FIX_RESET                          0x0 // 0
+#define PHY_CTRL6_XCVR_SEL_MSB                                       7
+#define PHY_CTRL6_XCVR_SEL_LSB                                       6
+#define PHY_CTRL6_XCVR_SEL_MASK                                      0x000000c0
+#define PHY_CTRL6_XCVR_SEL_GET(x)                                    (((x) & PHY_CTRL6_XCVR_SEL_MASK) >> PHY_CTRL6_XCVR_SEL_LSB)
+#define PHY_CTRL6_XCVR_SEL_SET(x)                                    (((x) << PHY_CTRL6_XCVR_SEL_LSB) & PHY_CTRL6_XCVR_SEL_MASK)
+#define PHY_CTRL6_XCVR_SEL_RESET                                     0x0 // 0
+#define PHY_CTRL6_XCVRSEL_OVERRIDE_MSB                               5
+#define PHY_CTRL6_XCVRSEL_OVERRIDE_LSB                               5
+#define PHY_CTRL6_XCVRSEL_OVERRIDE_MASK                              0x00000020
+#define PHY_CTRL6_XCVRSEL_OVERRIDE_GET(x)                            (((x) & PHY_CTRL6_XCVRSEL_OVERRIDE_MASK) >> PHY_CTRL6_XCVRSEL_OVERRIDE_LSB)
+#define PHY_CTRL6_XCVRSEL_OVERRIDE_SET(x)                            (((x) << PHY_CTRL6_XCVRSEL_OVERRIDE_LSB) & PHY_CTRL6_XCVRSEL_OVERRIDE_MASK)
+#define PHY_CTRL6_XCVRSEL_OVERRIDE_RESET                             0x0 // 0
+#define PHY_CTRL6_IDDIG_MSB                                          4
+#define PHY_CTRL6_IDDIG_LSB                                          4
+#define PHY_CTRL6_IDDIG_MASK                                         0x00000010
+#define PHY_CTRL6_IDDIG_GET(x)                                       (((x) & PHY_CTRL6_IDDIG_MASK) >> PHY_CTRL6_IDDIG_LSB)
+#define PHY_CTRL6_IDDIG_SET(x)                                       (((x) << PHY_CTRL6_IDDIG_LSB) & PHY_CTRL6_IDDIG_MASK)
+#define PHY_CTRL6_IDDIG_RESET                                        0x0 // 0
+#define PHY_CTRL6_SESSEND_MSB                                        3
+#define PHY_CTRL6_SESSEND_LSB                                        3
+#define PHY_CTRL6_SESSEND_MASK                                       0x00000008
+#define PHY_CTRL6_SESSEND_GET(x)                                     (((x) & PHY_CTRL6_SESSEND_MASK) >> PHY_CTRL6_SESSEND_LSB)
+#define PHY_CTRL6_SESSEND_SET(x)                                     (((x) << PHY_CTRL6_SESSEND_LSB) & PHY_CTRL6_SESSEND_MASK)
+#define PHY_CTRL6_SESSEND_RESET                                      0x0 // 0
+#define PHY_CTRL6_VBUSVALID_MSB                                      2
+#define PHY_CTRL6_VBUSVALID_LSB                                      2
+#define PHY_CTRL6_VBUSVALID_MASK                                     0x00000004
+#define PHY_CTRL6_VBUSVALID_GET(x)                                   (((x) & PHY_CTRL6_VBUSVALID_MASK) >> PHY_CTRL6_VBUSVALID_LSB)
+#define PHY_CTRL6_VBUSVALID_SET(x)                                   (((x) << PHY_CTRL6_VBUSVALID_LSB) & PHY_CTRL6_VBUSVALID_MASK)
+#define PHY_CTRL6_VBUSVALID_RESET                                    0x1 // 1
+#define PHY_CTRL6_BVALID_MSB                                         1
+#define PHY_CTRL6_BVALID_LSB                                         1
+#define PHY_CTRL6_BVALID_MASK                                        0x00000002
+#define PHY_CTRL6_BVALID_GET(x)                                      (((x) & PHY_CTRL6_BVALID_MASK) >> PHY_CTRL6_BVALID_LSB)
+#define PHY_CTRL6_BVALID_SET(x)                                      (((x) << PHY_CTRL6_BVALID_LSB) & PHY_CTRL6_BVALID_MASK)
+#define PHY_CTRL6_BVALID_RESET                                       0x1 // 1
+#define PHY_CTRL6_AVALID_MSB                                         0
+#define PHY_CTRL6_AVALID_LSB                                         0
+#define PHY_CTRL6_AVALID_MASK                                        0x00000001
+#define PHY_CTRL6_AVALID_GET(x)                                      (((x) & PHY_CTRL6_AVALID_MASK) >> PHY_CTRL6_AVALID_LSB)
+#define PHY_CTRL6_AVALID_SET(x)                                      (((x) << PHY_CTRL6_AVALID_LSB) & PHY_CTRL6_AVALID_MASK)
+#define PHY_CTRL6_AVALID_RESET                                       0x1 // 1
+#define PHY_CTRL6_ADDRESS                                            0x18116c98
+#define PHY_CTRL6_OFFSET                                             0x0018
+// SW modifiable bits
+#define PHY_CTRL6_SW_MASK                                            0xffffffff
+// bits defined at reset
+#define PHY_CTRL6_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL6_RESET                                              0x00000007
+
+#define PHY_STATUS_TX_CAL_MSB                                        3
+#define PHY_STATUS_TX_CAL_LSB                                        0
+#define PHY_STATUS_TX_CAL_MASK                                       0x0000000f
+#define PHY_STATUS_TX_CAL_GET(x)                                     (((x) & PHY_STATUS_TX_CAL_MASK) >> PHY_STATUS_TX_CAL_LSB)
+#define PHY_STATUS_TX_CAL_SET(x)                                     (((x) << PHY_STATUS_TX_CAL_LSB) & PHY_STATUS_TX_CAL_MASK)
+#define PHY_STATUS_TX_CAL_RESET                                      0x0 // 0
+#define PHY_STATUS_ADDRESS                                           0x18116c9c
+#define PHY_STATUS_OFFSET                                            0x001c
+// SW modifiable bits
+#define PHY_STATUS_SW_MASK                                           0x0000000f
+// bits defined at reset
+#define PHY_STATUS_RSTMASK                                           0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_STATUS_RESET                                             0x00000000
+
+#define PHY_CTRL7_PPRBS_ERROR_RATE_MSB                               31
+#define PHY_CTRL7_PPRBS_ERROR_RATE_LSB                               11
+#define PHY_CTRL7_PPRBS_ERROR_RATE_MASK                              0xfffff800
+#define PHY_CTRL7_PPRBS_ERROR_RATE_GET(x)                            (((x) & PHY_CTRL7_PPRBS_ERROR_RATE_MASK) >> PHY_CTRL7_PPRBS_ERROR_RATE_LSB)
+#define PHY_CTRL7_PPRBS_ERROR_RATE_SET(x)                            (((x) << PHY_CTRL7_PPRBS_ERROR_RATE_LSB) & PHY_CTRL7_PPRBS_ERROR_RATE_MASK)
+#define PHY_CTRL7_PPRBS_ERROR_RATE_RESET                             0xa000 // 40960
+#define PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_MSB                          10
+#define PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_LSB                          1
+#define PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_MASK                         0x000007fe
+#define PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_GET(x)                       (((x) & PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_MASK) >> PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_LSB)
+#define PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_SET(x)                       (((x) << PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_LSB) & PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_MASK)
+#define PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_RESET                        0x0 // 0
+#define PHY_CTRL7_PPRBS_TRIGGER_ERROR_MSB                            0
+#define PHY_CTRL7_PPRBS_TRIGGER_ERROR_LSB                            0
+#define PHY_CTRL7_PPRBS_TRIGGER_ERROR_MASK                           0x00000001
+#define PHY_CTRL7_PPRBS_TRIGGER_ERROR_GET(x)                         (((x) & PHY_CTRL7_PPRBS_TRIGGER_ERROR_MASK) >> PHY_CTRL7_PPRBS_TRIGGER_ERROR_LSB)
+#define PHY_CTRL7_PPRBS_TRIGGER_ERROR_SET(x)                         (((x) << PHY_CTRL7_PPRBS_TRIGGER_ERROR_LSB) & PHY_CTRL7_PPRBS_TRIGGER_ERROR_MASK)
+#define PHY_CTRL7_PPRBS_TRIGGER_ERROR_RESET                          0x0 // 0
+#define PHY_CTRL7_ADDRESS                                            0x18116ca0
+#define PHY_CTRL7_OFFSET                                             0x0020
+// SW modifiable bits
+#define PHY_CTRL7_SW_MASK                                            0xffffffff
+// bits defined at reset
+#define PHY_CTRL7_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL7_RESET                                              0x05000000
+
+#define PHY_CTRL8_USBPLL_PWD_MSB                                     7
+#define PHY_CTRL8_USBPLL_PWD_LSB                                     7
+#define PHY_CTRL8_USBPLL_PWD_MASK                                    0x00000080
+#define PHY_CTRL8_USBPLL_PWD_GET(x)                                  (((x) & PHY_CTRL8_USBPLL_PWD_MASK) >> PHY_CTRL8_USBPLL_PWD_LSB)
+#define PHY_CTRL8_USBPLL_PWD_SET(x)                                  (((x) << PHY_CTRL8_USBPLL_PWD_LSB) & PHY_CTRL8_USBPLL_PWD_MASK)
+#define PHY_CTRL8_USBPLL_PWD_RESET                                   0x0 // 0
+#define PHY_CTRL8_TX_FASTRISE_MSB                                    6
+#define PHY_CTRL8_TX_FASTRISE_LSB                                    4
+#define PHY_CTRL8_TX_FASTRISE_MASK                                   0x00000070
+#define PHY_CTRL8_TX_FASTRISE_GET(x)                                 (((x) & PHY_CTRL8_TX_FASTRISE_MASK) >> PHY_CTRL8_TX_FASTRISE_LSB)
+#define PHY_CTRL8_TX_FASTRISE_SET(x)                                 (((x) << PHY_CTRL8_TX_FASTRISE_LSB) & PHY_CTRL8_TX_FASTRISE_MASK)
+#define PHY_CTRL8_TX_FASTRISE_RESET                                  0x5 // 5
+#define PHY_CTRL8_TX_ENPRE_MSB                                       3
+#define PHY_CTRL8_TX_ENPRE_LSB                                       2
+#define PHY_CTRL8_TX_ENPRE_MASK                                      0x0000000c
+#define PHY_CTRL8_TX_ENPRE_GET(x)                                    (((x) & PHY_CTRL8_TX_ENPRE_MASK) >> PHY_CTRL8_TX_ENPRE_LSB)
+#define PHY_CTRL8_TX_ENPRE_SET(x)                                    (((x) << PHY_CTRL8_TX_ENPRE_LSB) & PHY_CTRL8_TX_ENPRE_MASK)
+#define PHY_CTRL8_TX_ENPRE_RESET                                     0x0 // 0
+#define PHY_CTRL8_RX_SQ_HYST_EN_MSB                                  1
+#define PHY_CTRL8_RX_SQ_HYST_EN_LSB                                  1
+#define PHY_CTRL8_RX_SQ_HYST_EN_MASK                                 0x00000002
+#define PHY_CTRL8_RX_SQ_HYST_EN_GET(x)                               (((x) & PHY_CTRL8_RX_SQ_HYST_EN_MASK) >> PHY_CTRL8_RX_SQ_HYST_EN_LSB)
+#define PHY_CTRL8_RX_SQ_HYST_EN_SET(x)                               (((x) << PHY_CTRL8_RX_SQ_HYST_EN_LSB) & PHY_CTRL8_RX_SQ_HYST_EN_MASK)
+#define PHY_CTRL8_RX_SQ_HYST_EN_RESET                                0x0 // 0
+#define PHY_CTRL8_RX_SKIP2_MSB                                       0
+#define PHY_CTRL8_RX_SKIP2_LSB                                       0
+#define PHY_CTRL8_RX_SKIP2_MASK                                      0x00000001
+#define PHY_CTRL8_RX_SKIP2_GET(x)                                    (((x) & PHY_CTRL8_RX_SKIP2_MASK) >> PHY_CTRL8_RX_SKIP2_LSB)
+#define PHY_CTRL8_RX_SKIP2_SET(x)                                    (((x) << PHY_CTRL8_RX_SKIP2_LSB) & PHY_CTRL8_RX_SKIP2_MASK)
+#define PHY_CTRL8_RX_SKIP2_RESET                                     0x0 // 0
+#define PHY_CTRL8_ADDRESS                                            0x18116ca4
+#define PHY_CTRL8_OFFSET                                             0x0024
+// SW modifiable bits
+#define PHY_CTRL8_SW_MASK                                            0x000000ff
+// bits defined at reset
+#define PHY_CTRL8_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL8_RESET                                              0x00000050
+#define CPU_DDR_CLOCK_CONTROL_SPARE_MSB                              31
+#define CPU_DDR_CLOCK_CONTROL_SPARE_LSB                              25
+#define CPU_DDR_CLOCK_CONTROL_SPARE_MASK                             0xfe000000
+#define CPU_DDR_CLOCK_CONTROL_SPARE_GET(x)                           (((x) & CPU_DDR_CLOCK_CONTROL_SPARE_MASK) >> CPU_DDR_CLOCK_CONTROL_SPARE_LSB)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_SET(x)                           (((x) << CPU_DDR_CLOCK_CONTROL_SPARE_LSB) & CPU_DDR_CLOCK_CONTROL_SPARE_MASK)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_RESET                            0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MSB                 24
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB                 24
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK                0x01000000
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB) & CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_RESET               0x1 // 1
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MSB            23
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB            23
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK           0x00800000
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_GET(x)         (((x) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_SET(x)         (((x) << CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_RESET          0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MSB               22
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB               22
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK              0x00400000
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_GET(x)            (((x) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_SET(x)            (((x) << CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_RESET             0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MSB                 21
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_LSB                 21
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MASK                0x00200000
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_LSB) & CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_RESET               0x1 // 1
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MSB                 20
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_LSB                 20
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MASK                0x00100000
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_LSB) & CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_RESET               0x1 // 1
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MSB                       19
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB                       15
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK                      0x000f8000
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_RESET                     0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MSB                       14
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB                       10
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK                      0x00007c00
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_RESET                     0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MSB                       9
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB                       5
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK                      0x000003e0
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_RESET                     0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MSB                     4
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB                     4
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK                    0x00000010
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_RESET                   0x1 // 1
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MSB                     3
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB                     3
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK                    0x00000008
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_RESET                   0x1 // 1
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MSB                     2
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB                     2
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK                    0x00000004
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_RESET                   0x1 // 1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MSB                       1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB                       1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK                      0x00000002
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK) >> CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB)
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB) & CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK)
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_RESET                     0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MSB                       0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB                       0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK                      0x00000001
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK) >> CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB) & CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_RESET                     0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_ADDRESS                                0x18050008
+
+#define PCIE_PLL_CONFIG_UPDATING_MSB                                 31
+#define PCIE_PLL_CONFIG_UPDATING_LSB                                 31
+#define PCIE_PLL_CONFIG_UPDATING_MASK                                0x80000000
+#define PCIE_PLL_CONFIG_UPDATING_GET(x)                              (((x) & PCIE_PLL_CONFIG_UPDATING_MASK) >> PCIE_PLL_CONFIG_UPDATING_LSB)
+#define PCIE_PLL_CONFIG_UPDATING_SET(x)                              (((x) << PCIE_PLL_CONFIG_UPDATING_LSB) & PCIE_PLL_CONFIG_UPDATING_MASK)
+#define PCIE_PLL_CONFIG_UPDATING_RESET                               0x0 // 0
+#define PCIE_PLL_CONFIG_PLLPWD_MSB                                   30
+#define PCIE_PLL_CONFIG_PLLPWD_LSB                                   30
+#define PCIE_PLL_CONFIG_PLLPWD_MASK                                  0x40000000
+#define PCIE_PLL_CONFIG_PLLPWD_GET(x)                                (((x) & PCIE_PLL_CONFIG_PLLPWD_MASK) >> PCIE_PLL_CONFIG_PLLPWD_LSB)
+#define PCIE_PLL_CONFIG_PLLPWD_SET(x)                                (((x) << PCIE_PLL_CONFIG_PLLPWD_LSB) & PCIE_PLL_CONFIG_PLLPWD_MASK)
+#define PCIE_PLL_CONFIG_PLLPWD_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_BYPASS_MSB                                   16
+#define PCIE_PLL_CONFIG_BYPASS_LSB                                   16
+#define PCIE_PLL_CONFIG_BYPASS_MASK                                  0x00010000
+#define PCIE_PLL_CONFIG_BYPASS_GET(x)                                (((x) & PCIE_PLL_CONFIG_BYPASS_MASK) >> PCIE_PLL_CONFIG_BYPASS_LSB)
+#define PCIE_PLL_CONFIG_BYPASS_SET(x)                                (((x) << PCIE_PLL_CONFIG_BYPASS_LSB) & PCIE_PLL_CONFIG_BYPASS_MASK)
+#define PCIE_PLL_CONFIG_BYPASS_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_REFDIV_MSB                                   14
+#define PCIE_PLL_CONFIG_REFDIV_LSB                                   10
+#define PCIE_PLL_CONFIG_REFDIV_MASK                                  0x00007c00
+#define PCIE_PLL_CONFIG_REFDIV_GET(x)                                (((x) & PCIE_PLL_CONFIG_REFDIV_MASK) >> PCIE_PLL_CONFIG_REFDIV_LSB)
+#define PCIE_PLL_CONFIG_REFDIV_SET(x)                                (((x) << PCIE_PLL_CONFIG_REFDIV_LSB) & PCIE_PLL_CONFIG_REFDIV_MASK)
+#define PCIE_PLL_CONFIG_REFDIV_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_ADDRESS                                      0x18050010
+
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MSB                        31
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB                        31
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK                       0x80000000
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_GET(x)                     (((x) & PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK) >> PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_SET(x)                     (((x) << PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB) & PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_RESET                      0x1 // 1
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MSB                          30
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB                          30
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK                         0x40000000
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_GET(x)                       (((x) & PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK) >> PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(x)                       (((x) << PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB) & PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_RESET                        0x1 // 1
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MSB                      20
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB                      15
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK                     0x001f8000
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_GET(x)                   (((x) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK) >> PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(x)                   (((x) << PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_RESET                    0x13 // 19
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MSB                     14
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB                     1
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK                    0x00007ffe
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_GET(x)                  (((x) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK) >> PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(x)                  (((x) << PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_RESET                   0x3fff // 16383
+#define PCIE_PLL_DITHER_DIV_MAX_ADDRESS                              0x18050014
+
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MSB                      20
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB                      15
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK                     0x001f8000
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_GET(x)                   (((x) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK) >> PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_SET(x)                   (((x) << PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_RESET                    0x13 // 19
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MSB                     14
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB                     1
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK                    0x00007ffe
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_GET(x)                  (((x) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK) >> PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_SET(x)                  (((x) << PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_RESET                   0x399d // 14749
+#define PCIE_PLL_DITHER_DIV_MIN_ADDRESS                              0x18050018
+
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_MSB                          31
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB                          28
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK                         0xf0000000
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_GET(x)                       (((x) & PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK) >> PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_SET(x)                       (((x) << PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB) & PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_RESET                        0x0 // 0
+#define PCIE_PLL_DITHER_STEP_STEP_INT_MSB                            24
+#define PCIE_PLL_DITHER_STEP_STEP_INT_LSB                            15
+#define PCIE_PLL_DITHER_STEP_STEP_INT_MASK                           0x01ff8000
+#define PCIE_PLL_DITHER_STEP_STEP_INT_GET(x)                         (((x) & PCIE_PLL_DITHER_STEP_STEP_INT_MASK) >> PCIE_PLL_DITHER_STEP_STEP_INT_LSB)
+#define PCIE_PLL_DITHER_STEP_STEP_INT_SET(x)                         (((x) << PCIE_PLL_DITHER_STEP_STEP_INT_LSB) & PCIE_PLL_DITHER_STEP_STEP_INT_MASK)
+#define PCIE_PLL_DITHER_STEP_STEP_INT_RESET                          0x0 // 0
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_MSB                           14
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB                           1
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK                          0x00007ffe
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_GET(x)                        (((x) & PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK) >> PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB)
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_SET(x)                        (((x) << PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB) & PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK)
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_RESET                         0xa // 10
+#define PCIE_PLL_DITHER_STEP_ADDRESS                                 0x1805001c
+
+
+
+// 32'h180f0008 (PCIE_PWR_MGMT)
+#define PCIE_PWR_MGMT_PME_INT_MSB                                    8
+#define PCIE_PWR_MGMT_PME_INT_LSB                                    8
+#define PCIE_PWR_MGMT_PME_INT_MASK                                   0x00000100
+#define PCIE_PWR_MGMT_PME_INT_GET(x)                                 (((x) & PCIE_PWR_MGMT_PME_INT_MASK) >> PCIE_PWR_MGMT_PME_INT_LSB)
+#define PCIE_PWR_MGMT_PME_INT_SET(x)                                 (((x) << PCIE_PWR_MGMT_PME_INT_LSB) & PCIE_PWR_MGMT_PME_INT_MASK)
+#define PCIE_PWR_MGMT_PME_INT_RESET                                  0x0 // 0
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_MSB                             7
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_LSB                             7
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_MASK                            0x00000080
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_GET(x)                          (((x) & PCIE_PWR_MGMT_ASSERT_CLKREQN_MASK) >> PCIE_PWR_MGMT_ASSERT_CLKREQN_LSB)
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_SET(x)                          (((x) << PCIE_PWR_MGMT_ASSERT_CLKREQN_LSB) & PCIE_PWR_MGMT_ASSERT_CLKREQN_MASK)
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_RESET                           0x0 // 0
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_MSB                             6
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_LSB                             6
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_MASK                            0x00000040
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_GET(x)                          (((x) & PCIE_PWR_MGMT_RADM_PM_TO_ACK_MASK) >> PCIE_PWR_MGMT_RADM_PM_TO_ACK_LSB)
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_SET(x)                          (((x) << PCIE_PWR_MGMT_RADM_PM_TO_ACK_LSB) & PCIE_PWR_MGMT_RADM_PM_TO_ACK_MASK)
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_RESET                           0x0 // 0
+#define PCIE_PWR_MGMT_RADM_PM_PME_MSB                                5
+#define PCIE_PWR_MGMT_RADM_PM_PME_LSB                                5
+#define PCIE_PWR_MGMT_RADM_PM_PME_MASK                               0x00000020
+#define PCIE_PWR_MGMT_RADM_PM_PME_GET(x)                             (((x) & PCIE_PWR_MGMT_RADM_PM_PME_MASK) >> PCIE_PWR_MGMT_RADM_PM_PME_LSB)
+#define PCIE_PWR_MGMT_RADM_PM_PME_SET(x)                             (((x) << PCIE_PWR_MGMT_RADM_PM_PME_LSB) & PCIE_PWR_MGMT_RADM_PM_PME_MASK)
+#define PCIE_PWR_MGMT_RADM_PM_PME_RESET                              0x0 // 0
+#define PCIE_PWR_MGMT_AUX_PM_EN_MSB                                  4
+#define PCIE_PWR_MGMT_AUX_PM_EN_LSB                                  4
+#define PCIE_PWR_MGMT_AUX_PM_EN_MASK                                 0x00000010
+#define PCIE_PWR_MGMT_AUX_PM_EN_GET(x)                               (((x) & PCIE_PWR_MGMT_AUX_PM_EN_MASK) >> PCIE_PWR_MGMT_AUX_PM_EN_LSB)
+#define PCIE_PWR_MGMT_AUX_PM_EN_SET(x)                               (((x) << PCIE_PWR_MGMT_AUX_PM_EN_LSB) & PCIE_PWR_MGMT_AUX_PM_EN_MASK)
+#define PCIE_PWR_MGMT_AUX_PM_EN_RESET                                0x0 // 0
+#define PCIE_PWR_MGMT_READY_ENTR_L23_MSB                             3
+#define PCIE_PWR_MGMT_READY_ENTR_L23_LSB                             3
+#define PCIE_PWR_MGMT_READY_ENTR_L23_MASK                            0x00000008
+#define PCIE_PWR_MGMT_READY_ENTR_L23_GET(x)                          (((x) & PCIE_PWR_MGMT_READY_ENTR_L23_MASK) >> PCIE_PWR_MGMT_READY_ENTR_L23_LSB)
+#define PCIE_PWR_MGMT_READY_ENTR_L23_SET(x)                          (((x) << PCIE_PWR_MGMT_READY_ENTR_L23_LSB) & PCIE_PWR_MGMT_READY_ENTR_L23_MASK)
+#define PCIE_PWR_MGMT_READY_ENTR_L23_RESET                           0x0 // 0
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_MSB                                2
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_LSB                                2
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_MASK                               0x00000004
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_GET(x)                             (((x) & PCIE_PWR_MGMT_REQ_EXIT_L1_MASK) >> PCIE_PWR_MGMT_REQ_EXIT_L1_LSB)
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_SET(x)                             (((x) << PCIE_PWR_MGMT_REQ_EXIT_L1_LSB) & PCIE_PWR_MGMT_REQ_EXIT_L1_MASK)
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_RESET                              0x0 // 0
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_MSB                               1
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_LSB                               1
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_MASK                              0x00000002
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_GET(x)                            (((x) & PCIE_PWR_MGMT_REQ_ENTRY_L1_MASK) >> PCIE_PWR_MGMT_REQ_ENTRY_L1_LSB)
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_SET(x)                            (((x) << PCIE_PWR_MGMT_REQ_ENTRY_L1_LSB) & PCIE_PWR_MGMT_REQ_ENTRY_L1_MASK)
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_RESET                             0x0 // 0
+#define PCIE_PWR_MGMT_AUX_PWR_DET_MSB                                0
+#define PCIE_PWR_MGMT_AUX_PWR_DET_LSB                                0
+#define PCIE_PWR_MGMT_AUX_PWR_DET_MASK                               0x00000001
+#define PCIE_PWR_MGMT_AUX_PWR_DET_GET(x)                             (((x) & PCIE_PWR_MGMT_AUX_PWR_DET_MASK) >> PCIE_PWR_MGMT_AUX_PWR_DET_LSB)
+#define PCIE_PWR_MGMT_AUX_PWR_DET_SET(x)                             (((x) << PCIE_PWR_MGMT_AUX_PWR_DET_LSB) & PCIE_PWR_MGMT_AUX_PWR_DET_MASK)
+#define PCIE_PWR_MGMT_AUX_PWR_DET_RESET                              0x0 // 0
+#define PCIE_PWR_MGMT_ADDRESS                                        0x180f0008
+#define PCIE_PWR_MGMT_OFFSET                                         0x0008
+// SW modifiable bits
+#define PCIE_PWR_MGMT_SW_MASK                                        0x000001ff
+// bits defined at reset
+#define PCIE_PWR_MGMT_RSTMASK                                        0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PWR_MGMT_RESET                                          0x00000000
+
+
+// 32'h180600c0 (RST_CLKGAT_EN)
+#define RST_CLKGAT_EN_SPARE_MSB                                      31
+#define RST_CLKGAT_EN_SPARE_LSB                                      12
+#define RST_CLKGAT_EN_SPARE_MASK                                     0xfffff000
+#define RST_CLKGAT_EN_SPARE_GET(x)                                   (((x) & RST_CLKGAT_EN_SPARE_MASK) >> RST_CLKGAT_EN_SPARE_LSB)
+#define RST_CLKGAT_EN_SPARE_SET(x)                                   (((x) << RST_CLKGAT_EN_SPARE_LSB) & RST_CLKGAT_EN_SPARE_MASK)
+#define RST_CLKGAT_EN_SPARE_RESET                                    0x0 // 0
+#define RST_CLKGAT_EN_WMAC_MSB                                       9
+#define RST_CLKGAT_EN_WMAC_LSB                                       9
+#define RST_CLKGAT_EN_WMAC_MASK                                      0x00000200
+#define RST_CLKGAT_EN_WMAC_GET(x)                                    (((x) & RST_CLKGAT_EN_WMAC_MASK) >> RST_CLKGAT_EN_WMAC_LSB)
+#define RST_CLKGAT_EN_WMAC_SET(x)                                    (((x) << RST_CLKGAT_EN_WMAC_LSB) & RST_CLKGAT_EN_WMAC_MASK)
+#define RST_CLKGAT_EN_WMAC_RESET                                     0x1 // 1
+#define RST_CLKGAT_EN_USB1_MSB                                       7
+#define RST_CLKGAT_EN_USB1_LSB                                       7
+#define RST_CLKGAT_EN_USB1_MASK                                      0x00000080
+#define RST_CLKGAT_EN_USB1_GET(x)                                    (((x) & RST_CLKGAT_EN_USB1_MASK) >> RST_CLKGAT_EN_USB1_LSB)
+#define RST_CLKGAT_EN_USB1_SET(x)                                    (((x) << RST_CLKGAT_EN_USB1_LSB) & RST_CLKGAT_EN_USB1_MASK)
+#define RST_CLKGAT_EN_USB1_RESET                                     0x1 // 1
+#define RST_CLKGAT_EN_GE1_MSB                                        6
+#define RST_CLKGAT_EN_GE1_LSB                                        6
+#define RST_CLKGAT_EN_GE1_MASK                                       0x00000040
+#define RST_CLKGAT_EN_GE1_GET(x)                                     (((x) & RST_CLKGAT_EN_GE1_MASK) >> RST_CLKGAT_EN_GE1_LSB)
+#define RST_CLKGAT_EN_GE1_SET(x)                                     (((x) << RST_CLKGAT_EN_GE1_LSB) & RST_CLKGAT_EN_GE1_MASK)
+#define RST_CLKGAT_EN_GE1_RESET                                      0x1 // 1
+#define RST_CLKGAT_EN_GE0_MSB                                        5
+#define RST_CLKGAT_EN_GE0_LSB                                        5
+#define RST_CLKGAT_EN_GE0_MASK                                       0x00000020
+#define RST_CLKGAT_EN_GE0_GET(x)                                     (((x) & RST_CLKGAT_EN_GE0_MASK) >> RST_CLKGAT_EN_GE0_LSB)
+#define RST_CLKGAT_EN_GE0_SET(x)                                     (((x) << RST_CLKGAT_EN_GE0_LSB) & RST_CLKGAT_EN_GE0_MASK)
+#define RST_CLKGAT_EN_GE0_RESET                                      0x1 // 1
+#define RST_CLKGAT_EN_PCIE_RC_MSB                                    1
+#define RST_CLKGAT_EN_PCIE_RC_LSB                                    1
+#define RST_CLKGAT_EN_PCIE_RC_MASK                                   0x00000002
+#define RST_CLKGAT_EN_PCIE_RC_GET(x)                                 (((x) & RST_CLKGAT_EN_PCIE_RC_MASK) >> RST_CLKGAT_EN_PCIE_RC_LSB)
+#define RST_CLKGAT_EN_PCIE_RC_SET(x)                                 (((x) << RST_CLKGAT_EN_PCIE_RC_LSB) & RST_CLKGAT_EN_PCIE_RC_MASK)
+#define RST_CLKGAT_EN_PCIE_RC_RESET                                  0x1 // 1
+#define RST_CLKGAT_EN_ADDRESS                                        0x180600c0
+#define RST_CLKGAT_EN_OFFSET                                         0x00c0
+// SW modifiable bits
+#define RST_CLKGAT_EN_SW_MASK                                        0xfffff2e2
+// bits defined at reset
+#define RST_CLKGAT_EN_RSTMASK                                        0xffffffff
+// reset value (ignore bits undefined at reset)
+#define RST_CLKGAT_EN_RESET                                          0x000002e2
+
+
+
+#define PCIE_PHY_REG_1_ADDRESS                                       0x18116cc0
+#define PCIE_PHY_REG_3_ADDRESS                                       0x18116cc8
+
+
+
+
+
+#define LDO_POWER_CONTROL_PKG_SEL_MSB                                5
+#define LDO_POWER_CONTROL_PKG_SEL_LSB                                5
+#define LDO_POWER_CONTROL_PKG_SEL_MASK                               0x00000020
+#define LDO_POWER_CONTROL_PKG_SEL_GET(x)                             (((x) & LDO_POWER_CONTROL_PKG_SEL_MASK) >> LDO_POWER_CONTROL_PKG_SEL_LSB)
+#define LDO_POWER_CONTROL_PKG_SEL_SET(x)                             (((x) << LDO_POWER_CONTROL_PKG_SEL_LSB) & LDO_POWER_CONTROL_PKG_SEL_MASK)
+#define LDO_POWER_CONTROL_PKG_SEL_RESET                              0x0 // 0
+#define LDO_POWER_CONTROL_PWDLDO_CPU_MSB                             4
+#define LDO_POWER_CONTROL_PWDLDO_CPU_LSB                             4
+#define LDO_POWER_CONTROL_PWDLDO_CPU_MASK                            0x00000010
+#define LDO_POWER_CONTROL_PWDLDO_CPU_GET(x)                          (((x) & LDO_POWER_CONTROL_PWDLDO_CPU_MASK) >> LDO_POWER_CONTROL_PWDLDO_CPU_LSB)
+#define LDO_POWER_CONTROL_PWDLDO_CPU_SET(x)                          (((x) << LDO_POWER_CONTROL_PWDLDO_CPU_LSB) & LDO_POWER_CONTROL_PWDLDO_CPU_MASK)
+#define LDO_POWER_CONTROL_PWDLDO_CPU_RESET                           0x0 // 0
+#define LDO_POWER_CONTROL_PWDLDO_DDR_MSB                             3
+#define LDO_POWER_CONTROL_PWDLDO_DDR_LSB                             3
+#define LDO_POWER_CONTROL_PWDLDO_DDR_MASK                            0x00000008
+#define LDO_POWER_CONTROL_PWDLDO_DDR_GET(x)                          (((x) & LDO_POWER_CONTROL_PWDLDO_DDR_MASK) >> LDO_POWER_CONTROL_PWDLDO_DDR_LSB)
+#define LDO_POWER_CONTROL_PWDLDO_DDR_SET(x)                          (((x) << LDO_POWER_CONTROL_PWDLDO_DDR_LSB) & LDO_POWER_CONTROL_PWDLDO_DDR_MASK)
+#define LDO_POWER_CONTROL_PWDLDO_DDR_RESET                           0x0 // 0
+#define LDO_POWER_CONTROL_CPU_REFSEL_MSB                             2
+#define LDO_POWER_CONTROL_CPU_REFSEL_LSB                             1
+#define LDO_POWER_CONTROL_CPU_REFSEL_MASK                            0x00000006
+#define LDO_POWER_CONTROL_CPU_REFSEL_GET(x)                          (((x) & LDO_POWER_CONTROL_CPU_REFSEL_MASK) >> LDO_POWER_CONTROL_CPU_REFSEL_LSB)
+#define LDO_POWER_CONTROL_CPU_REFSEL_SET(x)                          (((x) << LDO_POWER_CONTROL_CPU_REFSEL_LSB) & LDO_POWER_CONTROL_CPU_REFSEL_MASK)
+#define LDO_POWER_CONTROL_CPU_REFSEL_RESET                           0x3 // 3
+#define LDO_POWER_CONTROL_SELECT_DDR1_MSB                            0
+#define LDO_POWER_CONTROL_SELECT_DDR1_LSB                            0
+#define LDO_POWER_CONTROL_SELECT_DDR1_MASK                           0x00000001
+#define LDO_POWER_CONTROL_SELECT_DDR1_GET(x)                         (((x) & LDO_POWER_CONTROL_SELECT_DDR1_MASK) >> LDO_POWER_CONTROL_SELECT_DDR1_LSB)
+#define LDO_POWER_CONTROL_SELECT_DDR1_SET(x)                         (((x) << LDO_POWER_CONTROL_SELECT_DDR1_LSB) & LDO_POWER_CONTROL_SELECT_DDR1_MASK)
+#define LDO_POWER_CONTROL_SELECT_DDR1_RESET                          0x0 // 0
+#define LDO_POWER_CONTROL_ADDRESS                                    0x18050020
+
+#define SWITCH_CLOCK_SPARE_SPARE_MSB                                 31
+#define SWITCH_CLOCK_SPARE_SPARE_LSB                                 12
+#define SWITCH_CLOCK_SPARE_SPARE_MASK                                0xfffff000
+#define SWITCH_CLOCK_SPARE_SPARE_GET(x)                              (((x) & SWITCH_CLOCK_SPARE_SPARE_MASK) >> SWITCH_CLOCK_SPARE_SPARE_LSB)
+#define SWITCH_CLOCK_SPARE_SPARE_SET(x)                              (((x) << SWITCH_CLOCK_SPARE_SPARE_LSB) & SWITCH_CLOCK_SPARE_SPARE_MASK)
+#define SWITCH_CLOCK_SPARE_SPARE_RESET                               0x0 // 0
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MSB                   11
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB                   8
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK                  0x00000f00
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_GET(x)                (((x) & SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK) >> SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(x)                (((x) << SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB) & SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_RESET                 0x5 // 5
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MSB                         7
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB                         7
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK                        0x00000080
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_GET(x)                      (((x) & SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_SET(x)                      (((x) << SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_RESET                       0x0 // 0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MSB                          6
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_LSB                          6
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MASK                         0x00000040
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_GET(x)                       (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_SET(x)                       (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_RESET                        0x0 // 0
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MSB                       5
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB                       5
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK                      0x00000020
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK) >> SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB)
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB) & SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK)
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_RESET                     0x1 // 1
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_MSB                            4
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB                            4
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK                           0x00000010
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_GET(x)                         (((x) & SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK) >> SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB)
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_SET(x)                         (((x) << SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB) & SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK)
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_RESET                          0x1 // 1
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_MSB                            3
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB                            3
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK                           0x00000008
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_GET(x)                         (((x) & SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK) >> SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB)
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_SET(x)                         (((x) << SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB) & SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK)
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_RESET                          0x0 // 0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MSB             2
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_LSB             2
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MASK            0x00000004
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_GET(x)          (((x) & SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MASK) >> SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_LSB)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_SET(x)          (((x) << SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_LSB) & SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MASK)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_RESET           0x0 // 0
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MSB                  1
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB                  1
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK                 0x00000002
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_GET(x)               (((x) & SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK) >> SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB)
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_SET(x)               (((x) << SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB) & SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK)
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_RESET                0x0 // 0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MSB                         0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB                         0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK                        0x00000001
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_GET(x)                      (((x) & SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_SET(x)                      (((x) << SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB) & SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_RESET                       0x1 // 1
+#define SWITCH_CLOCK_SPARE_ADDRESS                                   0x18050024
+
+#define CURRENT_PCIE_PLL_DITHER_INT_MSB                              20
+#define CURRENT_PCIE_PLL_DITHER_INT_LSB                              15
+#define CURRENT_PCIE_PLL_DITHER_INT_MASK                             0x001f8000
+#define CURRENT_PCIE_PLL_DITHER_INT_GET(x)                           (((x) & CURRENT_PCIE_PLL_DITHER_INT_MASK) >> CURRENT_PCIE_PLL_DITHER_INT_LSB)
+#define CURRENT_PCIE_PLL_DITHER_INT_SET(x)                           (((x) << CURRENT_PCIE_PLL_DITHER_INT_LSB) & CURRENT_PCIE_PLL_DITHER_INT_MASK)
+#define CURRENT_PCIE_PLL_DITHER_INT_RESET                            0x1 // 1
+#define CURRENT_PCIE_PLL_DITHER_FRAC_MSB                             13
+#define CURRENT_PCIE_PLL_DITHER_FRAC_LSB                             0
+#define CURRENT_PCIE_PLL_DITHER_FRAC_MASK                            0x00003fff
+#define CURRENT_PCIE_PLL_DITHER_FRAC_GET(x)                          (((x) & CURRENT_PCIE_PLL_DITHER_FRAC_MASK) >> CURRENT_PCIE_PLL_DITHER_FRAC_LSB)
+#define CURRENT_PCIE_PLL_DITHER_FRAC_SET(x)                          (((x) << CURRENT_PCIE_PLL_DITHER_FRAC_LSB) & CURRENT_PCIE_PLL_DITHER_FRAC_MASK)
+#define CURRENT_PCIE_PLL_DITHER_FRAC_RESET                           0x0 // 0
+#define CURRENT_PCIE_PLL_DITHER_ADDRESS                              0x18050028
+
+#define ETH_XMII_TX_INVERT_MSB                                       31
+#define ETH_XMII_TX_INVERT_LSB                                       31
+#define ETH_XMII_TX_INVERT_MASK                                      0x80000000
+#define ETH_XMII_TX_INVERT_GET(x)                                    (((x) & ETH_XMII_TX_INVERT_MASK) >> ETH_XMII_TX_INVERT_LSB)
+#define ETH_XMII_TX_INVERT_SET(x)                                    (((x) << ETH_XMII_TX_INVERT_LSB) & ETH_XMII_TX_INVERT_MASK)
+#define ETH_XMII_TX_INVERT_RESET                                     0x0 // 0
+#define ETH_XMII_GIGE_QUAD_MSB                                       30
+#define ETH_XMII_GIGE_QUAD_LSB                                       30
+#define ETH_XMII_GIGE_QUAD_MASK                                      0x40000000
+#define ETH_XMII_GIGE_QUAD_GET(x)                                    (((x) & ETH_XMII_GIGE_QUAD_MASK) >> ETH_XMII_GIGE_QUAD_LSB)
+#define ETH_XMII_GIGE_QUAD_SET(x)                                    (((x) << ETH_XMII_GIGE_QUAD_LSB) & ETH_XMII_GIGE_QUAD_MASK)
+#define ETH_XMII_GIGE_QUAD_RESET                                     0x0 // 0
+#define ETH_XMII_RX_DELAY_MSB                                        29
+#define ETH_XMII_RX_DELAY_LSB                                        28
+#define ETH_XMII_RX_DELAY_MASK                                       0x30000000
+#define ETH_XMII_RX_DELAY_GET(x)                                     (((x) & ETH_XMII_RX_DELAY_MASK) >> ETH_XMII_RX_DELAY_LSB)
+#define ETH_XMII_RX_DELAY_SET(x)                                     (((x) << ETH_XMII_RX_DELAY_LSB) & ETH_XMII_RX_DELAY_MASK)
+#define ETH_XMII_RX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_TX_DELAY_MSB                                        27
+#define ETH_XMII_TX_DELAY_LSB                                        26
+#define ETH_XMII_TX_DELAY_MASK                                       0x0c000000
+#define ETH_XMII_TX_DELAY_GET(x)                                     (((x) & ETH_XMII_TX_DELAY_MASK) >> ETH_XMII_TX_DELAY_LSB)
+#define ETH_XMII_TX_DELAY_SET(x)                                     (((x) << ETH_XMII_TX_DELAY_LSB) & ETH_XMII_TX_DELAY_MASK)
+#define ETH_XMII_TX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_GIGE_MSB                                            25
+#define ETH_XMII_GIGE_LSB                                            25
+#define ETH_XMII_GIGE_MASK                                           0x02000000
+#define ETH_XMII_GIGE_GET(x)                                         (((x) & ETH_XMII_GIGE_MASK) >> ETH_XMII_GIGE_LSB)
+#define ETH_XMII_GIGE_SET(x)                                         (((x) << ETH_XMII_GIGE_LSB) & ETH_XMII_GIGE_MASK)
+#define ETH_XMII_GIGE_RESET                                          0x0 // 0
+#define ETH_XMII_OFFSET_PHASE_MSB                                    24
+#define ETH_XMII_OFFSET_PHASE_LSB                                    24
+#define ETH_XMII_OFFSET_PHASE_MASK                                   0x01000000
+#define ETH_XMII_OFFSET_PHASE_GET(x)                                 (((x) & ETH_XMII_OFFSET_PHASE_MASK) >> ETH_XMII_OFFSET_PHASE_LSB)
+#define ETH_XMII_OFFSET_PHASE_SET(x)                                 (((x) << ETH_XMII_OFFSET_PHASE_LSB) & ETH_XMII_OFFSET_PHASE_MASK)
+#define ETH_XMII_OFFSET_PHASE_RESET                                  0x0 // 0
+#define ETH_XMII_OFFSET_COUNT_MSB                                    23
+#define ETH_XMII_OFFSET_COUNT_LSB                                    16
+#define ETH_XMII_OFFSET_COUNT_MASK                                   0x00ff0000
+#define ETH_XMII_OFFSET_COUNT_GET(x)                                 (((x) & ETH_XMII_OFFSET_COUNT_MASK) >> ETH_XMII_OFFSET_COUNT_LSB)
+#define ETH_XMII_OFFSET_COUNT_SET(x)                                 (((x) << ETH_XMII_OFFSET_COUNT_LSB) & ETH_XMII_OFFSET_COUNT_MASK)
+#define ETH_XMII_OFFSET_COUNT_RESET                                  0x0 // 0
+#define ETH_XMII_PHASE1_COUNT_MSB                                    15
+#define ETH_XMII_PHASE1_COUNT_LSB                                    8
+#define ETH_XMII_PHASE1_COUNT_MASK                                   0x0000ff00
+#define ETH_XMII_PHASE1_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE1_COUNT_MASK) >> ETH_XMII_PHASE1_COUNT_LSB)
+#define ETH_XMII_PHASE1_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE1_COUNT_LSB) & ETH_XMII_PHASE1_COUNT_MASK)
+#define ETH_XMII_PHASE1_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_PHASE0_COUNT_MSB                                    7
+#define ETH_XMII_PHASE0_COUNT_LSB                                    0
+#define ETH_XMII_PHASE0_COUNT_MASK                                   0x000000ff
+#define ETH_XMII_PHASE0_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE0_COUNT_MASK) >> ETH_XMII_PHASE0_COUNT_LSB)
+#define ETH_XMII_PHASE0_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE0_COUNT_LSB) & ETH_XMII_PHASE0_COUNT_MASK)
+#define ETH_XMII_PHASE0_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_ADDRESS                                             0x1805002c
+
+#define BB_PLL_CONFIG_UPDATING_MSB                                   31
+#define BB_PLL_CONFIG_UPDATING_LSB                                   31
+#define BB_PLL_CONFIG_UPDATING_MASK                                  0x80000000
+#define BB_PLL_CONFIG_UPDATING_GET(x)                                (((x) & BB_PLL_CONFIG_UPDATING_MASK) >> BB_PLL_CONFIG_UPDATING_LSB)
+#define BB_PLL_CONFIG_UPDATING_SET(x)                                (((x) << BB_PLL_CONFIG_UPDATING_LSB) & BB_PLL_CONFIG_UPDATING_MASK)
+#define BB_PLL_CONFIG_UPDATING_RESET                                 0x1 // 1
+#define BB_PLL_CONFIG_PLLPWD_MSB                                     30
+#define BB_PLL_CONFIG_PLLPWD_LSB                                     30
+#define BB_PLL_CONFIG_PLLPWD_MASK                                    0x40000000
+#define BB_PLL_CONFIG_PLLPWD_GET(x)                                  (((x) & BB_PLL_CONFIG_PLLPWD_MASK) >> BB_PLL_CONFIG_PLLPWD_LSB)
+#define BB_PLL_CONFIG_PLLPWD_SET(x)                                  (((x) << BB_PLL_CONFIG_PLLPWD_LSB) & BB_PLL_CONFIG_PLLPWD_MASK)
+#define BB_PLL_CONFIG_PLLPWD_RESET                                   0x1 // 1
+#define BB_PLL_CONFIG_SPARE_MSB                                      29
+#define BB_PLL_CONFIG_SPARE_LSB                                      29
+#define BB_PLL_CONFIG_SPARE_MASK                                     0x20000000
+#define BB_PLL_CONFIG_SPARE_GET(x)                                   (((x) & BB_PLL_CONFIG_SPARE_MASK) >> BB_PLL_CONFIG_SPARE_LSB)
+#define BB_PLL_CONFIG_SPARE_SET(x)                                   (((x) << BB_PLL_CONFIG_SPARE_LSB) & BB_PLL_CONFIG_SPARE_MASK)
+#define BB_PLL_CONFIG_SPARE_RESET                                    0x0 // 0
+#define BB_PLL_CONFIG_REFDIV_MSB                                     28
+#define BB_PLL_CONFIG_REFDIV_LSB                                     24
+#define BB_PLL_CONFIG_REFDIV_MASK                                    0x1f000000
+#define BB_PLL_CONFIG_REFDIV_GET(x)                                  (((x) & BB_PLL_CONFIG_REFDIV_MASK) >> BB_PLL_CONFIG_REFDIV_LSB)
+#define BB_PLL_CONFIG_REFDIV_SET(x)                                  (((x) << BB_PLL_CONFIG_REFDIV_LSB) & BB_PLL_CONFIG_REFDIV_MASK)
+#define BB_PLL_CONFIG_REFDIV_RESET                                   0x1 // 1
+#define BB_PLL_CONFIG_NINT_MSB                                       21
+#define BB_PLL_CONFIG_NINT_LSB                                       16
+#define BB_PLL_CONFIG_NINT_MASK                                      0x003f0000
+#define BB_PLL_CONFIG_NINT_GET(x)                                    (((x) & BB_PLL_CONFIG_NINT_MASK) >> BB_PLL_CONFIG_NINT_LSB)
+#define BB_PLL_CONFIG_NINT_SET(x)                                    (((x) << BB_PLL_CONFIG_NINT_LSB) & BB_PLL_CONFIG_NINT_MASK)
+#define BB_PLL_CONFIG_NINT_RESET                                     0x2 // 2
+#define BB_PLL_CONFIG_NFRAC_MSB                                      13
+#define BB_PLL_CONFIG_NFRAC_LSB                                      0
+#define BB_PLL_CONFIG_NFRAC_MASK                                     0x00003fff
+#define BB_PLL_CONFIG_NFRAC_GET(x)                                   (((x) & BB_PLL_CONFIG_NFRAC_MASK) >> BB_PLL_CONFIG_NFRAC_LSB)
+#define BB_PLL_CONFIG_NFRAC_SET(x)                                   (((x) << BB_PLL_CONFIG_NFRAC_LSB) & BB_PLL_CONFIG_NFRAC_MASK)
+#define BB_PLL_CONFIG_NFRAC_RESET                                    0xccc // 3276
+#define BB_PLL_CONFIG_ADDRESS                                        0x18050040
+
+#define DDR_PLL_DITHER_DITHER_EN_MSB                                 31
+#define DDR_PLL_DITHER_DITHER_EN_LSB                                 31
+#define DDR_PLL_DITHER_DITHER_EN_MASK                                0x80000000
+#define DDR_PLL_DITHER_DITHER_EN_GET(x)                              (((x) & DDR_PLL_DITHER_DITHER_EN_MASK) >> DDR_PLL_DITHER_DITHER_EN_LSB)
+#define DDR_PLL_DITHER_DITHER_EN_SET(x)                              (((x) << DDR_PLL_DITHER_DITHER_EN_LSB) & DDR_PLL_DITHER_DITHER_EN_MASK)
+#define DDR_PLL_DITHER_DITHER_EN_RESET                               0x0 // 0
+#define DDR_PLL_DITHER_UPDATE_COUNT_MSB                              30
+#define DDR_PLL_DITHER_UPDATE_COUNT_LSB                              27
+#define DDR_PLL_DITHER_UPDATE_COUNT_MASK                             0x78000000
+#define DDR_PLL_DITHER_UPDATE_COUNT_GET(x)                           (((x) & DDR_PLL_DITHER_UPDATE_COUNT_MASK) >> DDR_PLL_DITHER_UPDATE_COUNT_LSB)
+#define DDR_PLL_DITHER_UPDATE_COUNT_SET(x)                           (((x) << DDR_PLL_DITHER_UPDATE_COUNT_LSB) & DDR_PLL_DITHER_UPDATE_COUNT_MASK)
+#define DDR_PLL_DITHER_UPDATE_COUNT_RESET                            0xf // 15
+#define DDR_PLL_DITHER_NFRAC_STEP_MSB                                26
+#define DDR_PLL_DITHER_NFRAC_STEP_LSB                                20
+#define DDR_PLL_DITHER_NFRAC_STEP_MASK                               0x07f00000
+#define DDR_PLL_DITHER_NFRAC_STEP_GET(x)                             (((x) & DDR_PLL_DITHER_NFRAC_STEP_MASK) >> DDR_PLL_DITHER_NFRAC_STEP_LSB)
+#define DDR_PLL_DITHER_NFRAC_STEP_SET(x)                             (((x) << DDR_PLL_DITHER_NFRAC_STEP_LSB) & DDR_PLL_DITHER_NFRAC_STEP_MASK)
+#define DDR_PLL_DITHER_NFRAC_STEP_RESET                              0x1 // 1
+#define DDR_PLL_DITHER_NFRAC_MIN_MSB                                 19
+#define DDR_PLL_DITHER_NFRAC_MIN_LSB                                 10
+#define DDR_PLL_DITHER_NFRAC_MIN_MASK                                0x000ffc00
+#define DDR_PLL_DITHER_NFRAC_MIN_GET(x)                              (((x) & DDR_PLL_DITHER_NFRAC_MIN_MASK) >> DDR_PLL_DITHER_NFRAC_MIN_LSB)
+#define DDR_PLL_DITHER_NFRAC_MIN_SET(x)                              (((x) << DDR_PLL_DITHER_NFRAC_MIN_LSB) & DDR_PLL_DITHER_NFRAC_MIN_MASK)
+#define DDR_PLL_DITHER_NFRAC_MIN_RESET                               0x19 // 25
+#define DDR_PLL_DITHER_NFRAC_MAX_MSB                                 9
+#define DDR_PLL_DITHER_NFRAC_MAX_LSB                                 0
+#define DDR_PLL_DITHER_NFRAC_MAX_MASK                                0x000003ff
+#define DDR_PLL_DITHER_NFRAC_MAX_GET(x)                              (((x) & DDR_PLL_DITHER_NFRAC_MAX_MASK) >> DDR_PLL_DITHER_NFRAC_MAX_LSB)
+#define DDR_PLL_DITHER_NFRAC_MAX_SET(x)                              (((x) << DDR_PLL_DITHER_NFRAC_MAX_LSB) & DDR_PLL_DITHER_NFRAC_MAX_MASK)
+#define DDR_PLL_DITHER_NFRAC_MAX_RESET                               0x3e8 // 1000
+#define DDR_PLL_DITHER_ADDRESS                                       0x18050044
+
+#define CPU_PLL_DITHER_DITHER_EN_MSB                                 31
+#define CPU_PLL_DITHER_DITHER_EN_LSB                                 31
+#define CPU_PLL_DITHER_DITHER_EN_MASK                                0x80000000
+#define CPU_PLL_DITHER_DITHER_EN_GET(x)                              (((x) & CPU_PLL_DITHER_DITHER_EN_MASK) >> CPU_PLL_DITHER_DITHER_EN_LSB)
+#define CPU_PLL_DITHER_DITHER_EN_SET(x)                              (((x) << CPU_PLL_DITHER_DITHER_EN_LSB) & CPU_PLL_DITHER_DITHER_EN_MASK)
+#define CPU_PLL_DITHER_DITHER_EN_RESET                               0x0 // 0
+#define CPU_PLL_DITHER_UPDATE_COUNT_MSB                              23
+#define CPU_PLL_DITHER_UPDATE_COUNT_LSB                              18
+#define CPU_PLL_DITHER_UPDATE_COUNT_MASK                             0x00fc0000
+#define CPU_PLL_DITHER_UPDATE_COUNT_GET(x)                           (((x) & CPU_PLL_DITHER_UPDATE_COUNT_MASK) >> CPU_PLL_DITHER_UPDATE_COUNT_LSB)
+#define CPU_PLL_DITHER_UPDATE_COUNT_SET(x)                           (((x) << CPU_PLL_DITHER_UPDATE_COUNT_LSB) & CPU_PLL_DITHER_UPDATE_COUNT_MASK)
+#define CPU_PLL_DITHER_UPDATE_COUNT_RESET                            0x14 // 20
+#define CPU_PLL_DITHER_NFRAC_STEP_MSB                                17
+#define CPU_PLL_DITHER_NFRAC_STEP_LSB                                12
+#define CPU_PLL_DITHER_NFRAC_STEP_MASK                               0x0003f000
+#define CPU_PLL_DITHER_NFRAC_STEP_GET(x)                             (((x) & CPU_PLL_DITHER_NFRAC_STEP_MASK) >> CPU_PLL_DITHER_NFRAC_STEP_LSB)
+#define CPU_PLL_DITHER_NFRAC_STEP_SET(x)                             (((x) << CPU_PLL_DITHER_NFRAC_STEP_LSB) & CPU_PLL_DITHER_NFRAC_STEP_MASK)
+#define CPU_PLL_DITHER_NFRAC_STEP_RESET                              0x1 // 1
+#define CPU_PLL_DITHER_NFRAC_MIN_MSB                                 11
+#define CPU_PLL_DITHER_NFRAC_MIN_LSB                                 6
+#define CPU_PLL_DITHER_NFRAC_MIN_MASK                                0x00000fc0
+#define CPU_PLL_DITHER_NFRAC_MIN_GET(x)                              (((x) & CPU_PLL_DITHER_NFRAC_MIN_MASK) >> CPU_PLL_DITHER_NFRAC_MIN_LSB)
+#define CPU_PLL_DITHER_NFRAC_MIN_SET(x)                              (((x) << CPU_PLL_DITHER_NFRAC_MIN_LSB) & CPU_PLL_DITHER_NFRAC_MIN_MASK)
+#define CPU_PLL_DITHER_NFRAC_MIN_RESET                               0x3 // 3
+#define CPU_PLL_DITHER_NFRAC_MAX_MSB                                 5
+#define CPU_PLL_DITHER_NFRAC_MAX_LSB                                 0
+#define CPU_PLL_DITHER_NFRAC_MAX_MASK                                0x0000003f
+#define CPU_PLL_DITHER_NFRAC_MAX_GET(x)                              (((x) & CPU_PLL_DITHER_NFRAC_MAX_MASK) >> CPU_PLL_DITHER_NFRAC_MAX_LSB)
+#define CPU_PLL_DITHER_NFRAC_MAX_SET(x)                              (((x) << CPU_PLL_DITHER_NFRAC_MAX_LSB) & CPU_PLL_DITHER_NFRAC_MAX_MASK)
+#define CPU_PLL_DITHER_NFRAC_MAX_RESET                               0x3c // 60
+#define CPU_PLL_DITHER_ADDRESS                                       0x18050048
+
+#define RST_RESET_USB_EXT_PWR_SEQ_MSB                                29
+#define RST_RESET_USB_EXT_PWR_SEQ_LSB                                29
+#define RST_RESET_USB_EXT_PWR_SEQ_MASK                               0x20000000
+#define RST_RESET_USB_EXT_PWR_SEQ_GET(x)                             (((x) & RST_RESET_USB_EXT_PWR_SEQ_MASK) >> RST_RESET_USB_EXT_PWR_SEQ_LSB)
+#define RST_RESET_USB_EXT_PWR_SEQ_SET(x)                             (((x) << RST_RESET_USB_EXT_PWR_SEQ_LSB) & RST_RESET_USB_EXT_PWR_SEQ_MASK)
+#define RST_RESET_USB_EXT_PWR_SEQ_RESET                              0x1 // 1
+#define RST_RESET_EXTERNAL_RESET_MSB                                 28
+#define RST_RESET_EXTERNAL_RESET_LSB                                 28
+#define RST_RESET_EXTERNAL_RESET_MASK                                0x10000000
+#define RST_RESET_EXTERNAL_RESET_GET(x)                              (((x) & RST_RESET_EXTERNAL_RESET_MASK) >> RST_RESET_EXTERNAL_RESET_LSB)
+#define RST_RESET_EXTERNAL_RESET_SET(x)                              (((x) << RST_RESET_EXTERNAL_RESET_LSB) & RST_RESET_EXTERNAL_RESET_MASK)
+#define RST_RESET_EXTERNAL_RESET_RESET                               0x0 // 0
+#define RST_RESET_RTC_RESET_MSB                                      27
+#define RST_RESET_RTC_RESET_LSB                                      27
+#define RST_RESET_RTC_RESET_MASK                                     0x08000000
+#define RST_RESET_RTC_RESET_GET(x)                                   (((x) & RST_RESET_RTC_RESET_MASK) >> RST_RESET_RTC_RESET_LSB)
+#define RST_RESET_RTC_RESET_SET(x)                                   (((x) << RST_RESET_RTC_RESET_LSB) & RST_RESET_RTC_RESET_MASK)
+#define RST_RESET_RTC_RESET_RESET                                    0x1 // 1
+#define RST_RESET_FULL_CHIP_RESET_MSB                                24
+#define RST_RESET_FULL_CHIP_RESET_LSB                                24
+#define RST_RESET_FULL_CHIP_RESET_MASK                               0x01000000
+#define RST_RESET_FULL_CHIP_RESET_GET(x)                             (((x) & RST_RESET_FULL_CHIP_RESET_MASK) >> RST_RESET_FULL_CHIP_RESET_LSB)
+#define RST_RESET_FULL_CHIP_RESET_SET(x)                             (((x) << RST_RESET_FULL_CHIP_RESET_LSB) & RST_RESET_FULL_CHIP_RESET_MASK)
+#define RST_RESET_FULL_CHIP_RESET_RESET                              0x0 // 0
+#define RST_RESET_GE1_MDIO_RESET_MSB                                 23
+#define RST_RESET_GE1_MDIO_RESET_LSB                                 23
+#define RST_RESET_GE1_MDIO_RESET_MASK                                0x00800000
+#define RST_RESET_GE1_MDIO_RESET_GET(x)                              (((x) & RST_RESET_GE1_MDIO_RESET_MASK) >> RST_RESET_GE1_MDIO_RESET_LSB)
+#define RST_RESET_GE1_MDIO_RESET_SET(x)                              (((x) << RST_RESET_GE1_MDIO_RESET_LSB) & RST_RESET_GE1_MDIO_RESET_MASK)
+#define RST_RESET_GE1_MDIO_RESET_RESET                               0x1 // 1
+#define RST_RESET_GE0_MDIO_RESET_MSB                                 22
+#define RST_RESET_GE0_MDIO_RESET_LSB                                 22
+#define RST_RESET_GE0_MDIO_RESET_MASK                                0x00400000
+#define RST_RESET_GE0_MDIO_RESET_GET(x)                              (((x) & RST_RESET_GE0_MDIO_RESET_MASK) >> RST_RESET_GE0_MDIO_RESET_LSB)
+#define RST_RESET_GE0_MDIO_RESET_SET(x)                              (((x) << RST_RESET_GE0_MDIO_RESET_LSB) & RST_RESET_GE0_MDIO_RESET_MASK)
+#define RST_RESET_GE0_MDIO_RESET_RESET                               0x1 // 1
+#define RST_RESET_CPU_NMI_MSB                                        21
+#define RST_RESET_CPU_NMI_LSB                                        21
+#define RST_RESET_CPU_NMI_MASK                                       0x00200000
+#define RST_RESET_CPU_NMI_GET(x)                                     (((x) & RST_RESET_CPU_NMI_MASK) >> RST_RESET_CPU_NMI_LSB)
+#define RST_RESET_CPU_NMI_SET(x)                                     (((x) << RST_RESET_CPU_NMI_LSB) & RST_RESET_CPU_NMI_MASK)
+#define RST_RESET_CPU_NMI_RESET                                      0x0 // 0
+#define RST_RESET_CPU_COLD_RESET_MSB                                 20
+#define RST_RESET_CPU_COLD_RESET_LSB                                 20
+#define RST_RESET_CPU_COLD_RESET_MASK                                0x00100000
+#define RST_RESET_CPU_COLD_RESET_GET(x)                              (((x) & RST_RESET_CPU_COLD_RESET_MASK) >> RST_RESET_CPU_COLD_RESET_LSB)
+#define RST_RESET_CPU_COLD_RESET_SET(x)                              (((x) << RST_RESET_CPU_COLD_RESET_LSB) & RST_RESET_CPU_COLD_RESET_MASK)
+#define RST_RESET_CPU_COLD_RESET_RESET                               0x0 // 0
+#define RST_RESET_DDR_RESET_MSB                                      16
+#define RST_RESET_DDR_RESET_LSB                                      16
+#define RST_RESET_DDR_RESET_MASK                                     0x00010000
+#define RST_RESET_DDR_RESET_GET(x)                                   (((x) & RST_RESET_DDR_RESET_MASK) >> RST_RESET_DDR_RESET_LSB)
+#define RST_RESET_DDR_RESET_SET(x)                                   (((x) << RST_RESET_DDR_RESET_LSB) & RST_RESET_DDR_RESET_MASK)
+#define RST_RESET_DDR_RESET_RESET                                    0x0 // 0
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_MSB                            15
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_LSB                            15
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_MASK                           0x00008000
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_GET(x)                         (((x) & RST_RESET_USB_PHY_PLL_PWD_EXT_MASK) >> RST_RESET_USB_PHY_PLL_PWD_EXT_LSB)
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_SET(x)                         (((x) << RST_RESET_USB_PHY_PLL_PWD_EXT_LSB) & RST_RESET_USB_PHY_PLL_PWD_EXT_MASK)
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_RESET                          0x0 // 0
+#define RST_RESET_GE1_MAC_RESET_MSB                                  13
+#define RST_RESET_GE1_MAC_RESET_LSB                                  13
+#define RST_RESET_GE1_MAC_RESET_MASK                                 0x00002000
+#define RST_RESET_GE1_MAC_RESET_GET(x)                               (((x) & RST_RESET_GE1_MAC_RESET_MASK) >> RST_RESET_GE1_MAC_RESET_LSB)
+#define RST_RESET_GE1_MAC_RESET_SET(x)                               (((x) << RST_RESET_GE1_MAC_RESET_LSB) & RST_RESET_GE1_MAC_RESET_MASK)
+#define RST_RESET_GE1_MAC_RESET_RESET                                0x1 // 1
+#define RST_RESET_ETH_SWITCH_ARESET_MSB                              12
+#define RST_RESET_ETH_SWITCH_ARESET_LSB                              12
+#define RST_RESET_ETH_SWITCH_ARESET_MASK                             0x00001000
+#define RST_RESET_ETH_SWITCH_ARESET_GET(x)                           (((x) & RST_RESET_ETH_SWITCH_ARESET_MASK) >> RST_RESET_ETH_SWITCH_ARESET_LSB)
+#define RST_RESET_ETH_SWITCH_ARESET_SET(x)                           (((x) << RST_RESET_ETH_SWITCH_ARESET_LSB) & RST_RESET_ETH_SWITCH_ARESET_MASK)
+#define RST_RESET_ETH_SWITCH_ARESET_RESET                            0x1 // 1
+#define RST_RESET_USB_PHY_ARESET_MSB                                 11
+#define RST_RESET_USB_PHY_ARESET_LSB                                 11
+#define RST_RESET_USB_PHY_ARESET_MASK                                0x00000800
+#define RST_RESET_USB_PHY_ARESET_GET(x)                              (((x) & RST_RESET_USB_PHY_ARESET_MASK) >> RST_RESET_USB_PHY_ARESET_LSB)
+#define RST_RESET_USB_PHY_ARESET_SET(x)                              (((x) << RST_RESET_USB_PHY_ARESET_LSB) & RST_RESET_USB_PHY_ARESET_MASK)
+#define RST_RESET_USB_PHY_ARESET_RESET                               0x1 // 1
+#define RST_RESET_GE0_MAC_RESET_MSB                                  9
+#define RST_RESET_GE0_MAC_RESET_LSB                                  9
+#define RST_RESET_GE0_MAC_RESET_MASK                                 0x00000200
+#define RST_RESET_GE0_MAC_RESET_GET(x)                               (((x) & RST_RESET_GE0_MAC_RESET_MASK) >> RST_RESET_GE0_MAC_RESET_LSB)
+#define RST_RESET_GE0_MAC_RESET_SET(x)                               (((x) << RST_RESET_GE0_MAC_RESET_LSB) & RST_RESET_GE0_MAC_RESET_MASK)
+#define RST_RESET_GE0_MAC_RESET_RESET                                0x1 // 1
+#define RST_RESET_ETH_SWITCH_RESET_MSB                               8
+#define RST_RESET_ETH_SWITCH_RESET_LSB                               8
+#define RST_RESET_ETH_SWITCH_RESET_MASK                              0x00000100
+#define RST_RESET_ETH_SWITCH_RESET_GET(x)                            (((x) & RST_RESET_ETH_SWITCH_RESET_MASK) >> RST_RESET_ETH_SWITCH_RESET_LSB)
+#define RST_RESET_ETH_SWITCH_RESET_SET(x)                            (((x) << RST_RESET_ETH_SWITCH_RESET_LSB) & RST_RESET_ETH_SWITCH_RESET_MASK)
+#define RST_RESET_ETH_SWITCH_RESET_RESET                             0x1 // 1
+#define RST_RESET_PCIE_PHY_RESET_MSB                                 7
+#define RST_RESET_PCIE_PHY_RESET_LSB                                 7
+#define RST_RESET_PCIE_PHY_RESET_MASK                                0x00000080
+#define RST_RESET_PCIE_PHY_RESET_GET(x)                              (((x) & RST_RESET_PCIE_PHY_RESET_MASK) >> RST_RESET_PCIE_PHY_RESET_LSB)
+#define RST_RESET_PCIE_PHY_RESET_SET(x)                              (((x) << RST_RESET_PCIE_PHY_RESET_LSB) & RST_RESET_PCIE_PHY_RESET_MASK)
+#define RST_RESET_PCIE_PHY_RESET_RESET                               0x1 // 1
+#define RST_RESET_PCIE_RESET_MSB                                     6
+#define RST_RESET_PCIE_RESET_LSB                                     6
+#define RST_RESET_PCIE_RESET_MASK                                    0x00000040
+#define RST_RESET_PCIE_RESET_GET(x)                                  (((x) & RST_RESET_PCIE_RESET_MASK) >> RST_RESET_PCIE_RESET_LSB)
+#define RST_RESET_PCIE_RESET_SET(x)                                  (((x) << RST_RESET_PCIE_RESET_LSB) & RST_RESET_PCIE_RESET_MASK)
+#define RST_RESET_PCIE_RESET_RESET                                   0x1 // 1
+#define RST_RESET_USB_HOST_RESET_MSB                                 5
+#define RST_RESET_USB_HOST_RESET_LSB                                 5
+#define RST_RESET_USB_HOST_RESET_MASK                                0x00000020
+#define RST_RESET_USB_HOST_RESET_GET(x)                              (((x) & RST_RESET_USB_HOST_RESET_MASK) >> RST_RESET_USB_HOST_RESET_LSB)
+#define RST_RESET_USB_HOST_RESET_SET(x)                              (((x) << RST_RESET_USB_HOST_RESET_LSB) & RST_RESET_USB_HOST_RESET_MASK)
+#define RST_RESET_USB_HOST_RESET_RESET                               0x1 // 1
+#define RST_RESET_USB_PHY_RESET_MSB                                  4
+#define RST_RESET_USB_PHY_RESET_LSB                                  4
+#define RST_RESET_USB_PHY_RESET_MASK                                 0x00000010
+#define RST_RESET_USB_PHY_RESET_GET(x)                               (((x) & RST_RESET_USB_PHY_RESET_MASK) >> RST_RESET_USB_PHY_RESET_LSB)
+#define RST_RESET_USB_PHY_RESET_SET(x)                               (((x) << RST_RESET_USB_PHY_RESET_LSB) & RST_RESET_USB_PHY_RESET_MASK)
+#define RST_RESET_USB_PHY_RESET_RESET                                0x1 // 1
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MSB                       3
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB                       3
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK                      0x00000008
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_GET(x)                    (((x) & RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK) >> RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB)
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(x)                    (((x) << RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB) & RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK)
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_RESET                     0x0 // 0
+#define RST_RESET_ADDRESS                                            0x1806001c
+
+
+#define RST_MISC2_SPARE_MSB                                          31
+#define RST_MISC2_SPARE_LSB                                          26
+#define RST_MISC2_SPARE_MASK                                         0xfc000000
+#define RST_MISC2_SPARE_GET(x)                                       (((x) & RST_MISC2_SPARE_MASK) >> RST_MISC2_SPARE_LSB)
+#define RST_MISC2_SPARE_SET(x)                                       (((x) << RST_MISC2_SPARE_LSB) & RST_MISC2_SPARE_MASK)
+#define RST_MISC2_SPARE_RESET                                        0x0 // 0
+#define RST_MISC2_PCIE_CLKOBS1_SEL_MSB                               19
+#define RST_MISC2_PCIE_CLKOBS1_SEL_LSB                               19
+#define RST_MISC2_PCIE_CLKOBS1_SEL_MASK                              0x00080000
+#define RST_MISC2_PCIE_CLKOBS1_SEL_GET(x)                            (((x) & RST_MISC2_PCIE_CLKOBS1_SEL_MASK) >> RST_MISC2_PCIE_CLKOBS1_SEL_LSB)
+#define RST_MISC2_PCIE_CLKOBS1_SEL_SET(x)                            (((x) << RST_MISC2_PCIE_CLKOBS1_SEL_LSB) & RST_MISC2_PCIE_CLKOBS1_SEL_MASK)
+#define RST_MISC2_PCIE_CLKOBS1_SEL_RESET                             0x0 // 0
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_MSB                           18
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_LSB                           18
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_MASK                          0x00040000
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_GET(x)                        (((x) & RST_MISC2_EXT_HOST_WASP_RST_EN_MASK) >> RST_MISC2_EXT_HOST_WASP_RST_EN_LSB)
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_SET(x)                        (((x) << RST_MISC2_EXT_HOST_WASP_RST_EN_LSB) & RST_MISC2_EXT_HOST_WASP_RST_EN_MASK)
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_RESET                         0x0 // 0
+#define RST_MISC2_PERSTN_RCPHY_MSB                                   13
+#define RST_MISC2_PERSTN_RCPHY_LSB                                   13
+#define RST_MISC2_PERSTN_RCPHY_MASK                                  0x00002000
+#define RST_MISC2_PERSTN_RCPHY_GET(x)                                (((x) & RST_MISC2_PERSTN_RCPHY_MASK) >> RST_MISC2_PERSTN_RCPHY_LSB)
+#define RST_MISC2_PERSTN_RCPHY_SET(x)                                (((x) << RST_MISC2_PERSTN_RCPHY_LSB) & RST_MISC2_PERSTN_RCPHY_MASK)
+#define RST_MISC2_PERSTN_RCPHY_RESET                                 0x1 // 1
+#define RST_MISC2_RESERVED_MSB                                       3
+#define RST_MISC2_RESERVED_LSB                                       1
+#define RST_MISC2_RESERVED_MASK                                      0x0000000e
+#define RST_MISC2_RESERVED_GET(x)                                    (((x) & RST_MISC2_RESERVED_MASK) >> RST_MISC2_RESERVED_LSB)
+#define RST_MISC2_RESERVED_SET(x)                                    (((x) << RST_MISC2_RESERVED_LSB) & RST_MISC2_RESERVED_MASK)
+#define RST_MISC2_RESERVED_RESET                                     0x0 // 0
+#define RST_MISC2_ADDRESS                                            0x180600bc
+
+#define PCIE_APP_CFG_TYPE_MSB                                        21
+#define PCIE_APP_CFG_TYPE_LSB                                        20
+#define PCIE_APP_CFG_TYPE_MASK                                       0x00300000
+#define PCIE_APP_CFG_TYPE_GET(x)                                     (((x) & PCIE_APP_CFG_TYPE_MASK) >> PCIE_APP_CFG_TYPE_LSB)
+#define PCIE_APP_CFG_TYPE_SET(x)                                     (((x) << PCIE_APP_CFG_TYPE_LSB) & PCIE_APP_CFG_TYPE_MASK)
+#define PCIE_APP_CFG_TYPE_RESET                                      0x0 // 0
+#define PCIE_APP_PCIE_BAR_MSN_MSB                                    19
+#define PCIE_APP_PCIE_BAR_MSN_LSB                                    16
+#define PCIE_APP_PCIE_BAR_MSN_MASK                                   0x000f0000
+#define PCIE_APP_PCIE_BAR_MSN_GET(x)                                 (((x) & PCIE_APP_PCIE_BAR_MSN_MASK) >> PCIE_APP_PCIE_BAR_MSN_LSB)
+#define PCIE_APP_PCIE_BAR_MSN_SET(x)                                 (((x) << PCIE_APP_PCIE_BAR_MSN_LSB) & PCIE_APP_PCIE_BAR_MSN_MASK)
+#define PCIE_APP_PCIE_BAR_MSN_RESET                                  0x1 // 1
+#define PCIE_APP_CFG_BE_MSB                                          15
+#define PCIE_APP_CFG_BE_LSB                                          12
+#define PCIE_APP_CFG_BE_MASK                                         0x0000f000
+#define PCIE_APP_CFG_BE_GET(x)                                       (((x) & PCIE_APP_CFG_BE_MASK) >> PCIE_APP_CFG_BE_LSB)
+#define PCIE_APP_CFG_BE_SET(x)                                       (((x) << PCIE_APP_CFG_BE_LSB) & PCIE_APP_CFG_BE_MASK)
+#define PCIE_APP_CFG_BE_RESET                                        0xf // 15
+#define PCIE_APP_SLV_RESP_ERR_MAP_MSB                                11
+#define PCIE_APP_SLV_RESP_ERR_MAP_LSB                                6
+#define PCIE_APP_SLV_RESP_ERR_MAP_MASK                               0x00000fc0
+#define PCIE_APP_SLV_RESP_ERR_MAP_GET(x)                             (((x) & PCIE_APP_SLV_RESP_ERR_MAP_MASK) >> PCIE_APP_SLV_RESP_ERR_MAP_LSB)
+#define PCIE_APP_SLV_RESP_ERR_MAP_SET(x)                             (((x) << PCIE_APP_SLV_RESP_ERR_MAP_LSB) & PCIE_APP_SLV_RESP_ERR_MAP_MASK)
+#define PCIE_APP_SLV_RESP_ERR_MAP_RESET                              0x3f // 63
+#define PCIE_APP_MSTR_RESP_ERR_MAP_MSB                               5
+#define PCIE_APP_MSTR_RESP_ERR_MAP_LSB                               4
+#define PCIE_APP_MSTR_RESP_ERR_MAP_MASK                              0x00000030
+#define PCIE_APP_MSTR_RESP_ERR_MAP_GET(x)                            (((x) & PCIE_APP_MSTR_RESP_ERR_MAP_MASK) >> PCIE_APP_MSTR_RESP_ERR_MAP_LSB)
+#define PCIE_APP_MSTR_RESP_ERR_MAP_SET(x)                            (((x) << PCIE_APP_MSTR_RESP_ERR_MAP_LSB) & PCIE_APP_MSTR_RESP_ERR_MAP_MASK)
+#define PCIE_APP_MSTR_RESP_ERR_MAP_RESET                             0x0 // 0
+#define PCIE_APP_INIT_RST_MSB                                        3
+#define PCIE_APP_INIT_RST_LSB                                        3
+#define PCIE_APP_INIT_RST_MASK                                       0x00000008
+#define PCIE_APP_INIT_RST_GET(x)                                     (((x) & PCIE_APP_INIT_RST_MASK) >> PCIE_APP_INIT_RST_LSB)
+#define PCIE_APP_INIT_RST_SET(x)                                     (((x) << PCIE_APP_INIT_RST_LSB) & PCIE_APP_INIT_RST_MASK)
+#define PCIE_APP_INIT_RST_RESET                                      0x0 // 0
+#define PCIE_APP_PM_XMT_TURNOFF_MSB                                  2
+#define PCIE_APP_PM_XMT_TURNOFF_LSB                                  2
+#define PCIE_APP_PM_XMT_TURNOFF_MASK                                 0x00000004
+#define PCIE_APP_PM_XMT_TURNOFF_GET(x)                               (((x) & PCIE_APP_PM_XMT_TURNOFF_MASK) >> PCIE_APP_PM_XMT_TURNOFF_LSB)
+#define PCIE_APP_PM_XMT_TURNOFF_SET(x)                               (((x) << PCIE_APP_PM_XMT_TURNOFF_LSB) & PCIE_APP_PM_XMT_TURNOFF_MASK)
+#define PCIE_APP_PM_XMT_TURNOFF_RESET                                0x0 // 0
+#define PCIE_APP_UNLOCK_MSG_MSB                                      1
+#define PCIE_APP_UNLOCK_MSG_LSB                                      1
+#define PCIE_APP_UNLOCK_MSG_MASK                                     0x00000002
+#define PCIE_APP_UNLOCK_MSG_GET(x)                                   (((x) & PCIE_APP_UNLOCK_MSG_MASK) >> PCIE_APP_UNLOCK_MSG_LSB)
+#define PCIE_APP_UNLOCK_MSG_SET(x)                                   (((x) << PCIE_APP_UNLOCK_MSG_LSB) & PCIE_APP_UNLOCK_MSG_MASK)
+#define PCIE_APP_UNLOCK_MSG_RESET                                    0x0 // 0
+#define PCIE_APP_LTSSM_ENABLE_MSB                                    0
+#define PCIE_APP_LTSSM_ENABLE_LSB                                    0
+#define PCIE_APP_LTSSM_ENABLE_MASK                                   0x00000001
+#define PCIE_APP_LTSSM_ENABLE_GET(x)                                 (((x) & PCIE_APP_LTSSM_ENABLE_MASK) >> PCIE_APP_LTSSM_ENABLE_LSB)
+#define PCIE_APP_LTSSM_ENABLE_SET(x)                                 (((x) << PCIE_APP_LTSSM_ENABLE_LSB) & PCIE_APP_LTSSM_ENABLE_MASK)
+#define PCIE_APP_LTSSM_ENABLE_RESET                                  0x0 // 0
+#define PCIE_APP_ADDRESS                                             0x180f0000
+
+#define PCIE_PWR_MGMT_PME_INT_MSB                                    8
+#define PCIE_PWR_MGMT_PME_INT_LSB                                    8
+#define PCIE_PWR_MGMT_PME_INT_MASK                                   0x00000100
+#define PCIE_PWR_MGMT_PME_INT_GET(x)                                 (((x) & PCIE_PWR_MGMT_PME_INT_MASK) >> PCIE_PWR_MGMT_PME_INT_LSB)
+#define PCIE_PWR_MGMT_PME_INT_SET(x)                                 (((x) << PCIE_PWR_MGMT_PME_INT_LSB) & PCIE_PWR_MGMT_PME_INT_MASK)
+#define PCIE_PWR_MGMT_PME_INT_RESET                                  0x0 // 0
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_MSB                             7
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_LSB                             7
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_MASK                            0x00000080
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_GET(x)                          (((x) & PCIE_PWR_MGMT_ASSERT_CLKREQN_MASK) >> PCIE_PWR_MGMT_ASSERT_CLKREQN_LSB)
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_SET(x)                          (((x) << PCIE_PWR_MGMT_ASSERT_CLKREQN_LSB) & PCIE_PWR_MGMT_ASSERT_CLKREQN_MASK)
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_RESET                           0x0 // 0
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_MSB                             6
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_LSB                             6
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_MASK                            0x00000040
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_GET(x)                          (((x) & PCIE_PWR_MGMT_RADM_PM_TO_ACK_MASK) >> PCIE_PWR_MGMT_RADM_PM_TO_ACK_LSB)
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_SET(x)                          (((x) << PCIE_PWR_MGMT_RADM_PM_TO_ACK_LSB) & PCIE_PWR_MGMT_RADM_PM_TO_ACK_MASK)
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_RESET                           0x0 // 0
+#define PCIE_PWR_MGMT_RADM_PM_PME_MSB                                5
+#define PCIE_PWR_MGMT_RADM_PM_PME_LSB                                5
+#define PCIE_PWR_MGMT_RADM_PM_PME_MASK                               0x00000020
+#define PCIE_PWR_MGMT_RADM_PM_PME_GET(x)                             (((x) & PCIE_PWR_MGMT_RADM_PM_PME_MASK) >> PCIE_PWR_MGMT_RADM_PM_PME_LSB)
+#define PCIE_PWR_MGMT_RADM_PM_PME_SET(x)                             (((x) << PCIE_PWR_MGMT_RADM_PM_PME_LSB) & PCIE_PWR_MGMT_RADM_PM_PME_MASK)
+#define PCIE_PWR_MGMT_RADM_PM_PME_RESET                              0x0 // 0
+#define PCIE_PWR_MGMT_AUX_PM_EN_MSB                                  4
+#define PCIE_PWR_MGMT_AUX_PM_EN_LSB                                  4
+#define PCIE_PWR_MGMT_AUX_PM_EN_MASK                                 0x00000010
+#define PCIE_PWR_MGMT_AUX_PM_EN_GET(x)                               (((x) & PCIE_PWR_MGMT_AUX_PM_EN_MASK) >> PCIE_PWR_MGMT_AUX_PM_EN_LSB)
+#define PCIE_PWR_MGMT_AUX_PM_EN_SET(x)                               (((x) << PCIE_PWR_MGMT_AUX_PM_EN_LSB) & PCIE_PWR_MGMT_AUX_PM_EN_MASK)
+#define PCIE_PWR_MGMT_AUX_PM_EN_RESET                                0x0 // 0
+#define PCIE_PWR_MGMT_READY_ENTR_L23_MSB                             3
+#define PCIE_PWR_MGMT_READY_ENTR_L23_LSB                             3
+#define PCIE_PWR_MGMT_READY_ENTR_L23_MASK                            0x00000008
+#define PCIE_PWR_MGMT_READY_ENTR_L23_GET(x)                          (((x) & PCIE_PWR_MGMT_READY_ENTR_L23_MASK) >> PCIE_PWR_MGMT_READY_ENTR_L23_LSB)
+#define PCIE_PWR_MGMT_READY_ENTR_L23_SET(x)                          (((x) << PCIE_PWR_MGMT_READY_ENTR_L23_LSB) & PCIE_PWR_MGMT_READY_ENTR_L23_MASK)
+#define PCIE_PWR_MGMT_READY_ENTR_L23_RESET                           0x0 // 0
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_MSB                                2
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_LSB                                2
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_MASK                               0x00000004
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_GET(x)                             (((x) & PCIE_PWR_MGMT_REQ_EXIT_L1_MASK) >> PCIE_PWR_MGMT_REQ_EXIT_L1_LSB)
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_SET(x)                             (((x) << PCIE_PWR_MGMT_REQ_EXIT_L1_LSB) & PCIE_PWR_MGMT_REQ_EXIT_L1_MASK)
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_RESET                              0x0 // 0
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_MSB                               1
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_LSB                               1
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_MASK                              0x00000002
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_GET(x)                            (((x) & PCIE_PWR_MGMT_REQ_ENTRY_L1_MASK) >> PCIE_PWR_MGMT_REQ_ENTRY_L1_LSB)
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_SET(x)                            (((x) << PCIE_PWR_MGMT_REQ_ENTRY_L1_LSB) & PCIE_PWR_MGMT_REQ_ENTRY_L1_MASK)
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_RESET                             0x0 // 0
+#define PCIE_PWR_MGMT_AUX_PWR_DET_MSB                                0
+#define PCIE_PWR_MGMT_AUX_PWR_DET_LSB                                0
+#define PCIE_PWR_MGMT_AUX_PWR_DET_MASK                               0x00000001
+#define PCIE_PWR_MGMT_AUX_PWR_DET_GET(x)                             (((x) & PCIE_PWR_MGMT_AUX_PWR_DET_MASK) >> PCIE_PWR_MGMT_AUX_PWR_DET_LSB)
+#define PCIE_PWR_MGMT_AUX_PWR_DET_SET(x)                             (((x) << PCIE_PWR_MGMT_AUX_PWR_DET_LSB) & PCIE_PWR_MGMT_AUX_PWR_DET_MASK)
+#define PCIE_PWR_MGMT_AUX_PWR_DET_RESET                              0x0 // 0
+#define PCIE_PWR_MGMT_ADDRESS                                        0x180f0008
+#define PCIE_PWR_MGMT_OFFSET                                         0x0008
+// SW modifiable bits
+#define PCIE_PWR_MGMT_SW_MASK                                        0x000001ff
+// bits defined at reset
+#define PCIE_PWR_MGMT_RSTMASK                                        0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PWR_MGMT_RESET                                          0x00000000
+
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MSB                          31
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB                          31
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK                         0x80000000
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_GET(x)                       (((x) & PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK) >> PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB)
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_SET(x)                       (((x) << PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB) & PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK)
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MSB                          30
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB                          29
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK                         0x60000000
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_GET(x)                       (((x) & PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK) >> PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB)
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_SET(x)                       (((x) << PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB) & PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK)
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_PERSTDELAY_MSB                                28
+#define PCIE_PHY_REG_1_PERSTDELAY_LSB                                27
+#define PCIE_PHY_REG_1_PERSTDELAY_MASK                               0x18000000
+#define PCIE_PHY_REG_1_PERSTDELAY_GET(x)                             (((x) & PCIE_PHY_REG_1_PERSTDELAY_MASK) >> PCIE_PHY_REG_1_PERSTDELAY_LSB)
+#define PCIE_PHY_REG_1_PERSTDELAY_SET(x)                             (((x) << PCIE_PHY_REG_1_PERSTDELAY_LSB) & PCIE_PHY_REG_1_PERSTDELAY_MASK)
+#define PCIE_PHY_REG_1_PERSTDELAY_RESET                              0x2 // 2
+#define PCIE_PHY_REG_1_CLKOBSSEL_MSB                                 26
+#define PCIE_PHY_REG_1_CLKOBSSEL_LSB                                 25
+#define PCIE_PHY_REG_1_CLKOBSSEL_MASK                                0x06000000
+#define PCIE_PHY_REG_1_CLKOBSSEL_GET(x)                              (((x) & PCIE_PHY_REG_1_CLKOBSSEL_MASK) >> PCIE_PHY_REG_1_CLKOBSSEL_LSB)
+#define PCIE_PHY_REG_1_CLKOBSSEL_SET(x)                              (((x) << PCIE_PHY_REG_1_CLKOBSSEL_LSB) & PCIE_PHY_REG_1_CLKOBSSEL_MASK)
+#define PCIE_PHY_REG_1_CLKOBSSEL_RESET                               0x0 // 0
+#define PCIE_PHY_REG_1_DATAOBSEN_MSB                                 24
+#define PCIE_PHY_REG_1_DATAOBSEN_LSB                                 24
+#define PCIE_PHY_REG_1_DATAOBSEN_MASK                                0x01000000
+#define PCIE_PHY_REG_1_DATAOBSEN_GET(x)                              (((x) & PCIE_PHY_REG_1_DATAOBSEN_MASK) >> PCIE_PHY_REG_1_DATAOBSEN_LSB)
+#define PCIE_PHY_REG_1_DATAOBSEN_SET(x)                              (((x) << PCIE_PHY_REG_1_DATAOBSEN_LSB) & PCIE_PHY_REG_1_DATAOBSEN_MASK)
+#define PCIE_PHY_REG_1_DATAOBSEN_RESET                               0x0 // 0
+#define PCIE_PHY_REG_1_FUNCTESTEN_MSB                                23
+#define PCIE_PHY_REG_1_FUNCTESTEN_LSB                                23
+#define PCIE_PHY_REG_1_FUNCTESTEN_MASK                               0x00800000
+#define PCIE_PHY_REG_1_FUNCTESTEN_GET(x)                             (((x) & PCIE_PHY_REG_1_FUNCTESTEN_MASK) >> PCIE_PHY_REG_1_FUNCTESTEN_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTEN_SET(x)                             (((x) << PCIE_PHY_REG_1_FUNCTESTEN_LSB) & PCIE_PHY_REG_1_FUNCTESTEN_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTEN_RESET                              0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_DISABLE_MSB                            22
+#define PCIE_PHY_REG_1_SERDES_DISABLE_LSB                            22
+#define PCIE_PHY_REG_1_SERDES_DISABLE_MASK                           0x00400000
+#define PCIE_PHY_REG_1_SERDES_DISABLE_GET(x)                         (((x) & PCIE_PHY_REG_1_SERDES_DISABLE_MASK) >> PCIE_PHY_REG_1_SERDES_DISABLE_LSB)
+#define PCIE_PHY_REG_1_SERDES_DISABLE_SET(x)                         (((x) << PCIE_PHY_REG_1_SERDES_DISABLE_LSB) & PCIE_PHY_REG_1_SERDES_DISABLE_MASK)
+#define PCIE_PHY_REG_1_SERDES_DISABLE_RESET                          0x0 // 0
+#define PCIE_PHY_REG_1_RXCLKINV_MSB                                  21
+#define PCIE_PHY_REG_1_RXCLKINV_LSB                                  21
+#define PCIE_PHY_REG_1_RXCLKINV_MASK                                 0x00200000
+#define PCIE_PHY_REG_1_RXCLKINV_GET(x)                               (((x) & PCIE_PHY_REG_1_RXCLKINV_MASK) >> PCIE_PHY_REG_1_RXCLKINV_LSB)
+#define PCIE_PHY_REG_1_RXCLKINV_SET(x)                               (((x) << PCIE_PHY_REG_1_RXCLKINV_LSB) & PCIE_PHY_REG_1_RXCLKINV_MASK)
+#define PCIE_PHY_REG_1_RXCLKINV_RESET                                0x1 // 1
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MSB                          20
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB                          20
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK                         0x00100000
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_GET(x)                       (((x) & PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK) >> PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_SET(x)                       (((x) << PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB) & PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MSB                          19
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB                          19
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK                         0x00080000
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_GET(x)                       (((x) & PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK) >> PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_SET(x)                       (((x) << PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB) & PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_ENABLECLKREQ_MSB                              18
+#define PCIE_PHY_REG_1_ENABLECLKREQ_LSB                              18
+#define PCIE_PHY_REG_1_ENABLECLKREQ_MASK                             0x00040000
+#define PCIE_PHY_REG_1_ENABLECLKREQ_GET(x)                           (((x) & PCIE_PHY_REG_1_ENABLECLKREQ_MASK) >> PCIE_PHY_REG_1_ENABLECLKREQ_LSB)
+#define PCIE_PHY_REG_1_ENABLECLKREQ_SET(x)                           (((x) << PCIE_PHY_REG_1_ENABLECLKREQ_LSB) & PCIE_PHY_REG_1_ENABLECLKREQ_MASK)
+#define PCIE_PHY_REG_1_ENABLECLKREQ_RESET                            0x0 // 0
+#define PCIE_PHY_REG_1_FORCELOOPBACK_MSB                             17
+#define PCIE_PHY_REG_1_FORCELOOPBACK_LSB                             17
+#define PCIE_PHY_REG_1_FORCELOOPBACK_MASK                            0x00020000
+#define PCIE_PHY_REG_1_FORCELOOPBACK_GET(x)                          (((x) & PCIE_PHY_REG_1_FORCELOOPBACK_MASK) >> PCIE_PHY_REG_1_FORCELOOPBACK_LSB)
+#define PCIE_PHY_REG_1_FORCELOOPBACK_SET(x)                          (((x) << PCIE_PHY_REG_1_FORCELOOPBACK_LSB) & PCIE_PHY_REG_1_FORCELOOPBACK_MASK)
+#define PCIE_PHY_REG_1_FORCELOOPBACK_RESET                           0x0 // 0
+#define PCIE_PHY_REG_1_SEL_CLK_MSB                                   16
+#define PCIE_PHY_REG_1_SEL_CLK_LSB                                   15
+#define PCIE_PHY_REG_1_SEL_CLK_MASK                                  0x00018000
+#define PCIE_PHY_REG_1_SEL_CLK_GET(x)                                (((x) & PCIE_PHY_REG_1_SEL_CLK_MASK) >> PCIE_PHY_REG_1_SEL_CLK_LSB)
+#define PCIE_PHY_REG_1_SEL_CLK_SET(x)                                (((x) << PCIE_PHY_REG_1_SEL_CLK_LSB) & PCIE_PHY_REG_1_SEL_CLK_MASK)
+#define PCIE_PHY_REG_1_SEL_CLK_RESET                                 0x2 // 2
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_MSB                              14
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_LSB                              14
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_MASK                             0x00004000
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_GET(x)                           (((x) & PCIE_PHY_REG_1_SERDES_RX_EQ_MASK) >> PCIE_PHY_REG_1_SERDES_RX_EQ_LSB)
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_SET(x)                           (((x) << PCIE_PHY_REG_1_SERDES_RX_EQ_LSB) & PCIE_PHY_REG_1_SERDES_RX_EQ_MASK)
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_RESET                            0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_MSB                           13
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB                           13
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK                          0x00002000
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK) >> PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB)
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB) & PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK)
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_RESET                         0x1 // 1
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MSB                     12
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB                     12
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK                    0x00001000
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_GET(x)                  (((x) & PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK) >> PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB)
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_SET(x)                  (((x) << PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB) & PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK)
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_RESET                   0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_MSB                         11
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB                         11
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK                        0x00000800
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_GET(x)                      (((x) & PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK) >> PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB)
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_SET(x)                      (((x) << PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB) & PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK)
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_RESET                       0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_MSB                             10
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_LSB                             9
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_MASK                            0x00000600
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_GET(x)                          (((x) & PCIE_PHY_REG_1_SERDES_CDR_BW_MASK) >> PCIE_PHY_REG_1_SERDES_CDR_BW_LSB)
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_SET(x)                          (((x) << PCIE_PHY_REG_1_SERDES_CDR_BW_LSB) & PCIE_PHY_REG_1_SERDES_CDR_BW_MASK)
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_RESET                           0x3 // 3
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_MSB                             8
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_LSB                             7
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_MASK                            0x00000180
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_GET(x)                          (((x) & PCIE_PHY_REG_1_SERDES_TH_LOS_MASK) >> PCIE_PHY_REG_1_SERDES_TH_LOS_LSB)
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_SET(x)                          (((x) << PCIE_PHY_REG_1_SERDES_TH_LOS_LSB) & PCIE_PHY_REG_1_SERDES_TH_LOS_MASK)
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_RESET                           0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_MSB                           6
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB                           6
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK                          0x00000040
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK) >> PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB)
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB) & PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK)
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_RESET                         0x1 // 1
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_MSB                           5
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB                           5
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK                          0x00000020
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK) >> PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB)
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB) & PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK)
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_RESET                         0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_MSB                            4
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB                            4
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK                           0x00000010
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_GET(x)                         (((x) & PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK) >> PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB)
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_SET(x)                         (((x) << PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB) & PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK)
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_RESET                          0x1 // 1
+#define PCIE_PHY_REG_1_S_MSB                                         3
+#define PCIE_PHY_REG_1_S_LSB                                         0
+#define PCIE_PHY_REG_1_S_MASK                                        0x0000000f
+#define PCIE_PHY_REG_1_S_GET(x)                                      (((x) & PCIE_PHY_REG_1_S_MASK) >> PCIE_PHY_REG_1_S_LSB)
+#define PCIE_PHY_REG_1_S_SET(x)                                      (((x) << PCIE_PHY_REG_1_S_LSB) & PCIE_PHY_REG_1_S_MASK)
+#define PCIE_PHY_REG_1_S_RESET                                       0xe // 14
+#define PCIE_PHY_REG_1_ADDRESS                                       0x18116cc0
+#define PCIE_PHY_REG_1_OFFSET                                        0x0000
+// SW modifiable bits
+#define PCIE_PHY_REG_1_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define PCIE_PHY_REG_1_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PHY_REG_1_RESET                                         0x1021265e
+#define PCIE_PHY_REG_1_RESET_1                                       0x0061060e  
+
+// 32'h18116cc4 (PCIE_PHY_REG_2)
+#define PCIE_PHY_REG_2_PRBS_ERROR_COUNT_MSB                          31
+#define PCIE_PHY_REG_2_PRBS_ERROR_COUNT_LSB                          24
+#define PCIE_PHY_REG_2_PRBS_ERROR_COUNT_MASK                         0xff000000
+#define PCIE_PHY_REG_2_PRBS_ERROR_COUNT_GET(x)                       (((x) & PCIE_PHY_REG_2_PRBS_ERROR_COUNT_MASK) >> PCIE_PHY_REG_2_PRBS_ERROR_COUNT_LSB)
+#define PCIE_PHY_REG_2_PRBS_ERROR_COUNT_SET(x)                       (((x) << PCIE_PHY_REG_2_PRBS_ERROR_COUNT_LSB) & PCIE_PHY_REG_2_PRBS_ERROR_COUNT_MASK)
+#define PCIE_PHY_REG_2_PRBS_ERROR_COUNT_RESET                        0x0 // 0
+#define PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_MSB                        23
+#define PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_LSB                        23
+#define PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_MASK                       0x00800000
+#define PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_GET(x)                     (((x) & PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_MASK) >> PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_LSB)
+#define PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_SET(x)                     (((x) << PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_LSB) & PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_MASK)
+#define PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_RESET                      0x0 // 0
+#define PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_MSB                        22
+#define PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_LSB                        22
+#define PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_MASK                       0x00400000
+#define PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_GET(x)                     (((x) & PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_MASK) >> PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_LSB)
+#define PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_SET(x)                     (((x) << PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_LSB) & PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_MASK)
+#define PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_RESET                      0x0 // 0
+#define PCIE_PHY_REG_2_PRBS_SCRAMBLE_MSB                             21
+#define PCIE_PHY_REG_2_PRBS_SCRAMBLE_LSB                             21
+#define PCIE_PHY_REG_2_PRBS_SCRAMBLE_MASK                            0x00200000
+#define PCIE_PHY_REG_2_PRBS_SCRAMBLE_GET(x)                          (((x) & PCIE_PHY_REG_2_PRBS_SCRAMBLE_MASK) >> PCIE_PHY_REG_2_PRBS_SCRAMBLE_LSB)
+#define PCIE_PHY_REG_2_PRBS_SCRAMBLE_SET(x)                          (((x) << PCIE_PHY_REG_2_PRBS_SCRAMBLE_LSB) & PCIE_PHY_REG_2_PRBS_SCRAMBLE_MASK)
+#define PCIE_PHY_REG_2_PRBS_SCRAMBLE_RESET                           0x0 // 0
+#define PCIE_PHY_REG_2_PRBS_START_MSB                                20
+#define PCIE_PHY_REG_2_PRBS_START_LSB                                20
+#define PCIE_PHY_REG_2_PRBS_START_MASK                               0x00100000
+#define PCIE_PHY_REG_2_PRBS_START_GET(x)                             (((x) & PCIE_PHY_REG_2_PRBS_START_MASK) >> PCIE_PHY_REG_2_PRBS_START_LSB)
+#define PCIE_PHY_REG_2_PRBS_START_SET(x)                             (((x) << PCIE_PHY_REG_2_PRBS_START_LSB) & PCIE_PHY_REG_2_PRBS_START_MASK)
+#define PCIE_PHY_REG_2_PRBS_START_RESET                              0x0 // 0
+#define PCIE_PHY_REG_2_PRBS_TS_NUM_MSB                               19
+#define PCIE_PHY_REG_2_PRBS_TS_NUM_LSB                               13
+#define PCIE_PHY_REG_2_PRBS_TS_NUM_MASK                              0x000fe000
+#define PCIE_PHY_REG_2_PRBS_TS_NUM_GET(x)                            (((x) & PCIE_PHY_REG_2_PRBS_TS_NUM_MASK) >> PCIE_PHY_REG_2_PRBS_TS_NUM_LSB)
+#define PCIE_PHY_REG_2_PRBS_TS_NUM_SET(x)                            (((x) << PCIE_PHY_REG_2_PRBS_TS_NUM_LSB) & PCIE_PHY_REG_2_PRBS_TS_NUM_MASK)
+#define PCIE_PHY_REG_2_PRBS_TS_NUM_RESET                             0x40 // 64
+#define PCIE_PHY_REG_2_TXDETRXOVRVALUE_MSB                           12
+#define PCIE_PHY_REG_2_TXDETRXOVRVALUE_LSB                           12
+#define PCIE_PHY_REG_2_TXDETRXOVRVALUE_MASK                          0x00001000
+#define PCIE_PHY_REG_2_TXDETRXOVRVALUE_GET(x)                        (((x) & PCIE_PHY_REG_2_TXDETRXOVRVALUE_MASK) >> PCIE_PHY_REG_2_TXDETRXOVRVALUE_LSB)
+#define PCIE_PHY_REG_2_TXDETRXOVRVALUE_SET(x)                        (((x) << PCIE_PHY_REG_2_TXDETRXOVRVALUE_LSB) & PCIE_PHY_REG_2_TXDETRXOVRVALUE_MASK)
+#define PCIE_PHY_REG_2_TXDETRXOVRVALUE_RESET                         0x0 // 0
+#define PCIE_PHY_REG_2_TXDETRXOVREN_MSB                              11
+#define PCIE_PHY_REG_2_TXDETRXOVREN_LSB                              11
+#define PCIE_PHY_REG_2_TXDETRXOVREN_MASK                             0x00000800
+#define PCIE_PHY_REG_2_TXDETRXOVREN_GET(x)                           (((x) & PCIE_PHY_REG_2_TXDETRXOVREN_MASK) >> PCIE_PHY_REG_2_TXDETRXOVREN_LSB)
+#define PCIE_PHY_REG_2_TXDETRXOVREN_SET(x)                           (((x) << PCIE_PHY_REG_2_TXDETRXOVREN_LSB) & PCIE_PHY_REG_2_TXDETRXOVREN_MASK)
+#define PCIE_PHY_REG_2_TXDETRXOVREN_RESET                            0x0 // 0
+#define PCIE_PHY_REG_2_DATAOBSPRBSERR_MSB                            10
+#define PCIE_PHY_REG_2_DATAOBSPRBSERR_LSB                            10
+#define PCIE_PHY_REG_2_DATAOBSPRBSERR_MASK                           0x00000400
+#define PCIE_PHY_REG_2_DATAOBSPRBSERR_GET(x)                         (((x) & PCIE_PHY_REG_2_DATAOBSPRBSERR_MASK) >> PCIE_PHY_REG_2_DATAOBSPRBSERR_LSB)
+#define PCIE_PHY_REG_2_DATAOBSPRBSERR_SET(x)                         (((x) << PCIE_PHY_REG_2_DATAOBSPRBSERR_LSB) & PCIE_PHY_REG_2_DATAOBSPRBSERR_MASK)
+#define PCIE_PHY_REG_2_DATAOBSPRBSERR_RESET                          0x0 // 0
+#define PCIE_PHY_REG_2_CDRREADYTIMER_MSB                             9
+#define PCIE_PHY_REG_2_CDRREADYTIMER_LSB                             6
+#define PCIE_PHY_REG_2_CDRREADYTIMER_MASK                            0x000003c0
+#define PCIE_PHY_REG_2_CDRREADYTIMER_GET(x)                          (((x) & PCIE_PHY_REG_2_CDRREADYTIMER_MASK) >> PCIE_PHY_REG_2_CDRREADYTIMER_LSB)
+#define PCIE_PHY_REG_2_CDRREADYTIMER_SET(x)                          (((x) << PCIE_PHY_REG_2_CDRREADYTIMER_LSB) & PCIE_PHY_REG_2_CDRREADYTIMER_MASK)
+#define PCIE_PHY_REG_2_CDRREADYTIMER_RESET                           0x7 // 7
+#define PCIE_PHY_REG_2_TXDETRXTARGETDELAY_MSB                        5
+#define PCIE_PHY_REG_2_TXDETRXTARGETDELAY_LSB                        1
+#define PCIE_PHY_REG_2_TXDETRXTARGETDELAY_MASK                       0x0000003e
+#define PCIE_PHY_REG_2_TXDETRXTARGETDELAY_GET(x)                     (((x) & PCIE_PHY_REG_2_TXDETRXTARGETDELAY_MASK) >> PCIE_PHY_REG_2_TXDETRXTARGETDELAY_LSB)
+#define PCIE_PHY_REG_2_TXDETRXTARGETDELAY_SET(x)                     (((x) << PCIE_PHY_REG_2_TXDETRXTARGETDELAY_LSB) & PCIE_PHY_REG_2_TXDETRXTARGETDELAY_MASK)
+#define PCIE_PHY_REG_2_TXDETRXTARGETDELAY_RESET                      0xc // 12
+#define PCIE_PHY_REG_2_FORCEDETECT_MSB                               0
+#define PCIE_PHY_REG_2_FORCEDETECT_LSB                               0
+#define PCIE_PHY_REG_2_FORCEDETECT_MASK                              0x00000001
+#define PCIE_PHY_REG_2_FORCEDETECT_GET(x)                            (((x) & PCIE_PHY_REG_2_FORCEDETECT_MASK) >> PCIE_PHY_REG_2_FORCEDETECT_LSB)
+#define PCIE_PHY_REG_2_FORCEDETECT_SET(x)                            (((x) << PCIE_PHY_REG_2_FORCEDETECT_LSB) & PCIE_PHY_REG_2_FORCEDETECT_MASK)
+#define PCIE_PHY_REG_2_FORCEDETECT_RESET                             0x0 // 0
+#define PCIE_PHY_REG_2_ADDRESS                                       0x18116cc4
+#define PCIE_PHY_REG_2_OFFSET                                        0x0004
+// SW modifiable bits
+#define PCIE_PHY_REG_2_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define PCIE_PHY_REG_2_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PHY_REG_2_RESET                                         0x000801d8
+
+#define PCIE_PHY_REG_3_PRBS_COMMA_STATUS_MSB                         31
+#define PCIE_PHY_REG_3_PRBS_COMMA_STATUS_LSB                         28
+#define PCIE_PHY_REG_3_PRBS_COMMA_STATUS_MASK                        0xf0000000
+#define PCIE_PHY_REG_3_PRBS_COMMA_STATUS_GET(x)                      (((x) & PCIE_PHY_REG_3_PRBS_COMMA_STATUS_MASK) >> PCIE_PHY_REG_3_PRBS_COMMA_STATUS_LSB)
+#define PCIE_PHY_REG_3_PRBS_COMMA_STATUS_SET(x)                      (((x) << PCIE_PHY_REG_3_PRBS_COMMA_STATUS_LSB) & PCIE_PHY_REG_3_PRBS_COMMA_STATUS_MASK)
+#define PCIE_PHY_REG_3_PRBS_COMMA_STATUS_RESET                       0x0 // 0
+#define PCIE_PHY_REG_3_SPARE_MSB                                     27
+#define PCIE_PHY_REG_3_SPARE_LSB                                     11
+#define PCIE_PHY_REG_3_SPARE_MASK                                    0x0ffff800
+#define PCIE_PHY_REG_3_SPARE_GET(x)                                  (((x) & PCIE_PHY_REG_3_SPARE_MASK) >> PCIE_PHY_REG_3_SPARE_LSB)
+#define PCIE_PHY_REG_3_SPARE_SET(x)                                  (((x) << PCIE_PHY_REG_3_SPARE_LSB) & PCIE_PHY_REG_3_SPARE_MASK)
+#define PCIE_PHY_REG_3_SPARE_RESET                                   0xa0b // 2571
+#define PCIE_PHY_REG_3_SEL_CLK100_MSB                                10
+#define PCIE_PHY_REG_3_SEL_CLK100_LSB                                10
+#define PCIE_PHY_REG_3_SEL_CLK100_MASK                               0x00000400
+#define PCIE_PHY_REG_3_SEL_CLK100_GET(x)                             (((x) & PCIE_PHY_REG_3_SEL_CLK100_MASK) >> PCIE_PHY_REG_3_SEL_CLK100_LSB)
+#define PCIE_PHY_REG_3_SEL_CLK100_SET(x)                             (((x) << PCIE_PHY_REG_3_SEL_CLK100_LSB) & PCIE_PHY_REG_3_SEL_CLK100_MASK)
+#define PCIE_PHY_REG_3_SEL_CLK100_RESET                              0x0 // 0
+#define PCIE_PHY_REG_3_EN_BEACONGEN_MSB                              9
+#define PCIE_PHY_REG_3_EN_BEACONGEN_LSB                              9
+#define PCIE_PHY_REG_3_EN_BEACONGEN_MASK                             0x00000200
+#define PCIE_PHY_REG_3_EN_BEACONGEN_GET(x)                           (((x) & PCIE_PHY_REG_3_EN_BEACONGEN_MASK) >> PCIE_PHY_REG_3_EN_BEACONGEN_LSB)
+#define PCIE_PHY_REG_3_EN_BEACONGEN_SET(x)                           (((x) << PCIE_PHY_REG_3_EN_BEACONGEN_LSB) & PCIE_PHY_REG_3_EN_BEACONGEN_MASK)
+#define PCIE_PHY_REG_3_EN_BEACONGEN_RESET                            0x0 // 0
+#define PCIE_PHY_REG_3_TXELECIDLE_MSB                                8
+#define PCIE_PHY_REG_3_TXELECIDLE_LSB                                8
+#define PCIE_PHY_REG_3_TXELECIDLE_MASK                               0x00000100
+#define PCIE_PHY_REG_3_TXELECIDLE_GET(x)                             (((x) & PCIE_PHY_REG_3_TXELECIDLE_MASK) >> PCIE_PHY_REG_3_TXELECIDLE_LSB)
+#define PCIE_PHY_REG_3_TXELECIDLE_SET(x)                             (((x) << PCIE_PHY_REG_3_TXELECIDLE_LSB) & PCIE_PHY_REG_3_TXELECIDLE_MASK)
+#define PCIE_PHY_REG_3_TXELECIDLE_RESET                              0x0 // 0
+#define PCIE_PHY_REG_3_SEL_CLK_MSB                                   7
+#define PCIE_PHY_REG_3_SEL_CLK_LSB                                   6
+#define PCIE_PHY_REG_3_SEL_CLK_MASK                                  0x000000c0
+#define PCIE_PHY_REG_3_SEL_CLK_GET(x)                                (((x) & PCIE_PHY_REG_3_SEL_CLK_MASK) >> PCIE_PHY_REG_3_SEL_CLK_LSB)
+#define PCIE_PHY_REG_3_SEL_CLK_SET(x)                                (((x) << PCIE_PHY_REG_3_SEL_CLK_LSB) & PCIE_PHY_REG_3_SEL_CLK_MASK)
+#define PCIE_PHY_REG_3_SEL_CLK_RESET                                 0x0 // 0
+#define PCIE_PHY_REG_3_RX_DET_REQ_MSB                                5
+#define PCIE_PHY_REG_3_RX_DET_REQ_LSB                                5
+#define PCIE_PHY_REG_3_RX_DET_REQ_MASK                               0x00000020
+#define PCIE_PHY_REG_3_RX_DET_REQ_GET(x)                             (((x) & PCIE_PHY_REG_3_RX_DET_REQ_MASK) >> PCIE_PHY_REG_3_RX_DET_REQ_LSB)
+#define PCIE_PHY_REG_3_RX_DET_REQ_SET(x)                             (((x) << PCIE_PHY_REG_3_RX_DET_REQ_LSB) & PCIE_PHY_REG_3_RX_DET_REQ_MASK)
+#define PCIE_PHY_REG_3_RX_DET_REQ_RESET                              0x0 // 0
+#define PCIE_PHY_REG_3_MODE_OCLK_IN_MSB                              4
+#define PCIE_PHY_REG_3_MODE_OCLK_IN_LSB                              4
+#define PCIE_PHY_REG_3_MODE_OCLK_IN_MASK                             0x00000010
+#define PCIE_PHY_REG_3_MODE_OCLK_IN_GET(x)                           (((x) & PCIE_PHY_REG_3_MODE_OCLK_IN_MASK) >> PCIE_PHY_REG_3_MODE_OCLK_IN_LSB)
+#define PCIE_PHY_REG_3_MODE_OCLK_IN_SET(x)                           (((x) << PCIE_PHY_REG_3_MODE_OCLK_IN_LSB) & PCIE_PHY_REG_3_MODE_OCLK_IN_MASK)
+#define PCIE_PHY_REG_3_MODE_OCLK_IN_RESET                            0x0 // 0
+#define PCIE_PHY_REG_3_EN_PLL_MSB                                    3
+#define PCIE_PHY_REG_3_EN_PLL_LSB                                    3
+#define PCIE_PHY_REG_3_EN_PLL_MASK                                   0x00000008
+#define PCIE_PHY_REG_3_EN_PLL_GET(x)                                 (((x) & PCIE_PHY_REG_3_EN_PLL_MASK) >> PCIE_PHY_REG_3_EN_PLL_LSB)
+#define PCIE_PHY_REG_3_EN_PLL_SET(x)                                 (((x) << PCIE_PHY_REG_3_EN_PLL_LSB) & PCIE_PHY_REG_3_EN_PLL_MASK)
+#define PCIE_PHY_REG_3_EN_PLL_RESET                                  0x1 // 1
+#define PCIE_PHY_REG_3_EN_LCKDT_MSB                                  2
+#define PCIE_PHY_REG_3_EN_LCKDT_LSB                                  2
+#define PCIE_PHY_REG_3_EN_LCKDT_MASK                                 0x00000004
+#define PCIE_PHY_REG_3_EN_LCKDT_GET(x)                               (((x) & PCIE_PHY_REG_3_EN_LCKDT_MASK) >> PCIE_PHY_REG_3_EN_LCKDT_LSB)
+#define PCIE_PHY_REG_3_EN_LCKDT_SET(x)                               (((x) << PCIE_PHY_REG_3_EN_LCKDT_LSB) & PCIE_PHY_REG_3_EN_LCKDT_MASK)
+#define PCIE_PHY_REG_3_EN_LCKDT_RESET                                0x1 // 1
+#define PCIE_PHY_REG_3_EN_BUFS_RX_MSB                                1
+#define PCIE_PHY_REG_3_EN_BUFS_RX_LSB                                1
+#define PCIE_PHY_REG_3_EN_BUFS_RX_MASK                               0x00000002
+#define PCIE_PHY_REG_3_EN_BUFS_RX_GET(x)                             (((x) & PCIE_PHY_REG_3_EN_BUFS_RX_MASK) >> PCIE_PHY_REG_3_EN_BUFS_RX_LSB)
+#define PCIE_PHY_REG_3_EN_BUFS_RX_SET(x)                             (((x) << PCIE_PHY_REG_3_EN_BUFS_RX_LSB) & PCIE_PHY_REG_3_EN_BUFS_RX_MASK)
+#define PCIE_PHY_REG_3_EN_BUFS_RX_RESET                              0x0 // 0
+#define PCIE_PHY_REG_3_EN_MSB                                        0
+#define PCIE_PHY_REG_3_EN_LSB                                        0
+#define PCIE_PHY_REG_3_EN_MASK                                       0x00000001
+#define PCIE_PHY_REG_3_EN_GET(x)                                     (((x) & PCIE_PHY_REG_3_EN_MASK) >> PCIE_PHY_REG_3_EN_LSB)
+#define PCIE_PHY_REG_3_EN_SET(x)                                     (((x) << PCIE_PHY_REG_3_EN_LSB) & PCIE_PHY_REG_3_EN_MASK)
+#define PCIE_PHY_REG_3_EN_RESET                                      0x0 // 0
+#define PCIE_PHY_REG_3_ADDRESS                                       0x18116cc8
+#define PCIE_PHY_REG_3_OFFSET                                        0x0008
+// SW modifiable bits
+#define PCIE_PHY_REG_3_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define PCIE_PHY_REG_3_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PHY_REG_3_RESET                                         0x0050580c
+#define PCIE_PHY_REG_3_RESET_1 		               		     0x00505900
+
+#define PCIE_PHY_REG_4_PRBS_ERROR_RATE_MSB                           31
+#define PCIE_PHY_REG_4_PRBS_ERROR_RATE_LSB                           11
+#define PCIE_PHY_REG_4_PRBS_ERROR_RATE_MASK                          0xfffff800
+#define PCIE_PHY_REG_4_PRBS_ERROR_RATE_GET(x)                        (((x) & PCIE_PHY_REG_4_PRBS_ERROR_RATE_MASK) >> PCIE_PHY_REG_4_PRBS_ERROR_RATE_LSB)
+#define PCIE_PHY_REG_4_PRBS_ERROR_RATE_SET(x)                        (((x) << PCIE_PHY_REG_4_PRBS_ERROR_RATE_LSB) & PCIE_PHY_REG_4_PRBS_ERROR_RATE_MASK)
+#define PCIE_PHY_REG_4_PRBS_ERROR_RATE_RESET                         0xa000 // 40960
+#define PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_MSB                      10
+#define PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_LSB                      1
+#define PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_MASK                     0x000007fe
+#define PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_GET(x)                   (((x) & PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_MASK) >> PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_LSB)
+#define PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_SET(x)                   (((x) << PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_LSB) & PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_MASK)
+#define PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_RESET                    0x0 // 0
+#define PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_MSB                        0
+#define PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_LSB                        0
+#define PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_MASK                       0x00000001
+#define PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_GET(x)                     (((x) & PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_MASK) >> PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_LSB)
+#define PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_SET(x)                     (((x) << PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_LSB) & PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_MASK)
+#define PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_RESET                      0x0 // 0
+#define PCIE_PHY_REG_4_ADDRESS                                       0x18116ccc
+#define PCIE_PHY_REG_4_OFFSET                                        0x000c
+// SW modifiable bits
+#define PCIE_PHY_REG_4_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define PCIE_PHY_REG_4_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PHY_REG_4_RESET                                         0x05000000
+
+#define XTAL_TCXODET_MSB                                             31
+#define XTAL_TCXODET_LSB                                             31
+#define XTAL_TCXODET_MASK                                            0x80000000
+#define XTAL_TCXODET_GET(x)                                          (((x) & XTAL_TCXODET_MASK) >> XTAL_TCXODET_LSB)
+#define XTAL_TCXODET_SET(x)                                          (((x) << XTAL_TCXODET_LSB) & XTAL_TCXODET_MASK)
+#define XTAL_TCXODET_RESET                                           0x0 // 0
+#define XTAL_XTAL_CAPINDAC_MSB                                       30
+#define XTAL_XTAL_CAPINDAC_LSB                                       24
+#define XTAL_XTAL_CAPINDAC_MASK                                      0x7f000000
+#define XTAL_XTAL_CAPINDAC_GET(x)                                    (((x) & XTAL_XTAL_CAPINDAC_MASK) >> XTAL_XTAL_CAPINDAC_LSB)
+#define XTAL_XTAL_CAPINDAC_SET(x)                                    (((x) << XTAL_XTAL_CAPINDAC_LSB) & XTAL_XTAL_CAPINDAC_MASK)
+#define XTAL_XTAL_CAPINDAC_RESET                                     0x4b // 75
+#define XTAL_XTAL_CAPOUTDAC_MSB                                      23
+#define XTAL_XTAL_CAPOUTDAC_LSB                                      17
+#define XTAL_XTAL_CAPOUTDAC_MASK                                     0x00fe0000
+#define XTAL_XTAL_CAPOUTDAC_GET(x)                                   (((x) & XTAL_XTAL_CAPOUTDAC_MASK) >> XTAL_XTAL_CAPOUTDAC_LSB)
+#define XTAL_XTAL_CAPOUTDAC_SET(x)                                   (((x) << XTAL_XTAL_CAPOUTDAC_LSB) & XTAL_XTAL_CAPOUTDAC_MASK)
+#define XTAL_XTAL_CAPOUTDAC_RESET                                    0x4b // 75
+#define XTAL_XTAL_DRVSTR_MSB                                         16
+#define XTAL_XTAL_DRVSTR_LSB                                         15
+#define XTAL_XTAL_DRVSTR_MASK                                        0x00018000
+#define XTAL_XTAL_DRVSTR_GET(x)                                      (((x) & XTAL_XTAL_DRVSTR_MASK) >> XTAL_XTAL_DRVSTR_LSB)
+#define XTAL_XTAL_DRVSTR_SET(x)                                      (((x) << XTAL_XTAL_DRVSTR_LSB) & XTAL_XTAL_DRVSTR_MASK)
+#define XTAL_XTAL_DRVSTR_RESET                                       0x0 // 0
+#define XTAL_XTAL_SHORTXIN_MSB                                       14
+#define XTAL_XTAL_SHORTXIN_LSB                                       14
+#define XTAL_XTAL_SHORTXIN_MASK                                      0x00004000
+#define XTAL_XTAL_SHORTXIN_GET(x)                                    (((x) & XTAL_XTAL_SHORTXIN_MASK) >> XTAL_XTAL_SHORTXIN_LSB)
+#define XTAL_XTAL_SHORTXIN_SET(x)                                    (((x) << XTAL_XTAL_SHORTXIN_LSB) & XTAL_XTAL_SHORTXIN_MASK)
+#define XTAL_XTAL_SHORTXIN_RESET                                     0x0 // 0
+#define XTAL_XTAL_LOCALBIAS_MSB                                      13
+#define XTAL_XTAL_LOCALBIAS_LSB                                      13
+#define XTAL_XTAL_LOCALBIAS_MASK                                     0x00002000
+#define XTAL_XTAL_LOCALBIAS_GET(x)                                   (((x) & XTAL_XTAL_LOCALBIAS_MASK) >> XTAL_XTAL_LOCALBIAS_LSB)
+#define XTAL_XTAL_LOCALBIAS_SET(x)                                   (((x) << XTAL_XTAL_LOCALBIAS_LSB) & XTAL_XTAL_LOCALBIAS_MASK)
+#define XTAL_XTAL_LOCALBIAS_RESET                                    0x1 // 1
+#define XTAL_XTAL_PWDCLKD_MSB                                        12
+#define XTAL_XTAL_PWDCLKD_LSB                                        12
+#define XTAL_XTAL_PWDCLKD_MASK                                       0x00001000
+#define XTAL_XTAL_PWDCLKD_GET(x)                                     (((x) & XTAL_XTAL_PWDCLKD_MASK) >> XTAL_XTAL_PWDCLKD_LSB)
+#define XTAL_XTAL_PWDCLKD_SET(x)                                     (((x) << XTAL_XTAL_PWDCLKD_LSB) & XTAL_XTAL_PWDCLKD_MASK)
+#define XTAL_XTAL_PWDCLKD_RESET                                      0x0 // 0
+#define XTAL_XTAL_BIAS2X_MSB                                         11
+#define XTAL_XTAL_BIAS2X_LSB                                         11
+#define XTAL_XTAL_BIAS2X_MASK                                        0x00000800
+#define XTAL_XTAL_BIAS2X_GET(x)                                      (((x) & XTAL_XTAL_BIAS2X_MASK) >> XTAL_XTAL_BIAS2X_LSB)
+#define XTAL_XTAL_BIAS2X_SET(x)                                      (((x) << XTAL_XTAL_BIAS2X_LSB) & XTAL_XTAL_BIAS2X_MASK)
+#define XTAL_XTAL_BIAS2X_RESET                                       0x0 // 0
+#define XTAL_XTAL_LBIAS2X_MSB                                        10
+#define XTAL_XTAL_LBIAS2X_LSB                                        10
+#define XTAL_XTAL_LBIAS2X_MASK                                       0x00000400
+#define XTAL_XTAL_LBIAS2X_GET(x)                                     (((x) & XTAL_XTAL_LBIAS2X_MASK) >> XTAL_XTAL_LBIAS2X_LSB)
+#define XTAL_XTAL_LBIAS2X_SET(x)                                     (((x) << XTAL_XTAL_LBIAS2X_LSB) & XTAL_XTAL_LBIAS2X_MASK)
+#define XTAL_XTAL_LBIAS2X_RESET                                      0x0 // 0
+#define XTAL_XTAL_SELVREG_MSB                                        9
+#define XTAL_XTAL_SELVREG_LSB                                        9
+#define XTAL_XTAL_SELVREG_MASK                                       0x00000200
+#define XTAL_XTAL_SELVREG_GET(x)                                     (((x) & XTAL_XTAL_SELVREG_MASK) >> XTAL_XTAL_SELVREG_LSB)
+#define XTAL_XTAL_SELVREG_SET(x)                                     (((x) << XTAL_XTAL_SELVREG_LSB) & XTAL_XTAL_SELVREG_MASK)
+#define XTAL_XTAL_SELVREG_RESET                                      0x0 // 0
+#define XTAL_XTAL_OSCON_MSB                                          8
+#define XTAL_XTAL_OSCON_LSB                                          8
+#define XTAL_XTAL_OSCON_MASK                                         0x00000100
+#define XTAL_XTAL_OSCON_GET(x)                                       (((x) & XTAL_XTAL_OSCON_MASK) >> XTAL_XTAL_OSCON_LSB)
+#define XTAL_XTAL_OSCON_SET(x)                                       (((x) << XTAL_XTAL_OSCON_LSB) & XTAL_XTAL_OSCON_MASK)
+#define XTAL_XTAL_OSCON_RESET                                        0x1 // 1
+#define XTAL_XTAL_PWDCLKIN_MSB                                       7
+#define XTAL_XTAL_PWDCLKIN_LSB                                       7
+#define XTAL_XTAL_PWDCLKIN_MASK                                      0x00000080
+#define XTAL_XTAL_PWDCLKIN_GET(x)                                    (((x) & XTAL_XTAL_PWDCLKIN_MASK) >> XTAL_XTAL_PWDCLKIN_LSB)
+#define XTAL_XTAL_PWDCLKIN_SET(x)                                    (((x) << XTAL_XTAL_PWDCLKIN_LSB) & XTAL_XTAL_PWDCLKIN_MASK)
+#define XTAL_XTAL_PWDCLKIN_RESET                                     0x0 // 0
+#define XTAL_LOCAL_XTAL_MSB                                          6
+#define XTAL_LOCAL_XTAL_LSB                                          6
+#define XTAL_LOCAL_XTAL_MASK                                         0x00000040
+#define XTAL_LOCAL_XTAL_GET(x)                                       (((x) & XTAL_LOCAL_XTAL_MASK) >> XTAL_LOCAL_XTAL_LSB)
+#define XTAL_LOCAL_XTAL_SET(x)                                       (((x) << XTAL_LOCAL_XTAL_LSB) & XTAL_LOCAL_XTAL_MASK)
+#define XTAL_LOCAL_XTAL_RESET                                        0x0 // 0
+#define XTAL_PWD_SWREGCLK_MSB                                        5
+#define XTAL_PWD_SWREGCLK_LSB                                        5
+#define XTAL_PWD_SWREGCLK_MASK                                       0x00000020
+#define XTAL_PWD_SWREGCLK_GET(x)                                     (((x) & XTAL_PWD_SWREGCLK_MASK) >> XTAL_PWD_SWREGCLK_LSB)
+#define XTAL_PWD_SWREGCLK_SET(x)                                     (((x) << XTAL_PWD_SWREGCLK_LSB) & XTAL_PWD_SWREGCLK_MASK)
+#define XTAL_PWD_SWREGCLK_RESET                                      0x0 // 0
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_MSB                                4
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_LSB                                4
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_MASK                               0x00000010
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_GET(x)                             (((x) & XTAL_LOCAL_EXT_CLK_OUT_EN_MASK) >> XTAL_LOCAL_EXT_CLK_OUT_EN_LSB)
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_SET(x)                             (((x) << XTAL_LOCAL_EXT_CLK_OUT_EN_LSB) & XTAL_LOCAL_EXT_CLK_OUT_EN_MASK)
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_RESET                              0x0 // 0
+#define XTAL_EXT_CLK_OUT_EN_MSB                                      3
+#define XTAL_EXT_CLK_OUT_EN_LSB                                      3
+#define XTAL_EXT_CLK_OUT_EN_MASK                                     0x00000008
+#define XTAL_EXT_CLK_OUT_EN_GET(x)                                   (((x) & XTAL_EXT_CLK_OUT_EN_MASK) >> XTAL_EXT_CLK_OUT_EN_LSB)
+#define XTAL_EXT_CLK_OUT_EN_SET(x)                                   (((x) << XTAL_EXT_CLK_OUT_EN_LSB) & XTAL_EXT_CLK_OUT_EN_MASK)
+#define XTAL_EXT_CLK_OUT_EN_RESET                                    0x0 // 0
+#define XTAL_XTAL_SVREG_MSB                                          2
+#define XTAL_XTAL_SVREG_LSB                                          2
+#define XTAL_XTAL_SVREG_MASK                                         0x00000004
+#define XTAL_XTAL_SVREG_GET(x)                                       (((x) & XTAL_XTAL_SVREG_MASK) >> XTAL_XTAL_SVREG_LSB)
+#define XTAL_XTAL_SVREG_SET(x)                                       (((x) << XTAL_XTAL_SVREG_LSB) & XTAL_XTAL_SVREG_MASK)
+#define XTAL_XTAL_SVREG_RESET                                        0x0 // 0
+#define XTAL_RBK_UDSEL_MSB                                           1
+#define XTAL_RBK_UDSEL_LSB                                           1
+#define XTAL_RBK_UDSEL_MASK                                          0x00000002
+#define XTAL_RBK_UDSEL_GET(x)                                        (((x) & XTAL_RBK_UDSEL_MASK) >> XTAL_RBK_UDSEL_LSB)
+#define XTAL_RBK_UDSEL_SET(x)                                        (((x) << XTAL_RBK_UDSEL_LSB) & XTAL_RBK_UDSEL_MASK)
+#define XTAL_RBK_UDSEL_RESET                                         0x0 // 0
+#define XTAL_SPARE_MSB                                               0
+#define XTAL_SPARE_LSB                                               0
+#define XTAL_SPARE_MASK                                              0x00000001
+#define XTAL_SPARE_GET(x)                                            (((x) & XTAL_SPARE_MASK) >> XTAL_SPARE_LSB)
+#define XTAL_SPARE_SET(x)                                            (((x) << XTAL_SPARE_LSB) & XTAL_SPARE_MASK)
+#define XTAL_SPARE_RESET                                             0x0 // 0
+#define XTAL_ADDRESS                                                 0x181162c0
+
+#define XTAL2_TDC_COUNT_MSB                                          31
+#define XTAL2_TDC_COUNT_LSB                                          26
+#define XTAL2_TDC_COUNT_MASK                                         0xfc000000
+#define XTAL2_TDC_COUNT_GET(x)                                       (((x) & XTAL2_TDC_COUNT_MASK) >> XTAL2_TDC_COUNT_LSB)
+#define XTAL2_TDC_COUNT_SET(x)                                       (((x) << XTAL2_TDC_COUNT_LSB) & XTAL2_TDC_COUNT_MASK)
+#define XTAL2_TDC_COUNT_RESET                                        0x0 // 0
+#define XTAL2_TDC_PH_COUNT_MSB                                       25
+#define XTAL2_TDC_PH_COUNT_LSB                                       21
+#define XTAL2_TDC_PH_COUNT_MASK                                      0x03e00000
+#define XTAL2_TDC_PH_COUNT_GET(x)                                    (((x) & XTAL2_TDC_PH_COUNT_MASK) >> XTAL2_TDC_PH_COUNT_LSB)
+#define XTAL2_TDC_PH_COUNT_SET(x)                                    (((x) << XTAL2_TDC_PH_COUNT_LSB) & XTAL2_TDC_PH_COUNT_MASK)
+#define XTAL2_TDC_PH_COUNT_RESET                                     0x0 // 0
+#define XTAL2_DUTY_UP_MSB                                            20
+#define XTAL2_DUTY_UP_LSB                                            16
+#define XTAL2_DUTY_UP_MASK                                           0x001f0000
+#define XTAL2_DUTY_UP_GET(x)                                         (((x) & XTAL2_DUTY_UP_MASK) >> XTAL2_DUTY_UP_LSB)
+#define XTAL2_DUTY_UP_SET(x)                                         (((x) << XTAL2_DUTY_UP_LSB) & XTAL2_DUTY_UP_MASK)
+#define XTAL2_DUTY_UP_RESET                                          0x0 // 0
+#define XTAL2_DUTY_DN_MSB                                            15
+#define XTAL2_DUTY_DN_LSB                                            11
+#define XTAL2_DUTY_DN_MASK                                           0x0000f800
+#define XTAL2_DUTY_DN_GET(x)                                         (((x) & XTAL2_DUTY_DN_MASK) >> XTAL2_DUTY_DN_LSB)
+#define XTAL2_DUTY_DN_SET(x)                                         (((x) << XTAL2_DUTY_DN_LSB) & XTAL2_DUTY_DN_MASK)
+#define XTAL2_DUTY_DN_RESET                                          0x0 // 0
+#define XTAL2_DCA_BYPASS_MSB                                         10
+#define XTAL2_DCA_BYPASS_LSB                                         10
+#define XTAL2_DCA_BYPASS_MASK                                        0x00000400
+#define XTAL2_DCA_BYPASS_GET(x)                                      (((x) & XTAL2_DCA_BYPASS_MASK) >> XTAL2_DCA_BYPASS_LSB)
+#define XTAL2_DCA_BYPASS_SET(x)                                      (((x) << XTAL2_DCA_BYPASS_LSB) & XTAL2_DCA_BYPASS_MASK)
+#define XTAL2_DCA_BYPASS_RESET                                       0x1 // 1
+#define XTAL2_DCA_SWCAL_MSB                                          9
+#define XTAL2_DCA_SWCAL_LSB                                          9
+#define XTAL2_DCA_SWCAL_MASK                                         0x00000200
+#define XTAL2_DCA_SWCAL_GET(x)                                       (((x) & XTAL2_DCA_SWCAL_MASK) >> XTAL2_DCA_SWCAL_LSB)
+#define XTAL2_DCA_SWCAL_SET(x)                                       (((x) << XTAL2_DCA_SWCAL_LSB) & XTAL2_DCA_SWCAL_MASK)
+#define XTAL2_DCA_SWCAL_RESET                                        0x0 // 0
+#define XTAL2_FSM_UD_HOLD_MSB                                        8
+#define XTAL2_FSM_UD_HOLD_LSB                                        8
+#define XTAL2_FSM_UD_HOLD_MASK                                       0x00000100
+#define XTAL2_FSM_UD_HOLD_GET(x)                                     (((x) & XTAL2_FSM_UD_HOLD_MASK) >> XTAL2_FSM_UD_HOLD_LSB)
+#define XTAL2_FSM_UD_HOLD_SET(x)                                     (((x) << XTAL2_FSM_UD_HOLD_LSB) & XTAL2_FSM_UD_HOLD_MASK)
+#define XTAL2_FSM_UD_HOLD_RESET                                      0x0 // 0
+#define XTAL2_FSM_START_L_MSB                                        7
+#define XTAL2_FSM_START_L_LSB                                        7
+#define XTAL2_FSM_START_L_MASK                                       0x00000080
+#define XTAL2_FSM_START_L_GET(x)                                     (((x) & XTAL2_FSM_START_L_MASK) >> XTAL2_FSM_START_L_LSB)
+#define XTAL2_FSM_START_L_SET(x)                                     (((x) << XTAL2_FSM_START_L_LSB) & XTAL2_FSM_START_L_MASK)
+#define XTAL2_FSM_START_L_RESET                                      0x1 // 1
+#define XTAL2_FSM_DN_READBACK_MSB                                    6
+#define XTAL2_FSM_DN_READBACK_LSB                                    2
+#define XTAL2_FSM_DN_READBACK_MASK                                   0x0000007c
+#define XTAL2_FSM_DN_READBACK_GET(x)                                 (((x) & XTAL2_FSM_DN_READBACK_MASK) >> XTAL2_FSM_DN_READBACK_LSB)
+#define XTAL2_FSM_DN_READBACK_SET(x)                                 (((x) << XTAL2_FSM_DN_READBACK_LSB) & XTAL2_FSM_DN_READBACK_MASK)
+#define XTAL2_FSM_DN_READBACK_RESET                                  0x0 // 0
+#define XTAL2_TDC_SAT_FLAG_MSB                                       1
+#define XTAL2_TDC_SAT_FLAG_LSB                                       1
+#define XTAL2_TDC_SAT_FLAG_MASK                                      0x00000002
+#define XTAL2_TDC_SAT_FLAG_GET(x)                                    (((x) & XTAL2_TDC_SAT_FLAG_MASK) >> XTAL2_TDC_SAT_FLAG_LSB)
+#define XTAL2_TDC_SAT_FLAG_SET(x)                                    (((x) << XTAL2_TDC_SAT_FLAG_LSB) & XTAL2_TDC_SAT_FLAG_MASK)
+#define XTAL2_TDC_SAT_FLAG_RESET                                     0x0 // 0
+#define XTAL2_FSM_READY_MSB                                          0
+#define XTAL2_FSM_READY_LSB                                          0
+#define XTAL2_FSM_READY_MASK                                         0x00000001
+#define XTAL2_FSM_READY_GET(x)                                       (((x) & XTAL2_FSM_READY_MASK) >> XTAL2_FSM_READY_LSB)
+#define XTAL2_FSM_READY_SET(x)                                       (((x) << XTAL2_FSM_READY_LSB) & XTAL2_FSM_READY_MASK)
+#define XTAL2_FSM_READY_RESET                                        0x0 // 0
+#define XTAL2_ADDRESS                                                0x181162c4
+
+#define XTAL3_FSM_UP_READBACK_MSB                                    31
+#define XTAL3_FSM_UP_READBACK_LSB                                    27
+#define XTAL3_FSM_UP_READBACK_MASK                                   0xf8000000
+#define XTAL3_FSM_UP_READBACK_GET(x)                                 (((x) & XTAL3_FSM_UP_READBACK_MASK) >> XTAL3_FSM_UP_READBACK_LSB)
+#define XTAL3_FSM_UP_READBACK_SET(x)                                 (((x) << XTAL3_FSM_UP_READBACK_LSB) & XTAL3_FSM_UP_READBACK_MASK)
+#define XTAL3_FSM_UP_READBACK_RESET                                  0x0 // 0
+#define XTAL3_EVAL_LENGTH_MSB                                        26
+#define XTAL3_EVAL_LENGTH_LSB                                        16
+#define XTAL3_EVAL_LENGTH_MASK                                       0x07ff0000
+#define XTAL3_EVAL_LENGTH_GET(x)                                     (((x) & XTAL3_EVAL_LENGTH_MASK) >> XTAL3_EVAL_LENGTH_LSB)
+#define XTAL3_EVAL_LENGTH_SET(x)                                     (((x) << XTAL3_EVAL_LENGTH_LSB) & XTAL3_EVAL_LENGTH_MASK)
+#define XTAL3_EVAL_LENGTH_RESET                                      0x400 // 1024
+#define XTAL3_TDC_ERROR_FLAG_MSB                                     15
+#define XTAL3_TDC_ERROR_FLAG_LSB                                     15
+#define XTAL3_TDC_ERROR_FLAG_MASK                                    0x00008000
+#define XTAL3_TDC_ERROR_FLAG_GET(x)                                  (((x) & XTAL3_TDC_ERROR_FLAG_MASK) >> XTAL3_TDC_ERROR_FLAG_LSB)
+#define XTAL3_TDC_ERROR_FLAG_SET(x)                                  (((x) << XTAL3_TDC_ERROR_FLAG_LSB) & XTAL3_TDC_ERROR_FLAG_MASK)
+#define XTAL3_TDC_ERROR_FLAG_RESET                                   0x0 // 0
+#define XTAL3_HARMONIC_NUMBER_MSB                                    14
+#define XTAL3_HARMONIC_NUMBER_LSB                                    2
+#define XTAL3_HARMONIC_NUMBER_MASK                                   0x00007ffc
+#define XTAL3_HARMONIC_NUMBER_GET(x)                                 (((x) & XTAL3_HARMONIC_NUMBER_MASK) >> XTAL3_HARMONIC_NUMBER_LSB)
+#define XTAL3_HARMONIC_NUMBER_SET(x)                                 (((x) << XTAL3_HARMONIC_NUMBER_LSB) & XTAL3_HARMONIC_NUMBER_MASK)
+#define XTAL3_HARMONIC_NUMBER_RESET                                  0x51 // 81
+#define XTAL3_SPARE_MSB                                              1
+#define XTAL3_SPARE_LSB                                              0
+#define XTAL3_SPARE_MASK                                             0x00000003
+#define XTAL3_SPARE_GET(x)                                           (((x) & XTAL3_SPARE_MASK) >> XTAL3_SPARE_LSB)
+#define XTAL3_SPARE_SET(x)                                           (((x) << XTAL3_SPARE_LSB) & XTAL3_SPARE_MASK)
+#define XTAL3_SPARE_RESET                                            0x0 // 0
+#define XTAL3_ADDRESS                                                0x181162c8
+
+#define RST_REVISION_ID_ADDRESS                                      0x18060090
+#define is_drqfn()	(!(ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0x1000))
+
+#define RST_BOOTSTRAP_RES4_MSB                                       15
+#define RST_BOOTSTRAP_RES4_LSB                                       13
+#define RST_BOOTSTRAP_RES4_MASK                                      0x0000e000
+#define RST_BOOTSTRAP_RES4_GET(x)                                    (((x) & RST_BOOTSTRAP_RES4_MASK) >> RST_BOOTSTRAP_RES4_LSB)
+#define RST_BOOTSTRAP_RES4_SET(x)                                    (((x) << RST_BOOTSTRAP_RES4_LSB) & RST_BOOTSTRAP_RES4_MASK)
+#define RST_BOOTSTRAP_RES4_RESET                                     0x0 // 0
+#define RST_BOOTSTRAP_SW_OPTION2_MSB                                 12
+#define RST_BOOTSTRAP_SW_OPTION2_LSB                                 12
+#define RST_BOOTSTRAP_SW_OPTION2_MASK                                0x00001000
+#define RST_BOOTSTRAP_SW_OPTION2_GET(x)                              (((x) & RST_BOOTSTRAP_SW_OPTION2_MASK) >> RST_BOOTSTRAP_SW_OPTION2_LSB)
+#define RST_BOOTSTRAP_SW_OPTION2_SET(x)                              (((x) << RST_BOOTSTRAP_SW_OPTION2_LSB) & RST_BOOTSTRAP_SW_OPTION2_MASK)
+#define RST_BOOTSTRAP_SW_OPTION2_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_SW_OPTION1_MSB                                 11
+#define RST_BOOTSTRAP_SW_OPTION1_LSB                                 11
+#define RST_BOOTSTRAP_SW_OPTION1_MASK                                0x00000800
+#define RST_BOOTSTRAP_SW_OPTION1_GET(x)                              (((x) & RST_BOOTSTRAP_SW_OPTION1_MASK) >> RST_BOOTSTRAP_SW_OPTION1_LSB)
+#define RST_BOOTSTRAP_SW_OPTION1_SET(x)                              (((x) << RST_BOOTSTRAP_SW_OPTION1_LSB) & RST_BOOTSTRAP_SW_OPTION1_MASK)
+#define RST_BOOTSTRAP_SW_OPTION1_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_TESTROM_ENABLE_MSB                             10
+#define RST_BOOTSTRAP_TESTROM_ENABLE_LSB                             10
+#define RST_BOOTSTRAP_TESTROM_ENABLE_MASK                            0x00000400
+#define RST_BOOTSTRAP_TESTROM_ENABLE_GET(x)                          (((x) & RST_BOOTSTRAP_TESTROM_ENABLE_MASK) >> RST_BOOTSTRAP_TESTROM_ENABLE_LSB)
+#define RST_BOOTSTRAP_TESTROM_ENABLE_SET(x)                          (((x) << RST_BOOTSTRAP_TESTROM_ENABLE_LSB) & RST_BOOTSTRAP_TESTROM_ENABLE_MASK)
+#define RST_BOOTSTRAP_TESTROM_ENABLE_RESET                           0x0 // 0
+#define RST_BOOTSTRAP_RES3_MSB                                       9
+#define RST_BOOTSTRAP_RES3_LSB                                       9
+#define RST_BOOTSTRAP_RES3_MASK                                      0x00000200
+#define RST_BOOTSTRAP_RES3_GET(x)                                    (((x) & RST_BOOTSTRAP_RES3_MASK) >> RST_BOOTSTRAP_RES3_LSB)
+#define RST_BOOTSTRAP_RES3_SET(x)                                    (((x) << RST_BOOTSTRAP_RES3_LSB) & RST_BOOTSTRAP_RES3_MASK)
+#define RST_BOOTSTRAP_RES3_RESET                                     0x0 // 0
+#define RST_BOOTSTRAP_SRIF_ENABLE_MSB                                8
+#define RST_BOOTSTRAP_SRIF_ENABLE_LSB                                8
+#define RST_BOOTSTRAP_SRIF_ENABLE_MASK                               0x00000100
+#define RST_BOOTSTRAP_SRIF_ENABLE_GET(x)                             (((x) & RST_BOOTSTRAP_SRIF_ENABLE_MASK) >> RST_BOOTSTRAP_SRIF_ENABLE_LSB)
+#define RST_BOOTSTRAP_SRIF_ENABLE_SET(x)                             (((x) << RST_BOOTSTRAP_SRIF_ENABLE_LSB) & RST_BOOTSTRAP_SRIF_ENABLE_MASK)
+#define RST_BOOTSTRAP_SRIF_ENABLE_RESET                              0x0 // 0
+#define RST_BOOTSTRAP_USB_MODE_MSB                                   7
+#define RST_BOOTSTRAP_USB_MODE_LSB                                   7
+#define RST_BOOTSTRAP_USB_MODE_MASK                                  0x00000080
+#define RST_BOOTSTRAP_USB_MODE_GET(x)                                (((x) & RST_BOOTSTRAP_USB_MODE_MASK) >> RST_BOOTSTRAP_USB_MODE_LSB)
+#define RST_BOOTSTRAP_USB_MODE_SET(x)                                (((x) << RST_BOOTSTRAP_USB_MODE_LSB) & RST_BOOTSTRAP_USB_MODE_MASK)
+#define RST_BOOTSTRAP_USB_MODE_RESET                                 0x0 // 0
+#define RST_BOOTSTRAP_RES2_MSB                                       6
+#define RST_BOOTSTRAP_RES2_LSB                                       6
+#define RST_BOOTSTRAP_RES2_MASK                                      0x00000040
+#define RST_BOOTSTRAP_RES2_GET(x)                                    (((x) & RST_BOOTSTRAP_RES2_MASK) >> RST_BOOTSTRAP_RES2_LSB)
+#define RST_BOOTSTRAP_RES2_SET(x)                                    (((x) << RST_BOOTSTRAP_RES2_LSB) & RST_BOOTSTRAP_RES2_MASK)
+#define RST_BOOTSTRAP_RES2_RESET                                     0x0 // 0
+#define RST_BOOTSTRAP_EJTAG_MODE_MSB                                 5
+#define RST_BOOTSTRAP_EJTAG_MODE_LSB                                 5
+#define RST_BOOTSTRAP_EJTAG_MODE_MASK                                0x00000020
+#define RST_BOOTSTRAP_EJTAG_MODE_GET(x)                              (((x) & RST_BOOTSTRAP_EJTAG_MODE_MASK) >> RST_BOOTSTRAP_EJTAG_MODE_LSB)
+#define RST_BOOTSTRAP_EJTAG_MODE_SET(x)                              (((x) << RST_BOOTSTRAP_EJTAG_MODE_LSB) & RST_BOOTSTRAP_EJTAG_MODE_MASK)
+#define RST_BOOTSTRAP_EJTAG_MODE_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_REF_CLK_MSB                                    4
+#define RST_BOOTSTRAP_REF_CLK_LSB                                    4
+#define RST_BOOTSTRAP_REF_CLK_MASK                                   0x00000010
+#define RST_BOOTSTRAP_REF_CLK_GET(x)                                 (((x) & RST_BOOTSTRAP_REF_CLK_MASK) >> RST_BOOTSTRAP_REF_CLK_LSB)
+#define RST_BOOTSTRAP_REF_CLK_SET(x)                                 (((x) << RST_BOOTSTRAP_REF_CLK_LSB) & RST_BOOTSTRAP_REF_CLK_MASK)
+#define RST_BOOTSTRAP_REF_CLK_RESET                                  0x0 // 0
+#define RST_BOOTSTRAP_RES1_MSB                                       3
+#define RST_BOOTSTRAP_RES1_LSB                                       3
+#define RST_BOOTSTRAP_RES1_MASK                                      0x00000008
+#define RST_BOOTSTRAP_RES1_GET(x)                                    (((x) & RST_BOOTSTRAP_RES1_MASK) >> RST_BOOTSTRAP_RES1_LSB)
+#define RST_BOOTSTRAP_RES1_SET(x)                                    (((x) << RST_BOOTSTRAP_RES1_LSB) & RST_BOOTSTRAP_RES1_MASK)
+#define RST_BOOTSTRAP_RES1_RESET                                     0x0 // 0
+#define RST_BOOTSTRAP_RES0_MSB                                       2
+#define RST_BOOTSTRAP_RES0_LSB                                       2
+#define RST_BOOTSTRAP_RES0_MASK                                      0x00000004
+#define RST_BOOTSTRAP_RES0_GET(x)                                    (((x) & RST_BOOTSTRAP_RES0_MASK) >> RST_BOOTSTRAP_RES0_LSB)
+#define RST_BOOTSTRAP_RES0_SET(x)                                    (((x) << RST_BOOTSTRAP_RES0_LSB) & RST_BOOTSTRAP_RES0_MASK)
+#define RST_BOOTSTRAP_RES0_RESET                                     0x0 // 0
+#define RST_BOOTSTRAP_SDRAM_SELECT_MSB                               1
+#define RST_BOOTSTRAP_SDRAM_SELECT_LSB                               1
+#define RST_BOOTSTRAP_SDRAM_SELECT_MASK                              0x00000002
+#define RST_BOOTSTRAP_SDRAM_SELECT_GET(x)                            (((x) & RST_BOOTSTRAP_SDRAM_SELECT_MASK) >> RST_BOOTSTRAP_SDRAM_SELECT_LSB)
+#define RST_BOOTSTRAP_SDRAM_SELECT_SET(x)                            (((x) << RST_BOOTSTRAP_SDRAM_SELECT_LSB) & RST_BOOTSTRAP_SDRAM_SELECT_MASK)
+#define RST_BOOTSTRAP_SDRAM_SELECT_RESET                             0x0 // 0
+#define RST_BOOTSTRAP_DDR_SELECT_MSB                                 0
+#define RST_BOOTSTRAP_DDR_SELECT_LSB                                 0
+#define RST_BOOTSTRAP_DDR_SELECT_MASK                                0x00000001
+#define RST_BOOTSTRAP_DDR_SELECT_GET(x)                              (((x) & RST_BOOTSTRAP_DDR_SELECT_MASK) >> RST_BOOTSTRAP_DDR_SELECT_LSB)
+#define RST_BOOTSTRAP_DDR_SELECT_SET(x)                              (((x) << RST_BOOTSTRAP_DDR_SELECT_LSB) & RST_BOOTSTRAP_DDR_SELECT_MASK)
+#define RST_BOOTSTRAP_DDR_SELECT_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_ADDRESS                                        0x180600b0
+
+#define RST_CLKGAT_EN_SPARE_MSB                                      31
+#define RST_CLKGAT_EN_SPARE_LSB                                      12
+#define RST_CLKGAT_EN_SPARE_MASK                                     0xfffff000
+#define RST_CLKGAT_EN_SPARE_GET(x)                                   (((x) & RST_CLKGAT_EN_SPARE_MASK) >> RST_CLKGAT_EN_SPARE_LSB)
+#define RST_CLKGAT_EN_SPARE_SET(x)                                   (((x) << RST_CLKGAT_EN_SPARE_LSB) & RST_CLKGAT_EN_SPARE_MASK)
+#define RST_CLKGAT_EN_SPARE_RESET                                    0x0 // 0
+#define RST_CLKGAT_EN_WMAC_MSB                                       9
+#define RST_CLKGAT_EN_WMAC_LSB                                       9
+#define RST_CLKGAT_EN_WMAC_MASK                                      0x00000200
+#define RST_CLKGAT_EN_WMAC_GET(x)                                    (((x) & RST_CLKGAT_EN_WMAC_MASK) >> RST_CLKGAT_EN_WMAC_LSB)
+#define RST_CLKGAT_EN_WMAC_SET(x)                                    (((x) << RST_CLKGAT_EN_WMAC_LSB) & RST_CLKGAT_EN_WMAC_MASK)
+#define RST_CLKGAT_EN_WMAC_RESET                                     0x1 // 1
+#define RST_CLKGAT_EN_USB1_MSB                                       7
+#define RST_CLKGAT_EN_USB1_LSB                                       7
+#define RST_CLKGAT_EN_USB1_MASK                                      0x00000080
+#define RST_CLKGAT_EN_USB1_GET(x)                                    (((x) & RST_CLKGAT_EN_USB1_MASK) >> RST_CLKGAT_EN_USB1_LSB)
+#define RST_CLKGAT_EN_USB1_SET(x)                                    (((x) << RST_CLKGAT_EN_USB1_LSB) & RST_CLKGAT_EN_USB1_MASK)
+#define RST_CLKGAT_EN_USB1_RESET                                     0x1 // 1
+#define RST_CLKGAT_EN_GE1_MSB                                        6
+#define RST_CLKGAT_EN_GE1_LSB                                        6
+#define RST_CLKGAT_EN_GE1_MASK                                       0x00000040
+#define RST_CLKGAT_EN_GE1_GET(x)                                     (((x) & RST_CLKGAT_EN_GE1_MASK) >> RST_CLKGAT_EN_GE1_LSB)
+#define RST_CLKGAT_EN_GE1_SET(x)                                     (((x) << RST_CLKGAT_EN_GE1_LSB) & RST_CLKGAT_EN_GE1_MASK)
+#define RST_CLKGAT_EN_GE1_RESET                                      0x1 // 1
+#define RST_CLKGAT_EN_GE0_MSB                                        5
+#define RST_CLKGAT_EN_GE0_LSB                                        5
+#define RST_CLKGAT_EN_GE0_MASK                                       0x00000020
+#define RST_CLKGAT_EN_GE0_GET(x)                                     (((x) & RST_CLKGAT_EN_GE0_MASK) >> RST_CLKGAT_EN_GE0_LSB)
+#define RST_CLKGAT_EN_GE0_SET(x)                                     (((x) << RST_CLKGAT_EN_GE0_LSB) & RST_CLKGAT_EN_GE0_MASK)
+#define RST_CLKGAT_EN_GE0_RESET                                      0x1 // 1
+#define RST_CLKGAT_EN_PCIE_RC_MSB                                    1
+#define RST_CLKGAT_EN_PCIE_RC_LSB                                    1
+#define RST_CLKGAT_EN_PCIE_RC_MASK                                   0x00000002
+#define RST_CLKGAT_EN_PCIE_RC_GET(x)                                 (((x) & RST_CLKGAT_EN_PCIE_RC_MASK) >> RST_CLKGAT_EN_PCIE_RC_LSB)
+#define RST_CLKGAT_EN_PCIE_RC_SET(x)                                 (((x) << RST_CLKGAT_EN_PCIE_RC_LSB) & RST_CLKGAT_EN_PCIE_RC_MASK)
+#define RST_CLKGAT_EN_PCIE_RC_RESET                                  0x1 // 1
+#define RST_CLKGAT_EN_ADDRESS                                        0x180600c0
+#define RST_CLKGAT_EN_OFFSET                                         0x00c0
+// SW modifiable bits
+#define RST_CLKGAT_EN_SW_MASK                                        0xfffff2e2
+// bits defined at reset
+#define RST_CLKGAT_EN_RSTMASK                                        0xffffffff
+// reset value (ignore bits undefined at reset)
+#define RST_CLKGAT_EN_RESET                                          0x000002e2
+
+#define GPIO_OE_ADDRESS                                              0x18040000
+#define GPIO_OUT_ADDRESS                                             0x18040008
+#define GPIO_SPARE_ADDRESS                                           0x18040070
+
+
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_MSB                         31
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_LSB                         24
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_MASK                        0xff000000
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_GET(x)                      (((x) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_MASK) >> GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_LSB)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_SET(x)                      (((x) << GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_LSB) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_MASK)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_MSB                         23
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_LSB                         16
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_MASK                        0x00ff0000
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_GET(x)                      (((x) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_MASK) >> GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_LSB)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_SET(x)                      (((x) << GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_LSB) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_MASK)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_MSB                         15
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_LSB                         8
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_GET(x)                      (((x) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_MASK) >> GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_LSB)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_SET(x)                      (((x) << GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_LSB) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_MASK)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_MSB                         7
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_LSB                         0
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_GET(x)                      (((x) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_MASK) >> GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_LSB)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_SET(x)                      (((x) << GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_LSB) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_MASK)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION0_ADDRESS                                   0x1804002c
+
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MSB                         31
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB                         24
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK                        0xff000000
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_RESET                       0xc // 12
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MSB                         23
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB                         16
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK                        0x00ff0000
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_RESET                       0x8 // 8
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MSB                         15
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB                         8
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_RESET                       0x9 // 9
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MSB                         7
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB                         0
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_RESET                       0x5d // 93
+#define GPIO_OUT_FUNCTION1_ADDRESS                                   0x18040030
+
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MSB                        31
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB                        24
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_GET(x)                     (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_SET(x)                     (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MSB                        23
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB                        16
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK                       0x00ff0000
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_GET(x)                     (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_SET(x)                     (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MSB                         15
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB                         8
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_GET(x)                      (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_SET(x)                      (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MSB                         7
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB                         0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_GET(x)                      (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_SET(x)                      (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION2_ADDRESS                                   0x18040034
+
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MSB                        31
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB                        24
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MSB                        23
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB                        16
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK                       0x00ff0000
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MSB                        15
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB                        8
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK                       0x0000ff00
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MSB                        7
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB                        0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK                       0x000000ff
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ADDRESS                                   0x18040038
+
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MSB                        15
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB                        8
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK                       0x0000ff00
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_RESET                      0x1 // 1
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MSB                        7
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB                        0
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK                       0x000000ff
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION4_ADDRESS                                   0x1804003c
+
+#define GPIO_IN_ENABLE0_UART_SIN_MSB                                 15
+#define GPIO_IN_ENABLE0_UART_SIN_LSB                                 8
+#define GPIO_IN_ENABLE0_UART_SIN_MASK                                0x0000ff00
+#define GPIO_IN_ENABLE0_UART_SIN_GET(x)                              (((x) & GPIO_IN_ENABLE0_UART_SIN_MASK) >> GPIO_IN_ENABLE0_UART_SIN_LSB)
+#define GPIO_IN_ENABLE0_UART_SIN_SET(x)                              (((x) << GPIO_IN_ENABLE0_UART_SIN_LSB) & GPIO_IN_ENABLE0_UART_SIN_MASK)
+#define GPIO_IN_ENABLE0_UART_SIN_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_MSB                              7
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_LSB                              0
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_MASK                             0x000000ff
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_GET(x)                           (((x) & GPIO_IN_ENABLE0_SPI_DATA_IN_MASK) >> GPIO_IN_ENABLE0_SPI_DATA_IN_LSB)
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_SET(x)                           (((x) << GPIO_IN_ENABLE0_SPI_DATA_IN_LSB) & GPIO_IN_ENABLE0_SPI_DATA_IN_MASK)
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_RESET                            0x8 // 8
+#define GPIO_IN_ENABLE0_ADDRESS                                      0x18040044
+
+#define GPIO_IN_ENABLE1_RES_MSB                                      31
+#define GPIO_IN_ENABLE1_RES_LSB                                      0
+#define GPIO_IN_ENABLE1_RES_MASK                                     0xffffffff
+#define GPIO_IN_ENABLE1_RES_GET(x)                                   (((x) & GPIO_IN_ENABLE1_RES_MASK) >> GPIO_IN_ENABLE1_RES_LSB)
+#define GPIO_IN_ENABLE1_RES_SET(x)                                   (((x) << GPIO_IN_ENABLE1_RES_LSB) & GPIO_IN_ENABLE1_RES_MASK)
+#define GPIO_IN_ENABLE1_RES_RESET                                    0x0 // 0
+#define GPIO_IN_ENABLE1_ADDRESS                                      0x18040048
+
+#define GPIO_IN_ENABLE2_RES_MSB                                      31
+#define GPIO_IN_ENABLE2_RES_LSB                                      0
+#define GPIO_IN_ENABLE2_RES_MASK                                     0xffffffff
+#define GPIO_IN_ENABLE2_RES_GET(x)                                   (((x) & GPIO_IN_ENABLE2_RES_MASK) >> GPIO_IN_ENABLE2_RES_LSB)
+#define GPIO_IN_ENABLE2_RES_SET(x)                                   (((x) << GPIO_IN_ENABLE2_RES_LSB) & GPIO_IN_ENABLE2_RES_MASK)
+#define GPIO_IN_ENABLE2_RES_RESET                                    0x0 // 0
+#define GPIO_IN_ENABLE2_ADDRESS                                      0x1804004c
+
+#define GPIO_IN_ENABLE3_RES_MSB                                      31
+#define GPIO_IN_ENABLE3_RES_LSB                                      0
+#define GPIO_IN_ENABLE3_RES_MASK                                     0xffffffff
+#define GPIO_IN_ENABLE3_RES_GET(x)                                   (((x) & GPIO_IN_ENABLE3_RES_MASK) >> GPIO_IN_ENABLE3_RES_LSB)
+#define GPIO_IN_ENABLE3_RES_SET(x)                                   (((x) << GPIO_IN_ENABLE3_RES_LSB) & GPIO_IN_ENABLE3_RES_MASK)
+#define GPIO_IN_ENABLE3_RES_RESET                                    0x0 // 0
+#define GPIO_IN_ENABLE3_ADDRESS                                      0x18040050
+
+#define GPIO_IN_ENABLE4_RES_MSB                                      31
+#define GPIO_IN_ENABLE4_RES_LSB                                      0
+#define GPIO_IN_ENABLE4_RES_MASK                                     0xffffffff
+#define GPIO_IN_ENABLE4_RES_GET(x)                                   (((x) & GPIO_IN_ENABLE4_RES_MASK) >> GPIO_IN_ENABLE4_RES_LSB)
+#define GPIO_IN_ENABLE4_RES_SET(x)                                   (((x) << GPIO_IN_ENABLE4_RES_LSB) & GPIO_IN_ENABLE4_RES_MASK)
+#define GPIO_IN_ENABLE4_RES_RESET                                    0x0 // 0
+#define GPIO_IN_ENABLE4_ADDRESS                                      0x18040054
+
+#define GPIO_IN_ENABLE5_WMAC_IN3_MSB                                 31
+#define GPIO_IN_ENABLE5_WMAC_IN3_LSB                                 24
+#define GPIO_IN_ENABLE5_WMAC_IN3_MASK                                0xff000000
+#define GPIO_IN_ENABLE5_WMAC_IN3_GET(x)                              (((x) & GPIO_IN_ENABLE5_WMAC_IN3_MASK) >> GPIO_IN_ENABLE5_WMAC_IN3_LSB)
+#define GPIO_IN_ENABLE5_WMAC_IN3_SET(x)                              (((x) << GPIO_IN_ENABLE5_WMAC_IN3_LSB) & GPIO_IN_ENABLE5_WMAC_IN3_MASK)
+#define GPIO_IN_ENABLE5_WMAC_IN3_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE5_WMAC_IN2_MSB                                 23
+#define GPIO_IN_ENABLE5_WMAC_IN2_LSB                                 16
+#define GPIO_IN_ENABLE5_WMAC_IN2_MASK                                0x00ff0000
+#define GPIO_IN_ENABLE5_WMAC_IN2_GET(x)                              (((x) & GPIO_IN_ENABLE5_WMAC_IN2_MASK) >> GPIO_IN_ENABLE5_WMAC_IN2_LSB)
+#define GPIO_IN_ENABLE5_WMAC_IN2_SET(x)                              (((x) << GPIO_IN_ENABLE5_WMAC_IN2_LSB) & GPIO_IN_ENABLE5_WMAC_IN2_MASK)
+#define GPIO_IN_ENABLE5_WMAC_IN2_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE5_WMAC_IN1_MSB                                 15
+#define GPIO_IN_ENABLE5_WMAC_IN1_LSB                                 8
+#define GPIO_IN_ENABLE5_WMAC_IN1_MASK                                0x0000ff00
+#define GPIO_IN_ENABLE5_WMAC_IN1_GET(x)                              (((x) & GPIO_IN_ENABLE5_WMAC_IN1_MASK) >> GPIO_IN_ENABLE5_WMAC_IN1_LSB)
+#define GPIO_IN_ENABLE5_WMAC_IN1_SET(x)                              (((x) << GPIO_IN_ENABLE5_WMAC_IN1_LSB) & GPIO_IN_ENABLE5_WMAC_IN1_MASK)
+#define GPIO_IN_ENABLE5_WMAC_IN1_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE5_WMAC_IN0_MSB                                 7
+#define GPIO_IN_ENABLE5_WMAC_IN0_LSB                                 0
+#define GPIO_IN_ENABLE5_WMAC_IN0_MASK                                0x000000ff
+#define GPIO_IN_ENABLE5_WMAC_IN0_GET(x)                              (((x) & GPIO_IN_ENABLE5_WMAC_IN0_MASK) >> GPIO_IN_ENABLE5_WMAC_IN0_LSB)
+#define GPIO_IN_ENABLE5_WMAC_IN0_SET(x)                              (((x) << GPIO_IN_ENABLE5_WMAC_IN0_LSB) & GPIO_IN_ENABLE5_WMAC_IN0_MASK)
+#define GPIO_IN_ENABLE5_WMAC_IN0_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE5_ADDRESS                                      0x18040058
+
+#define GPIO_IN_ENABLE6_WMAC_IN7_MSB                                 31
+#define GPIO_IN_ENABLE6_WMAC_IN7_LSB                                 24
+#define GPIO_IN_ENABLE6_WMAC_IN7_MASK                                0xff000000
+#define GPIO_IN_ENABLE6_WMAC_IN7_GET(x)                              (((x) & GPIO_IN_ENABLE6_WMAC_IN7_MASK) >> GPIO_IN_ENABLE6_WMAC_IN7_LSB)
+#define GPIO_IN_ENABLE6_WMAC_IN7_SET(x)                              (((x) << GPIO_IN_ENABLE6_WMAC_IN7_LSB) & GPIO_IN_ENABLE6_WMAC_IN7_MASK)
+#define GPIO_IN_ENABLE6_WMAC_IN7_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE6_WMAC_IN6_MSB                                 23
+#define GPIO_IN_ENABLE6_WMAC_IN6_LSB                                 16
+#define GPIO_IN_ENABLE6_WMAC_IN6_MASK                                0x00ff0000
+#define GPIO_IN_ENABLE6_WMAC_IN6_GET(x)                              (((x) & GPIO_IN_ENABLE6_WMAC_IN6_MASK) >> GPIO_IN_ENABLE6_WMAC_IN6_LSB)
+#define GPIO_IN_ENABLE6_WMAC_IN6_SET(x)                              (((x) << GPIO_IN_ENABLE6_WMAC_IN6_LSB) & GPIO_IN_ENABLE6_WMAC_IN6_MASK)
+#define GPIO_IN_ENABLE6_WMAC_IN6_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE6_WMAC_IN5_MSB                                 15
+#define GPIO_IN_ENABLE6_WMAC_IN5_LSB                                 8
+#define GPIO_IN_ENABLE6_WMAC_IN5_MASK                                0x0000ff00
+#define GPIO_IN_ENABLE6_WMAC_IN5_GET(x)                              (((x) & GPIO_IN_ENABLE6_WMAC_IN5_MASK) >> GPIO_IN_ENABLE6_WMAC_IN5_LSB)
+#define GPIO_IN_ENABLE6_WMAC_IN5_SET(x)                              (((x) << GPIO_IN_ENABLE6_WMAC_IN5_LSB) & GPIO_IN_ENABLE6_WMAC_IN5_MASK)
+#define GPIO_IN_ENABLE6_WMAC_IN5_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE6_WMAC_IN4_MSB                                 7
+#define GPIO_IN_ENABLE6_WMAC_IN4_LSB                                 0
+#define GPIO_IN_ENABLE6_WMAC_IN4_MASK                                0x000000ff
+#define GPIO_IN_ENABLE6_WMAC_IN4_GET(x)                              (((x) & GPIO_IN_ENABLE6_WMAC_IN4_MASK) >> GPIO_IN_ENABLE6_WMAC_IN4_LSB)
+#define GPIO_IN_ENABLE6_WMAC_IN4_SET(x)                              (((x) << GPIO_IN_ENABLE6_WMAC_IN4_LSB) & GPIO_IN_ENABLE6_WMAC_IN4_MASK)
+#define GPIO_IN_ENABLE6_WMAC_IN4_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE6_ADDRESS                                      0x1804005c
+
+#define GPIO_IN_ENABLE7_WMAC_IN11_MSB                                31
+#define GPIO_IN_ENABLE7_WMAC_IN11_LSB                                24
+#define GPIO_IN_ENABLE7_WMAC_IN11_MASK                               0xff000000
+#define GPIO_IN_ENABLE7_WMAC_IN11_GET(x)                             (((x) & GPIO_IN_ENABLE7_WMAC_IN11_MASK) >> GPIO_IN_ENABLE7_WMAC_IN11_LSB)
+#define GPIO_IN_ENABLE7_WMAC_IN11_SET(x)                             (((x) << GPIO_IN_ENABLE7_WMAC_IN11_LSB) & GPIO_IN_ENABLE7_WMAC_IN11_MASK)
+#define GPIO_IN_ENABLE7_WMAC_IN11_RESET                              0x80 // 128
+#define GPIO_IN_ENABLE7_WMAC_IN10_MSB                                23
+#define GPIO_IN_ENABLE7_WMAC_IN10_LSB                                16
+#define GPIO_IN_ENABLE7_WMAC_IN10_MASK                               0x00ff0000
+#define GPIO_IN_ENABLE7_WMAC_IN10_GET(x)                             (((x) & GPIO_IN_ENABLE7_WMAC_IN10_MASK) >> GPIO_IN_ENABLE7_WMAC_IN10_LSB)
+#define GPIO_IN_ENABLE7_WMAC_IN10_SET(x)                             (((x) << GPIO_IN_ENABLE7_WMAC_IN10_LSB) & GPIO_IN_ENABLE7_WMAC_IN10_MASK)
+#define GPIO_IN_ENABLE7_WMAC_IN10_RESET                              0x80 // 128
+#define GPIO_IN_ENABLE7_WMAC_IN9_MSB                                 15
+#define GPIO_IN_ENABLE7_WMAC_IN9_LSB                                 8
+#define GPIO_IN_ENABLE7_WMAC_IN9_MASK                                0x0000ff00
+#define GPIO_IN_ENABLE7_WMAC_IN9_GET(x)                              (((x) & GPIO_IN_ENABLE7_WMAC_IN9_MASK) >> GPIO_IN_ENABLE7_WMAC_IN9_LSB)
+#define GPIO_IN_ENABLE7_WMAC_IN9_SET(x)                              (((x) << GPIO_IN_ENABLE7_WMAC_IN9_LSB) & GPIO_IN_ENABLE7_WMAC_IN9_MASK)
+#define GPIO_IN_ENABLE7_WMAC_IN9_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE7_WMAC_IN8_MSB                                 7
+#define GPIO_IN_ENABLE7_WMAC_IN8_LSB                                 0
+#define GPIO_IN_ENABLE7_WMAC_IN8_MASK                                0x000000ff
+#define GPIO_IN_ENABLE7_WMAC_IN8_GET(x)                              (((x) & GPIO_IN_ENABLE7_WMAC_IN8_MASK) >> GPIO_IN_ENABLE7_WMAC_IN8_LSB)
+#define GPIO_IN_ENABLE7_WMAC_IN8_SET(x)                              (((x) << GPIO_IN_ENABLE7_WMAC_IN8_LSB) & GPIO_IN_ENABLE7_WMAC_IN8_MASK)
+#define GPIO_IN_ENABLE7_WMAC_IN8_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE7_ADDRESS                                      0x18040060
+
+#define GPIO_IN_ENABLE8_SRIF_SRESET_MSB                              31
+#define GPIO_IN_ENABLE8_SRIF_SRESET_LSB                              24
+#define GPIO_IN_ENABLE8_SRIF_SRESET_MASK                             0xff000000
+#define GPIO_IN_ENABLE8_SRIF_SRESET_GET(x)                           (((x) & GPIO_IN_ENABLE8_SRIF_SRESET_MASK) >> GPIO_IN_ENABLE8_SRIF_SRESET_LSB)
+#define GPIO_IN_ENABLE8_SRIF_SRESET_SET(x)                           (((x) << GPIO_IN_ENABLE8_SRIF_SRESET_LSB) & GPIO_IN_ENABLE8_SRIF_SRESET_MASK)
+#define GPIO_IN_ENABLE8_SRIF_SRESET_RESET                            0x80 // 128
+#define GPIO_IN_ENABLE8_SRIF_SIN_MSB                                 23
+#define GPIO_IN_ENABLE8_SRIF_SIN_LSB                                 16
+#define GPIO_IN_ENABLE8_SRIF_SIN_MASK                                0x00ff0000
+#define GPIO_IN_ENABLE8_SRIF_SIN_GET(x)                              (((x) & GPIO_IN_ENABLE8_SRIF_SIN_MASK) >> GPIO_IN_ENABLE8_SRIF_SIN_LSB)
+#define GPIO_IN_ENABLE8_SRIF_SIN_SET(x)                              (((x) << GPIO_IN_ENABLE8_SRIF_SIN_LSB) & GPIO_IN_ENABLE8_SRIF_SIN_MASK)
+#define GPIO_IN_ENABLE8_SRIF_SIN_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE8_SRIF_SOT_MSB                                 15
+#define GPIO_IN_ENABLE8_SRIF_SOT_LSB                                 8
+#define GPIO_IN_ENABLE8_SRIF_SOT_MASK                                0x0000ff00
+#define GPIO_IN_ENABLE8_SRIF_SOT_GET(x)                              (((x) & GPIO_IN_ENABLE8_SRIF_SOT_MASK) >> GPIO_IN_ENABLE8_SRIF_SOT_LSB)
+#define GPIO_IN_ENABLE8_SRIF_SOT_SET(x)                              (((x) << GPIO_IN_ENABLE8_SRIF_SOT_LSB) & GPIO_IN_ENABLE8_SRIF_SOT_MASK)
+#define GPIO_IN_ENABLE8_SRIF_SOT_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE8_SRIF_SCLK_MSB                                7
+#define GPIO_IN_ENABLE8_SRIF_SCLK_LSB                                0
+#define GPIO_IN_ENABLE8_SRIF_SCLK_MASK                               0x000000ff
+#define GPIO_IN_ENABLE8_SRIF_SCLK_GET(x)                             (((x) & GPIO_IN_ENABLE8_SRIF_SCLK_MASK) >> GPIO_IN_ENABLE8_SRIF_SCLK_LSB)
+#define GPIO_IN_ENABLE8_SRIF_SCLK_SET(x)                             (((x) << GPIO_IN_ENABLE8_SRIF_SCLK_LSB) & GPIO_IN_ENABLE8_SRIF_SCLK_MASK)
+#define GPIO_IN_ENABLE8_SRIF_SCLK_RESET                              0x80 // 128
+#define GPIO_IN_ENABLE8_ADDRESS                                      0x18040064
+
+#define GPIO_IN_ENABLE9_RES_MSB                                      31
+#define GPIO_IN_ENABLE9_RES_LSB                                      0
+#define GPIO_IN_ENABLE9_RES_MASK                                     0xffffffff
+#define GPIO_IN_ENABLE9_RES_GET(x)                                   (((x) & GPIO_IN_ENABLE9_RES_MASK) >> GPIO_IN_ENABLE9_RES_LSB)
+#define GPIO_IN_ENABLE9_RES_SET(x)                                   (((x) << GPIO_IN_ENABLE9_RES_LSB) & GPIO_IN_ENABLE9_RES_MASK)
+#define GPIO_IN_ENABLE9_RES_RESET                                    0x0 // 0
+#define GPIO_IN_ENABLE9_ADDRESS                                      0x18040068
+
+#define GPIO_FUNCTION_EXT_MDIO_SEL_MSB                               11
+#define GPIO_FUNCTION_EXT_MDIO_SEL_LSB                               11
+#define GPIO_FUNCTION_EXT_MDIO_SEL_MASK                              0x00000800
+#define GPIO_FUNCTION_EXT_MDIO_SEL_GET(x)                            (((x) & GPIO_FUNCTION_EXT_MDIO_SEL_MASK) >> GPIO_FUNCTION_EXT_MDIO_SEL_LSB)
+#define GPIO_FUNCTION_EXT_MDIO_SEL_SET(x)                            (((x) << GPIO_FUNCTION_EXT_MDIO_SEL_LSB) & GPIO_FUNCTION_EXT_MDIO_SEL_MASK)
+#define GPIO_FUNCTION_EXT_MDIO_SEL_RESET                             0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_MSB                            8
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB                            8
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK                           0x00000100
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_MSB                            7
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB                            7
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK                           0x00000080
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_MSB                            6
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB                            6
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK                           0x00000040
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_MSB                            5
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB                            5
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK                           0x00000020
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_RESET                          0x1 // 1
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_MSB                            4
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB                            4
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK                           0x00000010
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_MSB                            3
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB                            3
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK                           0x00000008
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_MSB                            2
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB                            2
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK                           0x00000004
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_DISABLE_JTAG_MSB                               1
+#define GPIO_FUNCTION_DISABLE_JTAG_LSB                               1
+#define GPIO_FUNCTION_DISABLE_JTAG_MASK                              0x00000002
+#define GPIO_FUNCTION_DISABLE_JTAG_GET(x)                            (((x) & GPIO_FUNCTION_DISABLE_JTAG_MASK) >> GPIO_FUNCTION_DISABLE_JTAG_LSB)
+#define GPIO_FUNCTION_DISABLE_JTAG_SET(x)                            (((x) << GPIO_FUNCTION_DISABLE_JTAG_LSB) & GPIO_FUNCTION_DISABLE_JTAG_MASK)
+#define GPIO_FUNCTION_DISABLE_JTAG_RESET                             0x0 // 0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_MSB                           0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB                           0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK                          0x00000001
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_GET(x)                        (((x) & GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK) >> GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB)
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_SET(x)                        (((x) << GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB) & GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK)
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_RESET                         0x0 // 0
+#define GPIO_FUNCTION_ADDRESS                                        0x1804006c
+
+#define PCIE_RESET_EP_RESET_L_MSB                                    2
+#define PCIE_RESET_EP_RESET_L_LSB                                    2
+#define PCIE_RESET_EP_RESET_L_MASK                                   0x00000004
+#define PCIE_RESET_EP_RESET_L_GET(x)                                 (((x) & PCIE_RESET_EP_RESET_L_MASK) >> PCIE_RESET_EP_RESET_L_LSB)
+#define PCIE_RESET_EP_RESET_L_SET(x)                                 (((x) << PCIE_RESET_EP_RESET_L_LSB) & PCIE_RESET_EP_RESET_L_MASK)
+#define PCIE_RESET_EP_RESET_L_RESET                                  0x0 // 0
+#define PCIE_RESET_LINK_REQ_RESET_MSB                                1
+#define PCIE_RESET_LINK_REQ_RESET_LSB                                1
+#define PCIE_RESET_LINK_REQ_RESET_MASK                               0x00000002
+#define PCIE_RESET_LINK_REQ_RESET_GET(x)                             (((x) & PCIE_RESET_LINK_REQ_RESET_MASK) >> PCIE_RESET_LINK_REQ_RESET_LSB)
+#define PCIE_RESET_LINK_REQ_RESET_SET(x)                             (((x) << PCIE_RESET_LINK_REQ_RESET_LSB) & PCIE_RESET_LINK_REQ_RESET_MASK)
+#define PCIE_RESET_LINK_REQ_RESET_RESET                              0x0 // 0
+#define PCIE_RESET_LINK_UP_MSB                                       0
+#define PCIE_RESET_LINK_UP_LSB                                       0
+#define PCIE_RESET_LINK_UP_MASK                                      0x00000001
+#define PCIE_RESET_LINK_UP_GET(x)                                    (((x) & PCIE_RESET_LINK_UP_MASK) >> PCIE_RESET_LINK_UP_LSB)
+#define PCIE_RESET_LINK_UP_SET(x)                                    (((x) << PCIE_RESET_LINK_UP_LSB) & PCIE_RESET_LINK_UP_MASK)
+#define PCIE_RESET_LINK_UP_RESET                                     0x0 // 0
+#define PCIE_RESET_ADDRESS                                           0x180f0018
+
+#define ETH_CFG_ETH_SPARE_MSB                                        31
+#define ETH_CFG_ETH_SPARE_LSB                                        22
+#define ETH_CFG_ETH_SPARE_MASK                                       0xffc00000
+#define ETH_CFG_ETH_SPARE_GET(x)                                     (((x) & ETH_CFG_ETH_SPARE_MASK) >> ETH_CFG_ETH_SPARE_LSB)
+#define ETH_CFG_ETH_SPARE_SET(x)                                     (((x) << ETH_CFG_ETH_SPARE_LSB) & ETH_CFG_ETH_SPARE_MASK)
+#define ETH_CFG_ETH_SPARE_RESET                                      0x0 // 0
+#define ETH_CFG_SW_ACC_MSB_FIRST_MSB                                 13
+#define ETH_CFG_SW_ACC_MSB_FIRST_LSB                                 13
+#define ETH_CFG_SW_ACC_MSB_FIRST_MASK                                0x00002000
+#define ETH_CFG_SW_ACC_MSB_FIRST_GET(x)                              (((x) & ETH_CFG_SW_ACC_MSB_FIRST_MASK) >> ETH_CFG_SW_ACC_MSB_FIRST_LSB)
+#define ETH_CFG_SW_ACC_MSB_FIRST_SET(x)                              (((x) << ETH_CFG_SW_ACC_MSB_FIRST_LSB) & ETH_CFG_SW_ACC_MSB_FIRST_MASK)
+#define ETH_CFG_SW_ACC_MSB_FIRST_RESET                               0x1 // 1
+#define ETH_CFG_SW_APB_ACCESS_MSB                                    9
+#define ETH_CFG_SW_APB_ACCESS_LSB                                    9
+#define ETH_CFG_SW_APB_ACCESS_MASK                                   0x00000200
+#define ETH_CFG_SW_APB_ACCESS_GET(x)                                 (((x) & ETH_CFG_SW_APB_ACCESS_MASK) >> ETH_CFG_SW_APB_ACCESS_LSB)
+#define ETH_CFG_SW_APB_ACCESS_SET(x)                                 (((x) << ETH_CFG_SW_APB_ACCESS_LSB) & ETH_CFG_SW_APB_ACCESS_MASK)
+#define ETH_CFG_SW_APB_ACCESS_RESET                                  0x0 // 0
+#define ETH_CFG_SW_PHY_ADDR_SWAP_MSB                                 8
+#define ETH_CFG_SW_PHY_ADDR_SWAP_LSB                                 8
+#define ETH_CFG_SW_PHY_ADDR_SWAP_MASK                                0x00000100
+#define ETH_CFG_SW_PHY_ADDR_SWAP_GET(x)                              (((x) & ETH_CFG_SW_PHY_ADDR_SWAP_MASK) >> ETH_CFG_SW_PHY_ADDR_SWAP_LSB)
+#define ETH_CFG_SW_PHY_ADDR_SWAP_SET(x)                              (((x) << ETH_CFG_SW_PHY_ADDR_SWAP_LSB) & ETH_CFG_SW_PHY_ADDR_SWAP_MASK)
+#define ETH_CFG_SW_PHY_ADDR_SWAP_RESET                               0x0 // 0
+#define ETH_CFG_SW_PHY_SWAP_MSB                                      7
+#define ETH_CFG_SW_PHY_SWAP_LSB                                      7
+#define ETH_CFG_SW_PHY_SWAP_MASK                                     0x00000080
+#define ETH_CFG_SW_PHY_SWAP_GET(x)                                   (((x) & ETH_CFG_SW_PHY_SWAP_MASK) >> ETH_CFG_SW_PHY_SWAP_LSB)
+#define ETH_CFG_SW_PHY_SWAP_SET(x)                                   (((x) << ETH_CFG_SW_PHY_SWAP_LSB) & ETH_CFG_SW_PHY_SWAP_MASK)
+#define ETH_CFG_SW_PHY_SWAP_RESET                                    0x0 // 0
+#define ETH_CFG_SW_ONLY_MODE_MSB                                     6
+#define ETH_CFG_SW_ONLY_MODE_LSB                                     6
+#define ETH_CFG_SW_ONLY_MODE_MASK                                    0x00000040
+#define ETH_CFG_SW_ONLY_MODE_GET(x)                                  (((x) & ETH_CFG_SW_ONLY_MODE_MASK) >> ETH_CFG_SW_ONLY_MODE_LSB)
+#define ETH_CFG_SW_ONLY_MODE_SET(x)                                  (((x) << ETH_CFG_SW_ONLY_MODE_LSB) & ETH_CFG_SW_ONLY_MODE_MASK)
+#define ETH_CFG_SW_ONLY_MODE_RESET                                   0x0 // 0
+#define ETH_CFG_ADDRESS                                              0x18070000
+
+#define CONFIG_MIPS32		1	/* MIPS32 CPU core	*/
+
+#define CONFIG_BOOTDELAY	2	/* autoboot after 4 seconds	*/
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{115200}
+
+#define	CONFIG_TIMESTAMP		/* Print image info with timestamp */
+
+#define CONFIG_ROOTFS_RD
+
+#define	CONFIG_BOOTARGS_RD     "console=ttyS0,115200 root=01:00 rd_start=0x802d0000 rd_size=5242880 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),4096k(rootfs),2048k(uImage)"
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),2048k(uImage)"
+
+#ifdef CONFIG_ROOTFS_FLASH
+#define CONFIG_BOOTARGS CONFIG_BOOTARGS_FL
+#else
+#define CONFIG_BOOTARGS ""
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"ath> "		/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		512		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE		(CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		(128*1024)
+
+#define CFG_BOOTPARAMS_LEN	(128*1024)
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+//#define CFG_SDRAM_BASE	0xa0000000     /* Cached addr */
+
+#define	CFG_LOAD_ADDR		0x81000000     /* default load address	*/
+//#define CFG_LOAD_ADDR		0xa1000000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#undef CFG_MEMTEST_START
+#define CFG_MEMTEST_START       0x80200000
+#define CFG_MEMTEST_END		0x83800000
+
+/*------------------------------------------------------------------------
+ * *  * JFFS2
+ */
+#define CFG_JFFS_CUSTOM_PART            /* board defined part   */
+#define CONFIG_JFFS2_CMDLINE
+#define MTDIDS_DEFAULT		"nor0=ath-nor0"
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#define CFG_RX_ETH_BUFFER	16
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		32768
+#define CFG_ICACHE_SIZE		65536
+#define CFG_CACHELINE_SIZE	32
+
+/*
+ * Address map
+ */
+#define ATH_PCI_MEM_BASE		0x10000000	/* 128M */
+#define ATH_APB_BASE			0x18000000	/* 384M */
+#define ATH_GE0_BASE			0x19000000	/* 16M */
+#define ATH_GE1_BASE			0x1a000000	/* 16M */
+#define ATH_USB_OHCI_BASE		0x1b000000
+#define ATH_USB_EHCI_BASE		0x1b000000
+#define ATH_USB_EHCI_BASE_1		0x1b000000
+#define ATH_USB_EHCI_BASE_2		0x1b400000
+#define ATH_SPI_BASE			0x1f000000
+
+/*
+ * Added the PCI LCL RESET register from u-boot
+ * ath_soc.h so that we can query the PCI LCL RESET
+ * register for the presence of WLAN H/W.
+ */
+#define ATH_PCI_LCL_BASE		(ATH_APB_BASE+0x000f0000)
+#define ATH_PCI_LCL_APP			(ATH_PCI_LCL_BASE+0x00)
+#define ATH_PCI_LCL_RESET		(ATH_PCI_LCL_BASE+0x18)
+
+/*
+ * APB block
+ */
+#define ATH_DDR_CTL_BASE		ATH_APB_BASE+0x00000000
+#define ATH_CPU_BASE			ATH_APB_BASE+0x00010000
+#define ATH_UART_BASE			ATH_APB_BASE+0x00020000
+#define ATH_USB_CONFIG_BASE		ATH_APB_BASE+0x00030000
+#define ATH_GPIO_BASE			ATH_APB_BASE+0x00040000
+#define ATH_PLL_BASE			ATH_APB_BASE+0x00050000
+#define ATH_RESET_BASE			ATH_APB_BASE+0x00060000
+#define ATH_DMA_BASE			ATH_APB_BASE+0x000A0000
+#define ATH_SLIC_BASE			ATH_APB_BASE+0x000A9000
+#define ATH_STEREO_BASE			ATH_APB_BASE+0x000B0000
+#define ATH_PCI_CTLR_BASE		ATH_APB_BASE+0x000F0000
+#define ATH_OTP_BASE			ATH_APB_BASE+0x00130000
+#define ATH_NAND_FLASH_BASE		0x1b800000u
+
+
+/*
+ * DDR Config values
+ */
+#define ATH_DDR_CONFIG_16BIT		(1 << 31)
+#define ATH_DDR_CONFIG_PAGE_OPEN	(1 << 30)
+#define ATH_DDR_CONFIG_CAS_LAT_SHIFT	27
+#define ATH_DDR_CONFIG_TMRD_SHIFT	23
+#define ATH_DDR_CONFIG_TRFC_SHIFT	17
+#define ATH_DDR_CONFIG_TRRD_SHIFT	13
+#define ATH_DDR_CONFIG_TRP_SHIFT	9
+#define ATH_DDR_CONFIG_TRCD_SHIFT	5
+#define ATH_DDR_CONFIG_TRAS_SHIFT	0
+
+#define ATH_DDR_CONFIG2_BL2		(2 << 0)
+#define ATH_DDR_CONFIG2_BL4		(4 << 0)
+#define ATH_DDR_CONFIG2_BL8		(8 << 0)
+
+#define ATH_DDR_CONFIG2_BT_IL		(1 << 4)
+#define ATH_DDR_CONFIG2_CNTL_OE_EN	(1 << 5)
+#define ATH_DDR_CONFIG2_PHASE_SEL	(1 << 6)
+#define ATH_DDR_CONFIG2_DRAM_CKE	(1 << 7)
+#define ATH_DDR_CONFIG2_TWR_SHIFT	8
+#define ATH_DDR_CONFIG2_TRTW_SHIFT	12
+#define ATH_DDR_CONFIG2_TRTP_SHIFT	17
+#define ATH_DDR_CONFIG2_TWTR_SHIFT	21
+#define ATH_DDR_CONFIG2_HALF_WIDTH_L	(1 << 31)
+
+#define ATH_DDR_TAP_DEFAULT		0x18
+
+/*
+ * DDR block, gmac flushing
+ */
+#define ATH_DDR_GE0_FLUSH		ATH_DDR_CTL_BASE+0x9c
+#define ATH_DDR_GE1_FLUSH		ATH_DDR_CTL_BASE+0xa0
+#define ATH_DDR_USB_FLUSH		ATH_DDR_CTL_BASE+0xa4
+#define ATH_DDR_PCIE_FLUSH		ATH_DDR_CTL_BASE+0x88
+
+#define ATH_EEPROM_GE0_MAC_ADDR		0xbfff1000
+#define ATH_EEPROM_GE1_MAC_ADDR		0xbfff1006
+
+/*
+ * PLL block/CPU
+ */
+
+#define ATH_PLL_CONFIG			ATH_PLL_BASE+0x0
+#define ATH_DDR_CLK_CTRL		ATH_PLL_BASE+0x8
+
+
+#define PLL_DIV_SHIFT			0
+#define PLL_DIV_MASK			0x3ff
+#define REF_DIV_SHIFT			10
+#define REF_DIV_MASK			0xf
+#define AHB_DIV_SHIFT			19
+#define AHB_DIV_MASK			0x1
+#define DDR_DIV_SHIFT			22
+#define DDR_DIV_MASK			0x1
+#define ATH_DDR_PLL_CONFIG		ATH_PLL_BASE+0x4
+#define ATH_ETH_XMII_CONFIG		ATH_PLL_BASE+0x2c
+#define ATH_AUDIO_PLL_CONFIG		ATH_PLL_BASE+0x30
+
+#define ATH_ETH_INT0_CLK		ATH_PLL_BASE+0x14
+#define ATH_ETH_INT1_CLK		ATH_PLL_BASE+0x18
+
+
+/*
+ * USB block
+ */
+#define ATH_USB_FLADJ_VAL		ATH_USB_CONFIG_BASE
+#define ATH_USB_CONFIG			ATH_USB_CONFIG_BASE+0x4
+#define ATH_USB_WINDOW			0x10000
+#define ATH_USB_MODE			ATH_USB_EHCI_BASE+0x1a8
+
+/*
+ * PCI block
+ */
+#define ATH_PCI_WINDOW			0x8000000 /* 128MB */
+#define ATH_PCI_WINDOW0_OFFSET		ATH_DDR_CTL_BASE+0x7c
+#define ATH_PCI_WINDOW1_OFFSET		ATH_DDR_CTL_BASE+0x80
+#define ATH_PCI_WINDOW2_OFFSET		ATH_DDR_CTL_BASE+0x84
+#define ATH_PCI_WINDOW3_OFFSET		ATH_DDR_CTL_BASE+0x88
+#define ATH_PCI_WINDOW4_OFFSET		ATH_DDR_CTL_BASE+0x8c
+#define ATH_PCI_WINDOW5_OFFSET		ATH_DDR_CTL_BASE+0x90
+#define ATH_PCI_WINDOW6_OFFSET		ATH_DDR_CTL_BASE+0x94
+#define ATH_PCI_WINDOW7_OFFSET		ATH_DDR_CTL_BASE+0x98
+
+#define ATH_PCI_WINDOW0_VAL		0x10000000
+#define ATH_PCI_WINDOW1_VAL		0x11000000
+#define ATH_PCI_WINDOW2_VAL		0x12000000
+#define ATH_PCI_WINDOW3_VAL		0x13000000
+#define ATH_PCI_WINDOW4_VAL		0x14000000
+#define ATH_PCI_WINDOW5_VAL		0x15000000
+#define ATH_PCI_WINDOW6_VAL		0x16000000
+#define ATH_PCI_WINDOW7_VAL		0x07000000
+
+#define ath_write_pci_window(_no)	\
+	ath_reg_wr(ATH_PCI_WINDOW##_no##_OFFSET, ATH_PCI_WINDOW##_no##_VAL);
+
+/*
+ * CRP. To access the host controller config and status registers
+ */
+#define ATH_PCI_CRP			0x180c0000
+#define ATH_PCI_DEV_CFGBASE		0x14000000
+#define ATH_PCI_CRP_AD_CBE		ATH_PCI_CRP
+#define ATH_PCI_CRP_WRDATA		ATH_PCI_CRP+0x4
+#define ATH_PCI_CRP_RDDATA		ATH_PCI_CRP+0x8
+#define ATH_PCI_ERROR			ATH_PCI_CRP+0x1c
+#define ATH_PCI_ERROR_ADDRESS		ATH_PCI_CRP+0x20
+#define ATH_PCI_AHB_ERROR		ATH_PCI_CRP+0x24
+#define ATH_PCI_AHB_ERROR_ADDRESS	ATH_PCI_CRP+0x28
+
+#define ATH_CRP_CMD_WRITE		0x00010000
+#define ATH_CRP_CMD_READ		0x00000000
+
+/*
+ * PCI CFG. To generate config cycles
+ */
+#define ATH_PCI_CFG_AD			ATH_PCI_CRP+0xc
+#define ATH_PCI_CFG_CBE			ATH_PCI_CRP+0x10
+#define ATH_PCI_CFG_WRDATA		ATH_PCI_CRP+0x14
+#define ATH_PCI_CFG_RDDATA		ATH_PCI_CRP+0x18
+#define ATH_CFG_CMD_READ		0x0000000a
+#define ATH_CFG_CMD_WRITE		0x0000000b
+
+#define ATH_PCI_IDSEL_ADLINE_START	17
+
+#define ATH_SPI_FS		(ATH_SPI_BASE+0x00)
+#define ATH_SPI_READ		(ATH_SPI_BASE+0x00)
+#define ATH_SPI_CLOCK		(ATH_SPI_BASE+0x04)
+#define ATH_SPI_WRITE		(ATH_SPI_BASE+0x08)
+#define ATH_SPI_RD_STATUS	(ATH_SPI_BASE+0x0c)
+#define ATH_SPI_SHIFT_DO	(ATH_SPI_BASE+0x10)
+#define ATH_SPI_SHIFT_CNT	(ATH_SPI_BASE+0x14)
+#define ATH_SPI_SHIFT_DI	(ATH_SPI_BASE+0x18)
+#define ATH_SPI_D0_HIGH		(1<<0)	/* Pin spi_do */
+#define ATH_SPI_CLK_HIGH	(1<<8)	/* Pin spi_clk */
+
+#define ATH_SPI_CS_ENABLE_0	(6<<16)	/* Pin gpio/cs0 (active low) */
+#define ATH_SPI_CS_ENABLE_1	(5<<16)	/* Pin gpio/cs1 (active low) */
+#define ATH_SPI_CS_ENABLE_2	(3<<16)	/* Pin gpio/cs2 (active low) */
+#define ATH_SPI_CS_DIS		0x70000
+#define ATH_SPI_CE_LOW		0x60000
+#define ATH_SPI_CE_HIGH		0x60100
+
+#define ATH_SPI_SECTOR_SIZE	(1024*64)
+#define ATH_SPI_PAGE_SIZE	256
+
+#define ATH_RESET_GE0_MAC	RST_RESET_GE0_MAC_RESET_SET(1)
+#define ATH_RESET_GE0_PHY	RST_RESET_ETH_SWITCH_RESET_SET(1)
+#define ATH_RESET_GE1_MAC	RST_RESET_GE1_MAC_RESET_SET(1)
+#define ATH_RESET_GE1_PHY	RST_RESET_ETH_SWITCH_ARESET_SET(1)
+#define ATH_RESET_GE0_MDIO	RST_RESET_GE0_MDIO_RESET_SET(1)
+#define ATH_RESET_GE1_MDIO	RST_RESET_GE1_MDIO_RESET_SET(1)
+
+/*
+ * SOC
+ */
+#define ATH_SPI_CMD_WRITE_SR		0x01
+#define ATH_SPI_CMD_WREN		0x06
+#define ATH_SPI_CMD_RD_STATUS		0x05
+#define ATH_SPI_CMD_FAST_READ		0x0b
+#define ATH_SPI_CMD_PAGE_PROG		0x02
+#define ATH_SPI_CMD_SECTOR_ERASE	0xd8
+#define ATH_SPI_CMD_CHIP_ERASE		0xc7
+#define ATH_SPI_CMD_RDID		0x9f
+
+#if defined(CFG_ATH_EMULATION)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(2)	// 80 MHz
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(1)	// 40 MHz
+
+#elif (CFG_PLL_FREQ == CFG_PLL_550_400_200)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_600_200)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_600_300)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(16)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_680_240)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(17)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_600_240)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_560_450_220)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(11)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0x100) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_680_680_226)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(1)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(17)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(17)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_550_600_200)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(24)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_600_200)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(1)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+ 						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+ 						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+ 						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+ 
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(24)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+ 						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+ 						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+ 						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#else
+#	error "CFG_PLL_FREQ not set"
+#endif	// CFG_PLL_FREQ
+
+#define CPU_CLK_FROM_DDR_PLL	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(0)
+#define CPU_CLK_FROM_CPU_PLL	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+
+#define DDR_CLK_FROM_DDR_PLL	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define DDR_CLK_FROM_CPU_PLL	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(0)
+
+#if CPU_DDR_SYNC_MODE
+
+#	define both_from_cpu		0
+#	define both_from_ddr		1
+
+#	if both_from_ddr
+#		define CLK_SRC_CONTROL		(CPU_CLK_FROM_DDR_PLL | DDR_CLK_FROM_DDR_PLL)
+#		define AHB_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#	elif both_from_cpu
+#		define CLK_SRC_CONTROL		(CPU_CLK_FROM_CPU_PLL | DDR_CLK_FROM_CPU_PLL)
+#		define AHB_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#	else
+#		error "Invalid sync mode settings"
+#	endif
+#else
+#	define CLK_SRC_CONTROL		(CPU_CLK_FROM_CPU_PLL | DDR_CLK_FROM_DDR_PLL)
+#endif
+
+
+
+#define __nint_to_mhz(n, ref)	((n) * (ref) * 1000000)
+#define __cpu_hz_40(pll)	(__nint_to_mhz(CPU_PLL_CONFIG_NINT_GET(pll), 40))
+#define __cpu_hz_25(pll)	(__nint_to_mhz(CPU_PLL_CONFIG_NINT_GET(pll), 25))
+
+/* Since the count is incremented every other tick, divide by 2 */
+#define CFG_HZ			(__cpu_hz_40(CPU_PLL_CONFIG_NINT_VAL) / 2)
+
+/* SGMII DEFINES */
+
+// 32'h18070034 (SGMII_CONFIG)
+#define SGMII_CONFIG_BERT_ENABLE_MSB                                 14
+#define SGMII_CONFIG_BERT_ENABLE_LSB                                 14
+#define SGMII_CONFIG_BERT_ENABLE_MASK                                0x00004000
+#define SGMII_CONFIG_BERT_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_BERT_ENABLE_MASK) >> SGMII_CONFIG_BERT_ENABLE_LSB)
+#define SGMII_CONFIG_BERT_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_BERT_ENABLE_LSB) & SGMII_CONFIG_BERT_ENABLE_MASK)
+#define SGMII_CONFIG_BERT_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_PRBS_ENABLE_MSB                                 13
+#define SGMII_CONFIG_PRBS_ENABLE_LSB                                 13
+#define SGMII_CONFIG_PRBS_ENABLE_MASK                                0x00002000
+#define SGMII_CONFIG_PRBS_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_PRBS_ENABLE_MASK) >> SGMII_CONFIG_PRBS_ENABLE_LSB)
+#define SGMII_CONFIG_PRBS_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_PRBS_ENABLE_LSB) & SGMII_CONFIG_PRBS_ENABLE_MASK)
+#define SGMII_CONFIG_PRBS_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_MDIO_COMPLETE_MSB                               12
+#define SGMII_CONFIG_MDIO_COMPLETE_LSB                               12
+#define SGMII_CONFIG_MDIO_COMPLETE_MASK                              0x00001000
+#define SGMII_CONFIG_MDIO_COMPLETE_GET(x)                            (((x) & SGMII_CONFIG_MDIO_COMPLETE_MASK) >> SGMII_CONFIG_MDIO_COMPLETE_LSB)
+#define SGMII_CONFIG_MDIO_COMPLETE_SET(x)                            (((x) << SGMII_CONFIG_MDIO_COMPLETE_LSB) & SGMII_CONFIG_MDIO_COMPLETE_MASK)
+#define SGMII_CONFIG_MDIO_COMPLETE_RESET                             0x0 // 0
+#define SGMII_CONFIG_MDIO_PULSE_MSB                                  11
+#define SGMII_CONFIG_MDIO_PULSE_LSB                                  11
+#define SGMII_CONFIG_MDIO_PULSE_MASK                                 0x00000800
+#define SGMII_CONFIG_MDIO_PULSE_GET(x)                               (((x) & SGMII_CONFIG_MDIO_PULSE_MASK) >> SGMII_CONFIG_MDIO_PULSE_LSB)
+#define SGMII_CONFIG_MDIO_PULSE_SET(x)                               (((x) << SGMII_CONFIG_MDIO_PULSE_LSB) & SGMII_CONFIG_MDIO_PULSE_MASK)
+#define SGMII_CONFIG_MDIO_PULSE_RESET                                0x0 // 0
+#define SGMII_CONFIG_MDIO_ENABLE_MSB                                 10
+#define SGMII_CONFIG_MDIO_ENABLE_LSB                                 10
+#define SGMII_CONFIG_MDIO_ENABLE_MASK                                0x00000400
+#define SGMII_CONFIG_MDIO_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_MDIO_ENABLE_MASK) >> SGMII_CONFIG_MDIO_ENABLE_LSB)
+#define SGMII_CONFIG_MDIO_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_MDIO_ENABLE_LSB) & SGMII_CONFIG_MDIO_ENABLE_MASK)
+#define SGMII_CONFIG_MDIO_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_MSB                            9
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_LSB                            9
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_MASK                           0x00000200
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_GET(x)                         (((x) & SGMII_CONFIG_NEXT_PAGE_LOADED_MASK) >> SGMII_CONFIG_NEXT_PAGE_LOADED_LSB)
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_SET(x)                         (((x) << SGMII_CONFIG_NEXT_PAGE_LOADED_LSB) & SGMII_CONFIG_NEXT_PAGE_LOADED_MASK)
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_RESET                          0x0 // 0
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MSB                         8
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB                         8
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK                        0x00000100
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_GET(x)                      (((x) & SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK) >> SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB)
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_SET(x)                      (((x) << SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB) & SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK)
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_RESET                       0x0 // 0
+#define SGMII_CONFIG_SPEED_MSB                                       7
+#define SGMII_CONFIG_SPEED_LSB                                       6
+#define SGMII_CONFIG_SPEED_MASK                                      0x000000c0
+#define SGMII_CONFIG_SPEED_GET(x)                                    (((x) & SGMII_CONFIG_SPEED_MASK) >> SGMII_CONFIG_SPEED_LSB)
+#define SGMII_CONFIG_SPEED_SET(x)                                    (((x) << SGMII_CONFIG_SPEED_LSB) & SGMII_CONFIG_SPEED_MASK)
+#define SGMII_CONFIG_SPEED_RESET                                     0x0 // 0
+#define SGMII_CONFIG_FORCE_SPEED_MSB                                 5
+#define SGMII_CONFIG_FORCE_SPEED_LSB                                 5
+#define SGMII_CONFIG_FORCE_SPEED_MASK                                0x00000020
+#define SGMII_CONFIG_FORCE_SPEED_GET(x)                              (((x) & SGMII_CONFIG_FORCE_SPEED_MASK) >> SGMII_CONFIG_FORCE_SPEED_LSB)
+#define SGMII_CONFIG_FORCE_SPEED_SET(x)                              (((x) << SGMII_CONFIG_FORCE_SPEED_LSB) & SGMII_CONFIG_FORCE_SPEED_MASK)
+#define SGMII_CONFIG_FORCE_SPEED_RESET                               0x0 // 0
+#define SGMII_CONFIG_MR_REG4_CHANGED_MSB                             4
+#define SGMII_CONFIG_MR_REG4_CHANGED_LSB                             4
+#define SGMII_CONFIG_MR_REG4_CHANGED_MASK                            0x00000010
+#define SGMII_CONFIG_MR_REG4_CHANGED_GET(x)                          (((x) & SGMII_CONFIG_MR_REG4_CHANGED_MASK) >> SGMII_CONFIG_MR_REG4_CHANGED_LSB)
+#define SGMII_CONFIG_MR_REG4_CHANGED_SET(x)                          (((x) << SGMII_CONFIG_MR_REG4_CHANGED_LSB) & SGMII_CONFIG_MR_REG4_CHANGED_MASK)
+#define SGMII_CONFIG_MR_REG4_CHANGED_RESET                           0x0 // 0
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MSB                       3
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB                       3
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK                      0x00000008
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_GET(x)                    (((x) & SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK) >> SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB)
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_SET(x)                    (((x) << SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB) & SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK)
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_RESET                     0x0 // 0
+#define SGMII_CONFIG_MODE_CTRL_MSB                                   2
+#define SGMII_CONFIG_MODE_CTRL_LSB                                   0
+#define SGMII_CONFIG_MODE_CTRL_MASK                                  0x00000007
+#define SGMII_CONFIG_MODE_CTRL_GET(x)                                (((x) & SGMII_CONFIG_MODE_CTRL_MASK) >> SGMII_CONFIG_MODE_CTRL_LSB)
+#define SGMII_CONFIG_MODE_CTRL_SET(x)                                (((x) << SGMII_CONFIG_MODE_CTRL_LSB) & SGMII_CONFIG_MODE_CTRL_MASK)
+#define SGMII_CONFIG_MODE_CTRL_RESET                                 0x0 // 0
+#define SGMII_CONFIG_ADDRESS                                         0x18070034
+
+
+
+// 32'h1807001c (MR_AN_CONTROL)
+#define MR_AN_CONTROL_PHY_RESET_MSB                                  15
+#define MR_AN_CONTROL_PHY_RESET_LSB                                  15
+#define MR_AN_CONTROL_PHY_RESET_MASK                                 0x00008000
+#define MR_AN_CONTROL_PHY_RESET_GET(x)                               (((x) & MR_AN_CONTROL_PHY_RESET_MASK) >> MR_AN_CONTROL_PHY_RESET_LSB)
+#define MR_AN_CONTROL_PHY_RESET_SET(x)                               (((x) << MR_AN_CONTROL_PHY_RESET_LSB) & MR_AN_CONTROL_PHY_RESET_MASK)
+#define MR_AN_CONTROL_PHY_RESET_RESET                                0x0 // 0
+#define MR_AN_CONTROL_LOOPBACK_MSB                                   14
+#define MR_AN_CONTROL_LOOPBACK_LSB                                   14
+#define MR_AN_CONTROL_LOOPBACK_MASK                                  0x00004000
+#define MR_AN_CONTROL_LOOPBACK_GET(x)                                (((x) & MR_AN_CONTROL_LOOPBACK_MASK) >> MR_AN_CONTROL_LOOPBACK_LSB)
+#define MR_AN_CONTROL_LOOPBACK_SET(x)                                (((x) << MR_AN_CONTROL_LOOPBACK_LSB) & MR_AN_CONTROL_LOOPBACK_MASK)
+#define MR_AN_CONTROL_LOOPBACK_RESET                                 0x0 // 0
+#define MR_AN_CONTROL_SPEED_SEL0_MSB                                 13
+#define MR_AN_CONTROL_SPEED_SEL0_LSB                                 13
+#define MR_AN_CONTROL_SPEED_SEL0_MASK                                0x00002000
+#define MR_AN_CONTROL_SPEED_SEL0_GET(x)                              (((x) & MR_AN_CONTROL_SPEED_SEL0_MASK) >> MR_AN_CONTROL_SPEED_SEL0_LSB)
+#define MR_AN_CONTROL_SPEED_SEL0_SET(x)                              (((x) << MR_AN_CONTROL_SPEED_SEL0_LSB) & MR_AN_CONTROL_SPEED_SEL0_MASK)
+#define MR_AN_CONTROL_SPEED_SEL0_RESET                               0x0 // 0
+#define MR_AN_CONTROL_AN_ENABLE_MSB                                  12
+#define MR_AN_CONTROL_AN_ENABLE_LSB                                  12
+#define MR_AN_CONTROL_AN_ENABLE_MASK                                 0x00001000
+#define MR_AN_CONTROL_AN_ENABLE_GET(x)                               (((x) & MR_AN_CONTROL_AN_ENABLE_MASK) >> MR_AN_CONTROL_AN_ENABLE_LSB)
+#define MR_AN_CONTROL_AN_ENABLE_SET(x)                               (((x) << MR_AN_CONTROL_AN_ENABLE_LSB) & MR_AN_CONTROL_AN_ENABLE_MASK)
+#define MR_AN_CONTROL_AN_ENABLE_RESET                                0x1 // 1
+#define MR_AN_CONTROL_POWER_DOWN_MSB                                 11
+#define MR_AN_CONTROL_POWER_DOWN_LSB                                 11
+#define MR_AN_CONTROL_POWER_DOWN_MASK                                0x00000800
+#define MR_AN_CONTROL_POWER_DOWN_GET(x)                              (((x) & MR_AN_CONTROL_POWER_DOWN_MASK) >> MR_AN_CONTROL_POWER_DOWN_LSB)
+#define MR_AN_CONTROL_POWER_DOWN_SET(x)                              (((x) << MR_AN_CONTROL_POWER_DOWN_LSB) & MR_AN_CONTROL_POWER_DOWN_MASK)
+#define MR_AN_CONTROL_POWER_DOWN_RESET                               0x0 // 0
+#define MR_AN_CONTROL_RESTART_AN_MSB                                 9
+#define MR_AN_CONTROL_RESTART_AN_LSB                                 9
+#define MR_AN_CONTROL_RESTART_AN_MASK                                0x00000200
+#define MR_AN_CONTROL_RESTART_AN_GET(x)                              (((x) & MR_AN_CONTROL_RESTART_AN_MASK) >> MR_AN_CONTROL_RESTART_AN_LSB)
+#define MR_AN_CONTROL_RESTART_AN_SET(x)                              (((x) << MR_AN_CONTROL_RESTART_AN_LSB) & MR_AN_CONTROL_RESTART_AN_MASK)
+#define MR_AN_CONTROL_RESTART_AN_RESET                               0x0 // 0
+#define MR_AN_CONTROL_DUPLEX_MODE_MSB                                8
+#define MR_AN_CONTROL_DUPLEX_MODE_LSB                                8
+#define MR_AN_CONTROL_DUPLEX_MODE_MASK                               0x00000100
+#define MR_AN_CONTROL_DUPLEX_MODE_GET(x)                             (((x) & MR_AN_CONTROL_DUPLEX_MODE_MASK) >> MR_AN_CONTROL_DUPLEX_MODE_LSB)
+#define MR_AN_CONTROL_DUPLEX_MODE_SET(x)                             (((x) << MR_AN_CONTROL_DUPLEX_MODE_LSB) & MR_AN_CONTROL_DUPLEX_MODE_MASK)
+#define MR_AN_CONTROL_DUPLEX_MODE_RESET                              0x1 // 1
+#define MR_AN_CONTROL_SPEED_SEL1_MSB                                 6
+#define MR_AN_CONTROL_SPEED_SEL1_LSB                                 6
+#define MR_AN_CONTROL_SPEED_SEL1_MASK                                0x00000040
+#define MR_AN_CONTROL_SPEED_SEL1_GET(x)                              (((x) & MR_AN_CONTROL_SPEED_SEL1_MASK) >> MR_AN_CONTROL_SPEED_SEL1_LSB)
+#define MR_AN_CONTROL_SPEED_SEL1_SET(x)                              (((x) << MR_AN_CONTROL_SPEED_SEL1_LSB) & MR_AN_CONTROL_SPEED_SEL1_MASK)
+#define MR_AN_CONTROL_SPEED_SEL1_RESET                               0x1 // 1
+#define MR_AN_CONTROL_ADDRESS                                        0x1807001c
+
+
+
+
+
+// 32'h18070014 (SGMII_RESET)
+#define SGMII_RESET_HW_RX_125M_N_MSB                                 4
+#define SGMII_RESET_HW_RX_125M_N_LSB                                 4
+#define SGMII_RESET_HW_RX_125M_N_MASK                                0x00000010
+#define SGMII_RESET_HW_RX_125M_N_GET(x)                              (((x) & SGMII_RESET_HW_RX_125M_N_MASK) >> SGMII_RESET_HW_RX_125M_N_LSB)
+#define SGMII_RESET_HW_RX_125M_N_SET(x)                              (((x) << SGMII_RESET_HW_RX_125M_N_LSB) & SGMII_RESET_HW_RX_125M_N_MASK)
+#define SGMII_RESET_HW_RX_125M_N_RESET                               0x0 // 0
+#define SGMII_RESET_TX_125M_N_MSB                                    3
+#define SGMII_RESET_TX_125M_N_LSB                                    3
+#define SGMII_RESET_TX_125M_N_MASK                                   0x00000008
+#define SGMII_RESET_TX_125M_N_GET(x)                                 (((x) & SGMII_RESET_TX_125M_N_MASK) >> SGMII_RESET_TX_125M_N_LSB)
+#define SGMII_RESET_TX_125M_N_SET(x)                                 (((x) << SGMII_RESET_TX_125M_N_LSB) & SGMII_RESET_TX_125M_N_MASK)
+#define SGMII_RESET_TX_125M_N_RESET                                  0x0 // 0
+#define SGMII_RESET_RX_125M_N_MSB                                    2
+#define SGMII_RESET_RX_125M_N_LSB                                    2
+#define SGMII_RESET_RX_125M_N_MASK                                   0x00000004
+#define SGMII_RESET_RX_125M_N_GET(x)                                 (((x) & SGMII_RESET_RX_125M_N_MASK) >> SGMII_RESET_RX_125M_N_LSB)
+#define SGMII_RESET_RX_125M_N_SET(x)                                 (((x) << SGMII_RESET_RX_125M_N_LSB) & SGMII_RESET_RX_125M_N_MASK)
+#define SGMII_RESET_RX_125M_N_RESET                                  0x0 // 0
+#define SGMII_RESET_TX_CLK_N_MSB                                     1
+#define SGMII_RESET_TX_CLK_N_LSB                                     1
+#define SGMII_RESET_TX_CLK_N_MASK                                    0x00000002
+#define SGMII_RESET_TX_CLK_N_GET(x)                                  (((x) & SGMII_RESET_TX_CLK_N_MASK) >> SGMII_RESET_TX_CLK_N_LSB)
+#define SGMII_RESET_TX_CLK_N_SET(x)                                  (((x) << SGMII_RESET_TX_CLK_N_LSB) & SGMII_RESET_TX_CLK_N_MASK)
+#define SGMII_RESET_TX_CLK_N_RESET                                   0x0 // 0
+#define SGMII_RESET_RX_CLK_N_MSB                                     0
+#define SGMII_RESET_RX_CLK_N_LSB                                     0
+#define SGMII_RESET_RX_CLK_N_MASK                                    0x00000001
+#define SGMII_RESET_RX_CLK_N_GET(x)                                  (((x) & SGMII_RESET_RX_CLK_N_MASK) >> SGMII_RESET_RX_CLK_N_LSB)
+#define SGMII_RESET_RX_CLK_N_SET(x)                                  (((x) << SGMII_RESET_RX_CLK_N_LSB) & SGMII_RESET_RX_CLK_N_MASK)
+#define SGMII_RESET_RX_CLK_N_RESET                                   0x0 // 0
+#define SGMII_RESET_ADDRESS                                          0x18070014
+
+
+
+// 32'h18070038 (SGMII_MAC_RX_CONFIG)
+#define SGMII_MAC_RX_CONFIG_LINK_MSB                                 15
+#define SGMII_MAC_RX_CONFIG_LINK_LSB                                 15
+#define SGMII_MAC_RX_CONFIG_LINK_MASK                                0x00008000
+#define SGMII_MAC_RX_CONFIG_LINK_GET(x)                              (((x) & SGMII_MAC_RX_CONFIG_LINK_MASK) >> SGMII_MAC_RX_CONFIG_LINK_LSB)
+#define SGMII_MAC_RX_CONFIG_LINK_SET(x)                              (((x) << SGMII_MAC_RX_CONFIG_LINK_LSB) & SGMII_MAC_RX_CONFIG_LINK_MASK)
+#define SGMII_MAC_RX_CONFIG_LINK_RESET                               0x0 // 0
+#define SGMII_MAC_RX_CONFIG_ACK_MSB                                  14
+#define SGMII_MAC_RX_CONFIG_ACK_LSB                                  14
+#define SGMII_MAC_RX_CONFIG_ACK_MASK                                 0x00004000
+#define SGMII_MAC_RX_CONFIG_ACK_GET(x)                               (((x) & SGMII_MAC_RX_CONFIG_ACK_MASK) >> SGMII_MAC_RX_CONFIG_ACK_LSB)
+#define SGMII_MAC_RX_CONFIG_ACK_SET(x)                               (((x) << SGMII_MAC_RX_CONFIG_ACK_LSB) & SGMII_MAC_RX_CONFIG_ACK_MASK)
+#define SGMII_MAC_RX_CONFIG_ACK_RESET                                0x0 // 0
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MSB                          12
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB                          12
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK                         0x00001000
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_GET(x)                       (((x) & SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK) >> SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB)
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_SET(x)                       (((x) << SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB) & SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK)
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_RESET                        0x0 // 0
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_MSB                           11
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB                           10
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK                          0x00000c00
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_GET(x)                        (((x) & SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK) >> SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB)
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_SET(x)                        (((x) << SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB) & SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK)
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_RESET                         0x0 // 0
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_MSB                            8
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB                            8
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK                           0x00000100
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_GET(x)                         (((x) & SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK) >> SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB)
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_SET(x)                         (((x) << SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB) & SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK)
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_RESET                          0x0 // 0
+#define SGMII_MAC_RX_CONFIG_PAUSE_MSB                                7
+#define SGMII_MAC_RX_CONFIG_PAUSE_LSB                                7
+#define SGMII_MAC_RX_CONFIG_PAUSE_MASK                               0x00000080
+#define SGMII_MAC_RX_CONFIG_PAUSE_GET(x)                             (((x) & SGMII_MAC_RX_CONFIG_PAUSE_MASK) >> SGMII_MAC_RX_CONFIG_PAUSE_LSB)
+#define SGMII_MAC_RX_CONFIG_PAUSE_SET(x)                             (((x) << SGMII_MAC_RX_CONFIG_PAUSE_LSB) & SGMII_MAC_RX_CONFIG_PAUSE_MASK)
+#define SGMII_MAC_RX_CONFIG_PAUSE_RESET                              0x0 // 0
+#define SGMII_MAC_RX_CONFIG_RES0_MSB                                 0
+#define SGMII_MAC_RX_CONFIG_RES0_LSB                                 0
+#define SGMII_MAC_RX_CONFIG_RES0_MASK                                0x00000001
+#define SGMII_MAC_RX_CONFIG_RES0_GET(x)                              (((x) & SGMII_MAC_RX_CONFIG_RES0_MASK) >> SGMII_MAC_RX_CONFIG_RES0_LSB)
+#define SGMII_MAC_RX_CONFIG_RES0_SET(x)                              (((x) << SGMII_MAC_RX_CONFIG_RES0_LSB) & SGMII_MAC_RX_CONFIG_RES0_MASK)
+#define SGMII_MAC_RX_CONFIG_RES0_RESET                               0x1 // 1
+#define SGMII_MAC_RX_CONFIG_ADDRESS                                  0x18070038
+
+// 32'h18070058 (SGMII_DEBUG)
+#define SGMII_DEBUG_ARB_STATE_MSB                                    27
+#define SGMII_DEBUG_ARB_STATE_LSB                                    24
+#define SGMII_DEBUG_ARB_STATE_MASK                                   0x0f000000
+#define SGMII_DEBUG_ARB_STATE_GET(x)                                 (((x) & SGMII_DEBUG_ARB_STATE_MASK) >> SGMII_DEBUG_ARB_STATE_LSB)
+#define SGMII_DEBUG_ARB_STATE_SET(x)                                 (((x) << SGMII_DEBUG_ARB_STATE_LSB) & SGMII_DEBUG_ARB_STATE_MASK)
+#define SGMII_DEBUG_ARB_STATE_RESET                                  0x0 // 0
+#define SGMII_DEBUG_RX_SYNC_STATE_MSB                                23
+#define SGMII_DEBUG_RX_SYNC_STATE_LSB                                16
+#define SGMII_DEBUG_RX_SYNC_STATE_MASK                               0x00ff0000
+#define SGMII_DEBUG_RX_SYNC_STATE_GET(x)                             (((x) & SGMII_DEBUG_RX_SYNC_STATE_MASK) >> SGMII_DEBUG_RX_SYNC_STATE_LSB)
+#define SGMII_DEBUG_RX_SYNC_STATE_SET(x)                             (((x) << SGMII_DEBUG_RX_SYNC_STATE_LSB) & SGMII_DEBUG_RX_SYNC_STATE_MASK)
+#define SGMII_DEBUG_RX_SYNC_STATE_RESET                              0x0 // 0
+#define SGMII_DEBUG_RX_STATE_MSB                                     15
+#define SGMII_DEBUG_RX_STATE_LSB                                     8
+#define SGMII_DEBUG_RX_STATE_MASK                                    0x0000ff00
+#define SGMII_DEBUG_RX_STATE_GET(x)                                  (((x) & SGMII_DEBUG_RX_STATE_MASK) >> SGMII_DEBUG_RX_STATE_LSB)
+#define SGMII_DEBUG_RX_STATE_SET(x)                                  (((x) << SGMII_DEBUG_RX_STATE_LSB) & SGMII_DEBUG_RX_STATE_MASK)
+#define SGMII_DEBUG_RX_STATE_RESET                                   0x0 // 0
+#define SGMII_DEBUG_TX_STATE_MSB                                     7
+#define SGMII_DEBUG_TX_STATE_LSB                                     0
+#define SGMII_DEBUG_TX_STATE_MASK                                    0x000000ff
+#define SGMII_DEBUG_TX_STATE_GET(x)                                  (((x) & SGMII_DEBUG_TX_STATE_MASK) >> SGMII_DEBUG_TX_STATE_LSB)
+#define SGMII_DEBUG_TX_STATE_SET(x)                                  (((x) << SGMII_DEBUG_TX_STATE_LSB) & SGMII_DEBUG_TX_STATE_MASK)
+#define SGMII_DEBUG_TX_STATE_RESET                                   0x0 // 0
+#define SGMII_DEBUG_ADDRESS                                          0x18070058
+#define SGMII_DEBUG_OFFSET                                           0x0058
+
+
+
+// 32'h18070060 (SGMII_INTERRUPT_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_MSB                                7
+#define SGMII_INTERRUPT_MASK_MASK_LSB                                0
+#define SGMII_INTERRUPT_MASK_MASK_MASK                               0x000000ff
+#define SGMII_INTERRUPT_MASK_MASK_GET(x)                             (((x) & SGMII_INTERRUPT_MASK_MASK_MASK) >> SGMII_INTERRUPT_MASK_MASK_LSB)
+#define SGMII_INTERRUPT_MASK_MASK_SET(x)                             (((x) << SGMII_INTERRUPT_MASK_MASK_LSB) & SGMII_INTERRUPT_MASK_MASK_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_RESET                              0x0 // 0
+#define SGMII_INTERRUPT_MASK_ADDRESS                                 0x18070060
+
+
+
+
+// 32'h1807005c (SGMII_INTERRUPT)
+#define SGMII_INTERRUPT_INTR_MSB                                     7
+#define SGMII_INTERRUPT_INTR_LSB                                     0
+#define SGMII_INTERRUPT_INTR_MASK                                    0x000000ff
+#define SGMII_INTERRUPT_INTR_GET(x)                                  (((x) & SGMII_INTERRUPT_INTR_MASK) >> SGMII_INTERRUPT_INTR_LSB)
+#define SGMII_INTERRUPT_INTR_SET(x)                                  (((x) << SGMII_INTERRUPT_INTR_LSB) & SGMII_INTERRUPT_INTR_MASK)
+#define SGMII_INTERRUPT_INTR_RESET                                   0x0 // 0
+#define SGMII_INTERRUPT_ADDRESS                                      0x1807005c
+#define SGMII_INTERRUPT_OFFSET                                       0x005c
+// SW modifiable bits
+#define SGMII_INTERRUPT_SW_MASK                                      0x000000ff
+// bits defined at reset
+#define SGMII_INTERRUPT_RSTMASK                                      0xffffffff
+// reset value (ignore bits undefined at reset)
+#define SGMII_INTERRUPT_RESET                                        0x00000000
+
+// 32'h18070060 (SGMII_INTERRUPT_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_MSB                                7
+#define SGMII_INTERRUPT_MASK_MASK_LSB                                0
+#define SGMII_INTERRUPT_MASK_MASK_MASK                               0x000000ff
+#define SGMII_INTERRUPT_MASK_MASK_GET(x)                             (((x) & SGMII_INTERRUPT_MASK_MASK_MASK) >> SGMII_INTERRUPT_MASK_MASK_LSB)
+#define SGMII_INTERRUPT_MASK_MASK_SET(x)                             (((x) << SGMII_INTERRUPT_MASK_MASK_LSB) & SGMII_INTERRUPT_MASK_MASK_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_RESET                              0x0 // 0
+#define SGMII_INTERRUPT_MASK_ADDRESS                                 0x18070060
+
+
+#define SGMII_LINK_FAIL				(1 << 0)
+#define SGMII_DUPLEX_ERR			(1 << 1)
+#define SGMII_MR_AN_COMPLETE			(1 << 2)
+#define SGMII_LINK_MAC_CHANGE			(1 << 3)
+#define SGMII_DUPLEX_MODE_CHANGE		(1 << 4)
+#define SGMII_SPEED_MODE_MAC_CHANGE		(1 << 5)
+#define SGMII_RX_QUIET_CHANGE			(1 << 6)
+#define SGMII_RX_MDIO_COMP_CHANGE		(1 << 7)
+
+#define SGMII_INTR				SGMII_LINK_FAIL | \
+						SGMII_LINK_MAC_CHANGE | \
+						SGMII_DUPLEX_MODE_CHANGE | \
+						SGMII_SPEED_MODE_MAC_CHANGE
+
+
+// 32'h18050048 (ETH_SGMII)
+#define ETH_SGMII_TX_INVERT_MSB                                      31
+#define ETH_SGMII_TX_INVERT_LSB                                      31
+#define ETH_SGMII_TX_INVERT_MASK                                     0x80000000
+#define ETH_SGMII_TX_INVERT_GET(x)                                   (((x) & ETH_SGMII_TX_INVERT_MASK) >> ETH_SGMII_TX_INVERT_LSB)
+#define ETH_SGMII_TX_INVERT_SET(x)                                   (((x) << ETH_SGMII_TX_INVERT_LSB) & ETH_SGMII_TX_INVERT_MASK)
+#define ETH_SGMII_TX_INVERT_RESET                                    0x0 // 0
+#define ETH_SGMII_GIGE_QUAD_MSB                                      30
+#define ETH_SGMII_GIGE_QUAD_LSB                                      30
+#define ETH_SGMII_GIGE_QUAD_MASK                                     0x40000000
+#define ETH_SGMII_GIGE_QUAD_GET(x)                                   (((x) & ETH_SGMII_GIGE_QUAD_MASK) >> ETH_SGMII_GIGE_QUAD_LSB)
+#define ETH_SGMII_GIGE_QUAD_SET(x)                                   (((x) << ETH_SGMII_GIGE_QUAD_LSB) & ETH_SGMII_GIGE_QUAD_MASK)
+#define ETH_SGMII_GIGE_QUAD_RESET                                    0x0 // 0
+#define ETH_SGMII_RX_DELAY_MSB                                       29
+#define ETH_SGMII_RX_DELAY_LSB                                       28
+#define ETH_SGMII_RX_DELAY_MASK                                      0x30000000
+#define ETH_SGMII_RX_DELAY_GET(x)                                    (((x) & ETH_SGMII_RX_DELAY_MASK) >> ETH_SGMII_RX_DELAY_LSB)
+#define ETH_SGMII_RX_DELAY_SET(x)                                    (((x) << ETH_SGMII_RX_DELAY_LSB) & ETH_SGMII_RX_DELAY_MASK)
+#define ETH_SGMII_RX_DELAY_RESET                                     0x0 // 0
+#define ETH_SGMII_TX_DELAY_MSB                                       27
+#define ETH_SGMII_TX_DELAY_LSB                                       26
+#define ETH_SGMII_TX_DELAY_MASK                                      0x0c000000
+#define ETH_SGMII_TX_DELAY_GET(x)                                    (((x) & ETH_SGMII_TX_DELAY_MASK) >> ETH_SGMII_TX_DELAY_LSB)
+#define ETH_SGMII_TX_DELAY_SET(x)                                    (((x) << ETH_SGMII_TX_DELAY_LSB) & ETH_SGMII_TX_DELAY_MASK)
+#define ETH_SGMII_TX_DELAY_RESET                                     0x0 // 0
+#define ETH_SGMII_CLK_SEL_MSB                                        25
+#define ETH_SGMII_CLK_SEL_LSB                                        25
+#define ETH_SGMII_CLK_SEL_MASK                                       0x02000000
+#define ETH_SGMII_CLK_SEL_GET(x)                                     (((x) & ETH_SGMII_CLK_SEL_MASK) >> ETH_SGMII_CLK_SEL_LSB)
+#define ETH_SGMII_CLK_SEL_SET(x)                                     (((x) << ETH_SGMII_CLK_SEL_LSB) & ETH_SGMII_CLK_SEL_MASK)
+#define ETH_SGMII_CLK_SEL_RESET                                      0x1 // 1
+#define ETH_SGMII_GIGE_MSB                                           24
+#define ETH_SGMII_GIGE_LSB                                           24
+#define ETH_SGMII_GIGE_MASK                                          0x01000000
+#define ETH_SGMII_GIGE_GET(x)                                        (((x) & ETH_SGMII_GIGE_MASK) >> ETH_SGMII_GIGE_LSB)
+#define ETH_SGMII_GIGE_SET(x)                                        (((x) << ETH_SGMII_GIGE_LSB) & ETH_SGMII_GIGE_MASK)
+#define ETH_SGMII_GIGE_RESET                                         0x1 // 1
+#define ETH_SGMII_PHASE1_COUNT_MSB                                   15
+#define ETH_SGMII_PHASE1_COUNT_LSB                                   8
+#define ETH_SGMII_PHASE1_COUNT_MASK                                  0x0000ff00
+#define ETH_SGMII_PHASE1_COUNT_GET(x)                                (((x) & ETH_SGMII_PHASE1_COUNT_MASK) >> ETH_SGMII_PHASE1_COUNT_LSB)
+#define ETH_SGMII_PHASE1_COUNT_SET(x)                                (((x) << ETH_SGMII_PHASE1_COUNT_LSB) & ETH_SGMII_PHASE1_COUNT_MASK)
+#define ETH_SGMII_PHASE1_COUNT_RESET                                 0x1 // 1
+#define ETH_SGMII_PHASE0_COUNT_MSB                                   7
+#define ETH_SGMII_PHASE0_COUNT_LSB                                   0
+#define ETH_SGMII_PHASE0_COUNT_MASK                                  0x000000ff
+#define ETH_SGMII_PHASE0_COUNT_GET(x)                                (((x) & ETH_SGMII_PHASE0_COUNT_MASK) >> ETH_SGMII_PHASE0_COUNT_LSB)
+#define ETH_SGMII_PHASE0_COUNT_SET(x)                                (((x) << ETH_SGMII_PHASE0_COUNT_LSB) & ETH_SGMII_PHASE0_COUNT_MASK)
+#define ETH_SGMII_PHASE0_COUNT_RESET                                 0x1 // 1
+#define ETH_SGMII_ADDRESS                                            0x18050048
+
+#endif /* _QCA953X_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/955x.h u-boot_1.1//include/955x.h
--- u-boot//include/955x.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/955x.h	2014-02-18 01:46:27.555052814 -0800
@@ -0,0 +1,3484 @@
+/*
+ * QCA 955x series processor SOC registers
+ *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _QCA955X_H
+#define _QCA955X_H
+
+#ifndef __ASSEMBLY__
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <linux/types.h>
+#endif /* __ASSEMBLY__ */
+
+#undef is_qca955x
+#undef is_sco
+
+#define is_qca955x()	(1)
+#define is_sco()	(1)
+
+
+#define CPU_PLL_CONFIG_UPDATING_MSB                                  31
+#define CPU_PLL_CONFIG_UPDATING_LSB                                  31
+#define CPU_PLL_CONFIG_UPDATING_MASK                                 0x80000000
+#define CPU_PLL_CONFIG_UPDATING_GET(x)                               (((x) & CPU_PLL_CONFIG_UPDATING_MASK) >> CPU_PLL_CONFIG_UPDATING_LSB)
+#define CPU_PLL_CONFIG_UPDATING_SET(x)                               (((x) << CPU_PLL_CONFIG_UPDATING_LSB) & CPU_PLL_CONFIG_UPDATING_MASK)
+#define CPU_PLL_CONFIG_UPDATING_RESET                                0x1 // 1
+#define CPU_PLL_CONFIG_PLLPWD_MSB                                    30
+#define CPU_PLL_CONFIG_PLLPWD_LSB                                    30
+#define CPU_PLL_CONFIG_PLLPWD_MASK                                   0x40000000
+#define CPU_PLL_CONFIG_PLLPWD_GET(x)                                 (((x) & CPU_PLL_CONFIG_PLLPWD_MASK) >> CPU_PLL_CONFIG_PLLPWD_LSB)
+#define CPU_PLL_CONFIG_PLLPWD_SET(x)                                 (((x) << CPU_PLL_CONFIG_PLLPWD_LSB) & CPU_PLL_CONFIG_PLLPWD_MASK)
+#define CPU_PLL_CONFIG_PLLPWD_RESET                                  0x1 // 1
+#define CPU_PLL_CONFIG_SPARE_MSB                                     29
+#define CPU_PLL_CONFIG_SPARE_LSB                                     22
+#define CPU_PLL_CONFIG_SPARE_MASK                                    0x3fc00000
+#define CPU_PLL_CONFIG_SPARE_GET(x)                                  (((x) & CPU_PLL_CONFIG_SPARE_MASK) >> CPU_PLL_CONFIG_SPARE_LSB)
+#define CPU_PLL_CONFIG_SPARE_SET(x)                                  (((x) << CPU_PLL_CONFIG_SPARE_LSB) & CPU_PLL_CONFIG_SPARE_MASK)
+#define CPU_PLL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define CPU_PLL_CONFIG_OUTDIV_MSB                                    21
+#define CPU_PLL_CONFIG_OUTDIV_LSB                                    19
+#define CPU_PLL_CONFIG_OUTDIV_MASK                                   0x00380000
+#define CPU_PLL_CONFIG_OUTDIV_GET(x)                                 (((x) & CPU_PLL_CONFIG_OUTDIV_MASK) >> CPU_PLL_CONFIG_OUTDIV_LSB)
+#define CPU_PLL_CONFIG_OUTDIV_SET(x)                                 (((x) << CPU_PLL_CONFIG_OUTDIV_LSB) & CPU_PLL_CONFIG_OUTDIV_MASK)
+#define CPU_PLL_CONFIG_OUTDIV_RESET                                  0x0 // 0
+#define CPU_PLL_CONFIG_RANGE_MSB                                     18
+#define CPU_PLL_CONFIG_RANGE_LSB                                     17
+#define CPU_PLL_CONFIG_RANGE_MASK                                    0x00060000
+#define CPU_PLL_CONFIG_RANGE_GET(x)                                  (((x) & CPU_PLL_CONFIG_RANGE_MASK) >> CPU_PLL_CONFIG_RANGE_LSB)
+#define CPU_PLL_CONFIG_RANGE_SET(x)                                  (((x) << CPU_PLL_CONFIG_RANGE_LSB) & CPU_PLL_CONFIG_RANGE_MASK)
+#define CPU_PLL_CONFIG_RANGE_RESET                                   0x3 // 3
+#define CPU_PLL_CONFIG_REFDIV_MSB                                    16
+#define CPU_PLL_CONFIG_REFDIV_LSB                                    12
+#define CPU_PLL_CONFIG_REFDIV_MASK                                   0x0001f000
+#define CPU_PLL_CONFIG_REFDIV_GET(x)                                 (((x) & CPU_PLL_CONFIG_REFDIV_MASK) >> CPU_PLL_CONFIG_REFDIV_LSB)
+#define CPU_PLL_CONFIG_REFDIV_SET(x)                                 (((x) << CPU_PLL_CONFIG_REFDIV_LSB) & CPU_PLL_CONFIG_REFDIV_MASK)
+#define CPU_PLL_CONFIG_REFDIV_RESET                                  0x2 // 2
+#define CPU_PLL_CONFIG_NINT_MSB                                      11
+#define CPU_PLL_CONFIG_NINT_LSB                                      6
+#define CPU_PLL_CONFIG_NINT_MASK                                     0x00000fc0
+#define CPU_PLL_CONFIG_NINT_GET(x)                                   (((x) & CPU_PLL_CONFIG_NINT_MASK) >> CPU_PLL_CONFIG_NINT_LSB)
+#define CPU_PLL_CONFIG_NINT_SET(x)                                   (((x) << CPU_PLL_CONFIG_NINT_LSB) & CPU_PLL_CONFIG_NINT_MASK)
+#define CPU_PLL_CONFIG_NINT_RESET                                    0x14 // 20
+#define CPU_PLL_CONFIG_NFRAC_MSB                                     5
+#define CPU_PLL_CONFIG_NFRAC_LSB                                     0
+#define CPU_PLL_CONFIG_NFRAC_MASK                                    0x0000003f
+#define CPU_PLL_CONFIG_NFRAC_GET(x)                                  (((x) & CPU_PLL_CONFIG_NFRAC_MASK) >> CPU_PLL_CONFIG_NFRAC_LSB)
+#define CPU_PLL_CONFIG_NFRAC_SET(x)                                  (((x) << CPU_PLL_CONFIG_NFRAC_LSB) & CPU_PLL_CONFIG_NFRAC_MASK)
+#define CPU_PLL_CONFIG_NFRAC_RESET                                   0x10 // 16
+#define CPU_PLL_CONFIG_ADDRESS                                       0x18050000
+
+#define DDR_PLL_CONFIG_UPDATING_MSB                                  31
+#define DDR_PLL_CONFIG_UPDATING_LSB                                  31
+#define DDR_PLL_CONFIG_UPDATING_MASK                                 0x80000000
+#define DDR_PLL_CONFIG_UPDATING_GET(x)                               (((x) & DDR_PLL_CONFIG_UPDATING_MASK) >> DDR_PLL_CONFIG_UPDATING_LSB)
+#define DDR_PLL_CONFIG_UPDATING_SET(x)                               (((x) << DDR_PLL_CONFIG_UPDATING_LSB) & DDR_PLL_CONFIG_UPDATING_MASK)
+#define DDR_PLL_CONFIG_UPDATING_RESET                                0x1 // 1
+#define DDR_PLL_CONFIG_PLLPWD_MSB                                    30
+#define DDR_PLL_CONFIG_PLLPWD_LSB                                    30
+#define DDR_PLL_CONFIG_PLLPWD_MASK                                   0x40000000
+#define DDR_PLL_CONFIG_PLLPWD_GET(x)                                 (((x) & DDR_PLL_CONFIG_PLLPWD_MASK) >> DDR_PLL_CONFIG_PLLPWD_LSB)
+#define DDR_PLL_CONFIG_PLLPWD_SET(x)                                 (((x) << DDR_PLL_CONFIG_PLLPWD_LSB) & DDR_PLL_CONFIG_PLLPWD_MASK)
+#define DDR_PLL_CONFIG_PLLPWD_RESET                                  0x1 // 1
+#define DDR_PLL_CONFIG_SPARE_MSB                                     29
+#define DDR_PLL_CONFIG_SPARE_LSB                                     26
+#define DDR_PLL_CONFIG_SPARE_MASK                                    0x3c000000
+#define DDR_PLL_CONFIG_SPARE_GET(x)                                  (((x) & DDR_PLL_CONFIG_SPARE_MASK) >> DDR_PLL_CONFIG_SPARE_LSB)
+#define DDR_PLL_CONFIG_SPARE_SET(x)                                  (((x) << DDR_PLL_CONFIG_SPARE_LSB) & DDR_PLL_CONFIG_SPARE_MASK)
+#define DDR_PLL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define DDR_PLL_CONFIG_OUTDIV_MSB                                    25
+#define DDR_PLL_CONFIG_OUTDIV_LSB                                    23
+#define DDR_PLL_CONFIG_OUTDIV_MASK                                   0x03800000
+#define DDR_PLL_CONFIG_OUTDIV_GET(x)                                 (((x) & DDR_PLL_CONFIG_OUTDIV_MASK) >> DDR_PLL_CONFIG_OUTDIV_LSB)
+#define DDR_PLL_CONFIG_OUTDIV_SET(x)                                 (((x) << DDR_PLL_CONFIG_OUTDIV_LSB) & DDR_PLL_CONFIG_OUTDIV_MASK)
+#define DDR_PLL_CONFIG_OUTDIV_RESET                                  0x0 // 0
+#define DDR_PLL_CONFIG_RANGE_MSB                                     22
+#define DDR_PLL_CONFIG_RANGE_LSB                                     21
+#define DDR_PLL_CONFIG_RANGE_MASK                                    0x00600000
+#define DDR_PLL_CONFIG_RANGE_GET(x)                                  (((x) & DDR_PLL_CONFIG_RANGE_MASK) >> DDR_PLL_CONFIG_RANGE_LSB)
+#define DDR_PLL_CONFIG_RANGE_SET(x)                                  (((x) << DDR_PLL_CONFIG_RANGE_LSB) & DDR_PLL_CONFIG_RANGE_MASK)
+#define DDR_PLL_CONFIG_RANGE_RESET                                   0x3 // 3
+#define DDR_PLL_CONFIG_REFDIV_MSB                                    20
+#define DDR_PLL_CONFIG_REFDIV_LSB                                    16
+#define DDR_PLL_CONFIG_REFDIV_MASK                                   0x001f0000
+#define DDR_PLL_CONFIG_REFDIV_GET(x)                                 (((x) & DDR_PLL_CONFIG_REFDIV_MASK) >> DDR_PLL_CONFIG_REFDIV_LSB)
+#define DDR_PLL_CONFIG_REFDIV_SET(x)                                 (((x) << DDR_PLL_CONFIG_REFDIV_LSB) & DDR_PLL_CONFIG_REFDIV_MASK)
+#define DDR_PLL_CONFIG_REFDIV_RESET                                  0x2 // 2
+#define DDR_PLL_CONFIG_NINT_MSB                                      15
+#define DDR_PLL_CONFIG_NINT_LSB                                      10
+#define DDR_PLL_CONFIG_NINT_MASK                                     0x0000fc00
+#define DDR_PLL_CONFIG_NINT_GET(x)                                   (((x) & DDR_PLL_CONFIG_NINT_MASK) >> DDR_PLL_CONFIG_NINT_LSB)
+#define DDR_PLL_CONFIG_NINT_SET(x)                                   (((x) << DDR_PLL_CONFIG_NINT_LSB) & DDR_PLL_CONFIG_NINT_MASK)
+#define DDR_PLL_CONFIG_NINT_RESET                                    0x14 // 20
+#define DDR_PLL_CONFIG_NFRAC_MSB                                     9
+#define DDR_PLL_CONFIG_NFRAC_LSB                                     0
+#define DDR_PLL_CONFIG_NFRAC_MASK                                    0x000003ff
+#define DDR_PLL_CONFIG_NFRAC_GET(x)                                  (((x) & DDR_PLL_CONFIG_NFRAC_MASK) >> DDR_PLL_CONFIG_NFRAC_LSB)
+#define DDR_PLL_CONFIG_NFRAC_SET(x)                                  (((x) << DDR_PLL_CONFIG_NFRAC_LSB) & DDR_PLL_CONFIG_NFRAC_MASK)
+#define DDR_PLL_CONFIG_NFRAC_RESET                                   0x200 // 512
+#define DDR_PLL_CONFIG_ADDRESS                                       0x18050004
+
+#define DDR_CTL_CONFIG_SRAM_TSEL_MSB                                 31
+#define DDR_CTL_CONFIG_SRAM_TSEL_LSB                                 30
+#define DDR_CTL_CONFIG_SRAM_TSEL_MASK                                0xc0000000
+#define DDR_CTL_CONFIG_SRAM_TSEL_GET(x)                              (((x) & DDR_CTL_CONFIG_SRAM_TSEL_MASK) >> DDR_CTL_CONFIG_SRAM_TSEL_LSB)
+#define DDR_CTL_CONFIG_SRAM_TSEL_SET(x)                              (((x) << DDR_CTL_CONFIG_SRAM_TSEL_LSB) & DDR_CTL_CONFIG_SRAM_TSEL_MASK)
+#define DDR_CTL_CONFIG_SRAM_TSEL_RESET                               0x1 // 1
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MSB                           29
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB                           21
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK                          0x3fe00000
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_GET(x)                        (((x) & DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK) >> DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB)
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_SET(x)                        (((x) << DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB) & DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK)
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_RESET                         0x0 // 0
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_MSB                             20
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB                             20
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK                            0x00100000
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_MSB                             19
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB                             19
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK                            0x00080000
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_MSB                             18
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB                             18
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK                            0x00040000
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MSB                            17
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB                            17
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK                           0x00020000
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_GET(x)                         (((x) & DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_SET(x)                         (((x) << DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_RESET                          0x1 // 1
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MSB                            16
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB                            16
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK                           0x00010000
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_GET(x)                         (((x) & DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_SET(x)                         (((x) << DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_RESET                          0x1 // 1
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_MSB                       15
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_LSB                       15
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_MASK                      0x00008000
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_GET(x)                    (((x) & DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_SET(x)                    (((x) << DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_RESET                     0x1 // 1
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_MSB                       14
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_LSB                       14
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_MASK                      0x00004000
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_GET(x)                    (((x) & DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_SET(x)                    (((x) << DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_RESET                     0x1 // 1
+#define DDR_CTL_CONFIG_SPARE_MSB                                     13
+#define DDR_CTL_CONFIG_SPARE_LSB                                     7
+#define DDR_CTL_CONFIG_SPARE_MASK                                    0x00003f80
+#define DDR_CTL_CONFIG_SPARE_GET(x)                                  (((x) & DDR_CTL_CONFIG_SPARE_MASK) >> DDR_CTL_CONFIG_SPARE_LSB)
+#define DDR_CTL_CONFIG_SPARE_SET(x)                                  (((x) << DDR_CTL_CONFIG_SPARE_LSB) & DDR_CTL_CONFIG_SPARE_MASK)
+#define DDR_CTL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_MSB                              6
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB                              6
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK                             0x00000040
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_GET(x)                           (((x) & DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK) >> DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB)
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(x)                           (((x) << DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB) & DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK)
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_MSB                             4
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB                             4
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK                            0x00000010
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_GET(x)                          (((x) & DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK) >> DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB)
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_SET(x)                          (((x) << DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB) & DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK)
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_RESET                           0x0 // 0
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_MSB                              3
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB                              3
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK                             0x00000008
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_GET(x)                           (((x) & DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK) >> DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB)
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_SET(x)                           (((x) << DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB) & DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK)
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_MSB                              2
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB                              2
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK                             0x00000004
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_GET(x)                           (((x) & DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK) >> DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB)
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(x)                           (((x) << DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB) & DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK)
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_HALF_WIDTH_MSB                                1
+#define DDR_CTL_CONFIG_HALF_WIDTH_LSB                                1
+#define DDR_CTL_CONFIG_HALF_WIDTH_MASK                               0x00000002
+#define DDR_CTL_CONFIG_HALF_WIDTH_GET(x)                             (((x) & DDR_CTL_CONFIG_HALF_WIDTH_MASK) >> DDR_CTL_CONFIG_HALF_WIDTH_LSB)
+#define DDR_CTL_CONFIG_HALF_WIDTH_SET(x)                             (((x) << DDR_CTL_CONFIG_HALF_WIDTH_LSB) & DDR_CTL_CONFIG_HALF_WIDTH_MASK)
+#define DDR_CTL_CONFIG_HALF_WIDTH_RESET                              0x1 // 1
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_MSB                             0
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB                             0
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK                            0x00000001
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_GET(x)                          (((x) & DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK) >> DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB)
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_SET(x)                          (((x) << DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB) & DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK)
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_RESET                           0x0 // 0
+#define DDR_CTL_CONFIG_ADDRESS                                       0x18000108
+
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MSB                            31
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB                            31
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK                           0x80000000
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK) >> DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_RESET                          0x0 // 0
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MSB                           30
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB                           30
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK                          0x40000000
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_GET(x)                        (((x) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK) >> DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_SET(x)                        (((x) << DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_RESET                         0x0 // 0
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_MSB                             29
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB                             29
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK                            0x20000000
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_GET(x)                          (((x) & DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK) >> DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB)
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_SET(x)                          (((x) << DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB) & DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK)
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_RESET                           0x0 // 0
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MSB                            28
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB                            28
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK                           0x10000000
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK) >> DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB)
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB) & DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK)
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_RESET                          0x1 // 1
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MSB                            27
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB                            27
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK                           0x08000000
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK) >> DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB)
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB) & DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK)
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_RESET                          0x0 // 0
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MSB                          14
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB                          13
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK                         0x00006000
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_GET(x)                       (((x) & DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK) >> DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_SET(x)                       (((x) << DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB) & DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_RESET                        0x0 // 0
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_MSB                               12
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_LSB                               8
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_MASK                              0x00001f00
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_GET(x)                            (((x) & DDR_DEBUG_RD_CNTL_GATE_TAP_MASK) >> DDR_DEBUG_RD_CNTL_GATE_TAP_LSB)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_SET(x)                            (((x) << DDR_DEBUG_RD_CNTL_GATE_TAP_LSB) & DDR_DEBUG_RD_CNTL_GATE_TAP_MASK)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_RESET                             0x1 // 1
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MSB                          6
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB                          5
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK                         0x00000060
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_GET(x)                       (((x) & DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK) >> DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_SET(x)                       (((x) << DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB) & DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_RESET                        0x0 // 0
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_MSB                               4
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB                               0
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK                              0x0000001f
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_GET(x)                            (((x) & DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK) >> DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_SET(x)                            (((x) << DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB) & DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_RESET                             0x1 // 1
+#define DDR_DEBUG_RD_CNTL_ADDRESS                                    0x18000118
+
+#define DDR2_CONFIG_DDR2_TWL_MSB                                     13
+#define DDR2_CONFIG_DDR2_TWL_LSB                                     10
+#define DDR2_CONFIG_DDR2_TWL_MASK                                    0x00003c00
+#define DDR2_CONFIG_DDR2_TWL_GET(x)                                  (((x) & DDR2_CONFIG_DDR2_TWL_MASK) >> DDR2_CONFIG_DDR2_TWL_LSB)
+#define DDR2_CONFIG_DDR2_TWL_SET(x)                                  (((x) << DDR2_CONFIG_DDR2_TWL_LSB) & DDR2_CONFIG_DDR2_TWL_MASK)
+#define DDR2_CONFIG_DDR2_TWL_RESET                                   0x1 // 1
+#define DDR2_CONFIG_DDR2_ODT_MSB                                     9
+#define DDR2_CONFIG_DDR2_ODT_LSB                                     9
+#define DDR2_CONFIG_DDR2_ODT_MASK                                    0x00000200
+#define DDR2_CONFIG_DDR2_ODT_GET(x)                                  (((x) & DDR2_CONFIG_DDR2_ODT_MASK) >> DDR2_CONFIG_DDR2_ODT_LSB)
+#define DDR2_CONFIG_DDR2_ODT_SET(x)                                  (((x) << DDR2_CONFIG_DDR2_ODT_LSB) & DDR2_CONFIG_DDR2_ODT_MASK)
+#define DDR2_CONFIG_DDR2_ODT_RESET                                   0x1 // 1
+#define DDR2_CONFIG_TFAW_MSB                                         7
+#define DDR2_CONFIG_TFAW_LSB                                         2
+#define DDR2_CONFIG_TFAW_MASK                                        0x000000fc
+#define DDR2_CONFIG_TFAW_GET(x)                                      (((x) & DDR2_CONFIG_TFAW_MASK) >> DDR2_CONFIG_TFAW_LSB)
+#define DDR2_CONFIG_TFAW_SET(x)                                      (((x) << DDR2_CONFIG_TFAW_LSB) & DDR2_CONFIG_TFAW_MASK)
+#define DDR2_CONFIG_TFAW_RESET                                       0x16 // 22
+#define DDR2_CONFIG_ENABLE_DDR2_MSB                                  0
+#define DDR2_CONFIG_ENABLE_DDR2_LSB                                  0
+#define DDR2_CONFIG_ENABLE_DDR2_MASK                                 0x00000001
+#define DDR2_CONFIG_ENABLE_DDR2_GET(x)                               (((x) & DDR2_CONFIG_ENABLE_DDR2_MASK) >> DDR2_CONFIG_ENABLE_DDR2_LSB)
+#define DDR2_CONFIG_ENABLE_DDR2_SET(x)                               (((x) << DDR2_CONFIG_ENABLE_DDR2_LSB) & DDR2_CONFIG_ENABLE_DDR2_MASK)
+#define DDR2_CONFIG_ENABLE_DDR2_RESET                                0x0 // 0
+#define DDR2_CONFIG_ADDRESS                                          0x180000b8
+
+#define DDR_CONTROL_EMR3S_MSB                                        5
+#define DDR_CONTROL_EMR3S_LSB                                        5
+#define DDR_CONTROL_EMR3S_MASK                                       0x00000020
+#define DDR_CONTROL_EMR3S_GET(x)                                     (((x) & DDR_CONTROL_EMR3S_MASK) >> DDR_CONTROL_EMR3S_LSB)
+#define DDR_CONTROL_EMR3S_SET(x)                                     (((x) << DDR_CONTROL_EMR3S_LSB) & DDR_CONTROL_EMR3S_MASK)
+#define DDR_CONTROL_EMR3S_RESET                                      0x0 // 0
+#define DDR_CONTROL_EMR2S_MSB                                        4
+#define DDR_CONTROL_EMR2S_LSB                                        4
+#define DDR_CONTROL_EMR2S_MASK                                       0x00000010
+#define DDR_CONTROL_EMR2S_GET(x)                                     (((x) & DDR_CONTROL_EMR2S_MASK) >> DDR_CONTROL_EMR2S_LSB)
+#define DDR_CONTROL_EMR2S_SET(x)                                     (((x) << DDR_CONTROL_EMR2S_LSB) & DDR_CONTROL_EMR2S_MASK)
+#define DDR_CONTROL_EMR2S_RESET                                      0x0 // 0
+#define DDR_CONTROL_PREA_MSB                                         3
+#define DDR_CONTROL_PREA_LSB                                         3
+#define DDR_CONTROL_PREA_MASK                                        0x00000008
+#define DDR_CONTROL_PREA_GET(x)                                      (((x) & DDR_CONTROL_PREA_MASK) >> DDR_CONTROL_PREA_LSB)
+#define DDR_CONTROL_PREA_SET(x)                                      (((x) << DDR_CONTROL_PREA_LSB) & DDR_CONTROL_PREA_MASK)
+#define DDR_CONTROL_PREA_RESET                                       0x0 // 0
+#define DDR_CONTROL_REF_MSB                                          2
+#define DDR_CONTROL_REF_LSB                                          2
+#define DDR_CONTROL_REF_MASK                                         0x00000004
+#define DDR_CONTROL_REF_GET(x)                                       (((x) & DDR_CONTROL_REF_MASK) >> DDR_CONTROL_REF_LSB)
+#define DDR_CONTROL_REF_SET(x)                                       (((x) << DDR_CONTROL_REF_LSB) & DDR_CONTROL_REF_MASK)
+#define DDR_CONTROL_REF_RESET                                        0x0 // 0
+#define DDR_CONTROL_EMRS_MSB                                         1
+#define DDR_CONTROL_EMRS_LSB                                         1
+#define DDR_CONTROL_EMRS_MASK                                        0x00000002
+#define DDR_CONTROL_EMRS_GET(x)                                      (((x) & DDR_CONTROL_EMRS_MASK) >> DDR_CONTROL_EMRS_LSB)
+#define DDR_CONTROL_EMRS_SET(x)                                      (((x) << DDR_CONTROL_EMRS_LSB) & DDR_CONTROL_EMRS_MASK)
+#define DDR_CONTROL_EMRS_RESET                                       0x0 // 0
+#define DDR_CONTROL_MRS_MSB                                          0
+#define DDR_CONTROL_MRS_LSB                                          0
+#define DDR_CONTROL_MRS_MASK                                         0x00000001
+#define DDR_CONTROL_MRS_GET(x)                                       (((x) & DDR_CONTROL_MRS_MASK) >> DDR_CONTROL_MRS_LSB)
+#define DDR_CONTROL_MRS_SET(x)                                       (((x) << DDR_CONTROL_MRS_LSB) & DDR_CONTROL_MRS_MASK)
+#define DDR_CONTROL_MRS_RESET                                        0x0 // 0
+#define DDR_CONTROL_ADDRESS                                          0x18000010
+
+#define DDR_CONFIG_CAS_LATENCY_MSB_MSB                               31
+#define DDR_CONFIG_CAS_LATENCY_MSB_LSB                               31
+#define DDR_CONFIG_CAS_LATENCY_MSB_MASK                              0x80000000
+#define DDR_CONFIG_CAS_LATENCY_MSB_GET(x)                            (((x) & DDR_CONFIG_CAS_LATENCY_MSB_MASK) >> DDR_CONFIG_CAS_LATENCY_MSB_LSB)
+#define DDR_CONFIG_CAS_LATENCY_MSB_SET(x)                            (((x) << DDR_CONFIG_CAS_LATENCY_MSB_LSB) & DDR_CONFIG_CAS_LATENCY_MSB_MASK)
+#define DDR_CONFIG_CAS_LATENCY_MSB_RESET                             0x0 // 0
+#define DDR_CONFIG_OPEN_PAGE_MSB                                     30
+#define DDR_CONFIG_OPEN_PAGE_LSB                                     30
+#define DDR_CONFIG_OPEN_PAGE_MASK                                    0x40000000
+#define DDR_CONFIG_OPEN_PAGE_GET(x)                                  (((x) & DDR_CONFIG_OPEN_PAGE_MASK) >> DDR_CONFIG_OPEN_PAGE_LSB)
+#define DDR_CONFIG_OPEN_PAGE_SET(x)                                  (((x) << DDR_CONFIG_OPEN_PAGE_LSB) & DDR_CONFIG_OPEN_PAGE_MASK)
+#define DDR_CONFIG_OPEN_PAGE_RESET                                   0x1 // 1
+#define DDR_CONFIG_CAS_LATENCY_MSB                                   29
+#define DDR_CONFIG_CAS_LATENCY_LSB                                   27
+#define DDR_CONFIG_CAS_LATENCY_MASK                                  0x38000000
+#define DDR_CONFIG_CAS_LATENCY_GET(x)                                (((x) & DDR_CONFIG_CAS_LATENCY_MASK) >> DDR_CONFIG_CAS_LATENCY_LSB)
+#define DDR_CONFIG_CAS_LATENCY_SET(x)                                (((x) << DDR_CONFIG_CAS_LATENCY_LSB) & DDR_CONFIG_CAS_LATENCY_MASK)
+#define DDR_CONFIG_CAS_LATENCY_RESET                                 0x6 // 6
+#define DDR_CONFIG_TMRD_MSB                                          26
+#define DDR_CONFIG_TMRD_LSB                                          23
+#define DDR_CONFIG_TMRD_MASK                                         0x07800000
+#define DDR_CONFIG_TMRD_GET(x)                                       (((x) & DDR_CONFIG_TMRD_MASK) >> DDR_CONFIG_TMRD_LSB)
+#define DDR_CONFIG_TMRD_SET(x)                                       (((x) << DDR_CONFIG_TMRD_LSB) & DDR_CONFIG_TMRD_MASK)
+#define DDR_CONFIG_TMRD_RESET                                        0xf // 15
+#define DDR_CONFIG_TRFC_MSB                                          22
+#define DDR_CONFIG_TRFC_LSB                                          17
+#define DDR_CONFIG_TRFC_MASK                                         0x007e0000
+#define DDR_CONFIG_TRFC_GET(x)                                       (((x) & DDR_CONFIG_TRFC_MASK) >> DDR_CONFIG_TRFC_LSB)
+#define DDR_CONFIG_TRFC_SET(x)                                       (((x) << DDR_CONFIG_TRFC_LSB) & DDR_CONFIG_TRFC_MASK)
+#define DDR_CONFIG_TRFC_RESET                                        0x24 // 36
+#define DDR_CONFIG_TRRD_MSB                                          16
+#define DDR_CONFIG_TRRD_LSB                                          13
+#define DDR_CONFIG_TRRD_MASK                                         0x0001e000
+#define DDR_CONFIG_TRRD_GET(x)                                       (((x) & DDR_CONFIG_TRRD_MASK) >> DDR_CONFIG_TRRD_LSB)
+#define DDR_CONFIG_TRRD_SET(x)                                       (((x) << DDR_CONFIG_TRRD_LSB) & DDR_CONFIG_TRRD_MASK)
+#define DDR_CONFIG_TRRD_RESET                                        0x4 // 4
+#define DDR_CONFIG_TRP_MSB                                           12
+#define DDR_CONFIG_TRP_LSB                                           9
+#define DDR_CONFIG_TRP_MASK                                          0x00001e00
+#define DDR_CONFIG_TRP_GET(x)                                        (((x) & DDR_CONFIG_TRP_MASK) >> DDR_CONFIG_TRP_LSB)
+#define DDR_CONFIG_TRP_SET(x)                                        (((x) << DDR_CONFIG_TRP_LSB) & DDR_CONFIG_TRP_MASK)
+#define DDR_CONFIG_TRP_RESET                                         0x6 // 6
+#define DDR_CONFIG_TRCD_MSB                                          8
+#define DDR_CONFIG_TRCD_LSB                                          5
+#define DDR_CONFIG_TRCD_MASK                                         0x000001e0
+#define DDR_CONFIG_TRCD_GET(x)                                       (((x) & DDR_CONFIG_TRCD_MASK) >> DDR_CONFIG_TRCD_LSB)
+#define DDR_CONFIG_TRCD_SET(x)                                       (((x) << DDR_CONFIG_TRCD_LSB) & DDR_CONFIG_TRCD_MASK)
+#define DDR_CONFIG_TRCD_RESET                                        0x6 // 6
+#define DDR_CONFIG_TRAS_MSB                                          4
+#define DDR_CONFIG_TRAS_LSB                                          0
+#define DDR_CONFIG_TRAS_MASK                                         0x0000001f
+#define DDR_CONFIG_TRAS_GET(x)                                       (((x) & DDR_CONFIG_TRAS_MASK) >> DDR_CONFIG_TRAS_LSB)
+#define DDR_CONFIG_TRAS_SET(x)                                       (((x) << DDR_CONFIG_TRAS_LSB) & DDR_CONFIG_TRAS_MASK)
+#define DDR_CONFIG_TRAS_RESET                                        0x10 // 16
+#define DDR_CONFIG_ADDRESS                                           0x18000000
+
+#define DDR_CONFIG2_HALF_WIDTH_LOW_MSB                               31
+#define DDR_CONFIG2_HALF_WIDTH_LOW_LSB                               31
+#define DDR_CONFIG2_HALF_WIDTH_LOW_MASK                              0x80000000
+#define DDR_CONFIG2_HALF_WIDTH_LOW_GET(x)                            (((x) & DDR_CONFIG2_HALF_WIDTH_LOW_MASK) >> DDR_CONFIG2_HALF_WIDTH_LOW_LSB)
+#define DDR_CONFIG2_HALF_WIDTH_LOW_SET(x)                            (((x) << DDR_CONFIG2_HALF_WIDTH_LOW_LSB) & DDR_CONFIG2_HALF_WIDTH_LOW_MASK)
+#define DDR_CONFIG2_HALF_WIDTH_LOW_RESET                             0x1 // 1
+#define DDR_CONFIG2_SWAP_A26_A27_MSB                                 30
+#define DDR_CONFIG2_SWAP_A26_A27_LSB                                 30
+#define DDR_CONFIG2_SWAP_A26_A27_MASK                                0x40000000
+#define DDR_CONFIG2_SWAP_A26_A27_GET(x)                              (((x) & DDR_CONFIG2_SWAP_A26_A27_MASK) >> DDR_CONFIG2_SWAP_A26_A27_LSB)
+#define DDR_CONFIG2_SWAP_A26_A27_SET(x)                              (((x) << DDR_CONFIG2_SWAP_A26_A27_LSB) & DDR_CONFIG2_SWAP_A26_A27_MASK)
+#define DDR_CONFIG2_SWAP_A26_A27_RESET                               0x0 // 0
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_MSB                            29
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_LSB                            26
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_MASK                           0x3c000000
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_GET(x)                         (((x) & DDR_CONFIG2_GATE_OPEN_LATENCY_MASK) >> DDR_CONFIG2_GATE_OPEN_LATENCY_LSB)
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_SET(x)                         (((x) << DDR_CONFIG2_GATE_OPEN_LATENCY_LSB) & DDR_CONFIG2_GATE_OPEN_LATENCY_MASK)
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_RESET                          0x6 // 6
+#define DDR_CONFIG2_TWTR_MSB                                         25
+#define DDR_CONFIG2_TWTR_LSB                                         21
+#define DDR_CONFIG2_TWTR_MASK                                        0x03e00000
+#define DDR_CONFIG2_TWTR_GET(x)                                      (((x) & DDR_CONFIG2_TWTR_MASK) >> DDR_CONFIG2_TWTR_LSB)
+#define DDR_CONFIG2_TWTR_SET(x)                                      (((x) << DDR_CONFIG2_TWTR_LSB) & DDR_CONFIG2_TWTR_MASK)
+#define DDR_CONFIG2_TWTR_RESET                                       0xe // 14
+#define DDR_CONFIG2_TRTP_MSB                                         20
+#define DDR_CONFIG2_TRTP_LSB                                         17
+#define DDR_CONFIG2_TRTP_MASK                                        0x001e0000
+#define DDR_CONFIG2_TRTP_GET(x)                                      (((x) & DDR_CONFIG2_TRTP_MASK) >> DDR_CONFIG2_TRTP_LSB)
+#define DDR_CONFIG2_TRTP_SET(x)                                      (((x) << DDR_CONFIG2_TRTP_LSB) & DDR_CONFIG2_TRTP_MASK)
+#define DDR_CONFIG2_TRTP_RESET                                       0x8 // 8
+#define DDR_CONFIG2_TRTW_MSB                                         16
+#define DDR_CONFIG2_TRTW_LSB                                         12
+#define DDR_CONFIG2_TRTW_MASK                                        0x0001f000
+#define DDR_CONFIG2_TRTW_GET(x)                                      (((x) & DDR_CONFIG2_TRTW_MASK) >> DDR_CONFIG2_TRTW_LSB)
+#define DDR_CONFIG2_TRTW_SET(x)                                      (((x) << DDR_CONFIG2_TRTW_LSB) & DDR_CONFIG2_TRTW_MASK)
+#define DDR_CONFIG2_TRTW_RESET                                       0x10 // 16
+#define DDR_CONFIG2_TWR_MSB                                          11
+#define DDR_CONFIG2_TWR_LSB                                          8
+#define DDR_CONFIG2_TWR_MASK                                         0x00000f00
+#define DDR_CONFIG2_TWR_GET(x)                                       (((x) & DDR_CONFIG2_TWR_MASK) >> DDR_CONFIG2_TWR_LSB)
+#define DDR_CONFIG2_TWR_SET(x)                                       (((x) << DDR_CONFIG2_TWR_LSB) & DDR_CONFIG2_TWR_MASK)
+#define DDR_CONFIG2_TWR_RESET                                        0x6 // 6
+#define DDR_CONFIG2_CKE_MSB                                          7
+#define DDR_CONFIG2_CKE_LSB                                          7
+#define DDR_CONFIG2_CKE_MASK                                         0x00000080
+#define DDR_CONFIG2_CKE_GET(x)                                       (((x) & DDR_CONFIG2_CKE_MASK) >> DDR_CONFIG2_CKE_LSB)
+#define DDR_CONFIG2_CKE_SET(x)                                       (((x) << DDR_CONFIG2_CKE_LSB) & DDR_CONFIG2_CKE_MASK)
+#define DDR_CONFIG2_CKE_RESET                                        0x0 // 0
+#define DDR_CONFIG2_PHASE_SELECT_MSB                                 6
+#define DDR_CONFIG2_PHASE_SELECT_LSB                                 6
+#define DDR_CONFIG2_PHASE_SELECT_MASK                                0x00000040
+#define DDR_CONFIG2_PHASE_SELECT_GET(x)                              (((x) & DDR_CONFIG2_PHASE_SELECT_MASK) >> DDR_CONFIG2_PHASE_SELECT_LSB)
+#define DDR_CONFIG2_PHASE_SELECT_SET(x)                              (((x) << DDR_CONFIG2_PHASE_SELECT_LSB) & DDR_CONFIG2_PHASE_SELECT_MASK)
+#define DDR_CONFIG2_PHASE_SELECT_RESET                               0x0 // 0
+#define DDR_CONFIG2_CNTL_OE_EN_MSB                                   5
+#define DDR_CONFIG2_CNTL_OE_EN_LSB                                   5
+#define DDR_CONFIG2_CNTL_OE_EN_MASK                                  0x00000020
+#define DDR_CONFIG2_CNTL_OE_EN_GET(x)                                (((x) & DDR_CONFIG2_CNTL_OE_EN_MASK) >> DDR_CONFIG2_CNTL_OE_EN_LSB)
+#define DDR_CONFIG2_CNTL_OE_EN_SET(x)                                (((x) << DDR_CONFIG2_CNTL_OE_EN_LSB) & DDR_CONFIG2_CNTL_OE_EN_MASK)
+#define DDR_CONFIG2_CNTL_OE_EN_RESET                                 0x1 // 1
+#define DDR_CONFIG2_BURST_TYPE_MSB                                   4
+#define DDR_CONFIG2_BURST_TYPE_LSB                                   4
+#define DDR_CONFIG2_BURST_TYPE_MASK                                  0x00000010
+#define DDR_CONFIG2_BURST_TYPE_GET(x)                                (((x) & DDR_CONFIG2_BURST_TYPE_MASK) >> DDR_CONFIG2_BURST_TYPE_LSB)
+#define DDR_CONFIG2_BURST_TYPE_SET(x)                                (((x) << DDR_CONFIG2_BURST_TYPE_LSB) & DDR_CONFIG2_BURST_TYPE_MASK)
+#define DDR_CONFIG2_BURST_TYPE_RESET                                 0x0 // 0
+#define DDR_CONFIG2_BURST_LENGTH_MSB                                 3
+#define DDR_CONFIG2_BURST_LENGTH_LSB                                 0
+#define DDR_CONFIG2_BURST_LENGTH_MASK                                0x0000000f
+#define DDR_CONFIG2_BURST_LENGTH_GET(x)                              (((x) & DDR_CONFIG2_BURST_LENGTH_MASK) >> DDR_CONFIG2_BURST_LENGTH_LSB)
+#define DDR_CONFIG2_BURST_LENGTH_SET(x)                              (((x) << DDR_CONFIG2_BURST_LENGTH_LSB) & DDR_CONFIG2_BURST_LENGTH_MASK)
+#define DDR_CONFIG2_BURST_LENGTH_RESET                               0x8 // 8
+#define DDR_CONFIG2_ADDRESS                                          0x18000004
+
+#define DDR_CONFIG_3_SPARE_MSB                                       31
+#define DDR_CONFIG_3_SPARE_LSB                                       4
+#define DDR_CONFIG_3_SPARE_MASK                                      0xfffffff0
+#define DDR_CONFIG_3_SPARE_GET(x)                                    (((x) & DDR_CONFIG_3_SPARE_MASK) >> DDR_CONFIG_3_SPARE_LSB)
+#define DDR_CONFIG_3_SPARE_SET(x)                                    (((x) << DDR_CONFIG_3_SPARE_LSB) & DDR_CONFIG_3_SPARE_MASK)
+#define DDR_CONFIG_3_SPARE_RESET                                     0x0 // 0
+#define DDR_CONFIG_3_TWR_MSB_MSB                                     3
+#define DDR_CONFIG_3_TWR_MSB_LSB                                     3
+#define DDR_CONFIG_3_TWR_MSB_MASK                                    0x00000008
+#define DDR_CONFIG_3_TWR_MSB_GET(x)                                  (((x) & DDR_CONFIG_3_TWR_MSB_MASK) >> DDR_CONFIG_3_TWR_MSB_LSB)
+#define DDR_CONFIG_3_TWR_MSB_SET(x)                                  (((x) << DDR_CONFIG_3_TWR_MSB_LSB) & DDR_CONFIG_3_TWR_MSB_MASK)
+#define DDR_CONFIG_3_TWR_MSB_RESET                                   0x0 // 0
+#define DDR_CONFIG_3_TRAS_MSB_MSB                                    2
+#define DDR_CONFIG_3_TRAS_MSB_LSB                                    2
+#define DDR_CONFIG_3_TRAS_MSB_MASK                                   0x00000004
+#define DDR_CONFIG_3_TRAS_MSB_GET(x)                                 (((x) & DDR_CONFIG_3_TRAS_MSB_MASK) >> DDR_CONFIG_3_TRAS_MSB_LSB)
+#define DDR_CONFIG_3_TRAS_MSB_SET(x)                                 (((x) << DDR_CONFIG_3_TRAS_MSB_LSB) & DDR_CONFIG_3_TRAS_MSB_MASK)
+#define DDR_CONFIG_3_TRAS_MSB_RESET                                  0x0 // 0
+#define DDR_CONFIG_3_TRFC_LSB_MSB                                    1
+#define DDR_CONFIG_3_TRFC_LSB_LSB                                    0
+#define DDR_CONFIG_3_TRFC_LSB_MASK                                   0x00000003
+#define DDR_CONFIG_3_TRFC_LSB_GET(x)                                 (((x) & DDR_CONFIG_3_TRFC_LSB_MASK) >> DDR_CONFIG_3_TRFC_LSB_LSB)
+#define DDR_CONFIG_3_TRFC_LSB_SET(x)                                 (((x) << DDR_CONFIG_3_TRFC_LSB_LSB) & DDR_CONFIG_3_TRFC_LSB_MASK)
+#define DDR_CONFIG_3_TRFC_LSB_RESET                                  0x0 // 0
+#define DDR_CONFIG_3_ADDRESS                                         0x1800015c
+
+#define DDR_MODE_REGISTER_VALUE_MSB                                  13
+#define DDR_MODE_REGISTER_VALUE_LSB                                  0
+#define DDR_MODE_REGISTER_VALUE_MASK                                 0x00003fff
+#define DDR_MODE_REGISTER_VALUE_GET(x)                               (((x) & DDR_MODE_REGISTER_VALUE_MASK) >> DDR_MODE_REGISTER_VALUE_LSB)
+#define DDR_MODE_REGISTER_VALUE_SET(x)                               (((x) << DDR_MODE_REGISTER_VALUE_LSB) & DDR_MODE_REGISTER_VALUE_MASK)
+#define DDR_MODE_REGISTER_VALUE_RESET                                0x133 // 307
+#define DDR_MODE_REGISTER_ADDRESS                                    0x18000008
+
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_MSB                         13
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_LSB                         0
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_MASK                        0x00003fff
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_GET(x)                      (((x) & DDR_EXTENDED_MODE_REGISTER_VALUE_MASK) >> DDR_EXTENDED_MODE_REGISTER_VALUE_LSB)
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_SET(x)                      (((x) << DDR_EXTENDED_MODE_REGISTER_VALUE_LSB) & DDR_EXTENDED_MODE_REGISTER_VALUE_MASK)
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_RESET                       0x2 // 2
+#define DDR_EXTENDED_MODE_REGISTER_ADDRESS                           0x1800000c
+
+#define DDR_REFRESH_ENABLE_MSB                                       14
+#define DDR_REFRESH_ENABLE_LSB                                       14
+#define DDR_REFRESH_ENABLE_MASK                                      0x00004000
+#define DDR_REFRESH_ENABLE_GET(x)                                    (((x) & DDR_REFRESH_ENABLE_MASK) >> DDR_REFRESH_ENABLE_LSB)
+#define DDR_REFRESH_ENABLE_SET(x)                                    (((x) << DDR_REFRESH_ENABLE_LSB) & DDR_REFRESH_ENABLE_MASK)
+#define DDR_REFRESH_ENABLE_RESET                                     0x0 // 0
+#define DDR_REFRESH_PERIOD_MSB                                       13
+#define DDR_REFRESH_PERIOD_LSB                                       0
+#define DDR_REFRESH_PERIOD_MASK                                      0x00003fff
+#define DDR_REFRESH_PERIOD_GET(x)                                    (((x) & DDR_REFRESH_PERIOD_MASK) >> DDR_REFRESH_PERIOD_LSB)
+#define DDR_REFRESH_PERIOD_SET(x)                                    (((x) << DDR_REFRESH_PERIOD_LSB) & DDR_REFRESH_PERIOD_MASK)
+#define DDR_REFRESH_PERIOD_RESET                                     0x12c // 300
+#define DDR_REFRESH_ADDRESS                                          0x18000014
+
+#define BB_DPLL2_RANGE_MSB                                           31
+#define BB_DPLL2_RANGE_LSB                                           31
+#define BB_DPLL2_RANGE_MASK                                          0x80000000
+#define BB_DPLL2_RANGE_GET(x)                                        (((x) & BB_DPLL2_RANGE_MASK) >> BB_DPLL2_RANGE_LSB)
+#define BB_DPLL2_RANGE_SET(x)                                        (((x) << BB_DPLL2_RANGE_LSB) & BB_DPLL2_RANGE_MASK)
+#define BB_DPLL2_RANGE_RESET                                         0x0 // 0
+#define BB_DPLL2_LOCAL_PLL_MSB                                       30
+#define BB_DPLL2_LOCAL_PLL_LSB                                       30
+#define BB_DPLL2_LOCAL_PLL_MASK                                      0x40000000
+#define BB_DPLL2_LOCAL_PLL_GET(x)                                    (((x) & BB_DPLL2_LOCAL_PLL_MASK) >> BB_DPLL2_LOCAL_PLL_LSB)
+#define BB_DPLL2_LOCAL_PLL_SET(x)                                    (((x) << BB_DPLL2_LOCAL_PLL_LSB) & BB_DPLL2_LOCAL_PLL_MASK)
+#define BB_DPLL2_LOCAL_PLL_RESET                                     0x0 // 0
+#define BB_DPLL2_KI_MSB                                              29
+#define BB_DPLL2_KI_LSB                                              26
+#define BB_DPLL2_KI_MASK                                             0x3c000000
+#define BB_DPLL2_KI_GET(x)                                           (((x) & BB_DPLL2_KI_MASK) >> BB_DPLL2_KI_LSB)
+#define BB_DPLL2_KI_SET(x)                                           (((x) << BB_DPLL2_KI_LSB) & BB_DPLL2_KI_MASK)
+#define BB_DPLL2_KI_RESET                                            0x6 // 6
+#define BB_DPLL2_KD_MSB                                              25
+#define BB_DPLL2_KD_LSB                                              19
+#define BB_DPLL2_KD_MASK                                             0x03f80000
+#define BB_DPLL2_KD_GET(x)                                           (((x) & BB_DPLL2_KD_MASK) >> BB_DPLL2_KD_LSB)
+#define BB_DPLL2_KD_SET(x)                                           (((x) << BB_DPLL2_KD_LSB) & BB_DPLL2_KD_MASK)
+#define BB_DPLL2_KD_RESET                                            0x7f // 127
+#define BB_DPLL2_EN_NEGTRIG_MSB                                      18
+#define BB_DPLL2_EN_NEGTRIG_LSB                                      18
+#define BB_DPLL2_EN_NEGTRIG_MASK                                     0x00040000
+#define BB_DPLL2_EN_NEGTRIG_GET(x)                                   (((x) & BB_DPLL2_EN_NEGTRIG_MASK) >> BB_DPLL2_EN_NEGTRIG_LSB)
+#define BB_DPLL2_EN_NEGTRIG_SET(x)                                   (((x) << BB_DPLL2_EN_NEGTRIG_LSB) & BB_DPLL2_EN_NEGTRIG_MASK)
+#define BB_DPLL2_EN_NEGTRIG_RESET                                    0x0 // 0
+#define BB_DPLL2_SEL_1SDM_MSB                                        17
+#define BB_DPLL2_SEL_1SDM_LSB                                        17
+#define BB_DPLL2_SEL_1SDM_MASK                                       0x00020000
+#define BB_DPLL2_SEL_1SDM_GET(x)                                     (((x) & BB_DPLL2_SEL_1SDM_MASK) >> BB_DPLL2_SEL_1SDM_LSB)
+#define BB_DPLL2_SEL_1SDM_SET(x)                                     (((x) << BB_DPLL2_SEL_1SDM_LSB) & BB_DPLL2_SEL_1SDM_MASK)
+#define BB_DPLL2_SEL_1SDM_RESET                                      0x0 // 0
+#define BB_DPLL2_PLL_PWD_MSB                                         16
+#define BB_DPLL2_PLL_PWD_LSB                                         16
+#define BB_DPLL2_PLL_PWD_MASK                                        0x00010000
+#define BB_DPLL2_PLL_PWD_GET(x)                                      (((x) & BB_DPLL2_PLL_PWD_MASK) >> BB_DPLL2_PLL_PWD_LSB)
+#define BB_DPLL2_PLL_PWD_SET(x)                                      (((x) << BB_DPLL2_PLL_PWD_LSB) & BB_DPLL2_PLL_PWD_MASK)
+#define BB_DPLL2_PLL_PWD_RESET                                       0x1 // 1
+#define BB_DPLL2_OUTDIV_MSB                                          15
+#define BB_DPLL2_OUTDIV_LSB                                          13
+#define BB_DPLL2_OUTDIV_MASK                                         0x0000e000
+#define BB_DPLL2_OUTDIV_GET(x)                                       (((x) & BB_DPLL2_OUTDIV_MASK) >> BB_DPLL2_OUTDIV_LSB)
+#define BB_DPLL2_OUTDIV_SET(x)                                       (((x) << BB_DPLL2_OUTDIV_LSB) & BB_DPLL2_OUTDIV_MASK)
+#define BB_DPLL2_OUTDIV_RESET                                        0x0 // 0
+#define BB_DPLL2_DELTA_MSB                                           12
+#define BB_DPLL2_DELTA_LSB                                           7
+#define BB_DPLL2_DELTA_MASK                                          0x00001f80
+#define BB_DPLL2_DELTA_GET(x)                                        (((x) & BB_DPLL2_DELTA_MASK) >> BB_DPLL2_DELTA_LSB)
+#define BB_DPLL2_DELTA_SET(x)                                        (((x) << BB_DPLL2_DELTA_LSB) & BB_DPLL2_DELTA_MASK)
+#define BB_DPLL2_DELTA_RESET                                         0x1e // 30
+#define BB_DPLL2_TESTINMSB_MSB                                       6
+#define BB_DPLL2_TESTINMSB_LSB                                       0
+#define BB_DPLL2_TESTINMSB_MASK                                      0x0000007f
+#define BB_DPLL2_TESTINMSB_GET(x)                                    (((x) & BB_DPLL2_TESTINMSB_MASK) >> BB_DPLL2_TESTINMSB_LSB)
+#define BB_DPLL2_TESTINMSB_SET(x)                                    (((x) << BB_DPLL2_TESTINMSB_LSB) & BB_DPLL2_TESTINMSB_MASK)
+#define BB_DPLL2_TESTINMSB_RESET                                     0x0 // 0
+#define BB_DPLL2_ADDRESS                                             0x18116184
+
+#define PCIe_DPLL2_RANGE_MSB                                         31
+#define PCIe_DPLL2_RANGE_LSB                                         31
+#define PCIe_DPLL2_RANGE_MASK                                        0x80000000
+#define PCIe_DPLL2_RANGE_GET(x)                                      (((x) & PCIe_DPLL2_RANGE_MASK) >> PCIe_DPLL2_RANGE_LSB)
+#define PCIe_DPLL2_RANGE_SET(x)                                      (((x) << PCIe_DPLL2_RANGE_LSB) & PCIe_DPLL2_RANGE_MASK)
+#define PCIe_DPLL2_RANGE_RESET                                       0x0 // 0
+#define PCIe_DPLL2_LOCAL_PLL_MSB                                     30
+#define PCIe_DPLL2_LOCAL_PLL_LSB                                     30
+#define PCIe_DPLL2_LOCAL_PLL_MASK                                    0x40000000
+#define PCIe_DPLL2_LOCAL_PLL_GET(x)                                  (((x) & PCIe_DPLL2_LOCAL_PLL_MASK) >> PCIe_DPLL2_LOCAL_PLL_LSB)
+#define PCIe_DPLL2_LOCAL_PLL_SET(x)                                  (((x) << PCIe_DPLL2_LOCAL_PLL_LSB) & PCIe_DPLL2_LOCAL_PLL_MASK)
+#define PCIe_DPLL2_LOCAL_PLL_RESET                                   0x0 // 0
+#define PCIe_DPLL2_KI_MSB                                            29
+#define PCIe_DPLL2_KI_LSB                                            26
+#define PCIe_DPLL2_KI_MASK                                           0x3c000000
+#define PCIe_DPLL2_KI_GET(x)                                         (((x) & PCIe_DPLL2_KI_MASK) >> PCIe_DPLL2_KI_LSB)
+#define PCIe_DPLL2_KI_SET(x)                                         (((x) << PCIe_DPLL2_KI_LSB) & PCIe_DPLL2_KI_MASK)
+#define PCIe_DPLL2_KI_RESET                                          0x6 // 6
+#define PCIe_DPLL2_KD_MSB                                            25
+#define PCIe_DPLL2_KD_LSB                                            19
+#define PCIe_DPLL2_KD_MASK                                           0x03f80000
+#define PCIe_DPLL2_KD_GET(x)                                         (((x) & PCIe_DPLL2_KD_MASK) >> PCIe_DPLL2_KD_LSB)
+#define PCIe_DPLL2_KD_SET(x)                                         (((x) << PCIe_DPLL2_KD_LSB) & PCIe_DPLL2_KD_MASK)
+#define PCIe_DPLL2_KD_RESET                                          0x7f // 127
+#define PCIe_DPLL2_EN_NEGTRIG_MSB                                    18
+#define PCIe_DPLL2_EN_NEGTRIG_LSB                                    18
+#define PCIe_DPLL2_EN_NEGTRIG_MASK                                   0x00040000
+#define PCIe_DPLL2_EN_NEGTRIG_GET(x)                                 (((x) & PCIe_DPLL2_EN_NEGTRIG_MASK) >> PCIe_DPLL2_EN_NEGTRIG_LSB)
+#define PCIe_DPLL2_EN_NEGTRIG_SET(x)                                 (((x) << PCIe_DPLL2_EN_NEGTRIG_LSB) & PCIe_DPLL2_EN_NEGTRIG_MASK)
+#define PCIe_DPLL2_EN_NEGTRIG_RESET                                  0x0 // 0
+#define PCIe_DPLL2_SEL_1SDM_MSB                                      17
+#define PCIe_DPLL2_SEL_1SDM_LSB                                      17
+#define PCIe_DPLL2_SEL_1SDM_MASK                                     0x00020000
+#define PCIe_DPLL2_SEL_1SDM_GET(x)                                   (((x) & PCIe_DPLL2_SEL_1SDM_MASK) >> PCIe_DPLL2_SEL_1SDM_LSB)
+#define PCIe_DPLL2_SEL_1SDM_SET(x)                                   (((x) << PCIe_DPLL2_SEL_1SDM_LSB) & PCIe_DPLL2_SEL_1SDM_MASK)
+#define PCIe_DPLL2_SEL_1SDM_RESET                                    0x0 // 0
+#define PCIe_DPLL2_PLL_PWD_MSB                                       16
+#define PCIe_DPLL2_PLL_PWD_LSB                                       16
+#define PCIe_DPLL2_PLL_PWD_MASK                                      0x00010000
+#define PCIe_DPLL2_PLL_PWD_GET(x)                                    (((x) & PCIe_DPLL2_PLL_PWD_MASK) >> PCIe_DPLL2_PLL_PWD_LSB)
+#define PCIe_DPLL2_PLL_PWD_SET(x)                                    (((x) << PCIe_DPLL2_PLL_PWD_LSB) & PCIe_DPLL2_PLL_PWD_MASK)
+#define PCIe_DPLL2_PLL_PWD_RESET                                     0x1 // 1
+#define PCIe_DPLL2_OUTDIV_MSB                                        15
+#define PCIe_DPLL2_OUTDIV_LSB                                        13
+#define PCIe_DPLL2_OUTDIV_MASK                                       0x0000e000
+#define PCIe_DPLL2_OUTDIV_GET(x)                                     (((x) & PCIe_DPLL2_OUTDIV_MASK) >> PCIe_DPLL2_OUTDIV_LSB)
+#define PCIe_DPLL2_OUTDIV_SET(x)                                     (((x) << PCIe_DPLL2_OUTDIV_LSB) & PCIe_DPLL2_OUTDIV_MASK)
+#define PCIe_DPLL2_OUTDIV_RESET                                      0x0 // 0
+#define PCIe_DPLL2_DELTA_MSB                                         12
+#define PCIe_DPLL2_DELTA_LSB                                         7
+#define PCIe_DPLL2_DELTA_MASK                                        0x00001f80
+#define PCIe_DPLL2_DELTA_GET(x)                                      (((x) & PCIe_DPLL2_DELTA_MASK) >> PCIe_DPLL2_DELTA_LSB)
+#define PCIe_DPLL2_DELTA_SET(x)                                      (((x) << PCIe_DPLL2_DELTA_LSB) & PCIe_DPLL2_DELTA_MASK)
+#define PCIe_DPLL2_DELTA_RESET                                       0x1e // 30
+#define PCIe_DPLL2_TESTINMSB_MSB                                     6
+#define PCIe_DPLL2_TESTINMSB_LSB                                     0
+#define PCIe_DPLL2_TESTINMSB_MASK                                    0x0000007f
+#define PCIe_DPLL2_TESTINMSB_GET(x)                                  (((x) & PCIe_DPLL2_TESTINMSB_MASK) >> PCIe_DPLL2_TESTINMSB_LSB)
+#define PCIe_DPLL2_TESTINMSB_SET(x)                                  (((x) << PCIe_DPLL2_TESTINMSB_LSB) & PCIe_DPLL2_TESTINMSB_MASK)
+#define PCIe_DPLL2_TESTINMSB_RESET                                   0x0 // 0
+#define PCIe_DPLL2_ADDRESS                                           0x18116c84
+
+#define DDR_DPLL2_RANGE_MSB                                          31
+#define DDR_DPLL2_RANGE_LSB                                          31
+#define DDR_DPLL2_RANGE_MASK                                         0x80000000
+#define DDR_DPLL2_RANGE_GET(x)                                       (((x) & DDR_DPLL2_RANGE_MASK) >> DDR_DPLL2_RANGE_LSB)
+#define DDR_DPLL2_RANGE_SET(x)                                       (((x) << DDR_DPLL2_RANGE_LSB) & DDR_DPLL2_RANGE_MASK)
+#define DDR_DPLL2_RANGE_RESET                                        0x0 // 0
+#define DDR_DPLL2_LOCAL_PLL_MSB                                      30
+#define DDR_DPLL2_LOCAL_PLL_LSB                                      30
+#define DDR_DPLL2_LOCAL_PLL_MASK                                     0x40000000
+#define DDR_DPLL2_LOCAL_PLL_GET(x)                                   (((x) & DDR_DPLL2_LOCAL_PLL_MASK) >> DDR_DPLL2_LOCAL_PLL_LSB)
+#define DDR_DPLL2_LOCAL_PLL_SET(x)                                   (((x) << DDR_DPLL2_LOCAL_PLL_LSB) & DDR_DPLL2_LOCAL_PLL_MASK)
+#define DDR_DPLL2_LOCAL_PLL_RESET                                    0x0 // 0
+#define DDR_DPLL2_KI_MSB                                             29
+#define DDR_DPLL2_KI_LSB                                             26
+#define DDR_DPLL2_KI_MASK                                            0x3c000000
+#define DDR_DPLL2_KI_GET(x)                                          (((x) & DDR_DPLL2_KI_MASK) >> DDR_DPLL2_KI_LSB)
+#define DDR_DPLL2_KI_SET(x)                                          (((x) << DDR_DPLL2_KI_LSB) & DDR_DPLL2_KI_MASK)
+#define DDR_DPLL2_KI_RESET                                           0x6 // 6
+#define DDR_DPLL2_KD_MSB                                             25
+#define DDR_DPLL2_KD_LSB                                             19
+#define DDR_DPLL2_KD_MASK                                            0x03f80000
+#define DDR_DPLL2_KD_GET(x)                                          (((x) & DDR_DPLL2_KD_MASK) >> DDR_DPLL2_KD_LSB)
+#define DDR_DPLL2_KD_SET(x)                                          (((x) << DDR_DPLL2_KD_LSB) & DDR_DPLL2_KD_MASK)
+#define DDR_DPLL2_KD_RESET                                           0x7f // 127
+#define DDR_DPLL2_EN_NEGTRIG_MSB                                     18
+#define DDR_DPLL2_EN_NEGTRIG_LSB                                     18
+#define DDR_DPLL2_EN_NEGTRIG_MASK                                    0x00040000
+#define DDR_DPLL2_EN_NEGTRIG_GET(x)                                  (((x) & DDR_DPLL2_EN_NEGTRIG_MASK) >> DDR_DPLL2_EN_NEGTRIG_LSB)
+#define DDR_DPLL2_EN_NEGTRIG_SET(x)                                  (((x) << DDR_DPLL2_EN_NEGTRIG_LSB) & DDR_DPLL2_EN_NEGTRIG_MASK)
+#define DDR_DPLL2_EN_NEGTRIG_RESET                                   0x0 // 0
+#define DDR_DPLL2_SEL_1SDM_MSB                                       17
+#define DDR_DPLL2_SEL_1SDM_LSB                                       17
+#define DDR_DPLL2_SEL_1SDM_MASK                                      0x00020000
+#define DDR_DPLL2_SEL_1SDM_GET(x)                                    (((x) & DDR_DPLL2_SEL_1SDM_MASK) >> DDR_DPLL2_SEL_1SDM_LSB)
+#define DDR_DPLL2_SEL_1SDM_SET(x)                                    (((x) << DDR_DPLL2_SEL_1SDM_LSB) & DDR_DPLL2_SEL_1SDM_MASK)
+#define DDR_DPLL2_SEL_1SDM_RESET                                     0x0 // 0
+#define DDR_DPLL2_PLL_PWD_MSB                                        16
+#define DDR_DPLL2_PLL_PWD_LSB                                        16
+#define DDR_DPLL2_PLL_PWD_MASK                                       0x00010000
+#define DDR_DPLL2_PLL_PWD_GET(x)                                     (((x) & DDR_DPLL2_PLL_PWD_MASK) >> DDR_DPLL2_PLL_PWD_LSB)
+#define DDR_DPLL2_PLL_PWD_SET(x)                                     (((x) << DDR_DPLL2_PLL_PWD_LSB) & DDR_DPLL2_PLL_PWD_MASK)
+#define DDR_DPLL2_PLL_PWD_RESET                                      0x1 // 1
+#define DDR_DPLL2_OUTDIV_MSB                                         15
+#define DDR_DPLL2_OUTDIV_LSB                                         13
+#define DDR_DPLL2_OUTDIV_MASK                                        0x0000e000
+#define DDR_DPLL2_OUTDIV_GET(x)                                      (((x) & DDR_DPLL2_OUTDIV_MASK) >> DDR_DPLL2_OUTDIV_LSB)
+#define DDR_DPLL2_OUTDIV_SET(x)                                      (((x) << DDR_DPLL2_OUTDIV_LSB) & DDR_DPLL2_OUTDIV_MASK)
+#define DDR_DPLL2_OUTDIV_RESET                                       0x0 // 0
+#define DDR_DPLL2_DELTA_MSB                                          12
+#define DDR_DPLL2_DELTA_LSB                                          7
+#define DDR_DPLL2_DELTA_MASK                                         0x00001f80
+#define DDR_DPLL2_DELTA_GET(x)                                       (((x) & DDR_DPLL2_DELTA_MASK) >> DDR_DPLL2_DELTA_LSB)
+#define DDR_DPLL2_DELTA_SET(x)                                       (((x) << DDR_DPLL2_DELTA_LSB) & DDR_DPLL2_DELTA_MASK)
+#define DDR_DPLL2_DELTA_RESET                                        0x1e // 30
+#define DDR_DPLL2_TESTINMSB_MSB                                      6
+#define DDR_DPLL2_TESTINMSB_LSB                                      0
+#define DDR_DPLL2_TESTINMSB_MASK                                     0x0000007f
+#define DDR_DPLL2_TESTINMSB_GET(x)                                   (((x) & DDR_DPLL2_TESTINMSB_MASK) >> DDR_DPLL2_TESTINMSB_LSB)
+#define DDR_DPLL2_TESTINMSB_SET(x)                                   (((x) << DDR_DPLL2_TESTINMSB_LSB) & DDR_DPLL2_TESTINMSB_MASK)
+#define DDR_DPLL2_TESTINMSB_RESET                                    0x0 // 0
+#define DDR_DPLL2_ADDRESS                                            0x18116ec4
+
+#define CPU_DPLL2_RANGE_MSB                                          31
+#define CPU_DPLL2_RANGE_LSB                                          31
+#define CPU_DPLL2_RANGE_MASK                                         0x80000000
+#define CPU_DPLL2_RANGE_GET(x)                                       (((x) & CPU_DPLL2_RANGE_MASK) >> CPU_DPLL2_RANGE_LSB)
+#define CPU_DPLL2_RANGE_SET(x)                                       (((x) << CPU_DPLL2_RANGE_LSB) & CPU_DPLL2_RANGE_MASK)
+#define CPU_DPLL2_RANGE_RESET                                        0x0 // 0
+#define CPU_DPLL2_LOCAL_PLL_MSB                                      30
+#define CPU_DPLL2_LOCAL_PLL_LSB                                      30
+#define CPU_DPLL2_LOCAL_PLL_MASK                                     0x40000000
+#define CPU_DPLL2_LOCAL_PLL_GET(x)                                   (((x) & CPU_DPLL2_LOCAL_PLL_MASK) >> CPU_DPLL2_LOCAL_PLL_LSB)
+#define CPU_DPLL2_LOCAL_PLL_SET(x)                                   (((x) << CPU_DPLL2_LOCAL_PLL_LSB) & CPU_DPLL2_LOCAL_PLL_MASK)
+#define CPU_DPLL2_LOCAL_PLL_RESET                                    0x0 // 0
+#define CPU_DPLL2_KI_MSB                                             29
+#define CPU_DPLL2_KI_LSB                                             26
+#define CPU_DPLL2_KI_MASK                                            0x3c000000
+#define CPU_DPLL2_KI_GET(x)                                          (((x) & CPU_DPLL2_KI_MASK) >> CPU_DPLL2_KI_LSB)
+#define CPU_DPLL2_KI_SET(x)                                          (((x) << CPU_DPLL2_KI_LSB) & CPU_DPLL2_KI_MASK)
+#define CPU_DPLL2_KI_RESET                                           0x6 // 6
+#define CPU_DPLL2_KD_MSB                                             25
+#define CPU_DPLL2_KD_LSB                                             19
+#define CPU_DPLL2_KD_MASK                                            0x03f80000
+#define CPU_DPLL2_KD_GET(x)                                          (((x) & CPU_DPLL2_KD_MASK) >> CPU_DPLL2_KD_LSB)
+#define CPU_DPLL2_KD_SET(x)                                          (((x) << CPU_DPLL2_KD_LSB) & CPU_DPLL2_KD_MASK)
+#define CPU_DPLL2_KD_RESET                                           0x7f // 127
+#define CPU_DPLL2_EN_NEGTRIG_MSB                                     18
+#define CPU_DPLL2_EN_NEGTRIG_LSB                                     18
+#define CPU_DPLL2_EN_NEGTRIG_MASK                                    0x00040000
+#define CPU_DPLL2_EN_NEGTRIG_GET(x)                                  (((x) & CPU_DPLL2_EN_NEGTRIG_MASK) >> CPU_DPLL2_EN_NEGTRIG_LSB)
+#define CPU_DPLL2_EN_NEGTRIG_SET(x)                                  (((x) << CPU_DPLL2_EN_NEGTRIG_LSB) & CPU_DPLL2_EN_NEGTRIG_MASK)
+#define CPU_DPLL2_EN_NEGTRIG_RESET                                   0x0 // 0
+#define CPU_DPLL2_SEL_1SDM_MSB                                       17
+#define CPU_DPLL2_SEL_1SDM_LSB                                       17
+#define CPU_DPLL2_SEL_1SDM_MASK                                      0x00020000
+#define CPU_DPLL2_SEL_1SDM_GET(x)                                    (((x) & CPU_DPLL2_SEL_1SDM_MASK) >> CPU_DPLL2_SEL_1SDM_LSB)
+#define CPU_DPLL2_SEL_1SDM_SET(x)                                    (((x) << CPU_DPLL2_SEL_1SDM_LSB) & CPU_DPLL2_SEL_1SDM_MASK)
+#define CPU_DPLL2_SEL_1SDM_RESET                                     0x0 // 0
+#define CPU_DPLL2_PLL_PWD_MSB                                        16
+#define CPU_DPLL2_PLL_PWD_LSB                                        16
+#define CPU_DPLL2_PLL_PWD_MASK                                       0x00010000
+#define CPU_DPLL2_PLL_PWD_GET(x)                                     (((x) & CPU_DPLL2_PLL_PWD_MASK) >> CPU_DPLL2_PLL_PWD_LSB)
+#define CPU_DPLL2_PLL_PWD_SET(x)                                     (((x) << CPU_DPLL2_PLL_PWD_LSB) & CPU_DPLL2_PLL_PWD_MASK)
+#define CPU_DPLL2_PLL_PWD_RESET                                      0x1 // 1
+#define CPU_DPLL2_OUTDIV_MSB                                         15
+#define CPU_DPLL2_OUTDIV_LSB                                         13
+#define CPU_DPLL2_OUTDIV_MASK                                        0x0000e000
+#define CPU_DPLL2_OUTDIV_GET(x)                                      (((x) & CPU_DPLL2_OUTDIV_MASK) >> CPU_DPLL2_OUTDIV_LSB)
+#define CPU_DPLL2_OUTDIV_SET(x)                                      (((x) << CPU_DPLL2_OUTDIV_LSB) & CPU_DPLL2_OUTDIV_MASK)
+#define CPU_DPLL2_OUTDIV_RESET                                       0x0 // 0
+#define CPU_DPLL2_DELTA_MSB                                          12
+#define CPU_DPLL2_DELTA_LSB                                          7
+#define CPU_DPLL2_DELTA_MASK                                         0x00001f80
+#define CPU_DPLL2_DELTA_GET(x)                                       (((x) & CPU_DPLL2_DELTA_MASK) >> CPU_DPLL2_DELTA_LSB)
+#define CPU_DPLL2_DELTA_SET(x)                                       (((x) << CPU_DPLL2_DELTA_LSB) & CPU_DPLL2_DELTA_MASK)
+#define CPU_DPLL2_DELTA_RESET                                        0x1e // 30
+#define CPU_DPLL2_TESTINMSB_MSB                                      6
+#define CPU_DPLL2_TESTINMSB_LSB                                      0
+#define CPU_DPLL2_TESTINMSB_MASK                                     0x0000007f
+#define CPU_DPLL2_TESTINMSB_GET(x)                                   (((x) & CPU_DPLL2_TESTINMSB_MASK) >> CPU_DPLL2_TESTINMSB_LSB)
+#define CPU_DPLL2_TESTINMSB_SET(x)                                   (((x) << CPU_DPLL2_TESTINMSB_LSB) & CPU_DPLL2_TESTINMSB_MASK)
+#define CPU_DPLL2_TESTINMSB_RESET                                    0x0 // 0
+#define CPU_DPLL2_ADDRESS                                            0x18116f04
+
+#define DDR_RD_DATA_THIS_CYCLE_ADDRESS                               0x18000018
+
+#define TAP_CONTROL_0_ADDRESS                                        0x1800001c
+#define TAP_CONTROL_1_ADDRESS                                        0x18000020
+#define TAP_CONTROL_2_ADDRESS                                        0x18000024
+#define TAP_CONTROL_3_ADDRESS                                        0x18000028
+
+#define DDR_BURST_ADDRESS                                            0x180000c4
+#define DDR_BURST2_ADDRESS                                           0x180000c8
+#define DDR_AHB_MASTER_TIMEOUT_MAX_ADDRESS                           0x180000cc
+
+#define PMU1_ADDRESS                                                 0x18116cc0
+
+#define PMU2_SWREGMSB_MSB                                            31
+#define PMU2_SWREGMSB_LSB                                            22
+#define PMU2_SWREGMSB_MASK                                           0xffc00000
+#define PMU2_SWREGMSB_GET(x)                                         (((x) & PMU2_SWREGMSB_MASK) >> PMU2_SWREGMSB_LSB)
+#define PMU2_SWREGMSB_SET(x)                                         (((x) << PMU2_SWREGMSB_LSB) & PMU2_SWREGMSB_MASK)
+#define PMU2_SWREGMSB_RESET                                          0x0 // 0
+#define PMU2_PGM_MSB                                                 21
+#define PMU2_PGM_LSB                                                 21
+#define PMU2_PGM_MASK                                                0x00200000
+#define PMU2_PGM_GET(x)                                              (((x) & PMU2_PGM_MASK) >> PMU2_PGM_LSB)
+#define PMU2_PGM_SET(x)                                              (((x) << PMU2_PGM_LSB) & PMU2_PGM_MASK)
+#define PMU2_PGM_RESET                                               0x0 // 0
+#define PMU2_LDO_TUNE_MSB                                            20
+#define PMU2_LDO_TUNE_LSB                                            19
+#define PMU2_LDO_TUNE_MASK                                           0x00180000
+#define PMU2_LDO_TUNE_GET(x)                                         (((x) & PMU2_LDO_TUNE_MASK) >> PMU2_LDO_TUNE_LSB)
+#define PMU2_LDO_TUNE_SET(x)                                         (((x) << PMU2_LDO_TUNE_LSB) & PMU2_LDO_TUNE_MASK)
+#define PMU2_LDO_TUNE_RESET                                          0x0 // 0
+#define PMU2_PWDLDO_DDR_MSB                                          18
+#define PMU2_PWDLDO_DDR_LSB                                          18
+#define PMU2_PWDLDO_DDR_MASK                                         0x00040000
+#define PMU2_PWDLDO_DDR_GET(x)                                       (((x) & PMU2_PWDLDO_DDR_MASK) >> PMU2_PWDLDO_DDR_LSB)
+#define PMU2_PWDLDO_DDR_SET(x)                                       (((x) << PMU2_PWDLDO_DDR_LSB) & PMU2_PWDLDO_DDR_MASK)
+#define PMU2_PWDLDO_DDR_RESET                                        0x0 // 0
+#define PMU2_LPOPWD_MSB                                              17
+#define PMU2_LPOPWD_LSB                                              17
+#define PMU2_LPOPWD_MASK                                             0x00020000
+#define PMU2_LPOPWD_GET(x)                                           (((x) & PMU2_LPOPWD_MASK) >> PMU2_LPOPWD_LSB)
+#define PMU2_LPOPWD_SET(x)                                           (((x) << PMU2_LPOPWD_LSB) & PMU2_LPOPWD_MASK)
+#define PMU2_LPOPWD_RESET                                            0x0 // 0
+#define PMU2_SPARE_MSB                                               16
+#define PMU2_SPARE_LSB                                               0
+#define PMU2_SPARE_MASK                                              0x0001ffff
+#define PMU2_SPARE_GET(x)                                            (((x) & PMU2_SPARE_MASK) >> PMU2_SPARE_LSB)
+#define PMU2_SPARE_SET(x)                                            (((x) << PMU2_SPARE_LSB) & PMU2_SPARE_MASK)
+#define PMU2_SPARE_RESET                                             0x0 // 0
+#define PMU2_ADDRESS                                                 0x18116cc4
+
+
+
+
+
+
+#define CPU_DDR_CLOCK_CONTROL_SPARE_MSB                              31
+#define CPU_DDR_CLOCK_CONTROL_SPARE_LSB                              25
+#define CPU_DDR_CLOCK_CONTROL_SPARE_MASK                             0xfe000000
+#define CPU_DDR_CLOCK_CONTROL_SPARE_GET(x)                           (((x) & CPU_DDR_CLOCK_CONTROL_SPARE_MASK) >> CPU_DDR_CLOCK_CONTROL_SPARE_LSB)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_SET(x)                           (((x) << CPU_DDR_CLOCK_CONTROL_SPARE_LSB) & CPU_DDR_CLOCK_CONTROL_SPARE_MASK)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_RESET                            0
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MSB                 24
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB                 24
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK                0x01000000
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB) & CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_RESET               1
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MSB            23
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB            23
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK           0x00800000
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_GET(x)         (((x) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_SET(x)         (((x) << CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_RESET          0
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MSB               22
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB               22
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK              0x00400000
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_GET(x)            (((x) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_SET(x)            (((x) << CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_RESET             0x0
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_MSB            21
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_LSB            21
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_MASK           0x00200000
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_GET(x)         (((x) & CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(x)         (((x) << CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_RESET          0x0
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_MSB            20
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_LSB            20
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_MASK           0x00100000
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_GET(x)         (((x) & CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(x)         (((x) << CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_RESET          0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MSB                       19
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB                       15
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK                      0x000f8000
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MSB                       14
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB                       10
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK                      0x00007c00
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MSB                       9
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB                       5
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK                      0x000003e0
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MSB                     4
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB                     4
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK                    0x00000010
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MSB                     3
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB                     3
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK                    0x00000008
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MSB                     2
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB                     2
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK                    0x00000004
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MSB                       1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB                       1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK                      0x00000002
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK) >> CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB)
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB) & CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK)
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MSB                       0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB                       0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK                      0x00000001
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK) >> CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB) & CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_ADDRESS                                0x18050008
+
+#define PCIE_PLL_CONFIG_UPDATING_MSB                                 31
+#define PCIE_PLL_CONFIG_UPDATING_LSB                                 31
+#define PCIE_PLL_CONFIG_UPDATING_MASK                                0x80000000
+#define PCIE_PLL_CONFIG_UPDATING_GET(x)                              (((x) & PCIE_PLL_CONFIG_UPDATING_MASK) >> PCIE_PLL_CONFIG_UPDATING_LSB)
+#define PCIE_PLL_CONFIG_UPDATING_SET(x)                              (((x) << PCIE_PLL_CONFIG_UPDATING_LSB) & PCIE_PLL_CONFIG_UPDATING_MASK)
+#define PCIE_PLL_CONFIG_UPDATING_RESET                               0x0 // 0
+#define PCIE_PLL_CONFIG_PLLPWD_MSB                                   30
+#define PCIE_PLL_CONFIG_PLLPWD_LSB                                   30
+#define PCIE_PLL_CONFIG_PLLPWD_MASK                                  0x40000000
+#define PCIE_PLL_CONFIG_PLLPWD_GET(x)                                (((x) & PCIE_PLL_CONFIG_PLLPWD_MASK) >> PCIE_PLL_CONFIG_PLLPWD_LSB)
+#define PCIE_PLL_CONFIG_PLLPWD_SET(x)                                (((x) << PCIE_PLL_CONFIG_PLLPWD_LSB) & PCIE_PLL_CONFIG_PLLPWD_MASK)
+#define PCIE_PLL_CONFIG_PLLPWD_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_BYPASS_MSB                                   16
+#define PCIE_PLL_CONFIG_BYPASS_LSB                                   16
+#define PCIE_PLL_CONFIG_BYPASS_MASK                                  0x00010000
+#define PCIE_PLL_CONFIG_BYPASS_GET(x)                                (((x) & PCIE_PLL_CONFIG_BYPASS_MASK) >> PCIE_PLL_CONFIG_BYPASS_LSB)
+#define PCIE_PLL_CONFIG_BYPASS_SET(x)                                (((x) << PCIE_PLL_CONFIG_BYPASS_LSB) & PCIE_PLL_CONFIG_BYPASS_MASK)
+#define PCIE_PLL_CONFIG_BYPASS_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_REFDIV_MSB                                   14
+#define PCIE_PLL_CONFIG_REFDIV_LSB                                   10
+#define PCIE_PLL_CONFIG_REFDIV_MASK                                  0x00007c00
+#define PCIE_PLL_CONFIG_REFDIV_GET(x)                                (((x) & PCIE_PLL_CONFIG_REFDIV_MASK) >> PCIE_PLL_CONFIG_REFDIV_LSB)
+#define PCIE_PLL_CONFIG_REFDIV_SET(x)                                (((x) << PCIE_PLL_CONFIG_REFDIV_LSB) & PCIE_PLL_CONFIG_REFDIV_MASK)
+#define PCIE_PLL_CONFIG_REFDIV_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_ADDRESS                                      0x1805000c
+
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MSB                        31
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB                        31
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK                       0x80000000
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_GET(x)                     (((x) & PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK) >> PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_SET(x)                     (((x) << PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB) & PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_RESET                      0x1 // 1
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MSB                          30
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB                          30
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK                         0x40000000
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_GET(x)                       (((x) & PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK) >> PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(x)                       (((x) << PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB) & PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_RESET                        0x1 // 1
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MSB                      20
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB                      15
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK                     0x001f8000
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_GET(x)                   (((x) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK) >> PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(x)                   (((x) << PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_RESET                    0x13 // 19
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MSB                     14
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB                     1
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK                    0x00007ffe
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_GET(x)                  (((x) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK) >> PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(x)                  (((x) << PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_RESET                   0x3fff // 16383
+#define PCIE_PLL_DITHER_DIV_MAX_ADDRESS                              0x18050010
+
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MSB                      20
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB                      15
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK                     0x001f8000
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_GET(x)                   (((x) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK) >> PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_SET(x)                   (((x) << PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_RESET                    0x13 // 19
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MSB                     14
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB                     1
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK                    0x00007ffe
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_GET(x)                  (((x) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK) >> PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_SET(x)                  (((x) << PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_RESET                   0x399d // 14749
+#define PCIE_PLL_DITHER_DIV_MIN_ADDRESS                              0x18050014
+
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_MSB                          31
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB                          28
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK                         0xf0000000
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_GET(x)                       (((x) & PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK) >> PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_SET(x)                       (((x) << PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB) & PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_RESET                        0x0 // 0
+#define PCIE_PLL_DITHER_STEP_STEP_INT_MSB                            24
+#define PCIE_PLL_DITHER_STEP_STEP_INT_LSB                            15
+#define PCIE_PLL_DITHER_STEP_STEP_INT_MASK                           0x01ff8000
+#define PCIE_PLL_DITHER_STEP_STEP_INT_GET(x)                         (((x) & PCIE_PLL_DITHER_STEP_STEP_INT_MASK) >> PCIE_PLL_DITHER_STEP_STEP_INT_LSB)
+#define PCIE_PLL_DITHER_STEP_STEP_INT_SET(x)                         (((x) << PCIE_PLL_DITHER_STEP_STEP_INT_LSB) & PCIE_PLL_DITHER_STEP_STEP_INT_MASK)
+#define PCIE_PLL_DITHER_STEP_STEP_INT_RESET                          0x0 // 0
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_MSB                           14
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB                           1
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK                          0x00007ffe
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_GET(x)                        (((x) & PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK) >> PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB)
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_SET(x)                        (((x) << PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB) & PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK)
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_RESET                         0xa // 10
+#define PCIE_PLL_DITHER_STEP_ADDRESS                                 0x18050018
+
+#define LDO_POWER_CONTROL_PKG_SEL_MSB                                5
+#define LDO_POWER_CONTROL_PKG_SEL_LSB                                5
+#define LDO_POWER_CONTROL_PKG_SEL_MASK                               0x00000020
+#define LDO_POWER_CONTROL_PKG_SEL_GET(x)                             (((x) & LDO_POWER_CONTROL_PKG_SEL_MASK) >> LDO_POWER_CONTROL_PKG_SEL_LSB)
+#define LDO_POWER_CONTROL_PKG_SEL_SET(x)                             (((x) << LDO_POWER_CONTROL_PKG_SEL_LSB) & LDO_POWER_CONTROL_PKG_SEL_MASK)
+#define LDO_POWER_CONTROL_PKG_SEL_RESET                              0x0 // 0
+#define LDO_POWER_CONTROL_PWDLDO_CPU_MSB                             4
+#define LDO_POWER_CONTROL_PWDLDO_CPU_LSB                             4
+#define LDO_POWER_CONTROL_PWDLDO_CPU_MASK                            0x00000010
+#define LDO_POWER_CONTROL_PWDLDO_CPU_GET(x)                          (((x) & LDO_POWER_CONTROL_PWDLDO_CPU_MASK) >> LDO_POWER_CONTROL_PWDLDO_CPU_LSB)
+#define LDO_POWER_CONTROL_PWDLDO_CPU_SET(x)                          (((x) << LDO_POWER_CONTROL_PWDLDO_CPU_LSB) & LDO_POWER_CONTROL_PWDLDO_CPU_MASK)
+#define LDO_POWER_CONTROL_PWDLDO_CPU_RESET                           0x0 // 0
+#define LDO_POWER_CONTROL_PWDLDO_DDR_MSB                             3
+#define LDO_POWER_CONTROL_PWDLDO_DDR_LSB                             3
+#define LDO_POWER_CONTROL_PWDLDO_DDR_MASK                            0x00000008
+#define LDO_POWER_CONTROL_PWDLDO_DDR_GET(x)                          (((x) & LDO_POWER_CONTROL_PWDLDO_DDR_MASK) >> LDO_POWER_CONTROL_PWDLDO_DDR_LSB)
+#define LDO_POWER_CONTROL_PWDLDO_DDR_SET(x)                          (((x) << LDO_POWER_CONTROL_PWDLDO_DDR_LSB) & LDO_POWER_CONTROL_PWDLDO_DDR_MASK)
+#define LDO_POWER_CONTROL_PWDLDO_DDR_RESET                           0x0 // 0
+#define LDO_POWER_CONTROL_CPU_REFSEL_MSB                             2
+#define LDO_POWER_CONTROL_CPU_REFSEL_LSB                             1
+#define LDO_POWER_CONTROL_CPU_REFSEL_MASK                            0x00000006
+#define LDO_POWER_CONTROL_CPU_REFSEL_GET(x)                          (((x) & LDO_POWER_CONTROL_CPU_REFSEL_MASK) >> LDO_POWER_CONTROL_CPU_REFSEL_LSB)
+#define LDO_POWER_CONTROL_CPU_REFSEL_SET(x)                          (((x) << LDO_POWER_CONTROL_CPU_REFSEL_LSB) & LDO_POWER_CONTROL_CPU_REFSEL_MASK)
+#define LDO_POWER_CONTROL_CPU_REFSEL_RESET                           0x3 // 3
+#define LDO_POWER_CONTROL_SELECT_DDR1_MSB                            0
+#define LDO_POWER_CONTROL_SELECT_DDR1_LSB                            0
+#define LDO_POWER_CONTROL_SELECT_DDR1_MASK                           0x00000001
+#define LDO_POWER_CONTROL_SELECT_DDR1_GET(x)                         (((x) & LDO_POWER_CONTROL_SELECT_DDR1_MASK) >> LDO_POWER_CONTROL_SELECT_DDR1_LSB)
+#define LDO_POWER_CONTROL_SELECT_DDR1_SET(x)                         (((x) << LDO_POWER_CONTROL_SELECT_DDR1_LSB) & LDO_POWER_CONTROL_SELECT_DDR1_MASK)
+#define LDO_POWER_CONTROL_SELECT_DDR1_RESET                          0x0 // 0
+#define LDO_POWER_CONTROL_ADDRESS                                    0x1805001c
+
+#define SWITCH_CLOCK_SPARE_SPARE_MSB                                 31
+#define SWITCH_CLOCK_SPARE_SPARE_LSB                                 16
+#define SWITCH_CLOCK_SPARE_SPARE_MASK                                0xffff0000
+#define SWITCH_CLOCK_SPARE_SPARE_GET(x)                              (((x) & SWITCH_CLOCK_SPARE_SPARE_MASK) >> SWITCH_CLOCK_SPARE_SPARE_LSB)
+#define SWITCH_CLOCK_SPARE_SPARE_SET(x)                              (((x) << SWITCH_CLOCK_SPARE_SPARE_LSB) & SWITCH_CLOCK_SPARE_SPARE_MASK)
+#define SWITCH_CLOCK_SPARE_SPARE_RESET                               0x0 // 0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_MSB                       15
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_LSB                       15
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_MASK                      0x00008000
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_RESET                     0x0 // 0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_MSB                       14
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_LSB                       14
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_MASK                      0x00004000
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_RESET                     0x0 // 0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_MSB                       13
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_LSB                       13
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_MASK                      0x00002000
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_RESET                     0x0 // 0
+#define SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_MSB                         12
+#define SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_LSB                         12
+#define SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_MASK                        0x00001000
+#define SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_GET(x)                      (((x) & SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_SET(x)                      (((x) << SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_RESET                       0x0 // 0
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MSB                   11
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB                   8
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK                  0x00000f00
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_GET(x)                (((x) & SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK) >> SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(x)                (((x) << SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB) & SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_RESET                 0x5 // 5
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MSB                         7
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB                         7
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK                        0x00000080
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_GET(x)                      (((x) & SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_SET(x)                      (((x) << SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_RESET                       0x0 // 0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_MSB                       6
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_LSB                       6
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_MASK                      0x00000040
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_RESET                     0x0 // 0
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_MSB                           5
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_LSB                           5
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_MASK                          0x00000020
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_GET(x)                        (((x) & SWITCH_CLOCK_SPARE_I2C_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_I2C_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_SET(x)                        (((x) << SWITCH_CLOCK_SPARE_I2C_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_I2C_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_RESET                         0x0 // 0
+#define SWITCH_CLOCK_SPARE_SPARE_0_MSB                               4
+#define SWITCH_CLOCK_SPARE_SPARE_0_LSB                               0
+#define SWITCH_CLOCK_SPARE_SPARE_0_MASK                              0x0000001f
+#define SWITCH_CLOCK_SPARE_SPARE_0_GET(x)                            (((x) & SWITCH_CLOCK_SPARE_SPARE_0_MASK) >> SWITCH_CLOCK_SPARE_SPARE_0_LSB)
+#define SWITCH_CLOCK_SPARE_SPARE_0_SET(x)                            (((x) << SWITCH_CLOCK_SPARE_SPARE_0_LSB) & SWITCH_CLOCK_SPARE_SPARE_0_MASK)
+#define SWITCH_CLOCK_SPARE_SPARE_0_RESET                             0x0 // 0
+#define SWITCH_CLOCK_SPARE_ADDRESS                                   0x18050020
+
+#define CURRENT_PCIE_PLL_DITHER_INT_MSB                              20
+#define CURRENT_PCIE_PLL_DITHER_INT_LSB                              15
+#define CURRENT_PCIE_PLL_DITHER_INT_MASK                             0x001f8000
+#define CURRENT_PCIE_PLL_DITHER_INT_GET(x)                           (((x) & CURRENT_PCIE_PLL_DITHER_INT_MASK) >> CURRENT_PCIE_PLL_DITHER_INT_LSB)
+#define CURRENT_PCIE_PLL_DITHER_INT_SET(x)                           (((x) << CURRENT_PCIE_PLL_DITHER_INT_LSB) & CURRENT_PCIE_PLL_DITHER_INT_MASK)
+#define CURRENT_PCIE_PLL_DITHER_INT_RESET                            0x1 // 1
+#define CURRENT_PCIE_PLL_DITHER_FRAC_MSB                             13
+#define CURRENT_PCIE_PLL_DITHER_FRAC_LSB                             0
+#define CURRENT_PCIE_PLL_DITHER_FRAC_MASK                            0x00003fff
+#define CURRENT_PCIE_PLL_DITHER_FRAC_GET(x)                          (((x) & CURRENT_PCIE_PLL_DITHER_FRAC_MASK) >> CURRENT_PCIE_PLL_DITHER_FRAC_LSB)
+#define CURRENT_PCIE_PLL_DITHER_FRAC_SET(x)                          (((x) << CURRENT_PCIE_PLL_DITHER_FRAC_LSB) & CURRENT_PCIE_PLL_DITHER_FRAC_MASK)
+#define CURRENT_PCIE_PLL_DITHER_FRAC_RESET                           0x0 // 0
+#define CURRENT_PCIE_PLL_DITHER_ADDRESS                              0x18050024
+
+#define ETH_XMII_TX_INVERT_MSB                                       31
+#define ETH_XMII_TX_INVERT_LSB                                       31
+#define ETH_XMII_TX_INVERT_MASK                                      0x80000000
+#define ETH_XMII_TX_INVERT_GET(x)                                    (((x) & ETH_XMII_TX_INVERT_MASK) >> ETH_XMII_TX_INVERT_LSB)
+#define ETH_XMII_TX_INVERT_SET(x)                                    (((x) << ETH_XMII_TX_INVERT_LSB) & ETH_XMII_TX_INVERT_MASK)
+#define ETH_XMII_TX_INVERT_RESET                                     0x0 // 0
+#define ETH_XMII_GIGE_QUAD_MSB                                       30
+#define ETH_XMII_GIGE_QUAD_LSB                                       30
+#define ETH_XMII_GIGE_QUAD_MASK                                      0x40000000
+#define ETH_XMII_GIGE_QUAD_GET(x)                                    (((x) & ETH_XMII_GIGE_QUAD_MASK) >> ETH_XMII_GIGE_QUAD_LSB)
+#define ETH_XMII_GIGE_QUAD_SET(x)                                    (((x) << ETH_XMII_GIGE_QUAD_LSB) & ETH_XMII_GIGE_QUAD_MASK)
+#define ETH_XMII_GIGE_QUAD_RESET                                     0x0 // 0
+#define ETH_XMII_RX_DELAY_MSB                                        29
+#define ETH_XMII_RX_DELAY_LSB                                        28
+#define ETH_XMII_RX_DELAY_MASK                                       0x30000000
+#define ETH_XMII_RX_DELAY_GET(x)                                     (((x) & ETH_XMII_RX_DELAY_MASK) >> ETH_XMII_RX_DELAY_LSB)
+#define ETH_XMII_RX_DELAY_SET(x)                                     (((x) << ETH_XMII_RX_DELAY_LSB) & ETH_XMII_RX_DELAY_MASK)
+#define ETH_XMII_RX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_TX_DELAY_MSB                                        27
+#define ETH_XMII_TX_DELAY_LSB                                        26
+#define ETH_XMII_TX_DELAY_MASK                                       0x0c000000
+#define ETH_XMII_TX_DELAY_GET(x)                                     (((x) & ETH_XMII_TX_DELAY_MASK) >> ETH_XMII_TX_DELAY_LSB)
+#define ETH_XMII_TX_DELAY_SET(x)                                     (((x) << ETH_XMII_TX_DELAY_LSB) & ETH_XMII_TX_DELAY_MASK)
+#define ETH_XMII_TX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_GIGE_MSB                                            25
+#define ETH_XMII_GIGE_LSB                                            25
+#define ETH_XMII_GIGE_MASK                                           0x02000000
+#define ETH_XMII_GIGE_GET(x)                                         (((x) & ETH_XMII_GIGE_MASK) >> ETH_XMII_GIGE_LSB)
+#define ETH_XMII_GIGE_SET(x)                                         (((x) << ETH_XMII_GIGE_LSB) & ETH_XMII_GIGE_MASK)
+#define ETH_XMII_GIGE_RESET                                          0x0 // 0
+#define ETH_XMII_OFFSET_PHASE_MSB                                    24
+#define ETH_XMII_OFFSET_PHASE_LSB                                    24
+#define ETH_XMII_OFFSET_PHASE_MASK                                   0x01000000
+#define ETH_XMII_OFFSET_PHASE_GET(x)                                 (((x) & ETH_XMII_OFFSET_PHASE_MASK) >> ETH_XMII_OFFSET_PHASE_LSB)
+#define ETH_XMII_OFFSET_PHASE_SET(x)                                 (((x) << ETH_XMII_OFFSET_PHASE_LSB) & ETH_XMII_OFFSET_PHASE_MASK)
+#define ETH_XMII_OFFSET_PHASE_RESET                                  0x0 // 0
+#define ETH_XMII_OFFSET_COUNT_MSB                                    23
+#define ETH_XMII_OFFSET_COUNT_LSB                                    16
+#define ETH_XMII_OFFSET_COUNT_MASK                                   0x00ff0000
+#define ETH_XMII_OFFSET_COUNT_GET(x)                                 (((x) & ETH_XMII_OFFSET_COUNT_MASK) >> ETH_XMII_OFFSET_COUNT_LSB)
+#define ETH_XMII_OFFSET_COUNT_SET(x)                                 (((x) << ETH_XMII_OFFSET_COUNT_LSB) & ETH_XMII_OFFSET_COUNT_MASK)
+#define ETH_XMII_OFFSET_COUNT_RESET                                  0x0 // 0
+#define ETH_XMII_PHASE1_COUNT_MSB                                    15
+#define ETH_XMII_PHASE1_COUNT_LSB                                    8
+#define ETH_XMII_PHASE1_COUNT_MASK                                   0x0000ff00
+#define ETH_XMII_PHASE1_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE1_COUNT_MASK) >> ETH_XMII_PHASE1_COUNT_LSB)
+#define ETH_XMII_PHASE1_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE1_COUNT_LSB) & ETH_XMII_PHASE1_COUNT_MASK)
+#define ETH_XMII_PHASE1_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_PHASE0_COUNT_MSB                                    7
+#define ETH_XMII_PHASE0_COUNT_LSB                                    0
+#define ETH_XMII_PHASE0_COUNT_MASK                                   0x000000ff
+#define ETH_XMII_PHASE0_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE0_COUNT_MASK) >> ETH_XMII_PHASE0_COUNT_LSB)
+#define ETH_XMII_PHASE0_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE0_COUNT_LSB) & ETH_XMII_PHASE0_COUNT_MASK)
+#define ETH_XMII_PHASE0_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_ADDRESS                                             0x18050028
+
+#define AUDIO_PLL_CONFIG_UPDATING_MSB                                31
+#define AUDIO_PLL_CONFIG_UPDATING_LSB                                31
+#define AUDIO_PLL_CONFIG_UPDATING_MASK                               0x80000000
+#define AUDIO_PLL_CONFIG_UPDATING_GET(x)                             (((x) & AUDIO_PLL_CONFIG_UPDATING_MASK) >> AUDIO_PLL_CONFIG_UPDATING_LSB)
+#define AUDIO_PLL_CONFIG_UPDATING_SET(x)                             (((x) << AUDIO_PLL_CONFIG_UPDATING_LSB) & AUDIO_PLL_CONFIG_UPDATING_MASK)
+#define AUDIO_PLL_CONFIG_UPDATING_RESET                              0x1 // 1
+#define AUDIO_PLL_CONFIG_EXT_DIV_MSB                                 14
+#define AUDIO_PLL_CONFIG_EXT_DIV_LSB                                 12
+#define AUDIO_PLL_CONFIG_EXT_DIV_MASK                                0x00007000
+#define AUDIO_PLL_CONFIG_EXT_DIV_GET(x)                              (((x) & AUDIO_PLL_CONFIG_EXT_DIV_MASK) >> AUDIO_PLL_CONFIG_EXT_DIV_LSB)
+#define AUDIO_PLL_CONFIG_EXT_DIV_SET(x)                              (((x) << AUDIO_PLL_CONFIG_EXT_DIV_LSB) & AUDIO_PLL_CONFIG_EXT_DIV_MASK)
+#define AUDIO_PLL_CONFIG_EXT_DIV_RESET                               0x1 // 1
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_MSB                              9
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_LSB                              7
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_MASK                             0x00000380
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_GET(x)                           (((x) & AUDIO_PLL_CONFIG_POSTPLLDIV_MASK) >> AUDIO_PLL_CONFIG_POSTPLLDIV_LSB)
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_SET(x)                           (((x) << AUDIO_PLL_CONFIG_POSTPLLDIV_LSB) & AUDIO_PLL_CONFIG_POSTPLLDIV_MASK)
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_RESET                            0x1 // 1
+#define AUDIO_PLL_CONFIG_PLLPWD_MSB                                  5
+#define AUDIO_PLL_CONFIG_PLLPWD_LSB                                  5
+#define AUDIO_PLL_CONFIG_PLLPWD_MASK                                 0x00000020
+#define AUDIO_PLL_CONFIG_PLLPWD_GET(x)                               (((x) & AUDIO_PLL_CONFIG_PLLPWD_MASK) >> AUDIO_PLL_CONFIG_PLLPWD_LSB)
+#define AUDIO_PLL_CONFIG_PLLPWD_SET(x)                               (((x) << AUDIO_PLL_CONFIG_PLLPWD_LSB) & AUDIO_PLL_CONFIG_PLLPWD_MASK)
+#define AUDIO_PLL_CONFIG_PLLPWD_RESET                                0x1 // 1
+#define AUDIO_PLL_CONFIG_BYPASS_MSB                                  4
+#define AUDIO_PLL_CONFIG_BYPASS_LSB                                  4
+#define AUDIO_PLL_CONFIG_BYPASS_MASK                                 0x00000010
+#define AUDIO_PLL_CONFIG_BYPASS_GET(x)                               (((x) & AUDIO_PLL_CONFIG_BYPASS_MASK) >> AUDIO_PLL_CONFIG_BYPASS_LSB)
+#define AUDIO_PLL_CONFIG_BYPASS_SET(x)                               (((x) << AUDIO_PLL_CONFIG_BYPASS_LSB) & AUDIO_PLL_CONFIG_BYPASS_MASK)
+#define AUDIO_PLL_CONFIG_BYPASS_RESET                                0x1 // 1
+#define AUDIO_PLL_CONFIG_REFDIV_MSB                                  3
+#define AUDIO_PLL_CONFIG_REFDIV_LSB                                  0
+#define AUDIO_PLL_CONFIG_REFDIV_MASK                                 0x0000000f
+#define AUDIO_PLL_CONFIG_REFDIV_GET(x)                               (((x) & AUDIO_PLL_CONFIG_REFDIV_MASK) >> AUDIO_PLL_CONFIG_REFDIV_LSB)
+#define AUDIO_PLL_CONFIG_REFDIV_SET(x)                               (((x) << AUDIO_PLL_CONFIG_REFDIV_LSB) & AUDIO_PLL_CONFIG_REFDIV_MASK)
+#define AUDIO_PLL_CONFIG_REFDIV_RESET                                0x3 // 3
+#define AUDIO_PLL_CONFIG_ADDRESS                                     0x1805002c
+
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MSB                        28
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_LSB                        11
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MASK                       0x1ffff800
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_GET(x)                     (((x) & AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MASK) >> AUDIO_PLL_MODULATION_TGT_DIV_FRAC_LSB)
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_SET(x)                     (((x) << AUDIO_PLL_MODULATION_TGT_DIV_FRAC_LSB) & AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MASK)
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_RESET                      0x148fe // 84222
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_MSB                         6
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_LSB                         1
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_MASK                        0x0000007e
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_GET(x)                      (((x) & AUDIO_PLL_MODULATION_TGT_DIV_INT_MASK) >> AUDIO_PLL_MODULATION_TGT_DIV_INT_LSB)
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_SET(x)                      (((x) << AUDIO_PLL_MODULATION_TGT_DIV_INT_LSB) & AUDIO_PLL_MODULATION_TGT_DIV_INT_MASK)
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_RESET                       0x14 // 20
+#define AUDIO_PLL_MODULATION_START_MSB                               0
+#define AUDIO_PLL_MODULATION_START_LSB                               0
+#define AUDIO_PLL_MODULATION_START_MASK                              0x00000001
+#define AUDIO_PLL_MODULATION_START_GET(x)                            (((x) & AUDIO_PLL_MODULATION_START_MASK) >> AUDIO_PLL_MODULATION_START_LSB)
+#define AUDIO_PLL_MODULATION_START_SET(x)                            (((x) << AUDIO_PLL_MODULATION_START_LSB) & AUDIO_PLL_MODULATION_START_MASK)
+#define AUDIO_PLL_MODULATION_START_RESET                             0x0 // 0
+#define AUDIO_PLL_MODULATION_ADDRESS                                 0x18050030
+
+#define AUDIO_PLL_MOD_STEP_FRAC_MSB                                  31
+#define AUDIO_PLL_MOD_STEP_FRAC_LSB                                  14
+#define AUDIO_PLL_MOD_STEP_FRAC_MASK                                 0xffffc000
+#define AUDIO_PLL_MOD_STEP_FRAC_GET(x)                               (((x) & AUDIO_PLL_MOD_STEP_FRAC_MASK) >> AUDIO_PLL_MOD_STEP_FRAC_LSB)
+#define AUDIO_PLL_MOD_STEP_FRAC_SET(x)                               (((x) << AUDIO_PLL_MOD_STEP_FRAC_LSB) & AUDIO_PLL_MOD_STEP_FRAC_MASK)
+#define AUDIO_PLL_MOD_STEP_FRAC_RESET                                0x1 // 1
+#define AUDIO_PLL_MOD_STEP_INT_MSB                                   13
+#define AUDIO_PLL_MOD_STEP_INT_LSB                                   4
+#define AUDIO_PLL_MOD_STEP_INT_MASK                                  0x00003ff0
+#define AUDIO_PLL_MOD_STEP_INT_GET(x)                                (((x) & AUDIO_PLL_MOD_STEP_INT_MASK) >> AUDIO_PLL_MOD_STEP_INT_LSB)
+#define AUDIO_PLL_MOD_STEP_INT_SET(x)                                (((x) << AUDIO_PLL_MOD_STEP_INT_LSB) & AUDIO_PLL_MOD_STEP_INT_MASK)
+#define AUDIO_PLL_MOD_STEP_INT_RESET                                 0x0 // 0
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_MSB                            3
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_LSB                            0
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_MASK                           0x0000000f
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_GET(x)                         (((x) & AUDIO_PLL_MOD_STEP_UPDATE_CNT_MASK) >> AUDIO_PLL_MOD_STEP_UPDATE_CNT_LSB)
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_SET(x)                         (((x) << AUDIO_PLL_MOD_STEP_UPDATE_CNT_LSB) & AUDIO_PLL_MOD_STEP_UPDATE_CNT_MASK)
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_RESET                          0x0 // 0
+#define AUDIO_PLL_MOD_STEP_ADDRESS                                   0x18050034
+
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_MSB                        27
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_LSB                        10
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_MASK                       0x0ffffc00
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_GET(x)                     (((x) & CURRENT_AUDIO_PLL_MODULATION_FRAC_MASK) >> CURRENT_AUDIO_PLL_MODULATION_FRAC_LSB)
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_SET(x)                     (((x) << CURRENT_AUDIO_PLL_MODULATION_FRAC_LSB) & CURRENT_AUDIO_PLL_MODULATION_FRAC_MASK)
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_RESET                      0x1 // 1
+#define CURRENT_AUDIO_PLL_MODULATION_INT_MSB                         6
+#define CURRENT_AUDIO_PLL_MODULATION_INT_LSB                         1
+#define CURRENT_AUDIO_PLL_MODULATION_INT_MASK                        0x0000007e
+#define CURRENT_AUDIO_PLL_MODULATION_INT_GET(x)                      (((x) & CURRENT_AUDIO_PLL_MODULATION_INT_MASK) >> CURRENT_AUDIO_PLL_MODULATION_INT_LSB)
+#define CURRENT_AUDIO_PLL_MODULATION_INT_SET(x)                      (((x) << CURRENT_AUDIO_PLL_MODULATION_INT_LSB) & CURRENT_AUDIO_PLL_MODULATION_INT_MASK)
+#define CURRENT_AUDIO_PLL_MODULATION_INT_RESET                       0x0 // 0
+#define CURRENT_AUDIO_PLL_MODULATION_ADDRESS                         0x18050038
+
+#define BB_PLL_CONFIG_UPDATING_MSB                                   31
+#define BB_PLL_CONFIG_UPDATING_LSB                                   31
+#define BB_PLL_CONFIG_UPDATING_MASK                                  0x80000000
+#define BB_PLL_CONFIG_UPDATING_GET(x)                                (((x) & BB_PLL_CONFIG_UPDATING_MASK) >> BB_PLL_CONFIG_UPDATING_LSB)
+#define BB_PLL_CONFIG_UPDATING_SET(x)                                (((x) << BB_PLL_CONFIG_UPDATING_LSB) & BB_PLL_CONFIG_UPDATING_MASK)
+#define BB_PLL_CONFIG_UPDATING_RESET                                 0x1 // 1
+#define BB_PLL_CONFIG_PLLPWD_MSB                                     30
+#define BB_PLL_CONFIG_PLLPWD_LSB                                     30
+#define BB_PLL_CONFIG_PLLPWD_MASK                                    0x40000000
+#define BB_PLL_CONFIG_PLLPWD_GET(x)                                  (((x) & BB_PLL_CONFIG_PLLPWD_MASK) >> BB_PLL_CONFIG_PLLPWD_LSB)
+#define BB_PLL_CONFIG_PLLPWD_SET(x)                                  (((x) << BB_PLL_CONFIG_PLLPWD_LSB) & BB_PLL_CONFIG_PLLPWD_MASK)
+#define BB_PLL_CONFIG_PLLPWD_RESET                                   0x1 // 1
+#define BB_PLL_CONFIG_SPARE_MSB                                      29
+#define BB_PLL_CONFIG_SPARE_LSB                                      29
+#define BB_PLL_CONFIG_SPARE_MASK                                     0x20000000
+#define BB_PLL_CONFIG_SPARE_GET(x)                                   (((x) & BB_PLL_CONFIG_SPARE_MASK) >> BB_PLL_CONFIG_SPARE_LSB)
+#define BB_PLL_CONFIG_SPARE_SET(x)                                   (((x) << BB_PLL_CONFIG_SPARE_LSB) & BB_PLL_CONFIG_SPARE_MASK)
+#define BB_PLL_CONFIG_SPARE_RESET                                    0x0 // 0
+#define BB_PLL_CONFIG_REFDIV_MSB                                     28
+#define BB_PLL_CONFIG_REFDIV_LSB                                     24
+#define BB_PLL_CONFIG_REFDIV_MASK                                    0x1f000000
+#define BB_PLL_CONFIG_REFDIV_GET(x)                                  (((x) & BB_PLL_CONFIG_REFDIV_MASK) >> BB_PLL_CONFIG_REFDIV_LSB)
+#define BB_PLL_CONFIG_REFDIV_SET(x)                                  (((x) << BB_PLL_CONFIG_REFDIV_LSB) & BB_PLL_CONFIG_REFDIV_MASK)
+#define BB_PLL_CONFIG_REFDIV_RESET                                   0x1 // 1
+#define BB_PLL_CONFIG_NINT_MSB                                       21
+#define BB_PLL_CONFIG_NINT_LSB                                       16
+#define BB_PLL_CONFIG_NINT_MASK                                      0x003f0000
+#define BB_PLL_CONFIG_NINT_GET(x)                                    (((x) & BB_PLL_CONFIG_NINT_MASK) >> BB_PLL_CONFIG_NINT_LSB)
+#define BB_PLL_CONFIG_NINT_SET(x)                                    (((x) << BB_PLL_CONFIG_NINT_LSB) & BB_PLL_CONFIG_NINT_MASK)
+#define BB_PLL_CONFIG_NINT_RESET                                     0x2 // 2
+#define BB_PLL_CONFIG_NFRAC_MSB                                      13
+#define BB_PLL_CONFIG_NFRAC_LSB                                      0
+#define BB_PLL_CONFIG_NFRAC_MASK                                     0x00003fff
+#define BB_PLL_CONFIG_NFRAC_GET(x)                                   (((x) & BB_PLL_CONFIG_NFRAC_MASK) >> BB_PLL_CONFIG_NFRAC_LSB)
+#define BB_PLL_CONFIG_NFRAC_SET(x)                                   (((x) << BB_PLL_CONFIG_NFRAC_LSB) & BB_PLL_CONFIG_NFRAC_MASK)
+#define BB_PLL_CONFIG_NFRAC_RESET                                    0xccc // 3276
+#define BB_PLL_CONFIG_ADDRESS                                        0x1805003c
+
+#define DDR_PLL_DITHER_DITHER_EN_MSB                                 31
+#define DDR_PLL_DITHER_DITHER_EN_LSB                                 31
+#define DDR_PLL_DITHER_DITHER_EN_MASK                                0x80000000
+#define DDR_PLL_DITHER_DITHER_EN_GET(x)                              (((x) & DDR_PLL_DITHER_DITHER_EN_MASK) >> DDR_PLL_DITHER_DITHER_EN_LSB)
+#define DDR_PLL_DITHER_DITHER_EN_SET(x)                              (((x) << DDR_PLL_DITHER_DITHER_EN_LSB) & DDR_PLL_DITHER_DITHER_EN_MASK)
+#define DDR_PLL_DITHER_DITHER_EN_RESET                               0x0 // 0
+#define DDR_PLL_DITHER_UPDATE_COUNT_MSB                              30
+#define DDR_PLL_DITHER_UPDATE_COUNT_LSB                              27
+#define DDR_PLL_DITHER_UPDATE_COUNT_MASK                             0x78000000
+#define DDR_PLL_DITHER_UPDATE_COUNT_GET(x)                           (((x) & DDR_PLL_DITHER_UPDATE_COUNT_MASK) >> DDR_PLL_DITHER_UPDATE_COUNT_LSB)
+#define DDR_PLL_DITHER_UPDATE_COUNT_SET(x)                           (((x) << DDR_PLL_DITHER_UPDATE_COUNT_LSB) & DDR_PLL_DITHER_UPDATE_COUNT_MASK)
+#define DDR_PLL_DITHER_UPDATE_COUNT_RESET                            0xf // 15
+#define DDR_PLL_DITHER_NFRAC_STEP_MSB                                26
+#define DDR_PLL_DITHER_NFRAC_STEP_LSB                                20
+#define DDR_PLL_DITHER_NFRAC_STEP_MASK                               0x07f00000
+#define DDR_PLL_DITHER_NFRAC_STEP_GET(x)                             (((x) & DDR_PLL_DITHER_NFRAC_STEP_MASK) >> DDR_PLL_DITHER_NFRAC_STEP_LSB)
+#define DDR_PLL_DITHER_NFRAC_STEP_SET(x)                             (((x) << DDR_PLL_DITHER_NFRAC_STEP_LSB) & DDR_PLL_DITHER_NFRAC_STEP_MASK)
+#define DDR_PLL_DITHER_NFRAC_STEP_RESET                              0x1 // 1
+#define DDR_PLL_DITHER_NFRAC_MIN_MSB                                 19
+#define DDR_PLL_DITHER_NFRAC_MIN_LSB                                 10
+#define DDR_PLL_DITHER_NFRAC_MIN_MASK                                0x000ffc00
+#define DDR_PLL_DITHER_NFRAC_MIN_GET(x)                              (((x) & DDR_PLL_DITHER_NFRAC_MIN_MASK) >> DDR_PLL_DITHER_NFRAC_MIN_LSB)
+#define DDR_PLL_DITHER_NFRAC_MIN_SET(x)                              (((x) << DDR_PLL_DITHER_NFRAC_MIN_LSB) & DDR_PLL_DITHER_NFRAC_MIN_MASK)
+#define DDR_PLL_DITHER_NFRAC_MIN_RESET                               0x19 // 25
+#define DDR_PLL_DITHER_NFRAC_MAX_MSB                                 9
+#define DDR_PLL_DITHER_NFRAC_MAX_LSB                                 0
+#define DDR_PLL_DITHER_NFRAC_MAX_MASK                                0x000003ff
+#define DDR_PLL_DITHER_NFRAC_MAX_GET(x)                              (((x) & DDR_PLL_DITHER_NFRAC_MAX_MASK) >> DDR_PLL_DITHER_NFRAC_MAX_LSB)
+#define DDR_PLL_DITHER_NFRAC_MAX_SET(x)                              (((x) << DDR_PLL_DITHER_NFRAC_MAX_LSB) & DDR_PLL_DITHER_NFRAC_MAX_MASK)
+#define DDR_PLL_DITHER_NFRAC_MAX_RESET                               0x3e8 // 1000
+#define DDR_PLL_DITHER_ADDRESS                                       0x18050040
+
+#define CPU_PLL_DITHER_DITHER_EN_MSB                                 31
+#define CPU_PLL_DITHER_DITHER_EN_LSB                                 31
+#define CPU_PLL_DITHER_DITHER_EN_MASK                                0x80000000
+#define CPU_PLL_DITHER_DITHER_EN_GET(x)                              (((x) & CPU_PLL_DITHER_DITHER_EN_MASK) >> CPU_PLL_DITHER_DITHER_EN_LSB)
+#define CPU_PLL_DITHER_DITHER_EN_SET(x)                              (((x) << CPU_PLL_DITHER_DITHER_EN_LSB) & CPU_PLL_DITHER_DITHER_EN_MASK)
+#define CPU_PLL_DITHER_DITHER_EN_RESET                               0x0 // 0
+#define CPU_PLL_DITHER_UPDATE_COUNT_MSB                              23
+#define CPU_PLL_DITHER_UPDATE_COUNT_LSB                              18
+#define CPU_PLL_DITHER_UPDATE_COUNT_MASK                             0x00fc0000
+#define CPU_PLL_DITHER_UPDATE_COUNT_GET(x)                           (((x) & CPU_PLL_DITHER_UPDATE_COUNT_MASK) >> CPU_PLL_DITHER_UPDATE_COUNT_LSB)
+#define CPU_PLL_DITHER_UPDATE_COUNT_SET(x)                           (((x) << CPU_PLL_DITHER_UPDATE_COUNT_LSB) & CPU_PLL_DITHER_UPDATE_COUNT_MASK)
+#define CPU_PLL_DITHER_UPDATE_COUNT_RESET                            0x14 // 20
+#define CPU_PLL_DITHER_NFRAC_STEP_MSB                                17
+#define CPU_PLL_DITHER_NFRAC_STEP_LSB                                12
+#define CPU_PLL_DITHER_NFRAC_STEP_MASK                               0x0003f000
+#define CPU_PLL_DITHER_NFRAC_STEP_GET(x)                             (((x) & CPU_PLL_DITHER_NFRAC_STEP_MASK) >> CPU_PLL_DITHER_NFRAC_STEP_LSB)
+#define CPU_PLL_DITHER_NFRAC_STEP_SET(x)                             (((x) << CPU_PLL_DITHER_NFRAC_STEP_LSB) & CPU_PLL_DITHER_NFRAC_STEP_MASK)
+#define CPU_PLL_DITHER_NFRAC_STEP_RESET                              0x1 // 1
+#define CPU_PLL_DITHER_NFRAC_MIN_MSB                                 11
+#define CPU_PLL_DITHER_NFRAC_MIN_LSB                                 6
+#define CPU_PLL_DITHER_NFRAC_MIN_MASK                                0x00000fc0
+#define CPU_PLL_DITHER_NFRAC_MIN_GET(x)                              (((x) & CPU_PLL_DITHER_NFRAC_MIN_MASK) >> CPU_PLL_DITHER_NFRAC_MIN_LSB)
+#define CPU_PLL_DITHER_NFRAC_MIN_SET(x)                              (((x) << CPU_PLL_DITHER_NFRAC_MIN_LSB) & CPU_PLL_DITHER_NFRAC_MIN_MASK)
+#define CPU_PLL_DITHER_NFRAC_MIN_RESET                               0x3 // 3
+#define CPU_PLL_DITHER_NFRAC_MAX_MSB                                 5
+#define CPU_PLL_DITHER_NFRAC_MAX_LSB                                 0
+#define CPU_PLL_DITHER_NFRAC_MAX_MASK                                0x0000003f
+#define CPU_PLL_DITHER_NFRAC_MAX_GET(x)                              (((x) & CPU_PLL_DITHER_NFRAC_MAX_MASK) >> CPU_PLL_DITHER_NFRAC_MAX_LSB)
+#define CPU_PLL_DITHER_NFRAC_MAX_SET(x)                              (((x) << CPU_PLL_DITHER_NFRAC_MAX_LSB) & CPU_PLL_DITHER_NFRAC_MAX_MASK)
+#define CPU_PLL_DITHER_NFRAC_MAX_RESET                               0x3c // 60
+#define CPU_PLL_DITHER_ADDRESS                                       0x18050044
+
+#define RST_RESET_HOST_RESET_MSB                                     31
+#define RST_RESET_HOST_RESET_LSB                                     31
+#define RST_RESET_HOST_RESET_MASK                                    0x80000000
+#define RST_RESET_HOST_RESET_GET(x)                                  (((x) & RST_RESET_HOST_RESET_MASK) >> RST_RESET_HOST_RESET_LSB)
+#define RST_RESET_HOST_RESET_SET(x)                                  (((x) << RST_RESET_HOST_RESET_LSB) & RST_RESET_HOST_RESET_MASK)
+#define RST_RESET_HOST_RESET_RESET                                   0x0 // 0
+#define RST_RESET_SLIC_RESET_MSB                                     30
+#define RST_RESET_SLIC_RESET_LSB                                     30
+#define RST_RESET_SLIC_RESET_MASK                                    0x40000000
+#define RST_RESET_SLIC_RESET_GET(x)                                  (((x) & RST_RESET_SLIC_RESET_MASK) >> RST_RESET_SLIC_RESET_LSB)
+#define RST_RESET_SLIC_RESET_SET(x)                                  (((x) << RST_RESET_SLIC_RESET_LSB) & RST_RESET_SLIC_RESET_MASK)
+#define RST_RESET_SLIC_RESET_RESET                                   0x0 // 0
+#define RST_RESET_HDMA_RESET_MSB                                     29
+#define RST_RESET_HDMA_RESET_LSB                                     29
+#define RST_RESET_HDMA_RESET_MASK                                    0x20000000
+#define RST_RESET_HDMA_RESET_GET(x)                                  (((x) & RST_RESET_HDMA_RESET_MASK) >> RST_RESET_HDMA_RESET_LSB)
+#define RST_RESET_HDMA_RESET_SET(x)                                  (((x) << RST_RESET_HDMA_RESET_LSB) & RST_RESET_HDMA_RESET_MASK)
+#define RST_RESET_HDMA_RESET_RESET                                   0x1 // 1
+#define RST_RESET_EXTERNAL_RESET_MSB                                 28
+#define RST_RESET_EXTERNAL_RESET_LSB                                 28
+#define RST_RESET_EXTERNAL_RESET_MASK                                0x10000000
+#define RST_RESET_EXTERNAL_RESET_GET(x)                              (((x) & RST_RESET_EXTERNAL_RESET_MASK) >> RST_RESET_EXTERNAL_RESET_LSB)
+#define RST_RESET_EXTERNAL_RESET_SET(x)                              (((x) << RST_RESET_EXTERNAL_RESET_LSB) & RST_RESET_EXTERNAL_RESET_MASK)
+#define RST_RESET_EXTERNAL_RESET_RESET                               0x0 // 0
+#define RST_RESET_RTC_RESET_MSB                                      27
+#define RST_RESET_RTC_RESET_LSB                                      27
+#define RST_RESET_RTC_RESET_MASK                                     0x08000000
+#define RST_RESET_RTC_RESET_GET(x)                                   (((x) & RST_RESET_RTC_RESET_MASK) >> RST_RESET_RTC_RESET_LSB)
+#define RST_RESET_RTC_RESET_SET(x)                                   (((x) << RST_RESET_RTC_RESET_LSB) & RST_RESET_RTC_RESET_MASK)
+#define RST_RESET_RTC_RESET_RESET                                    0x1 // 1
+#define RST_RESET_PCIEEP_RST_INT_MSB                                 26
+#define RST_RESET_PCIEEP_RST_INT_LSB                                 26
+#define RST_RESET_PCIEEP_RST_INT_MASK                                0x04000000
+#define RST_RESET_PCIEEP_RST_INT_GET(x)                              (((x) & RST_RESET_PCIEEP_RST_INT_MASK) >> RST_RESET_PCIEEP_RST_INT_LSB)
+#define RST_RESET_PCIEEP_RST_INT_SET(x)                              (((x) << RST_RESET_PCIEEP_RST_INT_LSB) & RST_RESET_PCIEEP_RST_INT_MASK)
+#define RST_RESET_PCIEEP_RST_INT_RESET                               0x0 // 0
+#define RST_RESET_CHKSUM_ACC_RESET_MSB                               25
+#define RST_RESET_CHKSUM_ACC_RESET_LSB                               25
+#define RST_RESET_CHKSUM_ACC_RESET_MASK                              0x02000000
+#define RST_RESET_CHKSUM_ACC_RESET_GET(x)                            (((x) & RST_RESET_CHKSUM_ACC_RESET_MASK) >> RST_RESET_CHKSUM_ACC_RESET_LSB)
+#define RST_RESET_CHKSUM_ACC_RESET_SET(x)                            (((x) << RST_RESET_CHKSUM_ACC_RESET_LSB) & RST_RESET_CHKSUM_ACC_RESET_MASK)
+#define RST_RESET_CHKSUM_ACC_RESET_RESET                             0x0 // 0
+#define RST_RESET_FULL_CHIP_RESET_MSB                                24
+#define RST_RESET_FULL_CHIP_RESET_LSB                                24
+#define RST_RESET_FULL_CHIP_RESET_MASK                               0x01000000
+#define RST_RESET_FULL_CHIP_RESET_GET(x)                             (((x) & RST_RESET_FULL_CHIP_RESET_MASK) >> RST_RESET_FULL_CHIP_RESET_LSB)
+#define RST_RESET_FULL_CHIP_RESET_SET(x)                             (((x) << RST_RESET_FULL_CHIP_RESET_LSB) & RST_RESET_FULL_CHIP_RESET_MASK)
+#define RST_RESET_FULL_CHIP_RESET_RESET                              0x0 // 0
+#define RST_RESET_GE1_MDIO_RESET_MSB                                 23
+#define RST_RESET_GE1_MDIO_RESET_LSB                                 23
+#define RST_RESET_GE1_MDIO_RESET_MASK                                0x00800000
+#define RST_RESET_GE1_MDIO_RESET_GET(x)                              (((x) & RST_RESET_GE1_MDIO_RESET_MASK) >> RST_RESET_GE1_MDIO_RESET_LSB)
+#define RST_RESET_GE1_MDIO_RESET_SET(x)                              (((x) << RST_RESET_GE1_MDIO_RESET_LSB) & RST_RESET_GE1_MDIO_RESET_MASK)
+#define RST_RESET_GE1_MDIO_RESET_RESET                               0x1 // 1
+#define RST_RESET_GE0_MDIO_RESET_MSB                                 22
+#define RST_RESET_GE0_MDIO_RESET_LSB                                 22
+#define RST_RESET_GE0_MDIO_RESET_MASK                                0x00400000
+#define RST_RESET_GE0_MDIO_RESET_GET(x)                              (((x) & RST_RESET_GE0_MDIO_RESET_MASK) >> RST_RESET_GE0_MDIO_RESET_LSB)
+#define RST_RESET_GE0_MDIO_RESET_SET(x)                              (((x) << RST_RESET_GE0_MDIO_RESET_LSB) & RST_RESET_GE0_MDIO_RESET_MASK)
+#define RST_RESET_GE0_MDIO_RESET_RESET                               0x1 // 1
+#define RST_RESET_CPU_NMI_MSB                                        21
+#define RST_RESET_CPU_NMI_LSB                                        21
+#define RST_RESET_CPU_NMI_MASK                                       0x00200000
+#define RST_RESET_CPU_NMI_GET(x)                                     (((x) & RST_RESET_CPU_NMI_MASK) >> RST_RESET_CPU_NMI_LSB)
+#define RST_RESET_CPU_NMI_SET(x)                                     (((x) << RST_RESET_CPU_NMI_LSB) & RST_RESET_CPU_NMI_MASK)
+#define RST_RESET_CPU_NMI_RESET                                      0x0 // 0
+#define RST_RESET_CPU_COLD_RESET_MSB                                 20
+#define RST_RESET_CPU_COLD_RESET_LSB                                 20
+#define RST_RESET_CPU_COLD_RESET_MASK                                0x00100000
+#define RST_RESET_CPU_COLD_RESET_GET(x)                              (((x) & RST_RESET_CPU_COLD_RESET_MASK) >> RST_RESET_CPU_COLD_RESET_LSB)
+#define RST_RESET_CPU_COLD_RESET_SET(x)                              (((x) << RST_RESET_CPU_COLD_RESET_LSB) & RST_RESET_CPU_COLD_RESET_MASK)
+#define RST_RESET_CPU_COLD_RESET_RESET                               0x0 // 0
+#define RST_RESET_HOST_RESET_INT_MSB                                 19
+#define RST_RESET_HOST_RESET_INT_LSB                                 19
+#define RST_RESET_HOST_RESET_INT_MASK                                0x00080000
+#define RST_RESET_HOST_RESET_INT_GET(x)                              (((x) & RST_RESET_HOST_RESET_INT_MASK) >> RST_RESET_HOST_RESET_INT_LSB)
+#define RST_RESET_HOST_RESET_INT_SET(x)                              (((x) << RST_RESET_HOST_RESET_INT_LSB) & RST_RESET_HOST_RESET_INT_MASK)
+#define RST_RESET_HOST_RESET_INT_RESET                               0x0 // 0
+#define RST_RESET_PCIEEP_RESET_MSB                                   18
+#define RST_RESET_PCIEEP_RESET_LSB                                   18
+#define RST_RESET_PCIEEP_RESET_MASK                                  0x00040000
+#define RST_RESET_PCIEEP_RESET_GET(x)                                (((x) & RST_RESET_PCIEEP_RESET_MASK) >> RST_RESET_PCIEEP_RESET_LSB)
+#define RST_RESET_PCIEEP_RESET_SET(x)                                (((x) << RST_RESET_PCIEEP_RESET_LSB) & RST_RESET_PCIEEP_RESET_MASK)
+#define RST_RESET_PCIEEP_RESET_RESET                                 0x0 // 0
+#define RST_RESET_UART1_RESET_MSB                                    17
+#define RST_RESET_UART1_RESET_LSB                                    17
+#define RST_RESET_UART1_RESET_MASK                                   0x00020000
+#define RST_RESET_UART1_RESET_GET(x)                                 (((x) & RST_RESET_UART1_RESET_MASK) >> RST_RESET_UART1_RESET_LSB)
+#define RST_RESET_UART1_RESET_SET(x)                                 (((x) << RST_RESET_UART1_RESET_LSB) & RST_RESET_UART1_RESET_MASK)
+#define RST_RESET_UART1_RESET_RESET                                  0x0 // 0
+#define RST_RESET_DDR_RESET_MSB                                      16
+#define RST_RESET_DDR_RESET_LSB                                      16
+#define RST_RESET_DDR_RESET_MASK                                     0x00010000
+#define RST_RESET_DDR_RESET_GET(x)                                   (((x) & RST_RESET_DDR_RESET_MASK) >> RST_RESET_DDR_RESET_LSB)
+#define RST_RESET_DDR_RESET_SET(x)                                   (((x) << RST_RESET_DDR_RESET_LSB) & RST_RESET_DDR_RESET_MASK)
+#define RST_RESET_DDR_RESET_RESET                                    0x0 // 0
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_MSB                            15
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_LSB                            15
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_MASK                           0x00008000
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_GET(x)                         (((x) & RST_RESET_USB_PHY_PLL_PWD_EXT_MASK) >> RST_RESET_USB_PHY_PLL_PWD_EXT_LSB)
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_SET(x)                         (((x) << RST_RESET_USB_PHY_PLL_PWD_EXT_LSB) & RST_RESET_USB_PHY_PLL_PWD_EXT_MASK)
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_RESET                          0x0 // 0
+#define RST_RESET_NANDF_RESET_MSB                                    14
+#define RST_RESET_NANDF_RESET_LSB                                    14
+#define RST_RESET_NANDF_RESET_MASK                                   0x00004000
+#define RST_RESET_NANDF_RESET_GET(x)                                 (((x) & RST_RESET_NANDF_RESET_MASK) >> RST_RESET_NANDF_RESET_LSB)
+#define RST_RESET_NANDF_RESET_SET(x)                                 (((x) << RST_RESET_NANDF_RESET_LSB) & RST_RESET_NANDF_RESET_MASK)
+#define RST_RESET_NANDF_RESET_RESET                                  0x1 // 1
+#define RST_RESET_GE1_MAC_RESET_MSB                                  13
+#define RST_RESET_GE1_MAC_RESET_LSB                                  13
+#define RST_RESET_GE1_MAC_RESET_MASK                                 0x00002000
+#define RST_RESET_GE1_MAC_RESET_GET(x)                               (((x) & RST_RESET_GE1_MAC_RESET_MASK) >> RST_RESET_GE1_MAC_RESET_LSB)
+#define RST_RESET_GE1_MAC_RESET_SET(x)                               (((x) << RST_RESET_GE1_MAC_RESET_LSB) & RST_RESET_GE1_MAC_RESET_MASK)
+#define RST_RESET_GE1_MAC_RESET_RESET                                0x1 // 1
+#define RST_RESET_ETH_SGMII_ARESET_MSB                               12
+#define RST_RESET_ETH_SGMII_ARESET_LSB                               12
+#define RST_RESET_ETH_SGMII_ARESET_MASK                              0x00001000
+#define RST_RESET_ETH_SGMII_ARESET_GET(x)                            (((x) & RST_RESET_ETH_SGMII_ARESET_MASK) >> RST_RESET_ETH_SGMII_ARESET_LSB)
+#define RST_RESET_ETH_SGMII_ARESET_SET(x)                            (((x) << RST_RESET_ETH_SGMII_ARESET_LSB) & RST_RESET_ETH_SGMII_ARESET_MASK)
+#define RST_RESET_ETH_SGMII_ARESET_RESET                             0x1 // 1
+#define RST_RESET_USB_PHY_ARESET_MSB                                 11
+#define RST_RESET_USB_PHY_ARESET_LSB                                 11
+#define RST_RESET_USB_PHY_ARESET_MASK                                0x00000800
+#define RST_RESET_USB_PHY_ARESET_GET(x)                              (((x) & RST_RESET_USB_PHY_ARESET_MASK) >> RST_RESET_USB_PHY_ARESET_LSB)
+#define RST_RESET_USB_PHY_ARESET_SET(x)                              (((x) << RST_RESET_USB_PHY_ARESET_LSB) & RST_RESET_USB_PHY_ARESET_MASK)
+#define RST_RESET_USB_PHY_ARESET_RESET                               0x1 // 1
+#define RST_RESET_HOST_DMA_INT_MSB                                   10
+#define RST_RESET_HOST_DMA_INT_LSB                                   10
+#define RST_RESET_HOST_DMA_INT_MASK                                  0x00000400
+#define RST_RESET_HOST_DMA_INT_GET(x)                                (((x) & RST_RESET_HOST_DMA_INT_MASK) >> RST_RESET_HOST_DMA_INT_LSB)
+#define RST_RESET_HOST_DMA_INT_SET(x)                                (((x) << RST_RESET_HOST_DMA_INT_LSB) & RST_RESET_HOST_DMA_INT_MASK)
+#define RST_RESET_HOST_DMA_INT_RESET                                 0x0 // 0
+#define RST_RESET_GE0_MAC_RESET_MSB                                  9
+#define RST_RESET_GE0_MAC_RESET_LSB                                  9
+#define RST_RESET_GE0_MAC_RESET_MASK                                 0x00000200
+#define RST_RESET_GE0_MAC_RESET_GET(x)                               (((x) & RST_RESET_GE0_MAC_RESET_MASK) >> RST_RESET_GE0_MAC_RESET_LSB)
+#define RST_RESET_GE0_MAC_RESET_SET(x)                               (((x) << RST_RESET_GE0_MAC_RESET_LSB) & RST_RESET_GE0_MAC_RESET_MASK)
+#define RST_RESET_GE0_MAC_RESET_RESET                                0x1 // 1
+#define RST_RESET_ETH_SGMII_RESET_MSB                                8
+#define RST_RESET_ETH_SGMII_RESET_LSB                                8
+#define RST_RESET_ETH_SGMII_RESET_MASK                               0x00000100
+#define RST_RESET_ETH_SGMII_RESET_GET(x)                             (((x) & RST_RESET_ETH_SGMII_RESET_MASK) >> RST_RESET_ETH_SGMII_RESET_LSB)
+#define RST_RESET_ETH_SGMII_RESET_SET(x)                             (((x) << RST_RESET_ETH_SGMII_RESET_LSB) & RST_RESET_ETH_SGMII_RESET_MASK)
+#define RST_RESET_ETH_SGMII_RESET_RESET                              0x1 // 1
+#define RST_RESET_PCIE_PHY_RESET_MSB                                 7
+#define RST_RESET_PCIE_PHY_RESET_LSB                                 7
+#define RST_RESET_PCIE_PHY_RESET_MASK                                0x00000080
+#define RST_RESET_PCIE_PHY_RESET_GET(x)                              (((x) & RST_RESET_PCIE_PHY_RESET_MASK) >> RST_RESET_PCIE_PHY_RESET_LSB)
+#define RST_RESET_PCIE_PHY_RESET_SET(x)                              (((x) << RST_RESET_PCIE_PHY_RESET_LSB) & RST_RESET_PCIE_PHY_RESET_MASK)
+#define RST_RESET_PCIE_PHY_RESET_RESET                               0x1 // 1
+#define RST_RESET_PCIE_RESET_MSB                                     6
+#define RST_RESET_PCIE_RESET_LSB                                     6
+#define RST_RESET_PCIE_RESET_MASK                                    0x00000040
+#define RST_RESET_PCIE_RESET_GET(x)                                  (((x) & RST_RESET_PCIE_RESET_MASK) >> RST_RESET_PCIE_RESET_LSB)
+#define RST_RESET_PCIE_RESET_SET(x)                                  (((x) << RST_RESET_PCIE_RESET_LSB) & RST_RESET_PCIE_RESET_MASK)
+#define RST_RESET_PCIE_RESET_RESET                                   0x1 // 1
+#define RST_RESET_USB_HOST_RESET_MSB                                 5
+#define RST_RESET_USB_HOST_RESET_LSB                                 5
+#define RST_RESET_USB_HOST_RESET_MASK                                0x00000020
+#define RST_RESET_USB_HOST_RESET_GET(x)                              (((x) & RST_RESET_USB_HOST_RESET_MASK) >> RST_RESET_USB_HOST_RESET_LSB)
+#define RST_RESET_USB_HOST_RESET_SET(x)                              (((x) << RST_RESET_USB_HOST_RESET_LSB) & RST_RESET_USB_HOST_RESET_MASK)
+#define RST_RESET_USB_HOST_RESET_RESET                               0x1 // 1
+#define RST_RESET_USB_PHY_RESET_MSB                                  4
+#define RST_RESET_USB_PHY_RESET_LSB                                  4
+#define RST_RESET_USB_PHY_RESET_MASK                                 0x00000010
+#define RST_RESET_USB_PHY_RESET_GET(x)                               (((x) & RST_RESET_USB_PHY_RESET_MASK) >> RST_RESET_USB_PHY_RESET_LSB)
+#define RST_RESET_USB_PHY_RESET_SET(x)                               (((x) << RST_RESET_USB_PHY_RESET_LSB) & RST_RESET_USB_PHY_RESET_MASK)
+#define RST_RESET_USB_PHY_RESET_RESET                                0x1 // 1
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MSB                       3
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB                       3
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK                      0x00000008
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_GET(x)                    (((x) & RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK) >> RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB)
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(x)                    (((x) << RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB) & RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK)
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_RESET                     0x0 // 0
+#define RST_RESET_LUT_RESET_MSB                                      2
+#define RST_RESET_LUT_RESET_LSB                                      2
+#define RST_RESET_LUT_RESET_MASK                                     0x00000004
+#define RST_RESET_LUT_RESET_GET(x)                                   (((x) & RST_RESET_LUT_RESET_MASK) >> RST_RESET_LUT_RESET_LSB)
+#define RST_RESET_LUT_RESET_SET(x)                                   (((x) << RST_RESET_LUT_RESET_LSB) & RST_RESET_LUT_RESET_MASK)
+#define RST_RESET_LUT_RESET_RESET                                    0x0 // 0
+#define RST_RESET_MBOX_RESET_MSB                                     1
+#define RST_RESET_MBOX_RESET_LSB                                     1
+#define RST_RESET_MBOX_RESET_MASK                                    0x00000002
+#define RST_RESET_MBOX_RESET_GET(x)                                  (((x) & RST_RESET_MBOX_RESET_MASK) >> RST_RESET_MBOX_RESET_LSB)
+#define RST_RESET_MBOX_RESET_SET(x)                                  (((x) << RST_RESET_MBOX_RESET_LSB) & RST_RESET_MBOX_RESET_MASK)
+#define RST_RESET_MBOX_RESET_RESET                                   0x0 // 0
+#define RST_RESET_I2S_RESET_MSB                                      0
+#define RST_RESET_I2S_RESET_LSB                                      0
+#define RST_RESET_I2S_RESET_MASK                                     0x00000001
+#define RST_RESET_I2S_RESET_GET(x)                                   (((x) & RST_RESET_I2S_RESET_MASK) >> RST_RESET_I2S_RESET_LSB)
+#define RST_RESET_I2S_RESET_SET(x)                                   (((x) << RST_RESET_I2S_RESET_LSB) & RST_RESET_I2S_RESET_MASK)
+#define RST_RESET_I2S_RESET_RESET                                    0x0 // 0
+#define RST_RESET_ADDRESS                                            0x1806001c
+
+#define RST_MISC2_PCIEEP_LINK_UP_MSB                                 30
+#define RST_MISC2_PCIEEP_LINK_UP_LSB                                 30
+#define RST_MISC2_PCIEEP_LINK_UP_MASK                                0x40000000
+#define RST_MISC2_PCIEEP_LINK_UP_GET(x)                              (((x) & RST_MISC2_PCIEEP_LINK_UP_MASK) >> RST_MISC2_PCIEEP_LINK_UP_LSB)
+#define RST_MISC2_PCIEEP_LINK_UP_SET(x)                              (((x) << RST_MISC2_PCIEEP_LINK_UP_LSB) & RST_MISC2_PCIEEP_LINK_UP_MASK)
+#define RST_MISC2_PCIEEP_LINK_UP_RESET                               0x0 // 0
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_MSB                             29
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_LSB                             29
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_MASK                            0x20000000
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_GET(x)                          (((x) & RST_MISC2_PCIEEP_CLKOBS2_SEL_MASK) >> RST_MISC2_PCIEEP_CLKOBS2_SEL_LSB)
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_SET(x)                          (((x) << RST_MISC2_PCIEEP_CLKOBS2_SEL_LSB) & RST_MISC2_PCIEEP_CLKOBS2_SEL_MASK)
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_RESET                           0x0 // 0
+#define RST_MISC2_PCIE_CLKOBS1_SEL_MSB                               28
+#define RST_MISC2_PCIE_CLKOBS1_SEL_LSB                               28
+#define RST_MISC2_PCIE_CLKOBS1_SEL_MASK                              0x10000000
+#define RST_MISC2_PCIE_CLKOBS1_SEL_GET(x)                            (((x) & RST_MISC2_PCIE_CLKOBS1_SEL_MASK) >> RST_MISC2_PCIE_CLKOBS1_SEL_LSB)
+#define RST_MISC2_PCIE_CLKOBS1_SEL_SET(x)                            (((x) << RST_MISC2_PCIE_CLKOBS1_SEL_LSB) & RST_MISC2_PCIE_CLKOBS1_SEL_MASK)
+#define RST_MISC2_PCIE_CLKOBS1_SEL_RESET                             0x0 // 0
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_MSB                     27
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_LSB                     27
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_MASK                    0x08000000
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_GET(x)                  (((x) & RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_MASK) >> RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_LSB)
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_SET(x)                  (((x) << RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_LSB) & RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_MASK)
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_RESET                   0x0 // 0
+#define RST_MISC2_WOW_STATUS_MSB                                     26
+#define RST_MISC2_WOW_STATUS_LSB                                     26
+#define RST_MISC2_WOW_STATUS_MASK                                    0x04000000
+#define RST_MISC2_WOW_STATUS_GET(x)                                  (((x) & RST_MISC2_WOW_STATUS_MASK) >> RST_MISC2_WOW_STATUS_LSB)
+#define RST_MISC2_WOW_STATUS_SET(x)                                  (((x) << RST_MISC2_WOW_STATUS_LSB) & RST_MISC2_WOW_STATUS_MASK)
+#define RST_MISC2_WOW_STATUS_RESET                                   0x0 // 0
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_MSB                             25
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_LSB                             25
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_MASK                            0x02000000
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L2_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L2_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L2_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L2_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_MSB                             24
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_LSB                             24
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_MASK                            0x01000000
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L2_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L2_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L2_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L2_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_MSB                             23
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_LSB                             23
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_MASK                            0x00800000
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L1_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L1_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L1_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L1_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_MSB                             22
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_LSB                             22
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_MASK                            0x00400000
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L1_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L1_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L1_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L1_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_MSB                            21
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB                            21
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK                           0x00200000
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_GET(x)                         (((x) & RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_SET(x)                         (((x) << RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_RESET                          0x0 // 0
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_MSB                            20
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB                            20
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK                           0x00100000
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_GET(x)                         (((x) & RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_SET(x)                         (((x) << RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_RESET                          0x0 // 0
+#define RST_MISC2_PCIEEP_REGWR_EN_MSB                                19
+#define RST_MISC2_PCIEEP_REGWR_EN_LSB                                19
+#define RST_MISC2_PCIEEP_REGWR_EN_MASK                               0x00080000
+#define RST_MISC2_PCIEEP_REGWR_EN_GET(x)                             (((x) & RST_MISC2_PCIEEP_REGWR_EN_MASK) >> RST_MISC2_PCIEEP_REGWR_EN_LSB)
+#define RST_MISC2_PCIEEP_REGWR_EN_SET(x)                             (((x) << RST_MISC2_PCIEEP_REGWR_EN_LSB) & RST_MISC2_PCIEEP_REGWR_EN_MASK)
+#define RST_MISC2_PCIEEP_REGWR_EN_RESET                              0x1 // 1
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_MSB                           18
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_LSB                           18
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_MASK                          0x00040000
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_GET(x)                        (((x) & RST_MISC2_EXT_HOST_WASP_RST_EN_MASK) >> RST_MISC2_EXT_HOST_WASP_RST_EN_LSB)
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_SET(x)                        (((x) << RST_MISC2_EXT_HOST_WASP_RST_EN_LSB) & RST_MISC2_EXT_HOST_WASP_RST_EN_MASK)
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_RESET                         0x0 // 0
+#define RST_MISC2_PCIEEP_RST_INT_MSB                                 17
+#define RST_MISC2_PCIEEP_RST_INT_LSB                                 17
+#define RST_MISC2_PCIEEP_RST_INT_MASK                                0x00020000
+#define RST_MISC2_PCIEEP_RST_INT_GET(x)                              (((x) & RST_MISC2_PCIEEP_RST_INT_MASK) >> RST_MISC2_PCIEEP_RST_INT_LSB)
+#define RST_MISC2_PCIEEP_RST_INT_SET(x)                              (((x) << RST_MISC2_PCIEEP_RST_INT_LSB) & RST_MISC2_PCIEEP_RST_INT_MASK)
+#define RST_MISC2_PCIEEP_RST_INT_RESET                               0x0 // 0
+#define RST_MISC2_HOST_RESET_INT_MSB                                 16
+#define RST_MISC2_HOST_RESET_INT_LSB                                 16
+#define RST_MISC2_HOST_RESET_INT_MASK                                0x00010000
+#define RST_MISC2_HOST_RESET_INT_GET(x)                              (((x) & RST_MISC2_HOST_RESET_INT_MASK) >> RST_MISC2_HOST_RESET_INT_LSB)
+#define RST_MISC2_HOST_RESET_INT_SET(x)                              (((x) << RST_MISC2_HOST_RESET_INT_LSB) & RST_MISC2_HOST_RESET_INT_MASK)
+#define RST_MISC2_HOST_RESET_INT_RESET                               0x0 // 0
+#define RST_MISC2_CPU_HOST_WA_MSB                                    15
+#define RST_MISC2_CPU_HOST_WA_LSB                                    15
+#define RST_MISC2_CPU_HOST_WA_MASK                                   0x00008000
+#define RST_MISC2_CPU_HOST_WA_GET(x)                                 (((x) & RST_MISC2_CPU_HOST_WA_MASK) >> RST_MISC2_CPU_HOST_WA_LSB)
+#define RST_MISC2_CPU_HOST_WA_SET(x)                                 (((x) << RST_MISC2_CPU_HOST_WA_LSB) & RST_MISC2_CPU_HOST_WA_MASK)
+#define RST_MISC2_CPU_HOST_WA_RESET                                  0x0 // 0
+#define RST_MISC2_PERSTN_RCPHY2_MSB                                  14
+#define RST_MISC2_PERSTN_RCPHY2_LSB                                  14
+#define RST_MISC2_PERSTN_RCPHY2_MASK                                 0x00004000
+#define RST_MISC2_PERSTN_RCPHY2_GET(x)                               (((x) & RST_MISC2_PERSTN_RCPHY2_MASK) >> RST_MISC2_PERSTN_RCPHY2_LSB)
+#define RST_MISC2_PERSTN_RCPHY2_SET(x)                               (((x) << RST_MISC2_PERSTN_RCPHY2_LSB) & RST_MISC2_PERSTN_RCPHY2_MASK)
+#define RST_MISC2_PERSTN_RCPHY2_RESET                                0x1 // 1
+#define RST_MISC2_PERSTN_RCPHY_MSB                                   13
+#define RST_MISC2_PERSTN_RCPHY_LSB                                   13
+#define RST_MISC2_PERSTN_RCPHY_MASK                                  0x00002000
+#define RST_MISC2_PERSTN_RCPHY_GET(x)                                (((x) & RST_MISC2_PERSTN_RCPHY_MASK) >> RST_MISC2_PERSTN_RCPHY_LSB)
+#define RST_MISC2_PERSTN_RCPHY_SET(x)                                (((x) << RST_MISC2_PERSTN_RCPHY_LSB) & RST_MISC2_PERSTN_RCPHY_MASK)
+#define RST_MISC2_PERSTN_RCPHY_RESET                                 0x1 // 1
+#define RST_MISC2_PCIEEP_LTSSM_STATE_MSB                             12
+#define RST_MISC2_PCIEEP_LTSSM_STATE_LSB                             8
+#define RST_MISC2_PCIEEP_LTSSM_STATE_MASK                            0x00001f00
+#define RST_MISC2_PCIEEP_LTSSM_STATE_GET(x)                          (((x) & RST_MISC2_PCIEEP_LTSSM_STATE_MASK) >> RST_MISC2_PCIEEP_LTSSM_STATE_LSB)
+#define RST_MISC2_PCIEEP_LTSSM_STATE_SET(x)                          (((x) << RST_MISC2_PCIEEP_LTSSM_STATE_LSB) & RST_MISC2_PCIEEP_LTSSM_STATE_MASK)
+#define RST_MISC2_PCIEEP_LTSSM_STATE_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_LINK_STATUS_MSB                             4
+#define RST_MISC2_PCIEEP_LINK_STATUS_LSB                             4
+#define RST_MISC2_PCIEEP_LINK_STATUS_MASK                            0x00000010
+#define RST_MISC2_PCIEEP_LINK_STATUS_GET(x)                          (((x) & RST_MISC2_PCIEEP_LINK_STATUS_MASK) >> RST_MISC2_PCIEEP_LINK_STATUS_LSB)
+#define RST_MISC2_PCIEEP_LINK_STATUS_SET(x)                          (((x) << RST_MISC2_PCIEEP_LINK_STATUS_LSB) & RST_MISC2_PCIEEP_LINK_STATUS_MASK)
+#define RST_MISC2_PCIEEP_LINK_STATUS_RESET                           0x0 // 0
+#define RST_MISC2_WOW_DETECT_MSB                                     3
+#define RST_MISC2_WOW_DETECT_LSB                                     3
+#define RST_MISC2_WOW_DETECT_MASK                                    0x00000008
+#define RST_MISC2_WOW_DETECT_GET(x)                                  (((x) & RST_MISC2_WOW_DETECT_MASK) >> RST_MISC2_WOW_DETECT_LSB)
+#define RST_MISC2_WOW_DETECT_SET(x)                                  (((x) << RST_MISC2_WOW_DETECT_LSB) & RST_MISC2_WOW_DETECT_MASK)
+#define RST_MISC2_WOW_DETECT_RESET                                   0x0 // 0
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_MSB                           2
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_LSB                           2
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_MASK                          0x00000004
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_GET(x)                        (((x) & RST_MISC2_PCIEEP_RXDETECT_DONE_MASK) >> RST_MISC2_PCIEEP_RXDETECT_DONE_LSB)
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_SET(x)                        (((x) << RST_MISC2_PCIEEP_RXDETECT_DONE_LSB) & RST_MISC2_PCIEEP_RXDETECT_DONE_MASK)
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_RESET                         0x0 // 0
+#define RST_MISC2_PCIEEP_WOW_INT_MSB                                 1
+#define RST_MISC2_PCIEEP_WOW_INT_LSB                                 1
+#define RST_MISC2_PCIEEP_WOW_INT_MASK                                0x00000002
+#define RST_MISC2_PCIEEP_WOW_INT_GET(x)                              (((x) & RST_MISC2_PCIEEP_WOW_INT_MASK) >> RST_MISC2_PCIEEP_WOW_INT_LSB)
+#define RST_MISC2_PCIEEP_WOW_INT_SET(x)                              (((x) << RST_MISC2_PCIEEP_WOW_INT_LSB) & RST_MISC2_PCIEEP_WOW_INT_MASK)
+#define RST_MISC2_PCIEEP_WOW_INT_RESET                               0x0 // 0
+#define RST_MISC2_PCIEEP_CFG_DONE_MSB                                0
+#define RST_MISC2_PCIEEP_CFG_DONE_LSB                                0
+#define RST_MISC2_PCIEEP_CFG_DONE_MASK                               0x00000001
+#define RST_MISC2_PCIEEP_CFG_DONE_GET(x)                             (((x) & RST_MISC2_PCIEEP_CFG_DONE_MASK) >> RST_MISC2_PCIEEP_CFG_DONE_LSB)
+#define RST_MISC2_PCIEEP_CFG_DONE_SET(x)                             (((x) << RST_MISC2_PCIEEP_CFG_DONE_LSB) & RST_MISC2_PCIEEP_CFG_DONE_MASK)
+#define RST_MISC2_PCIEEP_CFG_DONE_RESET                              0x0 // 0
+#define RST_MISC2_ADDRESS                                            0x180600bc
+
+#define PCIE_APP_CFG_TYPE_MSB                                        21
+#define PCIE_APP_CFG_TYPE_LSB                                        20
+#define PCIE_APP_CFG_TYPE_MASK                                       0x00300000
+#define PCIE_APP_CFG_TYPE_GET(x)                                     (((x) & PCIE_APP_CFG_TYPE_MASK) >> PCIE_APP_CFG_TYPE_LSB)
+#define PCIE_APP_CFG_TYPE_SET(x)                                     (((x) << PCIE_APP_CFG_TYPE_LSB) & PCIE_APP_CFG_TYPE_MASK)
+#define PCIE_APP_CFG_TYPE_RESET                                      0x0 // 0
+#define PCIE_APP_PCIE_BAR_MSN_MSB                                    19
+#define PCIE_APP_PCIE_BAR_MSN_LSB                                    16
+#define PCIE_APP_PCIE_BAR_MSN_MASK                                   0x000f0000
+#define PCIE_APP_PCIE_BAR_MSN_GET(x)                                 (((x) & PCIE_APP_PCIE_BAR_MSN_MASK) >> PCIE_APP_PCIE_BAR_MSN_LSB)
+#define PCIE_APP_PCIE_BAR_MSN_SET(x)                                 (((x) << PCIE_APP_PCIE_BAR_MSN_LSB) & PCIE_APP_PCIE_BAR_MSN_MASK)
+#define PCIE_APP_PCIE_BAR_MSN_RESET                                  0x1 // 1
+#define PCIE_APP_CFG_BE_MSB                                          15
+#define PCIE_APP_CFG_BE_LSB                                          12
+#define PCIE_APP_CFG_BE_MASK                                         0x0000f000
+#define PCIE_APP_CFG_BE_GET(x)                                       (((x) & PCIE_APP_CFG_BE_MASK) >> PCIE_APP_CFG_BE_LSB)
+#define PCIE_APP_CFG_BE_SET(x)                                       (((x) << PCIE_APP_CFG_BE_LSB) & PCIE_APP_CFG_BE_MASK)
+#define PCIE_APP_CFG_BE_RESET                                        0xf // 15
+#define PCIE_APP_SLV_RESP_ERR_MAP_MSB                                11
+#define PCIE_APP_SLV_RESP_ERR_MAP_LSB                                6
+#define PCIE_APP_SLV_RESP_ERR_MAP_MASK                               0x00000fc0
+#define PCIE_APP_SLV_RESP_ERR_MAP_GET(x)                             (((x) & PCIE_APP_SLV_RESP_ERR_MAP_MASK) >> PCIE_APP_SLV_RESP_ERR_MAP_LSB)
+#define PCIE_APP_SLV_RESP_ERR_MAP_SET(x)                             (((x) << PCIE_APP_SLV_RESP_ERR_MAP_LSB) & PCIE_APP_SLV_RESP_ERR_MAP_MASK)
+#define PCIE_APP_SLV_RESP_ERR_MAP_RESET                              0x3f // 63
+#define PCIE_APP_MSTR_RESP_ERR_MAP_MSB                               5
+#define PCIE_APP_MSTR_RESP_ERR_MAP_LSB                               4
+#define PCIE_APP_MSTR_RESP_ERR_MAP_MASK                              0x00000030
+#define PCIE_APP_MSTR_RESP_ERR_MAP_GET(x)                            (((x) & PCIE_APP_MSTR_RESP_ERR_MAP_MASK) >> PCIE_APP_MSTR_RESP_ERR_MAP_LSB)
+#define PCIE_APP_MSTR_RESP_ERR_MAP_SET(x)                            (((x) << PCIE_APP_MSTR_RESP_ERR_MAP_LSB) & PCIE_APP_MSTR_RESP_ERR_MAP_MASK)
+#define PCIE_APP_MSTR_RESP_ERR_MAP_RESET                             0x0 // 0
+#define PCIE_APP_INIT_RST_MSB                                        3
+#define PCIE_APP_INIT_RST_LSB                                        3
+#define PCIE_APP_INIT_RST_MASK                                       0x00000008
+#define PCIE_APP_INIT_RST_GET(x)                                     (((x) & PCIE_APP_INIT_RST_MASK) >> PCIE_APP_INIT_RST_LSB)
+#define PCIE_APP_INIT_RST_SET(x)                                     (((x) << PCIE_APP_INIT_RST_LSB) & PCIE_APP_INIT_RST_MASK)
+#define PCIE_APP_INIT_RST_RESET                                      0x0 // 0
+#define PCIE_APP_PM_XMT_TURNOFF_MSB                                  2
+#define PCIE_APP_PM_XMT_TURNOFF_LSB                                  2
+#define PCIE_APP_PM_XMT_TURNOFF_MASK                                 0x00000004
+#define PCIE_APP_PM_XMT_TURNOFF_GET(x)                               (((x) & PCIE_APP_PM_XMT_TURNOFF_MASK) >> PCIE_APP_PM_XMT_TURNOFF_LSB)
+#define PCIE_APP_PM_XMT_TURNOFF_SET(x)                               (((x) << PCIE_APP_PM_XMT_TURNOFF_LSB) & PCIE_APP_PM_XMT_TURNOFF_MASK)
+#define PCIE_APP_PM_XMT_TURNOFF_RESET                                0x0 // 0
+#define PCIE_APP_UNLOCK_MSG_MSB                                      1
+#define PCIE_APP_UNLOCK_MSG_LSB                                      1
+#define PCIE_APP_UNLOCK_MSG_MASK                                     0x00000002
+#define PCIE_APP_UNLOCK_MSG_GET(x)                                   (((x) & PCIE_APP_UNLOCK_MSG_MASK) >> PCIE_APP_UNLOCK_MSG_LSB)
+#define PCIE_APP_UNLOCK_MSG_SET(x)                                   (((x) << PCIE_APP_UNLOCK_MSG_LSB) & PCIE_APP_UNLOCK_MSG_MASK)
+#define PCIE_APP_UNLOCK_MSG_RESET                                    0x0 // 0
+#define PCIE_APP_LTSSM_ENABLE_MSB                                    0
+#define PCIE_APP_LTSSM_ENABLE_LSB                                    0
+#define PCIE_APP_LTSSM_ENABLE_MASK                                   0x00000001
+#define PCIE_APP_LTSSM_ENABLE_GET(x)                                 (((x) & PCIE_APP_LTSSM_ENABLE_MASK) >> PCIE_APP_LTSSM_ENABLE_LSB)
+#define PCIE_APP_LTSSM_ENABLE_SET(x)                                 (((x) << PCIE_APP_LTSSM_ENABLE_LSB) & PCIE_APP_LTSSM_ENABLE_MASK)
+#define PCIE_APP_LTSSM_ENABLE_RESET                                  0x0 // 0
+#define PCIE_APP_ADDRESS                                             0x180f0000
+
+
+#define XTAL_TCXODET_MSB                                             31
+#define XTAL_TCXODET_LSB                                             31
+#define XTAL_TCXODET_MASK                                            0x80000000
+#define XTAL_TCXODET_GET(x)                                          (((x) & XTAL_TCXODET_MASK) >> XTAL_TCXODET_LSB)
+#define XTAL_TCXODET_SET(x)                                          (((x) << XTAL_TCXODET_LSB) & XTAL_TCXODET_MASK)
+#define XTAL_TCXODET_RESET                                           0x0 // 0
+#define XTAL_XTAL_CAPINDAC_MSB                                       30
+#define XTAL_XTAL_CAPINDAC_LSB                                       24
+#define XTAL_XTAL_CAPINDAC_MASK                                      0x7f000000
+#define XTAL_XTAL_CAPINDAC_GET(x)                                    (((x) & XTAL_XTAL_CAPINDAC_MASK) >> XTAL_XTAL_CAPINDAC_LSB)
+#define XTAL_XTAL_CAPINDAC_SET(x)                                    (((x) << XTAL_XTAL_CAPINDAC_LSB) & XTAL_XTAL_CAPINDAC_MASK)
+#define XTAL_XTAL_CAPINDAC_RESET                                     0x4b // 75
+#define XTAL_XTAL_CAPOUTDAC_MSB                                      23
+#define XTAL_XTAL_CAPOUTDAC_LSB                                      17
+#define XTAL_XTAL_CAPOUTDAC_MASK                                     0x00fe0000
+#define XTAL_XTAL_CAPOUTDAC_GET(x)                                   (((x) & XTAL_XTAL_CAPOUTDAC_MASK) >> XTAL_XTAL_CAPOUTDAC_LSB)
+#define XTAL_XTAL_CAPOUTDAC_SET(x)                                   (((x) << XTAL_XTAL_CAPOUTDAC_LSB) & XTAL_XTAL_CAPOUTDAC_MASK)
+#define XTAL_XTAL_CAPOUTDAC_RESET                                    0x4b // 75
+#define XTAL_XTAL_DRVSTR_MSB                                         16
+#define XTAL_XTAL_DRVSTR_LSB                                         15
+#define XTAL_XTAL_DRVSTR_MASK                                        0x00018000
+#define XTAL_XTAL_DRVSTR_GET(x)                                      (((x) & XTAL_XTAL_DRVSTR_MASK) >> XTAL_XTAL_DRVSTR_LSB)
+#define XTAL_XTAL_DRVSTR_SET(x)                                      (((x) << XTAL_XTAL_DRVSTR_LSB) & XTAL_XTAL_DRVSTR_MASK)
+#define XTAL_XTAL_DRVSTR_RESET                                       0x0 // 0
+#define XTAL_XTAL_SHORTXIN_MSB                                       14
+#define XTAL_XTAL_SHORTXIN_LSB                                       14
+#define XTAL_XTAL_SHORTXIN_MASK                                      0x00004000
+#define XTAL_XTAL_SHORTXIN_GET(x)                                    (((x) & XTAL_XTAL_SHORTXIN_MASK) >> XTAL_XTAL_SHORTXIN_LSB)
+#define XTAL_XTAL_SHORTXIN_SET(x)                                    (((x) << XTAL_XTAL_SHORTXIN_LSB) & XTAL_XTAL_SHORTXIN_MASK)
+#define XTAL_XTAL_SHORTXIN_RESET                                     0x0 // 0
+#define XTAL_XTAL_LOCALBIAS_MSB                                      13
+#define XTAL_XTAL_LOCALBIAS_LSB                                      13
+#define XTAL_XTAL_LOCALBIAS_MASK                                     0x00002000
+#define XTAL_XTAL_LOCALBIAS_GET(x)                                   (((x) & XTAL_XTAL_LOCALBIAS_MASK) >> XTAL_XTAL_LOCALBIAS_LSB)
+#define XTAL_XTAL_LOCALBIAS_SET(x)                                   (((x) << XTAL_XTAL_LOCALBIAS_LSB) & XTAL_XTAL_LOCALBIAS_MASK)
+#define XTAL_XTAL_LOCALBIAS_RESET                                    0x1 // 1
+#define XTAL_XTAL_PWDCLKD_MSB                                        12
+#define XTAL_XTAL_PWDCLKD_LSB                                        12
+#define XTAL_XTAL_PWDCLKD_MASK                                       0x00001000
+#define XTAL_XTAL_PWDCLKD_GET(x)                                     (((x) & XTAL_XTAL_PWDCLKD_MASK) >> XTAL_XTAL_PWDCLKD_LSB)
+#define XTAL_XTAL_PWDCLKD_SET(x)                                     (((x) << XTAL_XTAL_PWDCLKD_LSB) & XTAL_XTAL_PWDCLKD_MASK)
+#define XTAL_XTAL_PWDCLKD_RESET                                      0x0 // 0
+#define XTAL_XTAL_BIAS2X_MSB                                         11
+#define XTAL_XTAL_BIAS2X_LSB                                         11
+#define XTAL_XTAL_BIAS2X_MASK                                        0x00000800
+#define XTAL_XTAL_BIAS2X_GET(x)                                      (((x) & XTAL_XTAL_BIAS2X_MASK) >> XTAL_XTAL_BIAS2X_LSB)
+#define XTAL_XTAL_BIAS2X_SET(x)                                      (((x) << XTAL_XTAL_BIAS2X_LSB) & XTAL_XTAL_BIAS2X_MASK)
+#define XTAL_XTAL_BIAS2X_RESET                                       0x1 // 1
+#define XTAL_XTAL_LBIAS2X_MSB                                        10
+#define XTAL_XTAL_LBIAS2X_LSB                                        10
+#define XTAL_XTAL_LBIAS2X_MASK                                       0x00000400
+#define XTAL_XTAL_LBIAS2X_GET(x)                                     (((x) & XTAL_XTAL_LBIAS2X_MASK) >> XTAL_XTAL_LBIAS2X_LSB)
+#define XTAL_XTAL_LBIAS2X_SET(x)                                     (((x) << XTAL_XTAL_LBIAS2X_LSB) & XTAL_XTAL_LBIAS2X_MASK)
+#define XTAL_XTAL_LBIAS2X_RESET                                      0x1 // 1
+#define XTAL_XTAL_ATBVREG_MSB                                        9
+#define XTAL_XTAL_ATBVREG_LSB                                        9
+#define XTAL_XTAL_ATBVREG_MASK                                       0x00000200
+#define XTAL_XTAL_ATBVREG_GET(x)                                     (((x) & XTAL_XTAL_ATBVREG_MASK) >> XTAL_XTAL_ATBVREG_LSB)
+#define XTAL_XTAL_ATBVREG_SET(x)                                     (((x) << XTAL_XTAL_ATBVREG_LSB) & XTAL_XTAL_ATBVREG_MASK)
+#define XTAL_XTAL_ATBVREG_RESET                                      0x0 // 0
+#define XTAL_XTAL_OSCON_MSB                                          8
+#define XTAL_XTAL_OSCON_LSB                                          8
+#define XTAL_XTAL_OSCON_MASK                                         0x00000100
+#define XTAL_XTAL_OSCON_GET(x)                                       (((x) & XTAL_XTAL_OSCON_MASK) >> XTAL_XTAL_OSCON_LSB)
+#define XTAL_XTAL_OSCON_SET(x)                                       (((x) << XTAL_XTAL_OSCON_LSB) & XTAL_XTAL_OSCON_MASK)
+#define XTAL_XTAL_OSCON_RESET                                        0x1 // 1
+#define XTAL_XTAL_PWDCLKIN_MSB                                       7
+#define XTAL_XTAL_PWDCLKIN_LSB                                       7
+#define XTAL_XTAL_PWDCLKIN_MASK                                      0x00000080
+#define XTAL_XTAL_PWDCLKIN_GET(x)                                    (((x) & XTAL_XTAL_PWDCLKIN_MASK) >> XTAL_XTAL_PWDCLKIN_LSB)
+#define XTAL_XTAL_PWDCLKIN_SET(x)                                    (((x) << XTAL_XTAL_PWDCLKIN_LSB) & XTAL_XTAL_PWDCLKIN_MASK)
+#define XTAL_XTAL_PWDCLKIN_RESET                                     0x0 // 0
+#define XTAL_LOCAL_XTAL_MSB                                          6
+#define XTAL_LOCAL_XTAL_LSB                                          6
+#define XTAL_LOCAL_XTAL_MASK                                         0x00000040
+#define XTAL_LOCAL_XTAL_GET(x)                                       (((x) & XTAL_LOCAL_XTAL_MASK) >> XTAL_LOCAL_XTAL_LSB)
+#define XTAL_LOCAL_XTAL_SET(x)                                       (((x) << XTAL_LOCAL_XTAL_LSB) & XTAL_LOCAL_XTAL_MASK)
+#define XTAL_LOCAL_XTAL_RESET                                        0x0 // 0
+#define XTAL_PWD_SWREGCLK_MSB                                        5
+#define XTAL_PWD_SWREGCLK_LSB                                        5
+#define XTAL_PWD_SWREGCLK_MASK                                       0x00000020
+#define XTAL_PWD_SWREGCLK_GET(x)                                     (((x) & XTAL_PWD_SWREGCLK_MASK) >> XTAL_PWD_SWREGCLK_LSB)
+#define XTAL_PWD_SWREGCLK_SET(x)                                     (((x) << XTAL_PWD_SWREGCLK_LSB) & XTAL_PWD_SWREGCLK_MASK)
+#define XTAL_PWD_SWREGCLK_RESET                                      0x0 // 0
+#define XTAL_SWREGCLK_EDGE_SEL_MSB                                   4
+#define XTAL_SWREGCLK_EDGE_SEL_LSB                                   4
+#define XTAL_SWREGCLK_EDGE_SEL_MASK                                  0x00000010
+#define XTAL_SWREGCLK_EDGE_SEL_GET(x)                                (((x) & XTAL_SWREGCLK_EDGE_SEL_MASK) >> XTAL_SWREGCLK_EDGE_SEL_LSB)
+#define XTAL_SWREGCLK_EDGE_SEL_SET(x)                                (((x) << XTAL_SWREGCLK_EDGE_SEL_LSB) & XTAL_SWREGCLK_EDGE_SEL_MASK)
+#define XTAL_SWREGCLK_EDGE_SEL_RESET                                 0x0 // 0
+#define XTAL_SPARE_MSB                                               3
+#define XTAL_SPARE_LSB                                               0
+#define XTAL_SPARE_MASK                                              0x0000000f
+#define XTAL_SPARE_GET(x)                                            (((x) & XTAL_SPARE_MASK) >> XTAL_SPARE_LSB)
+#define XTAL_SPARE_SET(x)                                            (((x) << XTAL_SPARE_LSB) & XTAL_SPARE_MASK)
+#define XTAL_SPARE_RESET                                             0xf // 15
+#define XTAL_ADDRESS                                                 0x18116290
+
+#define RST_REVISION_ID_ADDRESS                                      0x18060090
+#define is_drqfn()	(!(ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0x1000))
+
+#define RST_BOOTSTRAP_BOOT_INTF_SEL_MSB                              17
+#define RST_BOOTSTRAP_BOOT_INTF_SEL_LSB                              16
+#define RST_BOOTSTRAP_BOOT_INTF_SEL_MASK                             0x00030000
+#define RST_BOOTSTRAP_BOOT_INTF_SEL_GET(x)                           (((x) & RST_BOOTSTRAP_BOOT_INTF_SEL_MASK) >> RST_BOOTSTRAP_BOOT_INTF_SEL_LSB)
+#define RST_BOOTSTRAP_BOOT_INTF_SEL_SET(x)                           (((x) << RST_BOOTSTRAP_BOOT_INTF_SEL_LSB) & RST_BOOTSTRAP_BOOT_INTF_SEL_MASK)
+#define RST_BOOTSTRAP_BOOT_INTF_SEL_RESET                            0x0 // 0
+#define RST_BOOTSTRAP_RES0_MSB                                       15
+#define RST_BOOTSTRAP_RES0_LSB                                       13
+#define RST_BOOTSTRAP_RES0_MASK                                      0x0000e000
+#define RST_BOOTSTRAP_RES0_GET(x)                                    (((x) & RST_BOOTSTRAP_RES0_MASK) >> RST_BOOTSTRAP_RES0_LSB)
+#define RST_BOOTSTRAP_RES0_SET(x)                                    (((x) << RST_BOOTSTRAP_RES0_LSB) & RST_BOOTSTRAP_RES0_MASK)
+#define RST_BOOTSTRAP_RES0_RESET                                     0x0 // 0
+#define RST_BOOTSTRAP_SW_OPTION2_MSB                                 12
+#define RST_BOOTSTRAP_SW_OPTION2_LSB                                 12
+#define RST_BOOTSTRAP_SW_OPTION2_MASK                                0x00001000
+#define RST_BOOTSTRAP_SW_OPTION2_GET(x)                              (((x) & RST_BOOTSTRAP_SW_OPTION2_MASK) >> RST_BOOTSTRAP_SW_OPTION2_LSB)
+#define RST_BOOTSTRAP_SW_OPTION2_SET(x)                              (((x) << RST_BOOTSTRAP_SW_OPTION2_LSB) & RST_BOOTSTRAP_SW_OPTION2_MASK)
+#define RST_BOOTSTRAP_SW_OPTION2_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_SW_OPTION1_MSB                                 11
+#define RST_BOOTSTRAP_SW_OPTION1_LSB                                 11
+#define RST_BOOTSTRAP_SW_OPTION1_MASK                                0x00000800
+#define RST_BOOTSTRAP_SW_OPTION1_GET(x)                              (((x) & RST_BOOTSTRAP_SW_OPTION1_MASK) >> RST_BOOTSTRAP_SW_OPTION1_LSB)
+#define RST_BOOTSTRAP_SW_OPTION1_SET(x)                              (((x) << RST_BOOTSTRAP_SW_OPTION1_LSB) & RST_BOOTSTRAP_SW_OPTION1_MASK)
+#define RST_BOOTSTRAP_SW_OPTION1_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_TESTROM_DISABLE_MSB                            10
+#define RST_BOOTSTRAP_TESTROM_DISABLE_LSB                            10
+#define RST_BOOTSTRAP_TESTROM_DISABLE_MASK                           0x00000400
+#define RST_BOOTSTRAP_TESTROM_DISABLE_GET(x)                         (((x) & RST_BOOTSTRAP_TESTROM_DISABLE_MASK) >> RST_BOOTSTRAP_TESTROM_DISABLE_LSB)
+#define RST_BOOTSTRAP_TESTROM_DISABLE_SET(x)                         (((x) << RST_BOOTSTRAP_TESTROM_DISABLE_LSB) & RST_BOOTSTRAP_TESTROM_DISABLE_MASK)
+#define RST_BOOTSTRAP_TESTROM_DISABLE_RESET                          0x1 // 1
+#define RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_MSB                      9
+#define RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_LSB                      9
+#define RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_MASK                     0x00000200
+#define RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_GET(x)                   (((x) & RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_MASK) >> RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_LSB)
+#define RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_SET(x)                   (((x) << RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_LSB) & RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_MASK)
+#define RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_RESET                    0x0 // 0
+#define RST_BOOTSTRAP_SRIF_ENABLE_MSB                                8
+#define RST_BOOTSTRAP_SRIF_ENABLE_LSB                                8
+#define RST_BOOTSTRAP_SRIF_ENABLE_MASK                               0x00000100
+#define RST_BOOTSTRAP_SRIF_ENABLE_GET(x)                             (((x) & RST_BOOTSTRAP_SRIF_ENABLE_MASK) >> RST_BOOTSTRAP_SRIF_ENABLE_LSB)
+#define RST_BOOTSTRAP_SRIF_ENABLE_SET(x)                             (((x) << RST_BOOTSTRAP_SRIF_ENABLE_LSB) & RST_BOOTSTRAP_SRIF_ENABLE_MASK)
+#define RST_BOOTSTRAP_SRIF_ENABLE_RESET                              0x0 // 0
+#define RST_BOOTSTRAP_USB_MODE_MSB                                   7
+#define RST_BOOTSTRAP_USB_MODE_LSB                                   7
+#define RST_BOOTSTRAP_USB_MODE_MASK                                  0x00000080
+#define RST_BOOTSTRAP_USB_MODE_GET(x)                                (((x) & RST_BOOTSTRAP_USB_MODE_MASK) >> RST_BOOTSTRAP_USB_MODE_LSB)
+#define RST_BOOTSTRAP_USB_MODE_SET(x)                                (((x) << RST_BOOTSTRAP_USB_MODE_LSB) & RST_BOOTSTRAP_USB_MODE_MASK)
+#define RST_BOOTSTRAP_USB_MODE_RESET                                 0x0 // 0
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MSB                          6
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_LSB                          6
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MASK                         0x00000040
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_GET(x)                       (((x) & RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MASK) >> RST_BOOTSTRAP_PCIE_RC_EP_SELECT_LSB)
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_SET(x)                       (((x) << RST_BOOTSTRAP_PCIE_RC_EP_SELECT_LSB) & RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MASK)
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_RESET                        0x0 // 0
+#define RST_BOOTSTRAP_JTAG_MODE_MSB                                  5
+#define RST_BOOTSTRAP_JTAG_MODE_LSB                                  5
+#define RST_BOOTSTRAP_JTAG_MODE_MASK                                 0x00000020
+#define RST_BOOTSTRAP_JTAG_MODE_GET(x)                               (((x) & RST_BOOTSTRAP_JTAG_MODE_MASK) >> RST_BOOTSTRAP_JTAG_MODE_LSB)
+#define RST_BOOTSTRAP_JTAG_MODE_SET(x)                               (((x) << RST_BOOTSTRAP_JTAG_MODE_LSB) & RST_BOOTSTRAP_JTAG_MODE_MASK)
+#define RST_BOOTSTRAP_JTAG_MODE_RESET                                0x1 // 1
+#define RST_BOOTSTRAP_REF_CLK_MSB                                    4
+#define RST_BOOTSTRAP_REF_CLK_LSB                                    4
+#define RST_BOOTSTRAP_REF_CLK_MASK                                   0x00000010
+#define RST_BOOTSTRAP_REF_CLK_GET(x)                                 (((x) & RST_BOOTSTRAP_REF_CLK_MASK) >> RST_BOOTSTRAP_REF_CLK_LSB)
+#define RST_BOOTSTRAP_REF_CLK_SET(x)                                 (((x) << RST_BOOTSTRAP_REF_CLK_LSB) & RST_BOOTSTRAP_REF_CLK_MASK)
+#define RST_BOOTSTRAP_REF_CLK_RESET                                  0x0 // 0
+#define RST_BOOTSTRAP_DDR_WIDTH_MSB                                  3
+#define RST_BOOTSTRAP_DDR_WIDTH_LSB                                  3
+#define RST_BOOTSTRAP_DDR_WIDTH_MASK                                 0x00000008
+#define RST_BOOTSTRAP_DDR_WIDTH_GET(x)                               (((x) & RST_BOOTSTRAP_DDR_WIDTH_MASK) >> RST_BOOTSTRAP_DDR_WIDTH_LSB)
+#define RST_BOOTSTRAP_DDR_WIDTH_SET(x)                               (((x) << RST_BOOTSTRAP_DDR_WIDTH_LSB) & RST_BOOTSTRAP_DDR_WIDTH_MASK)
+#define RST_BOOTSTRAP_DDR_WIDTH_RESET                                0x0 // 0
+#define RST_BOOTSTRAP_BOOT_SELECT_MSB                                2
+#define RST_BOOTSTRAP_BOOT_SELECT_LSB                                2
+#define RST_BOOTSTRAP_BOOT_SELECT_MASK                               0x00000004
+#define RST_BOOTSTRAP_BOOT_SELECT_GET(x)                             (((x) & RST_BOOTSTRAP_BOOT_SELECT_MASK) >> RST_BOOTSTRAP_BOOT_SELECT_LSB)
+#define RST_BOOTSTRAP_BOOT_SELECT_SET(x)                             (((x) << RST_BOOTSTRAP_BOOT_SELECT_LSB) & RST_BOOTSTRAP_BOOT_SELECT_MASK)
+#define RST_BOOTSTRAP_BOOT_SELECT_RESET                              0x0 // 0
+#define RST_BOOTSTRAP_SDRAM_DISABLE_MSB                              1
+#define RST_BOOTSTRAP_SDRAM_DISABLE_LSB                              1
+#define RST_BOOTSTRAP_SDRAM_DISABLE_MASK                             0x00000002
+#define RST_BOOTSTRAP_SDRAM_DISABLE_GET(x)                           (((x) & RST_BOOTSTRAP_SDRAM_DISABLE_MASK) >> RST_BOOTSTRAP_SDRAM_DISABLE_LSB)
+#define RST_BOOTSTRAP_SDRAM_DISABLE_SET(x)                           (((x) << RST_BOOTSTRAP_SDRAM_DISABLE_LSB) & RST_BOOTSTRAP_SDRAM_DISABLE_MASK)
+#define RST_BOOTSTRAP_SDRAM_DISABLE_RESET                            0x0 // 0
+#define RST_BOOTSTRAP_DDR_SELECT_MSB                                 0
+#define RST_BOOTSTRAP_DDR_SELECT_LSB                                 0
+#define RST_BOOTSTRAP_DDR_SELECT_MASK                                0x00000001
+#define RST_BOOTSTRAP_DDR_SELECT_GET(x)                              (((x) & RST_BOOTSTRAP_DDR_SELECT_MASK) >> RST_BOOTSTRAP_DDR_SELECT_LSB)
+#define RST_BOOTSTRAP_DDR_SELECT_SET(x)                              (((x) << RST_BOOTSTRAP_DDR_SELECT_LSB) & RST_BOOTSTRAP_DDR_SELECT_MASK)
+#define RST_BOOTSTRAP_DDR_SELECT_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_ADDRESS                                        0x180600b0
+
+#define GPIO_OE_ADDRESS                                              0x18040000
+#define GPIO_OUT_ADDRESS                                             0x18040008
+#define GPIO_SPARE_ADDRESS                                           0x18040028
+
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MSB                         31
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB                         24
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK                        0xff000000
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_RESET                       0xb // 11
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MSB                         23
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB                         16
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK                        0x00ff0000
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_RESET                       0xa // 10
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MSB                         15
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB                         8
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_RESET                       0x9 // 9
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MSB                         7
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB                         0
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_RESET                       0x14 // 20
+#define GPIO_OUT_FUNCTION1_ADDRESS                                   0x18040030
+
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MSB                        31
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB                        24
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_GET(x)                     (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_SET(x)                     (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MSB                        23
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB                        16
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK                       0x00ff0000
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_GET(x)                     (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_SET(x)                     (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MSB                         15
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB                         8
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_GET(x)                      (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_SET(x)                      (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MSB                         7
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB                         0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_GET(x)                      (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_SET(x)                      (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION2_ADDRESS                                   0x18040034
+
+#define GPIO_IN_ENABLE0_UART_SIN_MSB                                 15
+#define GPIO_IN_ENABLE0_UART_SIN_LSB                                 8
+#define GPIO_IN_ENABLE0_UART_SIN_MASK                                0x0000ff00
+#define GPIO_IN_ENABLE0_UART_SIN_GET(x)                              (((x) & GPIO_IN_ENABLE0_UART_SIN_MASK) >> GPIO_IN_ENABLE0_UART_SIN_LSB)
+#define GPIO_IN_ENABLE0_UART_SIN_SET(x)                              (((x) << GPIO_IN_ENABLE0_UART_SIN_LSB) & GPIO_IN_ENABLE0_UART_SIN_MASK)
+#define GPIO_IN_ENABLE0_UART_SIN_RESET                               0x0 // 0
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_MSB                              7
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_LSB                              0
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_MASK                             0x000000ff
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_GET(x)                           (((x) & GPIO_IN_ENABLE0_SPI_DATA_IN_MASK) >> GPIO_IN_ENABLE0_SPI_DATA_IN_LSB)
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_SET(x)                           (((x) << GPIO_IN_ENABLE0_SPI_DATA_IN_LSB) & GPIO_IN_ENABLE0_SPI_DATA_IN_MASK)
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_RESET                            0x8 // 8
+#define GPIO_IN_ENABLE0_ADDRESS                                      0x18040044
+
+
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_MSB                              23
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_LSB                              16
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_MASK                             0x00ff0000
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_GET(x)                           (((x) & GPIO_IN_ENABLE3_MII_GE1_MDI_MASK) >> GPIO_IN_ENABLE3_MII_GE1_MDI_LSB)
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_SET(x)                           (((x) << GPIO_IN_ENABLE3_MII_GE1_MDI_LSB) & GPIO_IN_ENABLE3_MII_GE1_MDI_MASK)
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_RESET                            0x80 // 128
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDC_MSB                             15
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDC_LSB                             8
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDC_MASK                            0x0000ff00
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDC_GET(x)                          (((x) & GPIO_IN_ENABLE3_BOOT_EXT_MDC_MASK) >> GPIO_IN_ENABLE3_BOOT_EXT_MDC_LSB)
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDC_SET(x)                          (((x) << GPIO_IN_ENABLE3_BOOT_EXT_MDC_LSB) & GPIO_IN_ENABLE3_BOOT_EXT_MDC_MASK)
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDC_RESET                           0x80 // 128
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDO_MSB                             7
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDO_LSB                             0
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDO_MASK                            0x000000ff
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDO_GET(x)                          (((x) & GPIO_IN_ENABLE3_BOOT_EXT_MDO_MASK) >> GPIO_IN_ENABLE3_BOOT_EXT_MDO_LSB)
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDO_SET(x)                          (((x) << GPIO_IN_ENABLE3_BOOT_EXT_MDO_LSB) & GPIO_IN_ENABLE3_BOOT_EXT_MDO_MASK)
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDO_RESET                           0x80 // 128
+#define GPIO_IN_ENABLE3_ADDRESS                                      0x18040050
+
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MSB                        31
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB                        24
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MSB                        23
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB                        16
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK                       0x00ff0000
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MSB                        15
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB                        8
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK                       0x0000ff00
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MSB                        7
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB                        0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK                       0x000000ff
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ADDRESS				     0x18040038
+
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MSB                        31
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_LSB                        24
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MSB                        23
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_LSB                        16
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MASK                       0x00ff0000
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MSB                        15
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB                        8
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK                       0x0000ff00
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MSB                        7
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB                        0
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK                       0x000000ff
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION4_ADDRESS                                   0x1804003c
+
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_MSB                            11
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_LSB                            11
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_MASK                           0x00000800
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS9_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS9_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS9_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS9_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_MSB                            10
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_LSB                            10
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_MASK                           0x00000400
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS8_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS8_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS8_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS8_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_MSB                            9
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_LSB                            9
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_MASK                           0x00000200
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS7_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS7_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS7_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS7_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_MSB                            8
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB                            8
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK                           0x00000100
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_MSB                            7
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB                            7
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK                           0x00000080
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_RESET                          0x1 // 1
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_MSB                            6
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB                            6
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK                           0x00000040
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_MSB                            5
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB                            5
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK                           0x00000020
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_MSB                            4
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB                            4
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK                           0x00000010
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_MSB                            3
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB                            3
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK                           0x00000008
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_MSB                            2
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB                            2
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK                           0x00000004
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_DISABLE_JTAG_MSB                               1
+#define GPIO_FUNCTION_DISABLE_JTAG_LSB                               1
+#define GPIO_FUNCTION_DISABLE_JTAG_MASK                              0x00000002
+#define GPIO_FUNCTION_DISABLE_JTAG_GET(x)                            (((x) & GPIO_FUNCTION_DISABLE_JTAG_MASK) >> GPIO_FUNCTION_DISABLE_JTAG_LSB)
+#define GPIO_FUNCTION_DISABLE_JTAG_SET(x)                            (((x) << GPIO_FUNCTION_DISABLE_JTAG_LSB) & GPIO_FUNCTION_DISABLE_JTAG_MASK)
+#define GPIO_FUNCTION_DISABLE_JTAG_RESET                             0x0 // 0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_MSB                           0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB                           0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK                          0x00000001
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_GET(x)                        (((x) & GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK) >> GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB)
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_SET(x)                        (((x) << GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB) & GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK)
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_RESET                         0x0 // 0
+#define GPIO_FUNCTION_ADDRESS                                        0x1804006c
+
+
+
+#define PCIE_RESET_EP_RESET_L_MSB                                    2
+#define PCIE_RESET_EP_RESET_L_LSB                                    2
+#define PCIE_RESET_EP_RESET_L_MASK                                   0x00000004
+#define PCIE_RESET_EP_RESET_L_GET(x)                                 (((x) & PCIE_RESET_EP_RESET_L_MASK) >> PCIE_RESET_EP_RESET_L_LSB)
+#define PCIE_RESET_EP_RESET_L_SET(x)                                 (((x) << PCIE_RESET_EP_RESET_L_LSB) & PCIE_RESET_EP_RESET_L_MASK)
+#define PCIE_RESET_EP_RESET_L_RESET                                  0x0 // 0
+#define PCIE_RESET_LINK_REQ_RESET_MSB                                1
+#define PCIE_RESET_LINK_REQ_RESET_LSB                                1
+#define PCIE_RESET_LINK_REQ_RESET_MASK                               0x00000002
+#define PCIE_RESET_LINK_REQ_RESET_GET(x)                             (((x) & PCIE_RESET_LINK_REQ_RESET_MASK) >> PCIE_RESET_LINK_REQ_RESET_LSB)
+#define PCIE_RESET_LINK_REQ_RESET_SET(x)                             (((x) << PCIE_RESET_LINK_REQ_RESET_LSB) & PCIE_RESET_LINK_REQ_RESET_MASK)
+#define PCIE_RESET_LINK_REQ_RESET_RESET                              0x0 // 0
+#define PCIE_RESET_LINK_UP_MSB                                       0
+#define PCIE_RESET_LINK_UP_LSB                                       0
+#define PCIE_RESET_LINK_UP_MASK                                      0x00000001
+#define PCIE_RESET_LINK_UP_GET(x)                                    (((x) & PCIE_RESET_LINK_UP_MASK) >> PCIE_RESET_LINK_UP_LSB)
+#define PCIE_RESET_LINK_UP_SET(x)                                    (((x) << PCIE_RESET_LINK_UP_LSB) & PCIE_RESET_LINK_UP_MASK)
+#define PCIE_RESET_LINK_UP_RESET                                     0x0 // 0
+#define PCIE_RESET_ADDRESS                                           0x180f0018
+
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_MSB                          2
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_LSB                          2
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_MASK                         0x00000004
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_GET(x)                       (((x) & ETH_SGMII_SERDES_EN_LOCK_DETECT_MASK) >> ETH_SGMII_SERDES_EN_LOCK_DETECT_LSB)
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_SET(x)                       (((x) << ETH_SGMII_SERDES_EN_LOCK_DETECT_LSB) & ETH_SGMII_SERDES_EN_LOCK_DETECT_MASK)
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_RESET                        0x0 // 0
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_MSB                          1
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_LSB                          1
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_MASK                         0x00000002
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_GET(x)                       (((x) & ETH_SGMII_SERDES_PLL_REFCLK_SEL_MASK) >> ETH_SGMII_SERDES_PLL_REFCLK_SEL_LSB)
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_SET(x)                       (((x) << ETH_SGMII_SERDES_PLL_REFCLK_SEL_LSB) & ETH_SGMII_SERDES_PLL_REFCLK_SEL_MASK)
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_RESET                        0x0 // 0
+#define ETH_SGMII_SERDES_EN_PLL_MSB                                  0
+#define ETH_SGMII_SERDES_EN_PLL_LSB                                  0
+#define ETH_SGMII_SERDES_EN_PLL_MASK                                 0x00000001
+#define ETH_SGMII_SERDES_EN_PLL_GET(x)                               (((x) & ETH_SGMII_SERDES_EN_PLL_MASK) >> ETH_SGMII_SERDES_EN_PLL_LSB)
+#define ETH_SGMII_SERDES_EN_PLL_SET(x)                               (((x) << ETH_SGMII_SERDES_EN_PLL_LSB) & ETH_SGMII_SERDES_EN_PLL_MASK)
+#define ETH_SGMII_SERDES_EN_PLL_RESET                                0x1 // 1
+#define ETH_SGMII_SERDES_ADDRESS                                     0x1805004c
+
+
+#define ETH_CFG_ETH_SPARE_MSB                                        31
+#define ETH_CFG_ETH_SPARE_LSB                                        22
+#define ETH_CFG_ETH_SPARE_MASK                                       0xffc00000
+#define ETH_CFG_ETH_SPARE_GET(x)                                     (((x) & ETH_CFG_ETH_SPARE_MASK) >> ETH_CFG_ETH_SPARE_LSB)
+#define ETH_CFG_ETH_SPARE_SET(x)                                     (((x) << ETH_CFG_ETH_SPARE_LSB) & ETH_CFG_ETH_SPARE_MASK)
+#define ETH_CFG_ETH_SPARE_RESET                                      0x0 // 0
+#define ETH_CFG_ETH_TXEN_DELAY_MSB                                   21
+#define ETH_CFG_ETH_TXEN_DELAY_LSB                                   20
+#define ETH_CFG_ETH_TXEN_DELAY_MASK                                  0x00300000
+#define ETH_CFG_ETH_TXEN_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_TXEN_DELAY_MASK) >> ETH_CFG_ETH_TXEN_DELAY_LSB)
+#define ETH_CFG_ETH_TXEN_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_TXEN_DELAY_LSB) & ETH_CFG_ETH_TXEN_DELAY_MASK)
+#define ETH_CFG_ETH_TXEN_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_TXD_DELAY_MSB                                    19
+#define ETH_CFG_ETH_TXD_DELAY_LSB                                    18
+#define ETH_CFG_ETH_TXD_DELAY_MASK                                   0x000c0000
+#define ETH_CFG_ETH_TXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_TXD_DELAY_MASK) >> ETH_CFG_ETH_TXD_DELAY_LSB)
+#define ETH_CFG_ETH_TXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_TXD_DELAY_LSB) & ETH_CFG_ETH_TXD_DELAY_MASK)
+#define ETH_CFG_ETH_TXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_ETH_RXDV_DELAY_MSB                                   17
+#define ETH_CFG_ETH_RXDV_DELAY_LSB                                   16
+#define ETH_CFG_ETH_RXDV_DELAY_MASK                                  0x00030000
+#define ETH_CFG_ETH_RXDV_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_RXDV_DELAY_MASK) >> ETH_CFG_ETH_RXDV_DELAY_LSB)
+#define ETH_CFG_ETH_RXDV_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_RXDV_DELAY_LSB) & ETH_CFG_ETH_RXDV_DELAY_MASK)
+#define ETH_CFG_ETH_RXDV_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_RXD_DELAY_MSB                                    15
+#define ETH_CFG_ETH_RXD_DELAY_LSB                                    14
+#define ETH_CFG_ETH_RXD_DELAY_MASK                                   0x0000c000
+#define ETH_CFG_ETH_RXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_RXD_DELAY_MASK) >> ETH_CFG_ETH_RXD_DELAY_LSB)
+#define ETH_CFG_ETH_RXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_RXD_DELAY_LSB) & ETH_CFG_ETH_RXD_DELAY_MASK)
+#define ETH_CFG_ETH_RXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_RMII_GE0_MASTER_MSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_LSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_MASK                                 0x00001000
+#define ETH_CFG_RMII_GE0_MASTER_GET(x)                               (((x) & ETH_CFG_RMII_GE0_MASTER_MASK) >> ETH_CFG_RMII_GE0_MASTER_LSB)
+#define ETH_CFG_RMII_GE0_MASTER_SET(x)                               (((x) << ETH_CFG_RMII_GE0_MASTER_LSB) & ETH_CFG_RMII_GE0_MASTER_MASK)
+#define ETH_CFG_RMII_GE0_MASTER_RESET                                0x1 // 1
+#define ETH_CFG_MII_CNTL_SPEED_MSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_LSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_MASK                                  0x00000800
+#define ETH_CFG_MII_CNTL_SPEED_GET(x)                                (((x) & ETH_CFG_MII_CNTL_SPEED_MASK) >> ETH_CFG_MII_CNTL_SPEED_LSB)
+#define ETH_CFG_MII_CNTL_SPEED_SET(x)                                (((x) << ETH_CFG_MII_CNTL_SPEED_LSB) & ETH_CFG_MII_CNTL_SPEED_MASK)
+#define ETH_CFG_MII_CNTL_SPEED_RESET                                 0x0 // 0
+#define ETH_CFG_RMII_GE0_MSB                                         10
+#define ETH_CFG_RMII_GE0_LSB                                         10
+#define ETH_CFG_RMII_GE0_MASK                                        0x00000400
+#define ETH_CFG_RMII_GE0_GET(x)                                      (((x) & ETH_CFG_RMII_GE0_MASK) >> ETH_CFG_RMII_GE0_LSB)
+#define ETH_CFG_RMII_GE0_SET(x)                                      (((x) << ETH_CFG_RMII_GE0_LSB) & ETH_CFG_RMII_GE0_MASK)
+#define ETH_CFG_RMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_GE0_SGMII_MSB                                        6
+#define ETH_CFG_GE0_SGMII_LSB                                        6
+#define ETH_CFG_GE0_SGMII_MASK                                       0x00000040
+#define ETH_CFG_GE0_SGMII_GET(x)                                     (((x) & ETH_CFG_GE0_SGMII_MASK) >> ETH_CFG_GE0_SGMII_LSB)
+#define ETH_CFG_GE0_SGMII_SET(x)                                     (((x) << ETH_CFG_GE0_SGMII_LSB) & ETH_CFG_GE0_SGMII_MASK)
+#define ETH_CFG_GE0_SGMII_RESET                                      0x0 // 0
+#define ETH_CFG_GE0_ERR_EN_MSB                                       5
+#define ETH_CFG_GE0_ERR_EN_LSB                                       5
+#define ETH_CFG_GE0_ERR_EN_MASK                                      0x00000020
+#define ETH_CFG_GE0_ERR_EN_GET(x)                                    (((x) & ETH_CFG_GE0_ERR_EN_MASK) >> ETH_CFG_GE0_ERR_EN_LSB)
+#define ETH_CFG_GE0_ERR_EN_SET(x)                                    (((x) << ETH_CFG_GE0_ERR_EN_LSB) & ETH_CFG_GE0_ERR_EN_MASK)
+#define ETH_CFG_GE0_ERR_EN_RESET                                     0x0 // 0
+#define ETH_CFG_MII_GE0_SLAVE_MSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_LSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_MASK                                   0x00000010
+#define ETH_CFG_MII_GE0_SLAVE_GET(x)                                 (((x) & ETH_CFG_MII_GE0_SLAVE_MASK) >> ETH_CFG_MII_GE0_SLAVE_LSB)
+#define ETH_CFG_MII_GE0_SLAVE_SET(x)                                 (((x) << ETH_CFG_MII_GE0_SLAVE_LSB) & ETH_CFG_MII_GE0_SLAVE_MASK)
+#define ETH_CFG_MII_GE0_SLAVE_RESET                                  0x0 // 0
+#define ETH_CFG_MII_GE0_MASTER_MSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_LSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_MASK                                  0x00000008
+#define ETH_CFG_MII_GE0_MASTER_GET(x)                                (((x) & ETH_CFG_MII_GE0_MASTER_MASK) >> ETH_CFG_MII_GE0_MASTER_LSB)
+#define ETH_CFG_MII_GE0_MASTER_SET(x)                                (((x) << ETH_CFG_MII_GE0_MASTER_LSB) & ETH_CFG_MII_GE0_MASTER_MASK)
+#define ETH_CFG_MII_GE0_MASTER_RESET                                 0x0 // 0
+#define ETH_CFG_GMII_GE0_MSB                                         2
+#define ETH_CFG_GMII_GE0_LSB                                         2
+#define ETH_CFG_GMII_GE0_MASK                                        0x00000004
+#define ETH_CFG_GMII_GE0_GET(x)                                      (((x) & ETH_CFG_GMII_GE0_MASK) >> ETH_CFG_GMII_GE0_LSB)
+#define ETH_CFG_GMII_GE0_SET(x)                                      (((x) << ETH_CFG_GMII_GE0_LSB) & ETH_CFG_GMII_GE0_MASK)
+#define ETH_CFG_GMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_MII_GE0_MSB                                          1
+#define ETH_CFG_MII_GE0_LSB                                          1
+#define ETH_CFG_MII_GE0_MASK                                         0x00000002
+#define ETH_CFG_MII_GE0_GET(x)                                       (((x) & ETH_CFG_MII_GE0_MASK) >> ETH_CFG_MII_GE0_LSB)
+#define ETH_CFG_MII_GE0_SET(x)                                       (((x) << ETH_CFG_MII_GE0_LSB) & ETH_CFG_MII_GE0_MASK)
+#define ETH_CFG_MII_GE0_RESET                                        0x0 // 0
+#define ETH_CFG_RGMII_GE0_MSB                                        0
+#define ETH_CFG_RGMII_GE0_LSB                                        0
+#define ETH_CFG_RGMII_GE0_MASK                                       0x00000001
+#define ETH_CFG_RGMII_GE0_GET(x)                                     (((x) & ETH_CFG_RGMII_GE0_MASK) >> ETH_CFG_RGMII_GE0_LSB)
+#define ETH_CFG_RGMII_GE0_SET(x)                                     (((x) << ETH_CFG_RGMII_GE0_LSB) & ETH_CFG_RGMII_GE0_MASK)
+#define ETH_CFG_RGMII_GE0_RESET                                      0x0 // 0
+#define ETH_CFG_ADDRESS                                              0x18070000
+
+
+
+#define SGMII_SERDES_VCO_REG_MSB                                     30
+#define SGMII_SERDES_VCO_REG_LSB                                     27
+#define SGMII_SERDES_VCO_REG_MASK                                    0x78000000
+#define SGMII_SERDES_VCO_REG_GET(x)                                  (((x) & SGMII_SERDES_VCO_REG_MASK) >> SGMII_SERDES_VCO_REG_LSB)
+#define SGMII_SERDES_VCO_REG_SET(x)                                  (((x) << SGMII_SERDES_VCO_REG_LSB) & SGMII_SERDES_VCO_REG_MASK)
+#define SGMII_SERDES_VCO_REG_RESET                                   0x3 // 3
+#define SGMII_SERDES_RES_CALIBRATION_MSB                             26
+#define SGMII_SERDES_RES_CALIBRATION_LSB                             23
+#define SGMII_SERDES_RES_CALIBRATION_MASK                            0x07800000
+#define SGMII_SERDES_RES_CALIBRATION_GET(x)                          (((x) & SGMII_SERDES_RES_CALIBRATION_MASK) >> SGMII_SERDES_RES_CALIBRATION_LSB)
+#define SGMII_SERDES_RES_CALIBRATION_SET(x)                          (((x) << SGMII_SERDES_RES_CALIBRATION_LSB) & SGMII_SERDES_RES_CALIBRATION_MASK)
+#define SGMII_SERDES_RES_CALIBRATION_RESET                           0x0 // 0
+#define SGMII_SERDES_FIBER_MODE_MSB                                  21
+#define SGMII_SERDES_FIBER_MODE_LSB                                  20
+#define SGMII_SERDES_FIBER_MODE_MASK                                 0x00300000
+#define SGMII_SERDES_FIBER_MODE_GET(x)                               (((x) & SGMII_SERDES_FIBER_MODE_MASK) >> SGMII_SERDES_FIBER_MODE_LSB)
+#define SGMII_SERDES_FIBER_MODE_SET(x)                               (((x) << SGMII_SERDES_FIBER_MODE_LSB) & SGMII_SERDES_FIBER_MODE_MASK)
+#define SGMII_SERDES_FIBER_MODE_RESET                                0x0 // 0
+#define SGMII_SERDES_THRESHOLD_CTRL_MSB                              19
+#define SGMII_SERDES_THRESHOLD_CTRL_LSB                              18
+#define SGMII_SERDES_THRESHOLD_CTRL_MASK                             0x000c0000
+#define SGMII_SERDES_THRESHOLD_CTRL_GET(x)                           (((x) & SGMII_SERDES_THRESHOLD_CTRL_MASK) >> SGMII_SERDES_THRESHOLD_CTRL_LSB)
+#define SGMII_SERDES_THRESHOLD_CTRL_SET(x)                           (((x) << SGMII_SERDES_THRESHOLD_CTRL_LSB) & SGMII_SERDES_THRESHOLD_CTRL_MASK)
+#define SGMII_SERDES_THRESHOLD_CTRL_RESET                            0x0 // 0
+#define SGMII_SERDES_FIBER_SDO_MSB                                   17
+#define SGMII_SERDES_FIBER_SDO_LSB                                   17
+#define SGMII_SERDES_FIBER_SDO_MASK                                  0x00020000
+#define SGMII_SERDES_FIBER_SDO_GET(x)                                (((x) & SGMII_SERDES_FIBER_SDO_MASK) >> SGMII_SERDES_FIBER_SDO_LSB)
+#define SGMII_SERDES_FIBER_SDO_SET(x)                                (((x) << SGMII_SERDES_FIBER_SDO_LSB) & SGMII_SERDES_FIBER_SDO_MASK)
+#define SGMII_SERDES_FIBER_SDO_RESET                                 0x0 // 0
+#define SGMII_SERDES_EN_SIGNAL_DETECT_MSB                            16
+#define SGMII_SERDES_EN_SIGNAL_DETECT_LSB                            16
+#define SGMII_SERDES_EN_SIGNAL_DETECT_MASK                           0x00010000
+#define SGMII_SERDES_EN_SIGNAL_DETECT_GET(x)                         (((x) & SGMII_SERDES_EN_SIGNAL_DETECT_MASK) >> SGMII_SERDES_EN_SIGNAL_DETECT_LSB)
+#define SGMII_SERDES_EN_SIGNAL_DETECT_SET(x)                         (((x) << SGMII_SERDES_EN_SIGNAL_DETECT_LSB) & SGMII_SERDES_EN_SIGNAL_DETECT_MASK)
+#define SGMII_SERDES_EN_SIGNAL_DETECT_RESET                          0x1 // 1
+#define SGMII_SERDES_LOCK_DETECT_STATUS_MSB                          15
+#define SGMII_SERDES_LOCK_DETECT_STATUS_LSB                          15
+#define SGMII_SERDES_LOCK_DETECT_STATUS_MASK                         0x00008000
+#define SGMII_SERDES_LOCK_DETECT_STATUS_GET(x)                       (((x) & SGMII_SERDES_LOCK_DETECT_STATUS_MASK) >> SGMII_SERDES_LOCK_DETECT_STATUS_LSB)
+#define SGMII_SERDES_LOCK_DETECT_STATUS_SET(x)                       (((x) << SGMII_SERDES_LOCK_DETECT_STATUS_LSB) & SGMII_SERDES_LOCK_DETECT_STATUS_MASK)
+#define SGMII_SERDES_LOCK_DETECT_STATUS_RESET                        0x0 // 0
+#define SGMII_SERDES_SPARE0_MSB                                      14
+#define SGMII_SERDES_SPARE0_LSB                                      11
+#define SGMII_SERDES_SPARE0_MASK                                     0x00007800
+#define SGMII_SERDES_SPARE0_GET(x)                                   (((x) & SGMII_SERDES_SPARE0_MASK) >> SGMII_SERDES_SPARE0_LSB)
+#define SGMII_SERDES_SPARE0_SET(x)                                   (((x) << SGMII_SERDES_SPARE0_LSB) & SGMII_SERDES_SPARE0_MASK)
+#define SGMII_SERDES_SPARE0_RESET                                    0x0 // 0
+#define SGMII_SERDES_VCO_SLOW_MSB                                    10
+#define SGMII_SERDES_VCO_SLOW_LSB                                    10
+#define SGMII_SERDES_VCO_SLOW_MASK                                   0x00000400
+#define SGMII_SERDES_VCO_SLOW_GET(x)                                 (((x) & SGMII_SERDES_VCO_SLOW_MASK) >> SGMII_SERDES_VCO_SLOW_LSB)
+#define SGMII_SERDES_VCO_SLOW_SET(x)                                 (((x) << SGMII_SERDES_VCO_SLOW_LSB) & SGMII_SERDES_VCO_SLOW_MASK)
+#define SGMII_SERDES_VCO_SLOW_RESET                                  0x0 // 0
+#define SGMII_SERDES_VCO_FAST_MSB                                    9
+#define SGMII_SERDES_VCO_FAST_LSB                                    9
+#define SGMII_SERDES_VCO_FAST_MASK                                   0x00000200
+#define SGMII_SERDES_VCO_FAST_GET(x)                                 (((x) & SGMII_SERDES_VCO_FAST_MASK) >> SGMII_SERDES_VCO_FAST_LSB)
+#define SGMII_SERDES_VCO_FAST_SET(x)                                 (((x) << SGMII_SERDES_VCO_FAST_LSB) & SGMII_SERDES_VCO_FAST_MASK)
+#define SGMII_SERDES_VCO_FAST_RESET                                  0x0 // 0
+#define SGMII_SERDES_PLL_BW_MSB                                      8
+#define SGMII_SERDES_PLL_BW_LSB                                      8
+#define SGMII_SERDES_PLL_BW_MASK                                     0x00000100
+#define SGMII_SERDES_PLL_BW_GET(x)                                   (((x) & SGMII_SERDES_PLL_BW_MASK) >> SGMII_SERDES_PLL_BW_LSB)
+#define SGMII_SERDES_PLL_BW_SET(x)                                   (((x) << SGMII_SERDES_PLL_BW_LSB) & SGMII_SERDES_PLL_BW_MASK)
+#define SGMII_SERDES_PLL_BW_RESET                                    0x1 // 1
+#define SGMII_SERDES_TX_IMPEDANCE_MSB                                7
+#define SGMII_SERDES_TX_IMPEDANCE_LSB                                7
+#define SGMII_SERDES_TX_IMPEDANCE_MASK                               0x00000080
+#define SGMII_SERDES_TX_IMPEDANCE_GET(x)                             (((x) & SGMII_SERDES_TX_IMPEDANCE_MASK) >> SGMII_SERDES_TX_IMPEDANCE_LSB)
+#define SGMII_SERDES_TX_IMPEDANCE_SET(x)                             (((x) << SGMII_SERDES_TX_IMPEDANCE_LSB) & SGMII_SERDES_TX_IMPEDANCE_MASK)
+#define SGMII_SERDES_TX_IMPEDANCE_RESET                              0x0 // 0
+#define SGMII_SERDES_TX_DR_CTRL_MSB                                  6
+#define SGMII_SERDES_TX_DR_CTRL_LSB                                  4
+#define SGMII_SERDES_TX_DR_CTRL_MASK                                 0x00000070
+#define SGMII_SERDES_TX_DR_CTRL_GET(x)                               (((x) & SGMII_SERDES_TX_DR_CTRL_MASK) >> SGMII_SERDES_TX_DR_CTRL_LSB)
+#define SGMII_SERDES_TX_DR_CTRL_SET(x)                               (((x) << SGMII_SERDES_TX_DR_CTRL_LSB) & SGMII_SERDES_TX_DR_CTRL_MASK)
+#define SGMII_SERDES_TX_DR_CTRL_RESET                                0x1 // 1
+#define SGMII_SERDES_HALF_TX_MSB                                     3
+#define SGMII_SERDES_HALF_TX_LSB                                     3
+#define SGMII_SERDES_HALF_TX_MASK                                    0x00000008
+#define SGMII_SERDES_HALF_TX_GET(x)                                  (((x) & SGMII_SERDES_HALF_TX_MASK) >> SGMII_SERDES_HALF_TX_LSB)
+#define SGMII_SERDES_HALF_TX_SET(x)                                  (((x) << SGMII_SERDES_HALF_TX_LSB) & SGMII_SERDES_HALF_TX_MASK)
+#define SGMII_SERDES_HALF_TX_RESET                                   0x0 // 0
+#define SGMII_SERDES_CDR_BW_MSB                                      2
+#define SGMII_SERDES_CDR_BW_LSB                                      1
+#define SGMII_SERDES_CDR_BW_MASK                                     0x00000006
+#define SGMII_SERDES_CDR_BW_GET(x)                                   (((x) & SGMII_SERDES_CDR_BW_MASK) >> SGMII_SERDES_CDR_BW_LSB)
+#define SGMII_SERDES_CDR_BW_SET(x)                                   (((x) << SGMII_SERDES_CDR_BW_LSB) & SGMII_SERDES_CDR_BW_MASK)
+#define SGMII_SERDES_CDR_BW_RESET                                    0x3 // 3
+#define SGMII_SERDES_RX_IMPEDANCE_MSB                                0
+#define SGMII_SERDES_RX_IMPEDANCE_LSB                                0
+#define SGMII_SERDES_RX_IMPEDANCE_MASK                               0x00000001
+#define SGMII_SERDES_RX_IMPEDANCE_GET(x)                             (((x) & SGMII_SERDES_RX_IMPEDANCE_MASK) >> SGMII_SERDES_RX_IMPEDANCE_LSB)
+#define SGMII_SERDES_RX_IMPEDANCE_SET(x)                             (((x) << SGMII_SERDES_RX_IMPEDANCE_LSB) & SGMII_SERDES_RX_IMPEDANCE_MASK)
+#define SGMII_SERDES_RX_IMPEDANCE_RESET                              0x0 // 0
+#define SGMII_SERDES_ADDRESS                                         0x18070018
+
+#define RST_RESET2_SPARE_MSB                                         31
+#define RST_RESET2_SPARE_LSB                                         19
+#define RST_RESET2_SPARE_MASK                                        0xfff80000
+#define RST_RESET2_SPARE_GET(x)                                      (((x) & RST_RESET2_SPARE_MASK) >> RST_RESET2_SPARE_LSB)
+#define RST_RESET2_SPARE_SET(x)                                      (((x) << RST_RESET2_SPARE_LSB) & RST_RESET2_SPARE_MASK)
+#define RST_RESET2_SPARE_RESET                                       0x0 // 0
+#define RST_RESET2_EP_MODE_MSB                                       18
+#define RST_RESET2_EP_MODE_LSB                                       18
+#define RST_RESET2_EP_MODE_MASK                                      0x00040000
+#define RST_RESET2_EP_MODE_GET(x)                                    (((x) & RST_RESET2_EP_MODE_MASK) >> RST_RESET2_EP_MODE_LSB)
+#define RST_RESET2_EP_MODE_SET(x)                                    (((x) << RST_RESET2_EP_MODE_LSB) & RST_RESET2_EP_MODE_MASK)
+#define RST_RESET2_EP_MODE_RESET                                     0x0 // 0
+#define RST_RESET2_USB2_EXT_PWR_SEQ_MSB                              17
+#define RST_RESET2_USB2_EXT_PWR_SEQ_LSB                              17
+#define RST_RESET2_USB2_EXT_PWR_SEQ_MASK                             0x00020000
+#define RST_RESET2_USB2_EXT_PWR_SEQ_GET(x)                           (((x) & RST_RESET2_USB2_EXT_PWR_SEQ_MASK) >> RST_RESET2_USB2_EXT_PWR_SEQ_LSB)
+#define RST_RESET2_USB2_EXT_PWR_SEQ_SET(x)                           (((x) << RST_RESET2_USB2_EXT_PWR_SEQ_LSB) & RST_RESET2_USB2_EXT_PWR_SEQ_MASK)
+#define RST_RESET2_USB2_EXT_PWR_SEQ_RESET                            0x1 // 1
+#define RST_RESET2_USB1_EXT_PWR_SEQ_MSB                              16
+#define RST_RESET2_USB1_EXT_PWR_SEQ_LSB                              16
+#define RST_RESET2_USB1_EXT_PWR_SEQ_MASK                             0x00010000
+#define RST_RESET2_USB1_EXT_PWR_SEQ_GET(x)                           (((x) & RST_RESET2_USB1_EXT_PWR_SEQ_MASK) >> RST_RESET2_USB1_EXT_PWR_SEQ_LSB)
+#define RST_RESET2_USB1_EXT_PWR_SEQ_SET(x)                           (((x) << RST_RESET2_USB1_EXT_PWR_SEQ_LSB) & RST_RESET2_USB1_EXT_PWR_SEQ_MASK)
+#define RST_RESET2_USB1_EXT_PWR_SEQ_RESET                            0x1 // 1
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_MSB                          15
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_LSB                          15
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_MASK                         0x00008000
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_GET(x)                       (((x) & RST_RESET2_USB_PHY2_PLL_PWD_EXT_MASK) >> RST_RESET2_USB_PHY2_PLL_PWD_EXT_LSB)
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_SET(x)                       (((x) << RST_RESET2_USB_PHY2_PLL_PWD_EXT_LSB) & RST_RESET2_USB_PHY2_PLL_PWD_EXT_MASK)
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_RESET                        0x0 // 0
+#define RST_RESET2_USB_PHY2_ARESET_MSB                               11
+#define RST_RESET2_USB_PHY2_ARESET_LSB                               11
+#define RST_RESET2_USB_PHY2_ARESET_MASK                              0x00000800
+#define RST_RESET2_USB_PHY2_ARESET_GET(x)                            (((x) & RST_RESET2_USB_PHY2_ARESET_MASK) >> RST_RESET2_USB_PHY2_ARESET_LSB)
+#define RST_RESET2_USB_PHY2_ARESET_SET(x)                            (((x) << RST_RESET2_USB_PHY2_ARESET_LSB) & RST_RESET2_USB_PHY2_ARESET_MASK)
+#define RST_RESET2_USB_PHY2_ARESET_RESET                             0x1 // 1
+#define RST_RESET2_PCIE2_PHY_RESET_MSB                               7
+#define RST_RESET2_PCIE2_PHY_RESET_LSB                               7
+#define RST_RESET2_PCIE2_PHY_RESET_MASK                              0x00000080
+#define RST_RESET2_PCIE2_PHY_RESET_GET(x)                            (((x) & RST_RESET2_PCIE2_PHY_RESET_MASK) >> RST_RESET2_PCIE2_PHY_RESET_LSB)
+#define RST_RESET2_PCIE2_PHY_RESET_SET(x)                            (((x) << RST_RESET2_PCIE2_PHY_RESET_LSB) & RST_RESET2_PCIE2_PHY_RESET_MASK)
+#define RST_RESET2_PCIE2_PHY_RESET_RESET                             0x1 // 1
+#define RST_RESET2_PCIE2_RESET_MSB                                   6
+#define RST_RESET2_PCIE2_RESET_LSB                                   6
+#define RST_RESET2_PCIE2_RESET_MASK                                  0x00000040
+#define RST_RESET2_PCIE2_RESET_GET(x)                                (((x) & RST_RESET2_PCIE2_RESET_MASK) >> RST_RESET2_PCIE2_RESET_LSB)
+#define RST_RESET2_PCIE2_RESET_SET(x)                                (((x) << RST_RESET2_PCIE2_RESET_LSB) & RST_RESET2_PCIE2_RESET_MASK)
+#define RST_RESET2_PCIE2_RESET_RESET                                 0x1 // 1
+#define RST_RESET2_USB_HOST2_RESET_MSB                               5
+#define RST_RESET2_USB_HOST2_RESET_LSB                               5
+#define RST_RESET2_USB_HOST2_RESET_MASK                              0x00000020
+#define RST_RESET2_USB_HOST2_RESET_GET(x)                            (((x) & RST_RESET2_USB_HOST2_RESET_MASK) >> RST_RESET2_USB_HOST2_RESET_LSB)
+#define RST_RESET2_USB_HOST2_RESET_SET(x)                            (((x) << RST_RESET2_USB_HOST2_RESET_LSB) & RST_RESET2_USB_HOST2_RESET_MASK)
+#define RST_RESET2_USB_HOST2_RESET_RESET                             0x1 // 1
+#define RST_RESET2_USB_PHY2_RESET_MSB                                4
+#define RST_RESET2_USB_PHY2_RESET_LSB                                4
+#define RST_RESET2_USB_PHY2_RESET_MASK                               0x00000010
+#define RST_RESET2_USB_PHY2_RESET_GET(x)                             (((x) & RST_RESET2_USB_PHY2_RESET_MASK) >> RST_RESET2_USB_PHY2_RESET_LSB)
+#define RST_RESET2_USB_PHY2_RESET_SET(x)                             (((x) << RST_RESET2_USB_PHY2_RESET_LSB) & RST_RESET2_USB_PHY2_RESET_MASK)
+#define RST_RESET2_USB_PHY2_RESET_RESET                              0x1 // 1
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_MSB                     3
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_LSB                     3
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_MASK                    0x00000008
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_GET(x)                  (((x) & RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_MASK) >> RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_LSB)
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_SET(x)                  (((x) << RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_LSB) & RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_MASK)
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_RESET                   0x0 // 0
+#define RST_RESET2_USB2_MODE_MSB                                     0
+#define RST_RESET2_USB2_MODE_LSB                                     0
+#define RST_RESET2_USB2_MODE_MASK                                    0x00000001
+#define RST_RESET2_USB2_MODE_GET(x)                                  (((x) & RST_RESET2_USB2_MODE_MASK) >> RST_RESET2_USB2_MODE_LSB)
+#define RST_RESET2_USB2_MODE_SET(x)                                  (((x) << RST_RESET2_USB2_MODE_LSB) & RST_RESET2_USB2_MODE_MASK)
+#define RST_RESET2_USB2_MODE_RESET                                   0x1 // 1
+#define RST_RESET2_ADDRESS                                           0x180600c4
+
+#define PCIE2_RESET_EP_RESET_L_MSB                                   2
+#define PCIE2_RESET_EP_RESET_L_LSB                                   2
+#define PCIE2_RESET_EP_RESET_L_MASK                                  0x00000004
+#define PCIE2_RESET_EP_RESET_L_GET(x)                                (((x) & PCIE2_RESET_EP_RESET_L_MASK) >> PCIE2_RESET_EP_RESET_L_LSB)
+#define PCIE2_RESET_EP_RESET_L_SET(x)                                (((x) << PCIE2_RESET_EP_RESET_L_LSB) & PCIE2_RESET_EP_RESET_L_MASK)
+#define PCIE2_RESET_EP_RESET_L_RESET                                 0x0 // 0
+#define PCIE2_RESET_LINK_REQ_RESET_MSB                               1
+#define PCIE2_RESET_LINK_REQ_RESET_LSB                               1
+#define PCIE2_RESET_LINK_REQ_RESET_MASK                              0x00000002
+#define PCIE2_RESET_LINK_REQ_RESET_GET(x)                            (((x) & PCIE2_RESET_LINK_REQ_RESET_MASK) >> PCIE2_RESET_LINK_REQ_RESET_LSB)
+#define PCIE2_RESET_LINK_REQ_RESET_SET(x)                            (((x) << PCIE2_RESET_LINK_REQ_RESET_LSB) & PCIE2_RESET_LINK_REQ_RESET_MASK)
+#define PCIE2_RESET_LINK_REQ_RESET_RESET                             0x0 // 0
+#define PCIE2_RESET_LINK_UP_MSB                                      0
+#define PCIE2_RESET_LINK_UP_LSB                                      0
+#define PCIE2_RESET_LINK_UP_MASK                                     0x00000001
+#define PCIE2_RESET_LINK_UP_GET(x)                                   (((x) & PCIE2_RESET_LINK_UP_MASK) >> PCIE2_RESET_LINK_UP_LSB)
+#define PCIE2_RESET_LINK_UP_SET(x)                                   (((x) << PCIE2_RESET_LINK_UP_LSB) & PCIE2_RESET_LINK_UP_MASK)
+#define PCIE2_RESET_LINK_UP_RESET                                    0x0 // 0
+#define PCIE2_RESET_ADDRESS                                          0x18280018
+
+#define PCIE2_APP_CFG_TYPE_MSB                                       21
+#define PCIE2_APP_CFG_TYPE_LSB                                       20
+#define PCIE2_APP_CFG_TYPE_MASK                                      0x00300000
+#define PCIE2_APP_CFG_TYPE_GET(x)                                    (((x) & PCIE2_APP_CFG_TYPE_MASK) >> PCIE2_APP_CFG_TYPE_LSB)
+#define PCIE2_APP_CFG_TYPE_SET(x)                                    (((x) << PCIE2_APP_CFG_TYPE_LSB) & PCIE2_APP_CFG_TYPE_MASK)
+#define PCIE2_APP_CFG_TYPE_RESET                                     0x0 // 0
+#define PCIE2_APP_PCIE2_BAR_MSN_MSB                                   19
+#define PCIE2_APP_PCIE2_BAR_MSN_LSB                                   16
+#define PCIE2_APP_PCIE2_BAR_MSN_MASK                                  0x000f0000
+#define PCIE2_APP_PCIE2_BAR_MSN_GET(x)                                (((x) & PCIE2_APP_PCIE2_BAR_MSN_MASK) >> PCIE2_APP_PCIE2_BAR_MSN_LSB)
+#define PCIE2_APP_PCIE2_BAR_MSN_SET(x)                                (((x) << PCIE2_APP_PCIE2_BAR_MSN_LSB) & PCIE2_APP_PCIE2_BAR_MSN_MASK)
+#define PCIE2_APP_PCIE2_BAR_MSN_RESET                                 0x1 // 1
+#define PCIE2_APP_CFG_BE_MSB                                         15
+#define PCIE2_APP_CFG_BE_LSB                                         12
+#define PCIE2_APP_CFG_BE_MASK                                        0x0000f000
+#define PCIE2_APP_CFG_BE_GET(x)                                      (((x) & PCIE2_APP_CFG_BE_MASK) >> PCIE2_APP_CFG_BE_LSB)
+#define PCIE2_APP_CFG_BE_SET(x)                                      (((x) << PCIE2_APP_CFG_BE_LSB) & PCIE2_APP_CFG_BE_MASK)
+#define PCIE2_APP_CFG_BE_RESET                                       0xf // 15
+#define PCIE2_APP_SLV_RESP_ERR_MAP_MSB                               11
+#define PCIE2_APP_SLV_RESP_ERR_MAP_LSB                               6
+#define PCIE2_APP_SLV_RESP_ERR_MAP_MASK                              0x00000fc0
+#define PCIE2_APP_SLV_RESP_ERR_MAP_GET(x)                            (((x) & PCIE2_APP_SLV_RESP_ERR_MAP_MASK) >> PCIE2_APP_SLV_RESP_ERR_MAP_LSB)
+#define PCIE2_APP_SLV_RESP_ERR_MAP_SET(x)                            (((x) << PCIE2_APP_SLV_RESP_ERR_MAP_LSB) & PCIE2_APP_SLV_RESP_ERR_MAP_MASK)
+#define PCIE2_APP_SLV_RESP_ERR_MAP_RESET                             0x3f // 63
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_MSB                              5
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_LSB                              4
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_MASK                             0x00000030
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_GET(x)                           (((x) & PCIE2_APP_MSTR_RESP_ERR_MAP_MASK) >> PCIE2_APP_MSTR_RESP_ERR_MAP_LSB)
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_SET(x)                           (((x) << PCIE2_APP_MSTR_RESP_ERR_MAP_LSB) & PCIE2_APP_MSTR_RESP_ERR_MAP_MASK)
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_RESET                            0x0 // 0
+#define PCIE2_APP_INIT_RST_MSB                                       3
+#define PCIE2_APP_INIT_RST_LSB                                       3
+#define PCIE2_APP_INIT_RST_MASK                                      0x00000008
+#define PCIE2_APP_INIT_RST_GET(x)                                    (((x) & PCIE2_APP_INIT_RST_MASK) >> PCIE2_APP_INIT_RST_LSB)
+#define PCIE2_APP_INIT_RST_SET(x)                                    (((x) << PCIE2_APP_INIT_RST_LSB) & PCIE2_APP_INIT_RST_MASK)
+#define PCIE2_APP_INIT_RST_RESET                                     0x0 // 0
+#define PCIE2_APP_PM_XMT_TURNOFF_MSB                                 2
+#define PCIE2_APP_PM_XMT_TURNOFF_LSB                                 2
+#define PCIE2_APP_PM_XMT_TURNOFF_MASK                                0x00000004
+#define PCIE2_APP_PM_XMT_TURNOFF_GET(x)                              (((x) & PCIE2_APP_PM_XMT_TURNOFF_MASK) >> PCIE2_APP_PM_XMT_TURNOFF_LSB)
+#define PCIE2_APP_PM_XMT_TURNOFF_SET(x)                              (((x) << PCIE2_APP_PM_XMT_TURNOFF_LSB) & PCIE2_APP_PM_XMT_TURNOFF_MASK)
+#define PCIE2_APP_PM_XMT_TURNOFF_RESET                               0x0 // 0
+#define PCIE2_APP_UNLOCK_MSG_MSB                                     1
+#define PCIE2_APP_UNLOCK_MSG_LSB                                     1
+#define PCIE2_APP_UNLOCK_MSG_MASK                                    0x00000002
+#define PCIE2_APP_UNLOCK_MSG_GET(x)                                  (((x) & PCIE2_APP_UNLOCK_MSG_MASK) >> PCIE2_APP_UNLOCK_MSG_LSB)
+#define PCIE2_APP_UNLOCK_MSG_SET(x)                                  (((x) << PCIE2_APP_UNLOCK_MSG_LSB) & PCIE2_APP_UNLOCK_MSG_MASK)
+#define PCIE2_APP_UNLOCK_MSG_RESET                                   0x0 // 0
+#define PCIE2_APP_LTSSM_ENABLE_MSB                                   0
+#define PCIE2_APP_LTSSM_ENABLE_LSB                                   0
+#define PCIE2_APP_LTSSM_ENABLE_MASK                                  0x00000001
+#define PCIE2_APP_LTSSM_ENABLE_GET(x)                                (((x) & PCIE2_APP_LTSSM_ENABLE_MASK) >> PCIE2_APP_LTSSM_ENABLE_LSB)
+#define PCIE2_APP_LTSSM_ENABLE_SET(x)                                (((x) << PCIE2_APP_LTSSM_ENABLE_LSB) & PCIE2_APP_LTSSM_ENABLE_MASK)
+#define PCIE2_APP_LTSSM_ENABLE_RESET                                 0x0 // 0
+#define PCIE2_APP_ADDRESS                                            0x18280000
+
+
+
+
+
+#define CONFIG_MIPS32		1	/* MIPS32 CPU core	*/
+
+#define CONFIG_BOOTDELAY	2	/* autoboot after 4 seconds	*/
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{115200}
+
+#define	CONFIG_TIMESTAMP		/* Print image info with timestamp */
+
+#define CONFIG_ROOTFS_RD
+
+#define	CONFIG_BOOTARGS_RD     "console=ttyS0,115200 root=01:00 rd_start=0x802d0000 rd_size=5242880 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),4096k(rootfs),2048k(uImage)"
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),2048k(uImage)"
+
+#ifdef CONFIG_ROOTFS_FLASH
+#define CONFIG_BOOTARGS CONFIG_BOOTARGS_FL
+#else
+#define CONFIG_BOOTARGS ""
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"ath> "		/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		512		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE		(CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		(128*1024)
+
+#define CFG_BOOTPARAMS_LEN	(128*1024)
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+//#define CFG_SDRAM_BASE	0xa0000000     /* Cached addr */
+
+#define	CFG_LOAD_ADDR		0x81000000     /* default load address	*/
+//#define CFG_LOAD_ADDR		0xa1000000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#undef CFG_MEMTEST_START
+#define CFG_MEMTEST_START       0x80200000
+#define CFG_MEMTEST_END		0x83800000
+
+/*------------------------------------------------------------------------
+ * *  * JFFS2
+ */
+#define CFG_JFFS_CUSTOM_PART            /* board defined part   */
+#define CONFIG_JFFS2_CMDLINE
+#define MTDIDS_DEFAULT		"nor0=ath-nor0"
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#define CFG_RX_ETH_BUFFER	16
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		32768
+#define CFG_ICACHE_SIZE		65536
+#define CFG_CACHELINE_SIZE	32
+
+/*
+ * Address map
+ */
+#define ATH_PCI_MEM_BASE		0x10000000	/* 128M */
+#define ATH_APB_BASE			0x18000000	/* 384M */
+#define ATH_GE0_BASE			0x19000000	/* 16M */
+#define ATH_GE1_BASE			0x1a000000	/* 16M */
+#define ATH_USB_OHCI_BASE		0x1b000000
+#define ATH_USB_EHCI_BASE		0x1b000000
+#define ATH_USB_EHCI_BASE_1		0x1b000000
+#define ATH_USB_EHCI_BASE_2		0x1b400000
+#define ATH_SPI_BASE			0x1f000000
+
+/*
+ * Added the PCI LCL RESET register from u-boot
+ * ath_soc.h so that we can query the PCI LCL RESET
+ * register for the presence of WLAN H/W.
+ */
+#define ATH_PCI_LCL_BASE		(ATH_APB_BASE+0x000f0000)
+#define ATH_PCI_LCL_APP			(ATH_PCI_LCL_BASE+0x00)
+#define ATH_PCI_LCL_RESET		(ATH_PCI_LCL_BASE+0x18)
+
+/*
+ * APB block
+ */
+#define ATH_DDR_CTL_BASE		ATH_APB_BASE+0x00000000
+#define ATH_CPU_BASE			ATH_APB_BASE+0x00010000
+#define ATH_UART_BASE			ATH_APB_BASE+0x00020000
+#define ATH_USB_CONFIG_BASE		ATH_APB_BASE+0x00030000
+#define ATH_GPIO_BASE			ATH_APB_BASE+0x00040000
+#define ATH_PLL_BASE			ATH_APB_BASE+0x00050000
+#define ATH_RESET_BASE			ATH_APB_BASE+0x00060000
+#define ATH_DMA_BASE			ATH_APB_BASE+0x000A0000
+#define ATH_SLIC_BASE			ATH_APB_BASE+0x000A9000
+#define ATH_STEREO_BASE			ATH_APB_BASE+0x000B0000
+#define ATH_PCI_CTLR_BASE		ATH_APB_BASE+0x000F0000
+#define ATH_OTP_BASE			ATH_APB_BASE+0x00130000
+#define ATH_NAND_FLASH_BASE		0x1b800000u
+
+
+/*
+ * DDR Config values
+ */
+#define ATH_DDR_CONFIG_16BIT		(1 << 31)
+#define ATH_DDR_CONFIG_PAGE_OPEN	(1 << 30)
+#define ATH_DDR_CONFIG_CAS_LAT_SHIFT	27
+#define ATH_DDR_CONFIG_TMRD_SHIFT	23
+#define ATH_DDR_CONFIG_TRFC_SHIFT	17
+#define ATH_DDR_CONFIG_TRRD_SHIFT	13
+#define ATH_DDR_CONFIG_TRP_SHIFT	9
+#define ATH_DDR_CONFIG_TRCD_SHIFT	5
+#define ATH_DDR_CONFIG_TRAS_SHIFT	0
+
+#define ATH_DDR_CONFIG2_BL2		(2 << 0)
+#define ATH_DDR_CONFIG2_BL4		(4 << 0)
+#define ATH_DDR_CONFIG2_BL8		(8 << 0)
+
+#define ATH_DDR_CONFIG2_BT_IL		(1 << 4)
+#define ATH_DDR_CONFIG2_CNTL_OE_EN	(1 << 5)
+#define ATH_DDR_CONFIG2_PHASE_SEL	(1 << 6)
+#define ATH_DDR_CONFIG2_DRAM_CKE	(1 << 7)
+#define ATH_DDR_CONFIG2_TWR_SHIFT	8
+#define ATH_DDR_CONFIG2_TRTW_SHIFT	12
+#define ATH_DDR_CONFIG2_TRTP_SHIFT	17
+#define ATH_DDR_CONFIG2_TWTR_SHIFT	21
+#define ATH_DDR_CONFIG2_HALF_WIDTH_L	(1 << 31)
+
+#define ATH_DDR_TAP_DEFAULT		0x18
+
+/*
+ * DDR block, gmac flushing
+ */
+#define ATH_DDR_GE0_FLUSH		ATH_DDR_CTL_BASE+0x9c
+#define ATH_DDR_GE1_FLUSH		ATH_DDR_CTL_BASE+0xa0
+#define ATH_DDR_USB_FLUSH		ATH_DDR_CTL_BASE+0xa4
+#define ATH_DDR_PCIE_FLUSH		ATH_DDR_CTL_BASE+0x88
+
+#define ATH_EEPROM_GE0_MAC_ADDR		0xbfff1000
+#define ATH_EEPROM_GE1_MAC_ADDR		0xbfff1006
+
+/*
+ * PLL block/CPU
+ */
+
+#define ATH_PLL_CONFIG			ATH_PLL_BASE+0x0
+#define ATH_DDR_CLK_CTRL		ATH_PLL_BASE+0x8
+
+
+#define PLL_DIV_SHIFT			0
+#define PLL_DIV_MASK			0x3ff
+#define REF_DIV_SHIFT			10
+#define REF_DIV_MASK			0xf
+#define AHB_DIV_SHIFT			19
+#define AHB_DIV_MASK			0x1
+#define DDR_DIV_SHIFT			22
+#define DDR_DIV_MASK			0x1
+#define ATH_DDR_PLL_CONFIG		ATH_PLL_BASE+0x4
+#define ATH_ETH_XMII_CONFIG		ATH_PLL_BASE+0x2c
+#define ATH_AUDIO_PLL_CONFIG		ATH_PLL_BASE+0x30
+
+#define ATH_ETH_INT0_CLK		ATH_PLL_BASE+0x14
+#define ATH_ETH_INT1_CLK		ATH_PLL_BASE+0x18
+
+
+/*
+ * USB block
+ */
+#define ATH_USB_FLADJ_VAL		ATH_USB_CONFIG_BASE
+#define ATH_USB_CONFIG			ATH_USB_CONFIG_BASE+0x4
+#define ATH_USB_WINDOW			0x10000
+#define ATH_USB_MODE			ATH_USB_EHCI_BASE+0x1a8
+
+/*
+ * PCI block
+ */
+#define ATH_PCI_WINDOW			0x8000000 /* 128MB */
+#define ATH_PCI_WINDOW0_OFFSET		ATH_DDR_CTL_BASE+0x7c
+#define ATH_PCI_WINDOW1_OFFSET		ATH_DDR_CTL_BASE+0x80
+#define ATH_PCI_WINDOW2_OFFSET		ATH_DDR_CTL_BASE+0x84
+#define ATH_PCI_WINDOW3_OFFSET		ATH_DDR_CTL_BASE+0x88
+#define ATH_PCI_WINDOW4_OFFSET		ATH_DDR_CTL_BASE+0x8c
+#define ATH_PCI_WINDOW5_OFFSET		ATH_DDR_CTL_BASE+0x90
+#define ATH_PCI_WINDOW6_OFFSET		ATH_DDR_CTL_BASE+0x94
+#define ATH_PCI_WINDOW7_OFFSET		ATH_DDR_CTL_BASE+0x98
+
+#define ATH_PCI_WINDOW0_VAL		0x10000000
+#define ATH_PCI_WINDOW1_VAL		0x11000000
+#define ATH_PCI_WINDOW2_VAL		0x12000000
+#define ATH_PCI_WINDOW3_VAL		0x13000000
+#define ATH_PCI_WINDOW4_VAL		0x14000000
+#define ATH_PCI_WINDOW5_VAL		0x15000000
+#define ATH_PCI_WINDOW6_VAL		0x16000000
+#define ATH_PCI_WINDOW7_VAL		0x07000000
+
+#define ath_write_pci_window(_no)	\
+	ath_reg_wr(ATH_PCI_WINDOW##_no##_OFFSET, ATH_PCI_WINDOW##_no##_VAL);
+
+/*
+ * CRP. To access the host controller config and status registers
+ */
+#define ATH_PCI_CRP			0x180c0000
+#define ATH_PCI_DEV_CFGBASE		0x14000000
+#define ATH_PCI_CRP_AD_CBE		ATH_PCI_CRP
+#define ATH_PCI_CRP_WRDATA		ATH_PCI_CRP+0x4
+#define ATH_PCI_CRP_RDDATA		ATH_PCI_CRP+0x8
+#define ATH_PCI_ERROR			ATH_PCI_CRP+0x1c
+#define ATH_PCI_ERROR_ADDRESS		ATH_PCI_CRP+0x20
+#define ATH_PCI_AHB_ERROR		ATH_PCI_CRP+0x24
+#define ATH_PCI_AHB_ERROR_ADDRESS	ATH_PCI_CRP+0x28
+
+#define ATH_CRP_CMD_WRITE		0x00010000
+#define ATH_CRP_CMD_READ		0x00000000
+
+/*
+ * PCI CFG. To generate config cycles
+ */
+#define ATH_PCI_CFG_AD			ATH_PCI_CRP+0xc
+#define ATH_PCI_CFG_CBE			ATH_PCI_CRP+0x10
+#define ATH_PCI_CFG_WRDATA		ATH_PCI_CRP+0x14
+#define ATH_PCI_CFG_RDDATA		ATH_PCI_CRP+0x18
+#define ATH_CFG_CMD_READ		0x0000000a
+#define ATH_CFG_CMD_WRITE		0x0000000b
+
+#define ATH_PCI_IDSEL_ADLINE_START	17
+
+#define ATH_SPI_FS		(ATH_SPI_BASE+0x00)
+#define ATH_SPI_READ		(ATH_SPI_BASE+0x00)
+#define ATH_SPI_CLOCK		(ATH_SPI_BASE+0x04)
+#define ATH_SPI_WRITE		(ATH_SPI_BASE+0x08)
+#define ATH_SPI_RD_STATUS	(ATH_SPI_BASE+0x0c)
+#define ATH_SPI_SHIFT_DO	(ATH_SPI_BASE+0x10)
+#define ATH_SPI_SHIFT_CNT	(ATH_SPI_BASE+0x14)
+#define ATH_SPI_SHIFT_DI	(ATH_SPI_BASE+0x18)
+#define ATH_SPI_D0_HIGH		(1<<0)	/* Pin spi_do */
+#define ATH_SPI_CLK_HIGH	(1<<8)	/* Pin spi_clk */
+
+#define ATH_SPI_CS_ENABLE_0	(6<<16)	/* Pin gpio/cs0 (active low) */
+#define ATH_SPI_CS_ENABLE_1	(5<<16)	/* Pin gpio/cs1 (active low) */
+#define ATH_SPI_CS_ENABLE_2	(3<<16)	/* Pin gpio/cs2 (active low) */
+#define ATH_SPI_CS_DIS		0x70000
+#define ATH_SPI_CE_LOW		0x60000
+#define ATH_SPI_CE_HIGH		0x60100
+
+#define ATH_SPI_SECTOR_SIZE	(1024*64)
+#define ATH_SPI_PAGE_SIZE	256
+
+#define ATH_RESET_GE0_MAC	RST_RESET_GE0_MAC_RESET_SET(1)
+#define ATH_RESET_GE0_PHY	(0)	// Nothing similar to wasp??
+#define ATH_RESET_GE1_MAC	RST_RESET_GE1_MAC_RESET_SET(1)
+#define ATH_RESET_GE1_PHY	(0)	// Nothing similar to wasp??
+#define ATH_RESET_GE0_MDIO	RST_RESET_GE0_MDIO_RESET_SET(1)
+#define ATH_RESET_GE1_MDIO	RST_RESET_GE1_MDIO_RESET_SET(1)
+
+/*
+ * SOC
+ */
+#define ATH_SPI_CMD_WRITE_SR		0x01
+#define ATH_SPI_CMD_WREN		0x06
+#define ATH_SPI_CMD_RD_STATUS		0x05
+#define ATH_SPI_CMD_FAST_READ		0x0b
+#define ATH_SPI_CMD_PAGE_PROG		0x02
+#define ATH_SPI_CMD_SECTOR_ERASE	0xd8
+#define ATH_SPI_CMD_CHIP_ERASE		0xc7
+#define ATH_SPI_CMD_RDID		0x9f
+
+#if defined(CFG_ATH_EMULATION)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(2)	// 80 MHz
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(1)	// 40 MHz
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_600_200)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_AND_DDR_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_600_300)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_AND_DDR_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(10)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(10)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_AND_DDR_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_680_240)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(17)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_600_240)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_560_450_220)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(11)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0x100) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_AND_DDR_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_680_680_226)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(1)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(17)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(17)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_AND_DDR_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(1)
+#define CPU_AND_DDR_CLK_FROM_CPU		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#else
+#	error "CFG_PLL_FREQ not set"
+#endif	// CFG_PLL_FREQ
+
+#if CPU_AND_DDR_CLK_FROM_DDR && CPU_AND_DDR_CLK_FROM_CPU
+#	error "Incorrect settings. Both 'from CPU' and 'from DDR' set"
+#endif
+
+
+
+#define __nint_to_mhz(n, ref)	((n) * (ref) * 1000000)
+#define __cpu_hz_40(pll)	(__nint_to_mhz(CPU_PLL_CONFIG_NINT_GET(pll), 40))
+#define __cpu_hz_25(pll)	(__nint_to_mhz(CPU_PLL_CONFIG_NINT_GET(pll), 25))
+
+/* Since the count is incremented every other tick, divide by 2 */
+#define CFG_HZ			(__cpu_hz_40(CPU_PLL_CONFIG_NINT_VAL) / 2)
+
+/* SGMII DEFINES */
+
+// 32'h18070034 (SGMII_CONFIG)
+#define SGMII_CONFIG_BERT_ENABLE_MSB                                 14
+#define SGMII_CONFIG_BERT_ENABLE_LSB                                 14
+#define SGMII_CONFIG_BERT_ENABLE_MASK                                0x00004000
+#define SGMII_CONFIG_BERT_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_BERT_ENABLE_MASK) >> SGMII_CONFIG_BERT_ENABLE_LSB)
+#define SGMII_CONFIG_BERT_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_BERT_ENABLE_LSB) & SGMII_CONFIG_BERT_ENABLE_MASK)
+#define SGMII_CONFIG_BERT_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_PRBS_ENABLE_MSB                                 13
+#define SGMII_CONFIG_PRBS_ENABLE_LSB                                 13
+#define SGMII_CONFIG_PRBS_ENABLE_MASK                                0x00002000
+#define SGMII_CONFIG_PRBS_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_PRBS_ENABLE_MASK) >> SGMII_CONFIG_PRBS_ENABLE_LSB)
+#define SGMII_CONFIG_PRBS_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_PRBS_ENABLE_LSB) & SGMII_CONFIG_PRBS_ENABLE_MASK)
+#define SGMII_CONFIG_PRBS_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_MDIO_COMPLETE_MSB                               12
+#define SGMII_CONFIG_MDIO_COMPLETE_LSB                               12
+#define SGMII_CONFIG_MDIO_COMPLETE_MASK                              0x00001000
+#define SGMII_CONFIG_MDIO_COMPLETE_GET(x)                            (((x) & SGMII_CONFIG_MDIO_COMPLETE_MASK) >> SGMII_CONFIG_MDIO_COMPLETE_LSB)
+#define SGMII_CONFIG_MDIO_COMPLETE_SET(x)                            (((x) << SGMII_CONFIG_MDIO_COMPLETE_LSB) & SGMII_CONFIG_MDIO_COMPLETE_MASK)
+#define SGMII_CONFIG_MDIO_COMPLETE_RESET                             0x0 // 0
+#define SGMII_CONFIG_MDIO_PULSE_MSB                                  11
+#define SGMII_CONFIG_MDIO_PULSE_LSB                                  11
+#define SGMII_CONFIG_MDIO_PULSE_MASK                                 0x00000800
+#define SGMII_CONFIG_MDIO_PULSE_GET(x)                               (((x) & SGMII_CONFIG_MDIO_PULSE_MASK) >> SGMII_CONFIG_MDIO_PULSE_LSB)
+#define SGMII_CONFIG_MDIO_PULSE_SET(x)                               (((x) << SGMII_CONFIG_MDIO_PULSE_LSB) & SGMII_CONFIG_MDIO_PULSE_MASK)
+#define SGMII_CONFIG_MDIO_PULSE_RESET                                0x0 // 0
+#define SGMII_CONFIG_MDIO_ENABLE_MSB                                 10
+#define SGMII_CONFIG_MDIO_ENABLE_LSB                                 10
+#define SGMII_CONFIG_MDIO_ENABLE_MASK                                0x00000400
+#define SGMII_CONFIG_MDIO_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_MDIO_ENABLE_MASK) >> SGMII_CONFIG_MDIO_ENABLE_LSB)
+#define SGMII_CONFIG_MDIO_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_MDIO_ENABLE_LSB) & SGMII_CONFIG_MDIO_ENABLE_MASK)
+#define SGMII_CONFIG_MDIO_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_MSB                            9
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_LSB                            9
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_MASK                           0x00000200
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_GET(x)                         (((x) & SGMII_CONFIG_NEXT_PAGE_LOADED_MASK) >> SGMII_CONFIG_NEXT_PAGE_LOADED_LSB)
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_SET(x)                         (((x) << SGMII_CONFIG_NEXT_PAGE_LOADED_LSB) & SGMII_CONFIG_NEXT_PAGE_LOADED_MASK)
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_RESET                          0x0 // 0
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MSB                         8
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB                         8
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK                        0x00000100
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_GET(x)                      (((x) & SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK) >> SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB)
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_SET(x)                      (((x) << SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB) & SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK)
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_RESET                       0x0 // 0
+#define SGMII_CONFIG_SPEED_MSB                                       7
+#define SGMII_CONFIG_SPEED_LSB                                       6
+#define SGMII_CONFIG_SPEED_MASK                                      0x000000c0
+#define SGMII_CONFIG_SPEED_GET(x)                                    (((x) & SGMII_CONFIG_SPEED_MASK) >> SGMII_CONFIG_SPEED_LSB)
+#define SGMII_CONFIG_SPEED_SET(x)                                    (((x) << SGMII_CONFIG_SPEED_LSB) & SGMII_CONFIG_SPEED_MASK)
+#define SGMII_CONFIG_SPEED_RESET                                     0x0 // 0
+#define SGMII_CONFIG_FORCE_SPEED_MSB                                 5
+#define SGMII_CONFIG_FORCE_SPEED_LSB                                 5
+#define SGMII_CONFIG_FORCE_SPEED_MASK                                0x00000020
+#define SGMII_CONFIG_FORCE_SPEED_GET(x)                              (((x) & SGMII_CONFIG_FORCE_SPEED_MASK) >> SGMII_CONFIG_FORCE_SPEED_LSB)
+#define SGMII_CONFIG_FORCE_SPEED_SET(x)                              (((x) << SGMII_CONFIG_FORCE_SPEED_LSB) & SGMII_CONFIG_FORCE_SPEED_MASK)
+#define SGMII_CONFIG_FORCE_SPEED_RESET                               0x0 // 0
+#define SGMII_CONFIG_MR_REG4_CHANGED_MSB                             4
+#define SGMII_CONFIG_MR_REG4_CHANGED_LSB                             4
+#define SGMII_CONFIG_MR_REG4_CHANGED_MASK                            0x00000010
+#define SGMII_CONFIG_MR_REG4_CHANGED_GET(x)                          (((x) & SGMII_CONFIG_MR_REG4_CHANGED_MASK) >> SGMII_CONFIG_MR_REG4_CHANGED_LSB)
+#define SGMII_CONFIG_MR_REG4_CHANGED_SET(x)                          (((x) << SGMII_CONFIG_MR_REG4_CHANGED_LSB) & SGMII_CONFIG_MR_REG4_CHANGED_MASK)
+#define SGMII_CONFIG_MR_REG4_CHANGED_RESET                           0x0 // 0
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MSB                       3
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB                       3
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK                      0x00000008
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_GET(x)                    (((x) & SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK) >> SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB)
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_SET(x)                    (((x) << SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB) & SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK)
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_RESET                     0x0 // 0
+#define SGMII_CONFIG_MODE_CTRL_MSB                                   2
+#define SGMII_CONFIG_MODE_CTRL_LSB                                   0
+#define SGMII_CONFIG_MODE_CTRL_MASK                                  0x00000007
+#define SGMII_CONFIG_MODE_CTRL_GET(x)                                (((x) & SGMII_CONFIG_MODE_CTRL_MASK) >> SGMII_CONFIG_MODE_CTRL_LSB)
+#define SGMII_CONFIG_MODE_CTRL_SET(x)                                (((x) << SGMII_CONFIG_MODE_CTRL_LSB) & SGMII_CONFIG_MODE_CTRL_MASK)
+#define SGMII_CONFIG_MODE_CTRL_RESET                                 0x0 // 0
+#define SGMII_CONFIG_ADDRESS                                         0x18070034
+
+
+
+// 32'h1807001c (MR_AN_CONTROL)
+#define MR_AN_CONTROL_PHY_RESET_MSB                                  15
+#define MR_AN_CONTROL_PHY_RESET_LSB                                  15
+#define MR_AN_CONTROL_PHY_RESET_MASK                                 0x00008000
+#define MR_AN_CONTROL_PHY_RESET_GET(x)                               (((x) & MR_AN_CONTROL_PHY_RESET_MASK) >> MR_AN_CONTROL_PHY_RESET_LSB)
+#define MR_AN_CONTROL_PHY_RESET_SET(x)                               (((x) << MR_AN_CONTROL_PHY_RESET_LSB) & MR_AN_CONTROL_PHY_RESET_MASK)
+#define MR_AN_CONTROL_PHY_RESET_RESET                                0x0 // 0
+#define MR_AN_CONTROL_LOOPBACK_MSB                                   14
+#define MR_AN_CONTROL_LOOPBACK_LSB                                   14
+#define MR_AN_CONTROL_LOOPBACK_MASK                                  0x00004000
+#define MR_AN_CONTROL_LOOPBACK_GET(x)                                (((x) & MR_AN_CONTROL_LOOPBACK_MASK) >> MR_AN_CONTROL_LOOPBACK_LSB)
+#define MR_AN_CONTROL_LOOPBACK_SET(x)                                (((x) << MR_AN_CONTROL_LOOPBACK_LSB) & MR_AN_CONTROL_LOOPBACK_MASK)
+#define MR_AN_CONTROL_LOOPBACK_RESET                                 0x0 // 0
+#define MR_AN_CONTROL_SPEED_SEL0_MSB                                 13
+#define MR_AN_CONTROL_SPEED_SEL0_LSB                                 13
+#define MR_AN_CONTROL_SPEED_SEL0_MASK                                0x00002000
+#define MR_AN_CONTROL_SPEED_SEL0_GET(x)                              (((x) & MR_AN_CONTROL_SPEED_SEL0_MASK) >> MR_AN_CONTROL_SPEED_SEL0_LSB)
+#define MR_AN_CONTROL_SPEED_SEL0_SET(x)                              (((x) << MR_AN_CONTROL_SPEED_SEL0_LSB) & MR_AN_CONTROL_SPEED_SEL0_MASK)
+#define MR_AN_CONTROL_SPEED_SEL0_RESET                               0x0 // 0
+#define MR_AN_CONTROL_AN_ENABLE_MSB                                  12
+#define MR_AN_CONTROL_AN_ENABLE_LSB                                  12
+#define MR_AN_CONTROL_AN_ENABLE_MASK                                 0x00001000
+#define MR_AN_CONTROL_AN_ENABLE_GET(x)                               (((x) & MR_AN_CONTROL_AN_ENABLE_MASK) >> MR_AN_CONTROL_AN_ENABLE_LSB)
+#define MR_AN_CONTROL_AN_ENABLE_SET(x)                               (((x) << MR_AN_CONTROL_AN_ENABLE_LSB) & MR_AN_CONTROL_AN_ENABLE_MASK)
+#define MR_AN_CONTROL_AN_ENABLE_RESET                                0x1 // 1
+#define MR_AN_CONTROL_POWER_DOWN_MSB                                 11
+#define MR_AN_CONTROL_POWER_DOWN_LSB                                 11
+#define MR_AN_CONTROL_POWER_DOWN_MASK                                0x00000800
+#define MR_AN_CONTROL_POWER_DOWN_GET(x)                              (((x) & MR_AN_CONTROL_POWER_DOWN_MASK) >> MR_AN_CONTROL_POWER_DOWN_LSB)
+#define MR_AN_CONTROL_POWER_DOWN_SET(x)                              (((x) << MR_AN_CONTROL_POWER_DOWN_LSB) & MR_AN_CONTROL_POWER_DOWN_MASK)
+#define MR_AN_CONTROL_POWER_DOWN_RESET                               0x0 // 0
+#define MR_AN_CONTROL_RESTART_AN_MSB                                 9
+#define MR_AN_CONTROL_RESTART_AN_LSB                                 9
+#define MR_AN_CONTROL_RESTART_AN_MASK                                0x00000200
+#define MR_AN_CONTROL_RESTART_AN_GET(x)                              (((x) & MR_AN_CONTROL_RESTART_AN_MASK) >> MR_AN_CONTROL_RESTART_AN_LSB)
+#define MR_AN_CONTROL_RESTART_AN_SET(x)                              (((x) << MR_AN_CONTROL_RESTART_AN_LSB) & MR_AN_CONTROL_RESTART_AN_MASK)
+#define MR_AN_CONTROL_RESTART_AN_RESET                               0x0 // 0
+#define MR_AN_CONTROL_DUPLEX_MODE_MSB                                8
+#define MR_AN_CONTROL_DUPLEX_MODE_LSB                                8
+#define MR_AN_CONTROL_DUPLEX_MODE_MASK                               0x00000100
+#define MR_AN_CONTROL_DUPLEX_MODE_GET(x)                             (((x) & MR_AN_CONTROL_DUPLEX_MODE_MASK) >> MR_AN_CONTROL_DUPLEX_MODE_LSB)
+#define MR_AN_CONTROL_DUPLEX_MODE_SET(x)                             (((x) << MR_AN_CONTROL_DUPLEX_MODE_LSB) & MR_AN_CONTROL_DUPLEX_MODE_MASK)
+#define MR_AN_CONTROL_DUPLEX_MODE_RESET                              0x1 // 1
+#define MR_AN_CONTROL_SPEED_SEL1_MSB                                 6
+#define MR_AN_CONTROL_SPEED_SEL1_LSB                                 6
+#define MR_AN_CONTROL_SPEED_SEL1_MASK                                0x00000040
+#define MR_AN_CONTROL_SPEED_SEL1_GET(x)                              (((x) & MR_AN_CONTROL_SPEED_SEL1_MASK) >> MR_AN_CONTROL_SPEED_SEL1_LSB)
+#define MR_AN_CONTROL_SPEED_SEL1_SET(x)                              (((x) << MR_AN_CONTROL_SPEED_SEL1_LSB) & MR_AN_CONTROL_SPEED_SEL1_MASK)
+#define MR_AN_CONTROL_SPEED_SEL1_RESET                               0x1 // 1
+#define MR_AN_CONTROL_ADDRESS                                        0x1807001c
+
+
+
+
+
+// 32'h18070014 (SGMII_RESET)
+#define SGMII_RESET_HW_RX_125M_N_MSB                                 4
+#define SGMII_RESET_HW_RX_125M_N_LSB                                 4
+#define SGMII_RESET_HW_RX_125M_N_MASK                                0x00000010
+#define SGMII_RESET_HW_RX_125M_N_GET(x)                              (((x) & SGMII_RESET_HW_RX_125M_N_MASK) >> SGMII_RESET_HW_RX_125M_N_LSB)
+#define SGMII_RESET_HW_RX_125M_N_SET(x)                              (((x) << SGMII_RESET_HW_RX_125M_N_LSB) & SGMII_RESET_HW_RX_125M_N_MASK)
+#define SGMII_RESET_HW_RX_125M_N_RESET                               0x0 // 0
+#define SGMII_RESET_TX_125M_N_MSB                                    3
+#define SGMII_RESET_TX_125M_N_LSB                                    3
+#define SGMII_RESET_TX_125M_N_MASK                                   0x00000008
+#define SGMII_RESET_TX_125M_N_GET(x)                                 (((x) & SGMII_RESET_TX_125M_N_MASK) >> SGMII_RESET_TX_125M_N_LSB)
+#define SGMII_RESET_TX_125M_N_SET(x)                                 (((x) << SGMII_RESET_TX_125M_N_LSB) & SGMII_RESET_TX_125M_N_MASK)
+#define SGMII_RESET_TX_125M_N_RESET                                  0x0 // 0
+#define SGMII_RESET_RX_125M_N_MSB                                    2
+#define SGMII_RESET_RX_125M_N_LSB                                    2
+#define SGMII_RESET_RX_125M_N_MASK                                   0x00000004
+#define SGMII_RESET_RX_125M_N_GET(x)                                 (((x) & SGMII_RESET_RX_125M_N_MASK) >> SGMII_RESET_RX_125M_N_LSB)
+#define SGMII_RESET_RX_125M_N_SET(x)                                 (((x) << SGMII_RESET_RX_125M_N_LSB) & SGMII_RESET_RX_125M_N_MASK)
+#define SGMII_RESET_RX_125M_N_RESET                                  0x0 // 0
+#define SGMII_RESET_TX_CLK_N_MSB                                     1
+#define SGMII_RESET_TX_CLK_N_LSB                                     1
+#define SGMII_RESET_TX_CLK_N_MASK                                    0x00000002
+#define SGMII_RESET_TX_CLK_N_GET(x)                                  (((x) & SGMII_RESET_TX_CLK_N_MASK) >> SGMII_RESET_TX_CLK_N_LSB)
+#define SGMII_RESET_TX_CLK_N_SET(x)                                  (((x) << SGMII_RESET_TX_CLK_N_LSB) & SGMII_RESET_TX_CLK_N_MASK)
+#define SGMII_RESET_TX_CLK_N_RESET                                   0x0 // 0
+#define SGMII_RESET_RX_CLK_N_MSB                                     0
+#define SGMII_RESET_RX_CLK_N_LSB                                     0
+#define SGMII_RESET_RX_CLK_N_MASK                                    0x00000001
+#define SGMII_RESET_RX_CLK_N_GET(x)                                  (((x) & SGMII_RESET_RX_CLK_N_MASK) >> SGMII_RESET_RX_CLK_N_LSB)
+#define SGMII_RESET_RX_CLK_N_SET(x)                                  (((x) << SGMII_RESET_RX_CLK_N_LSB) & SGMII_RESET_RX_CLK_N_MASK)
+#define SGMII_RESET_RX_CLK_N_RESET                                   0x0 // 0
+#define SGMII_RESET_ADDRESS                                          0x18070014
+
+
+
+// 32'h18070038 (SGMII_MAC_RX_CONFIG)
+#define SGMII_MAC_RX_CONFIG_LINK_MSB                                 15
+#define SGMII_MAC_RX_CONFIG_LINK_LSB                                 15
+#define SGMII_MAC_RX_CONFIG_LINK_MASK                                0x00008000
+#define SGMII_MAC_RX_CONFIG_LINK_GET(x)                              (((x) & SGMII_MAC_RX_CONFIG_LINK_MASK) >> SGMII_MAC_RX_CONFIG_LINK_LSB)
+#define SGMII_MAC_RX_CONFIG_LINK_SET(x)                              (((x) << SGMII_MAC_RX_CONFIG_LINK_LSB) & SGMII_MAC_RX_CONFIG_LINK_MASK)
+#define SGMII_MAC_RX_CONFIG_LINK_RESET                               0x0 // 0
+#define SGMII_MAC_RX_CONFIG_ACK_MSB                                  14
+#define SGMII_MAC_RX_CONFIG_ACK_LSB                                  14
+#define SGMII_MAC_RX_CONFIG_ACK_MASK                                 0x00004000
+#define SGMII_MAC_RX_CONFIG_ACK_GET(x)                               (((x) & SGMII_MAC_RX_CONFIG_ACK_MASK) >> SGMII_MAC_RX_CONFIG_ACK_LSB)
+#define SGMII_MAC_RX_CONFIG_ACK_SET(x)                               (((x) << SGMII_MAC_RX_CONFIG_ACK_LSB) & SGMII_MAC_RX_CONFIG_ACK_MASK)
+#define SGMII_MAC_RX_CONFIG_ACK_RESET                                0x0 // 0
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MSB                          12
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB                          12
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK                         0x00001000
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_GET(x)                       (((x) & SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK) >> SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB)
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_SET(x)                       (((x) << SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB) & SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK)
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_RESET                        0x0 // 0
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_MSB                           11
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB                           10
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK                          0x00000c00
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_GET(x)                        (((x) & SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK) >> SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB)
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_SET(x)                        (((x) << SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB) & SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK)
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_RESET                         0x0 // 0
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_MSB                            8
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB                            8
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK                           0x00000100
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_GET(x)                         (((x) & SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK) >> SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB)
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_SET(x)                         (((x) << SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB) & SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK)
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_RESET                          0x0 // 0
+#define SGMII_MAC_RX_CONFIG_PAUSE_MSB                                7
+#define SGMII_MAC_RX_CONFIG_PAUSE_LSB                                7
+#define SGMII_MAC_RX_CONFIG_PAUSE_MASK                               0x00000080
+#define SGMII_MAC_RX_CONFIG_PAUSE_GET(x)                             (((x) & SGMII_MAC_RX_CONFIG_PAUSE_MASK) >> SGMII_MAC_RX_CONFIG_PAUSE_LSB)
+#define SGMII_MAC_RX_CONFIG_PAUSE_SET(x)                             (((x) << SGMII_MAC_RX_CONFIG_PAUSE_LSB) & SGMII_MAC_RX_CONFIG_PAUSE_MASK)
+#define SGMII_MAC_RX_CONFIG_PAUSE_RESET                              0x0 // 0
+#define SGMII_MAC_RX_CONFIG_RES0_MSB                                 0
+#define SGMII_MAC_RX_CONFIG_RES0_LSB                                 0
+#define SGMII_MAC_RX_CONFIG_RES0_MASK                                0x00000001
+#define SGMII_MAC_RX_CONFIG_RES0_GET(x)                              (((x) & SGMII_MAC_RX_CONFIG_RES0_MASK) >> SGMII_MAC_RX_CONFIG_RES0_LSB)
+#define SGMII_MAC_RX_CONFIG_RES0_SET(x)                              (((x) << SGMII_MAC_RX_CONFIG_RES0_LSB) & SGMII_MAC_RX_CONFIG_RES0_MASK)
+#define SGMII_MAC_RX_CONFIG_RES0_RESET                               0x1 // 1
+#define SGMII_MAC_RX_CONFIG_ADDRESS                                  0x18070038
+
+// 32'h18070058 (SGMII_DEBUG)
+#define SGMII_DEBUG_ARB_STATE_MSB                                    27
+#define SGMII_DEBUG_ARB_STATE_LSB                                    24
+#define SGMII_DEBUG_ARB_STATE_MASK                                   0x0f000000
+#define SGMII_DEBUG_ARB_STATE_GET(x)                                 (((x) & SGMII_DEBUG_ARB_STATE_MASK) >> SGMII_DEBUG_ARB_STATE_LSB)
+#define SGMII_DEBUG_ARB_STATE_SET(x)                                 (((x) << SGMII_DEBUG_ARB_STATE_LSB) & SGMII_DEBUG_ARB_STATE_MASK)
+#define SGMII_DEBUG_ARB_STATE_RESET                                  0x0 // 0
+#define SGMII_DEBUG_RX_SYNC_STATE_MSB                                23
+#define SGMII_DEBUG_RX_SYNC_STATE_LSB                                16
+#define SGMII_DEBUG_RX_SYNC_STATE_MASK                               0x00ff0000
+#define SGMII_DEBUG_RX_SYNC_STATE_GET(x)                             (((x) & SGMII_DEBUG_RX_SYNC_STATE_MASK) >> SGMII_DEBUG_RX_SYNC_STATE_LSB)
+#define SGMII_DEBUG_RX_SYNC_STATE_SET(x)                             (((x) << SGMII_DEBUG_RX_SYNC_STATE_LSB) & SGMII_DEBUG_RX_SYNC_STATE_MASK)
+#define SGMII_DEBUG_RX_SYNC_STATE_RESET                              0x0 // 0
+#define SGMII_DEBUG_RX_STATE_MSB                                     15
+#define SGMII_DEBUG_RX_STATE_LSB                                     8
+#define SGMII_DEBUG_RX_STATE_MASK                                    0x0000ff00
+#define SGMII_DEBUG_RX_STATE_GET(x)                                  (((x) & SGMII_DEBUG_RX_STATE_MASK) >> SGMII_DEBUG_RX_STATE_LSB)
+#define SGMII_DEBUG_RX_STATE_SET(x)                                  (((x) << SGMII_DEBUG_RX_STATE_LSB) & SGMII_DEBUG_RX_STATE_MASK)
+#define SGMII_DEBUG_RX_STATE_RESET                                   0x0 // 0
+#define SGMII_DEBUG_TX_STATE_MSB                                     7
+#define SGMII_DEBUG_TX_STATE_LSB                                     0
+#define SGMII_DEBUG_TX_STATE_MASK                                    0x000000ff
+#define SGMII_DEBUG_TX_STATE_GET(x)                                  (((x) & SGMII_DEBUG_TX_STATE_MASK) >> SGMII_DEBUG_TX_STATE_LSB)
+#define SGMII_DEBUG_TX_STATE_SET(x)                                  (((x) << SGMII_DEBUG_TX_STATE_LSB) & SGMII_DEBUG_TX_STATE_MASK)
+#define SGMII_DEBUG_TX_STATE_RESET                                   0x0 // 0
+#define SGMII_DEBUG_ADDRESS                                          0x18070058
+#define SGMII_DEBUG_OFFSET                                           0x0058
+
+
+
+// 32'h18070060 (SGMII_INTERRUPT_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_MSB                                7
+#define SGMII_INTERRUPT_MASK_MASK_LSB                                0
+#define SGMII_INTERRUPT_MASK_MASK_MASK                               0x000000ff
+#define SGMII_INTERRUPT_MASK_MASK_GET(x)                             (((x) & SGMII_INTERRUPT_MASK_MASK_MASK) >> SGMII_INTERRUPT_MASK_MASK_LSB)
+#define SGMII_INTERRUPT_MASK_MASK_SET(x)                             (((x) << SGMII_INTERRUPT_MASK_MASK_LSB) & SGMII_INTERRUPT_MASK_MASK_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_RESET                              0x0 // 0
+#define SGMII_INTERRUPT_MASK_ADDRESS                                 0x18070060
+
+
+
+
+// 32'h1807005c (SGMII_INTERRUPT)
+#define SGMII_INTERRUPT_INTR_MSB                                     7
+#define SGMII_INTERRUPT_INTR_LSB                                     0
+#define SGMII_INTERRUPT_INTR_MASK                                    0x000000ff
+#define SGMII_INTERRUPT_INTR_GET(x)                                  (((x) & SGMII_INTERRUPT_INTR_MASK) >> SGMII_INTERRUPT_INTR_LSB)
+#define SGMII_INTERRUPT_INTR_SET(x)                                  (((x) << SGMII_INTERRUPT_INTR_LSB) & SGMII_INTERRUPT_INTR_MASK)
+#define SGMII_INTERRUPT_INTR_RESET                                   0x0 // 0
+#define SGMII_INTERRUPT_ADDRESS                                      0x1807005c
+#define SGMII_INTERRUPT_OFFSET                                       0x005c
+// SW modifiable bits
+#define SGMII_INTERRUPT_SW_MASK                                      0x000000ff
+// bits defined at reset
+#define SGMII_INTERRUPT_RSTMASK                                      0xffffffff
+// reset value (ignore bits undefined at reset)
+#define SGMII_INTERRUPT_RESET                                        0x00000000
+
+// 32'h18070060 (SGMII_INTERRUPT_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_MSB                                7
+#define SGMII_INTERRUPT_MASK_MASK_LSB                                0
+#define SGMII_INTERRUPT_MASK_MASK_MASK                               0x000000ff
+#define SGMII_INTERRUPT_MASK_MASK_GET(x)                             (((x) & SGMII_INTERRUPT_MASK_MASK_MASK) >> SGMII_INTERRUPT_MASK_MASK_LSB)
+#define SGMII_INTERRUPT_MASK_MASK_SET(x)                             (((x) << SGMII_INTERRUPT_MASK_MASK_LSB) & SGMII_INTERRUPT_MASK_MASK_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_RESET                              0x0 // 0
+#define SGMII_INTERRUPT_MASK_ADDRESS                                 0x18070060
+
+
+#define SGMII_LINK_FAIL				(1 << 0)
+#define SGMII_DUPLEX_ERR			(1 << 1)
+#define SGMII_MR_AN_COMPLETE			(1 << 2)
+#define SGMII_LINK_MAC_CHANGE			(1 << 3)
+#define SGMII_DUPLEX_MODE_CHANGE		(1 << 4)
+#define SGMII_SPEED_MODE_MAC_CHANGE		(1 << 5)
+#define SGMII_RX_QUIET_CHANGE			(1 << 6)
+#define SGMII_RX_MDIO_COMP_CHANGE		(1 << 7)
+
+#define SGMII_INTR				SGMII_LINK_FAIL | \
+						SGMII_LINK_MAC_CHANGE | \
+						SGMII_DUPLEX_MODE_CHANGE | \
+						SGMII_SPEED_MODE_MAC_CHANGE
+
+
+// 32'h18050048 (ETH_SGMII)
+#define ETH_SGMII_TX_INVERT_MSB                                      31
+#define ETH_SGMII_TX_INVERT_LSB                                      31
+#define ETH_SGMII_TX_INVERT_MASK                                     0x80000000
+#define ETH_SGMII_TX_INVERT_GET(x)                                   (((x) & ETH_SGMII_TX_INVERT_MASK) >> ETH_SGMII_TX_INVERT_LSB)
+#define ETH_SGMII_TX_INVERT_SET(x)                                   (((x) << ETH_SGMII_TX_INVERT_LSB) & ETH_SGMII_TX_INVERT_MASK)
+#define ETH_SGMII_TX_INVERT_RESET                                    0x0 // 0
+#define ETH_SGMII_GIGE_QUAD_MSB                                      30
+#define ETH_SGMII_GIGE_QUAD_LSB                                      30
+#define ETH_SGMII_GIGE_QUAD_MASK                                     0x40000000
+#define ETH_SGMII_GIGE_QUAD_GET(x)                                   (((x) & ETH_SGMII_GIGE_QUAD_MASK) >> ETH_SGMII_GIGE_QUAD_LSB)
+#define ETH_SGMII_GIGE_QUAD_SET(x)                                   (((x) << ETH_SGMII_GIGE_QUAD_LSB) & ETH_SGMII_GIGE_QUAD_MASK)
+#define ETH_SGMII_GIGE_QUAD_RESET                                    0x0 // 0
+#define ETH_SGMII_RX_DELAY_MSB                                       29
+#define ETH_SGMII_RX_DELAY_LSB                                       28
+#define ETH_SGMII_RX_DELAY_MASK                                      0x30000000
+#define ETH_SGMII_RX_DELAY_GET(x)                                    (((x) & ETH_SGMII_RX_DELAY_MASK) >> ETH_SGMII_RX_DELAY_LSB)
+#define ETH_SGMII_RX_DELAY_SET(x)                                    (((x) << ETH_SGMII_RX_DELAY_LSB) & ETH_SGMII_RX_DELAY_MASK)
+#define ETH_SGMII_RX_DELAY_RESET                                     0x0 // 0
+#define ETH_SGMII_TX_DELAY_MSB                                       27
+#define ETH_SGMII_TX_DELAY_LSB                                       26
+#define ETH_SGMII_TX_DELAY_MASK                                      0x0c000000
+#define ETH_SGMII_TX_DELAY_GET(x)                                    (((x) & ETH_SGMII_TX_DELAY_MASK) >> ETH_SGMII_TX_DELAY_LSB)
+#define ETH_SGMII_TX_DELAY_SET(x)                                    (((x) << ETH_SGMII_TX_DELAY_LSB) & ETH_SGMII_TX_DELAY_MASK)
+#define ETH_SGMII_TX_DELAY_RESET                                     0x0 // 0
+#define ETH_SGMII_CLK_SEL_MSB                                        25
+#define ETH_SGMII_CLK_SEL_LSB                                        25
+#define ETH_SGMII_CLK_SEL_MASK                                       0x02000000
+#define ETH_SGMII_CLK_SEL_GET(x)                                     (((x) & ETH_SGMII_CLK_SEL_MASK) >> ETH_SGMII_CLK_SEL_LSB)
+#define ETH_SGMII_CLK_SEL_SET(x)                                     (((x) << ETH_SGMII_CLK_SEL_LSB) & ETH_SGMII_CLK_SEL_MASK)
+#define ETH_SGMII_CLK_SEL_RESET                                      0x1 // 1
+#define ETH_SGMII_GIGE_MSB                                           24
+#define ETH_SGMII_GIGE_LSB                                           24
+#define ETH_SGMII_GIGE_MASK                                          0x01000000
+#define ETH_SGMII_GIGE_GET(x)                                        (((x) & ETH_SGMII_GIGE_MASK) >> ETH_SGMII_GIGE_LSB)
+#define ETH_SGMII_GIGE_SET(x)                                        (((x) << ETH_SGMII_GIGE_LSB) & ETH_SGMII_GIGE_MASK)
+#define ETH_SGMII_GIGE_RESET                                         0x1 // 1
+#define ETH_SGMII_PHASE1_COUNT_MSB                                   15
+#define ETH_SGMII_PHASE1_COUNT_LSB                                   8
+#define ETH_SGMII_PHASE1_COUNT_MASK                                  0x0000ff00
+#define ETH_SGMII_PHASE1_COUNT_GET(x)                                (((x) & ETH_SGMII_PHASE1_COUNT_MASK) >> ETH_SGMII_PHASE1_COUNT_LSB)
+#define ETH_SGMII_PHASE1_COUNT_SET(x)                                (((x) << ETH_SGMII_PHASE1_COUNT_LSB) & ETH_SGMII_PHASE1_COUNT_MASK)
+#define ETH_SGMII_PHASE1_COUNT_RESET                                 0x1 // 1
+#define ETH_SGMII_PHASE0_COUNT_MSB                                   7
+#define ETH_SGMII_PHASE0_COUNT_LSB                                   0
+#define ETH_SGMII_PHASE0_COUNT_MASK                                  0x000000ff
+#define ETH_SGMII_PHASE0_COUNT_GET(x)                                (((x) & ETH_SGMII_PHASE0_COUNT_MASK) >> ETH_SGMII_PHASE0_COUNT_LSB)
+#define ETH_SGMII_PHASE0_COUNT_SET(x)                                (((x) << ETH_SGMII_PHASE0_COUNT_LSB) & ETH_SGMII_PHASE0_COUNT_MASK)
+#define ETH_SGMII_PHASE0_COUNT_RESET                                 0x1 // 1
+#define ETH_SGMII_ADDRESS                                            0x18050048
+
+
+#define OTP_INTF2_ADDRESS                                            0x18131008
+#define OTP_LDO_CONTROL_ADDRESS                                      0x18131024
+
+#define OTP_LDO_STATUS_POWER_ON_MSB                                  0
+#define OTP_LDO_STATUS_POWER_ON_LSB                                  0
+#define OTP_LDO_STATUS_POWER_ON_MASK                                 0x00000001
+#define OTP_LDO_STATUS_POWER_ON_GET(x)                               (((x) & OTP_LDO_STATUS_POWER_ON_MASK) >> OTP_LDO_STATUS_POWER_ON_LSB)
+#define OTP_LDO_STATUS_POWER_ON_SET(x)                               (((x) << OTP_LDO_STATUS_POWER_ON_LSB) & OTP_LDO_STATUS_POWER_ON_MASK)
+#define OTP_LDO_STATUS_POWER_ON_RESET                                0x0 // 0
+#define OTP_LDO_STATUS_ADDRESS                                       0x1813102c
+
+#define OTP_MEM_0_ADDRESS                                            0x18130000
+
+#define OTP_STATUS0_EFUSE_READ_DATA_VALID_MSB                        2
+#define OTP_STATUS0_EFUSE_READ_DATA_VALID_LSB                        2
+#define OTP_STATUS0_EFUSE_READ_DATA_VALID_MASK                       0x00000004
+#define OTP_STATUS0_EFUSE_READ_DATA_VALID_GET(x)                     (((x) & OTP_STATUS0_EFUSE_READ_DATA_VALID_MASK) >> OTP_STATUS0_EFUSE_READ_DATA_VALID_LSB)
+#define OTP_STATUS0_EFUSE_READ_DATA_VALID_SET(x)                     (((x) << OTP_STATUS0_EFUSE_READ_DATA_VALID_LSB) & OTP_STATUS0_EFUSE_READ_DATA_VALID_MASK)
+#define OTP_STATUS0_EFUSE_READ_DATA_VALID_RESET                      0x0 // 0
+#define OTP_STATUS0_EFUSE_ACCESS_BUSY_MSB                            1
+#define OTP_STATUS0_EFUSE_ACCESS_BUSY_LSB                            1
+#define OTP_STATUS0_EFUSE_ACCESS_BUSY_MASK                           0x00000002
+#define OTP_STATUS0_EFUSE_ACCESS_BUSY_GET(x)                         (((x) & OTP_STATUS0_EFUSE_ACCESS_BUSY_MASK) >> OTP_STATUS0_EFUSE_ACCESS_BUSY_LSB)
+#define OTP_STATUS0_EFUSE_ACCESS_BUSY_SET(x)                         (((x) << OTP_STATUS0_EFUSE_ACCESS_BUSY_LSB) & OTP_STATUS0_EFUSE_ACCESS_BUSY_MASK)
+#define OTP_STATUS0_EFUSE_ACCESS_BUSY_RESET                          0x0 // 0
+#define OTP_STATUS0_OTP_SM_BUSY_MSB                                  0
+#define OTP_STATUS0_OTP_SM_BUSY_LSB                                  0
+#define OTP_STATUS0_OTP_SM_BUSY_MASK                                 0x00000001
+#define OTP_STATUS0_OTP_SM_BUSY_GET(x)                               (((x) & OTP_STATUS0_OTP_SM_BUSY_MASK) >> OTP_STATUS0_OTP_SM_BUSY_LSB)
+#define OTP_STATUS0_OTP_SM_BUSY_SET(x)                               (((x) << OTP_STATUS0_OTP_SM_BUSY_LSB) & OTP_STATUS0_OTP_SM_BUSY_MASK)
+#define OTP_STATUS0_OTP_SM_BUSY_RESET                                0x0 // 0
+#define OTP_STATUS0_ADDRESS                                          0x18131018
+
+#define OTP_STATUS1_ADDRESS                                          0x1813101c
+
+
+
+
+
+#endif /* _QCA955X_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/956x.h u-boot_1.1//include/956x.h
--- u-boot//include/956x.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/956x.h	2014-02-18 01:46:27.603052860 -0800
@@ -0,0 +1,4487 @@
+/*
+ * QCA 956x series processor SOC registers
+ *
+ * (C) Copyright 2008 Atheros Communications, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _QCA956X_H
+#define _QCA956X_H
+
+#ifndef __ASSEMBLY__
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <linux/types.h>
+#endif /* __ASSEMBLY__ */
+
+#undef is_qca956x
+#undef is_sco
+
+#define is_qca956x()    (1)
+#define is_sco()    (1)
+
+
+#define CPU_PLL_CONFIG_UPDATING_MSB                                  31
+#define CPU_PLL_CONFIG_UPDATING_LSB                                  31
+#define CPU_PLL_CONFIG_UPDATING_MASK                                 0x80000000
+#define CPU_PLL_CONFIG_UPDATING_GET(x)                               (((x) & CPU_PLL_CONFIG_UPDATING_MASK) >> CPU_PLL_CONFIG_UPDATING_LSB)
+#define CPU_PLL_CONFIG_UPDATING_SET(x)                               (((x) << CPU_PLL_CONFIG_UPDATING_LSB) & CPU_PLL_CONFIG_UPDATING_MASK)
+#define CPU_PLL_CONFIG_UPDATING_RESET                                0x1 // 1
+#define CPU_PLL_CONFIG_PLLPWD_MSB                                    30
+#define CPU_PLL_CONFIG_PLLPWD_LSB                                    30
+#define CPU_PLL_CONFIG_PLLPWD_MASK                                   0x40000000
+#define CPU_PLL_CONFIG_PLLPWD_GET(x)                                 (((x) & CPU_PLL_CONFIG_PLLPWD_MASK) >> CPU_PLL_CONFIG_PLLPWD_LSB)
+#define CPU_PLL_CONFIG_PLLPWD_SET(x)                                 (((x) << CPU_PLL_CONFIG_PLLPWD_LSB) & CPU_PLL_CONFIG_PLLPWD_MASK)
+#define CPU_PLL_CONFIG_PLLPWD_RESET                                  0x1 // 1
+#define CPU_PLL_CONFIG_SPARE_MSB                                     29
+#define CPU_PLL_CONFIG_SPARE_LSB                                     22
+#define CPU_PLL_CONFIG_SPARE_MASK                                    0x3fc00000
+#define CPU_PLL_CONFIG_SPARE_GET(x)                                  (((x) & CPU_PLL_CONFIG_SPARE_MASK) >> CPU_PLL_CONFIG_SPARE_LSB)
+#define CPU_PLL_CONFIG_SPARE_SET(x)                                  (((x) << CPU_PLL_CONFIG_SPARE_LSB) & CPU_PLL_CONFIG_SPARE_MASK)
+#define CPU_PLL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define CPU_PLL_CONFIG_OUTDIV_MSB                                    21
+#define CPU_PLL_CONFIG_OUTDIV_LSB                                    19
+#define CPU_PLL_CONFIG_OUTDIV_MASK                                   0x00380000
+#define CPU_PLL_CONFIG_OUTDIV_GET(x)                                 (((x) & CPU_PLL_CONFIG_OUTDIV_MASK) >> CPU_PLL_CONFIG_OUTDIV_LSB)
+#define CPU_PLL_CONFIG_OUTDIV_SET(x)                                 (((x) << CPU_PLL_CONFIG_OUTDIV_LSB) & CPU_PLL_CONFIG_OUTDIV_MASK)
+#define CPU_PLL_CONFIG_OUTDIV_RESET                                  0x0 // 0
+#define CPU_PLL_CONFIG_RANGE_MSB                                     18
+#define CPU_PLL_CONFIG_RANGE_LSB                                     17
+#define CPU_PLL_CONFIG_RANGE_MASK                                    0x00060000
+#define CPU_PLL_CONFIG_RANGE_GET(x)                                  (((x) & CPU_PLL_CONFIG_RANGE_MASK) >> CPU_PLL_CONFIG_RANGE_LSB)
+#define CPU_PLL_CONFIG_RANGE_SET(x)                                  (((x) << CPU_PLL_CONFIG_RANGE_LSB) & CPU_PLL_CONFIG_RANGE_MASK)
+#define CPU_PLL_CONFIG_RANGE_RESET                                   0x3 // 3
+#define CPU_PLL_CONFIG_REFDIV_MSB                                    16
+#define CPU_PLL_CONFIG_REFDIV_LSB                                    12
+#define CPU_PLL_CONFIG_REFDIV_MASK                                   0x0001f000
+#define CPU_PLL_CONFIG_REFDIV_GET(x)                                 (((x) & CPU_PLL_CONFIG_REFDIV_MASK) >> CPU_PLL_CONFIG_REFDIV_LSB)
+#define CPU_PLL_CONFIG_REFDIV_SET(x)                                 (((x) << CPU_PLL_CONFIG_REFDIV_LSB) & CPU_PLL_CONFIG_REFDIV_MASK)
+#define CPU_PLL_CONFIG_REFDIV_RESET                                  0x2 // 2
+#define CPU_PLL_CONFIG_ADDRESS                                       0x18050000
+
+#define CPU_PLL_CONFIG1_NINT_MSB                                     26
+#define CPU_PLL_CONFIG1_NINT_LSB                                     18
+#define CPU_PLL_CONFIG1_NINT_MASK                                    0x07fc0000
+#define CPU_PLL_CONFIG1_NINT_GET(x)                                  (((x) & CPU_PLL_CONFIG1_NINT_MASK) >> CPU_PLL_CONFIG1_NINT_LSB)
+#define CPU_PLL_CONFIG1_NINT_SET(x)                                  (((x) << CPU_PLL_CONFIG1_NINT_LSB) & CPU_PLL_CONFIG1_NINT_MASK)
+#define CPU_PLL_CONFIG1_NINT_RESET                                   0x14 // 20
+#define CPU_PLL_CONFIG1_NFRAC_MSB                                    17
+#define CPU_PLL_CONFIG1_NFRAC_LSB                                    0
+#define CPU_PLL_CONFIG1_NFRAC_MASK                                   0x0003ffff
+#define CPU_PLL_CONFIG1_NFRAC_GET(x)                                 (((x) & CPU_PLL_CONFIG1_NFRAC_MASK) >> CPU_PLL_CONFIG1_NFRAC_LSB)
+#define CPU_PLL_CONFIG1_NFRAC_SET(x)                                 (((x) << CPU_PLL_CONFIG1_NFRAC_LSB) & CPU_PLL_CONFIG1_NFRAC_MASK)
+#define CPU_PLL_CONFIG1_NFRAC_RESET                                  0x10000 //65536
+#define CPU_PLL_CONFIG1_ADDRESS                                      0x18050004
+
+#define DDR_PLL_CONFIG_UPDATING_MSB                                  31
+#define DDR_PLL_CONFIG_UPDATING_LSB                                  31
+#define DDR_PLL_CONFIG_UPDATING_MASK                                 0x80000000
+#define DDR_PLL_CONFIG_UPDATING_GET(x)                               (((x) & DDR_PLL_CONFIG_UPDATING_MASK) >> DDR_PLL_CONFIG_UPDATING_LSB)
+#define DDR_PLL_CONFIG_UPDATING_SET(x)                               (((x) << DDR_PLL_CONFIG_UPDATING_LSB) & DDR_PLL_CONFIG_UPDATING_MASK)
+#define DDR_PLL_CONFIG_UPDATING_RESET                                0x1 // 1
+#define DDR_PLL_CONFIG_PLLPWD_MSB                                    30
+#define DDR_PLL_CONFIG_PLLPWD_LSB                                    30
+#define DDR_PLL_CONFIG_PLLPWD_MASK                                   0x40000000
+#define DDR_PLL_CONFIG_PLLPWD_GET(x)                                 (((x) & DDR_PLL_CONFIG_PLLPWD_MASK) >> DDR_PLL_CONFIG_PLLPWD_LSB)
+#define DDR_PLL_CONFIG_PLLPWD_SET(x)                                 (((x) << DDR_PLL_CONFIG_PLLPWD_LSB) & DDR_PLL_CONFIG_PLLPWD_MASK)
+#define DDR_PLL_CONFIG_PLLPWD_RESET                                  0x1 // 1
+#define DDR_PLL_CONFIG_SPARE_MSB                                     29
+#define DDR_PLL_CONFIG_SPARE_LSB                                     26
+#define DDR_PLL_CONFIG_SPARE_MASK                                    0x3c000000
+#define DDR_PLL_CONFIG_SPARE_GET(x)                                  (((x) & DDR_PLL_CONFIG_SPARE_MASK) >> DDR_PLL_CONFIG_SPARE_LSB)
+#define DDR_PLL_CONFIG_SPARE_SET(x)                                  (((x) << DDR_PLL_CONFIG_SPARE_LSB) & DDR_PLL_CONFIG_SPARE_MASK)
+#define DDR_PLL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define DDR_PLL_CONFIG_OUTDIV_MSB                                    25
+#define DDR_PLL_CONFIG_OUTDIV_LSB                                    23
+#define DDR_PLL_CONFIG_OUTDIV_MASK                                   0x03800000
+#define DDR_PLL_CONFIG_OUTDIV_GET(x)                                 (((x) & DDR_PLL_CONFIG_OUTDIV_MASK) >> DDR_PLL_CONFIG_OUTDIV_LSB)
+#define DDR_PLL_CONFIG_OUTDIV_SET(x)                                 (((x) << DDR_PLL_CONFIG_OUTDIV_LSB) & DDR_PLL_CONFIG_OUTDIV_MASK)
+#define DDR_PLL_CONFIG_OUTDIV_RESET                                  0x0 // 0
+#define DDR_PLL_CONFIG_RANGE_MSB                                     22
+#define DDR_PLL_CONFIG_RANGE_LSB                                     21
+#define DDR_PLL_CONFIG_RANGE_MASK                                    0x00600000
+#define DDR_PLL_CONFIG_RANGE_GET(x)                                  (((x) & DDR_PLL_CONFIG_RANGE_MASK) >> DDR_PLL_CONFIG_RANGE_LSB)
+#define DDR_PLL_CONFIG_RANGE_SET(x)                                  (((x) << DDR_PLL_CONFIG_RANGE_LSB) & DDR_PLL_CONFIG_RANGE_MASK)
+#define DDR_PLL_CONFIG_RANGE_RESET                                   0x3 // 3
+#define DDR_PLL_CONFIG_REFDIV_MSB                                    20
+#define DDR_PLL_CONFIG_REFDIV_LSB                                    16
+#define DDR_PLL_CONFIG_REFDIV_MASK                                   0x001f0000
+#define DDR_PLL_CONFIG_REFDIV_GET(x)                                 (((x) & DDR_PLL_CONFIG_REFDIV_MASK) >> DDR_PLL_CONFIG_REFDIV_LSB)
+#define DDR_PLL_CONFIG_REFDIV_SET(x)                                 (((x) << DDR_PLL_CONFIG_REFDIV_LSB) & DDR_PLL_CONFIG_REFDIV_MASK)
+#define DDR_PLL_CONFIG_REFDIV_RESET                                  0x2 // 2
+#define DDR_PLL_CONFIG_ADDRESS                                       0x18050008
+
+#define DDR_PLL_CONFIG1_NINT_MSB                                     26
+#define DDR_PLL_CONFIG1_NINT_LSB                                     18
+#define DDR_PLL_CONFIG1_NINT_MASK                                    0x07fc0000
+#define DDR_PLL_CONFIG1_NINT_GET(x)                                  (((x) & DDR_PLL_CONFIG1_NINT_MASK) >> DDR_PLL_CONFIG1_NINT_LSB)
+#define DDR_PLL_CONFIG1_NINT_SET(x)                                  (((x) << DDR_PLL_CONFIG1_NINT_LSB) & DDR_PLL_CONFIG1_NINT_MASK)
+#define DDR_PLL_CONFIG1_NINT_RESET                                   0x14 // 20
+#define DDR_PLL_CONFIG1_NFRAC_MSB                                    17
+#define DDR_PLL_CONFIG1_NFRAC_LSB                                    0
+#define DDR_PLL_CONFIG1_NFRAC_MASK                                   0x0003ffff
+#define DDR_PLL_CONFIG1_NFRAC_GET(x)                                 (((x) & DDR_PLL_CONFIG1_NFRAC_MASK) >> DDR_PLL_CONFIG1_NFRAC_LSB)
+#define DDR_PLL_CONFIG1_NFRAC_SET(x)                                 (((x) << DDR_PLL_CONFIG1_NFRAC_LSB) & DDR_PLL_CONFIG1_NFRAC_MASK)
+#define DDR_PLL_CONFIG1_NFRAC_RESET                                  0x20000 // 131072
+#define DDR_PLL_CONFIG1_ADDRESS                                      0x1805000c
+
+#define DDR_CTL_CONFIG_SRAM_TSEL_MSB                                 31
+#define DDR_CTL_CONFIG_SRAM_TSEL_LSB                                 30
+#define DDR_CTL_CONFIG_SRAM_TSEL_MASK                                0xc0000000
+#define DDR_CTL_CONFIG_SRAM_TSEL_GET(x)                              (((x) & DDR_CTL_CONFIG_SRAM_TSEL_MASK) >> DDR_CTL_CONFIG_SRAM_TSEL_LSB)
+#define DDR_CTL_CONFIG_SRAM_TSEL_SET(x)                              (((x) << DDR_CTL_CONFIG_SRAM_TSEL_LSB) & DDR_CTL_CONFIG_SRAM_TSEL_MASK)
+#define DDR_CTL_CONFIG_SRAM_TSEL_RESET                               0x1 // 1
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MSB                           29
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB                           21
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK                          0x3fe00000
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_GET(x)                        (((x) & DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK) >> DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB)
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_SET(x)                        (((x) << DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB) & DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK)
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_RESET                         0x0 // 0
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_MSB                             20
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB                             20
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK                            0x00100000
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_MSB                             19
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB                             19
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK                            0x00080000
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_MSB                             18
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB                             18
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK                            0x00040000
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MSB                            17
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB                            17
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK                           0x00020000
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_GET(x)                         (((x) & DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_SET(x)                         (((x) << DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_RESET                          0x1 // 1
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MSB                            16
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB                            16
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK                           0x00010000
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_GET(x)                         (((x) & DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_SET(x)                         (((x) << DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_RESET                          0x1 // 1
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_MSB                       15
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_LSB                       15
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_MASK                      0x00008000
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_GET(x)                    (((x) & DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_SET(x)                    (((x) << DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_RESET                     0x1 // 1
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_MSB                       14
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_LSB                       14
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_MASK                      0x00004000
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_GET(x)                    (((x) & DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_SET(x)                    (((x) << DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_RESET                     0x1 // 1
+#define DDR_CTL_CONFIG_SPARE_MSB                                     13
+#define DDR_CTL_CONFIG_SPARE_LSB                                     7
+#define DDR_CTL_CONFIG_SPARE_MASK                                    0x00003f80
+#define DDR_CTL_CONFIG_SPARE_GET(x)                                  (((x) & DDR_CTL_CONFIG_SPARE_MASK) >> DDR_CTL_CONFIG_SPARE_LSB)
+#define DDR_CTL_CONFIG_SPARE_SET(x)                                  (((x) << DDR_CTL_CONFIG_SPARE_LSB) & DDR_CTL_CONFIG_SPARE_MASK)
+#define DDR_CTL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_MSB                              6
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB                              6
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK                             0x00000040
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_GET(x)                           (((x) & DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK) >> DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB)
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(x)                           (((x) << DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB) & DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK)
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_MSB                             4
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB                             4
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK                            0x00000010
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_GET(x)                          (((x) & DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK) >> DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB)
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_SET(x)                          (((x) << DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB) & DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK)
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_RESET                           0x0 // 0
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_MSB                              3
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB                              3
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK                             0x00000008
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_GET(x)                           (((x) & DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK) >> DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB)
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_SET(x)                           (((x) << DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB) & DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK)
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_MSB                              2
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB                              2
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK                             0x00000004
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_GET(x)                           (((x) & DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK) >> DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB)
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(x)                           (((x) << DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB) & DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK)
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_HALF_WIDTH_MSB                                1
+#define DDR_CTL_CONFIG_HALF_WIDTH_LSB                                1
+#define DDR_CTL_CONFIG_HALF_WIDTH_MASK                               0x00000002
+#define DDR_CTL_CONFIG_HALF_WIDTH_GET(x)                             (((x) & DDR_CTL_CONFIG_HALF_WIDTH_MASK) >> DDR_CTL_CONFIG_HALF_WIDTH_LSB)
+#define DDR_CTL_CONFIG_HALF_WIDTH_SET(x)                             (((x) << DDR_CTL_CONFIG_HALF_WIDTH_LSB) & DDR_CTL_CONFIG_HALF_WIDTH_MASK)
+#define DDR_CTL_CONFIG_HALF_WIDTH_RESET                              0x1 // 1
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_MSB                             0
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB                             0
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK                            0x00000001
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_GET(x)                          (((x) & DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK) >> DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB)
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_SET(x)                          (((x) << DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB) & DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK)
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_RESET                           0x0 // 0
+#define DDR_CTL_CONFIG_ADDRESS                                       0x18000108
+
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MSB                            31
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB                            31
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK                           0x80000000
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK) >> DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_RESET                          0x0 // 0
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MSB                           30
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB                           30
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK                          0x40000000
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_GET(x)                        (((x) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK) >> DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_SET(x)                        (((x) << DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_RESET                         0x0 // 0
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_MSB                             29
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB                             29
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK                            0x20000000
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_GET(x)                          (((x) & DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK) >> DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB)
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_SET(x)                          (((x) << DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB) & DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK)
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_RESET                           0x0 // 0
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MSB                            28
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB                            28
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK                           0x10000000
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK) >> DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB)
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB) & DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK)
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_RESET                          0x1 // 1
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MSB                            27
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB                            27
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK                           0x08000000
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK) >> DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB)
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB) & DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK)
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_RESET                          0x0 // 0
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MSB                          14
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB                          13
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK                         0x00006000
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_GET(x)                       (((x) & DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK) >> DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_SET(x)                       (((x) << DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB) & DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_RESET                        0x0 // 0
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_MSB                               12
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_LSB                               8
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_MASK                              0x00001f00
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_GET(x)                            (((x) & DDR_DEBUG_RD_CNTL_GATE_TAP_MASK) >> DDR_DEBUG_RD_CNTL_GATE_TAP_LSB)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_SET(x)                            (((x) << DDR_DEBUG_RD_CNTL_GATE_TAP_LSB) & DDR_DEBUG_RD_CNTL_GATE_TAP_MASK)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_RESET                             0x1 // 1
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MSB                          6
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB                          5
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK                         0x00000060
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_GET(x)                       (((x) & DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK) >> DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_SET(x)                       (((x) << DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB) & DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_RESET                        0x0 // 0
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_MSB                               4
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB                               0
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK                              0x0000001f
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_GET(x)                            (((x) & DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK) >> DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_SET(x)                            (((x) << DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB) & DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_RESET                             0x1 // 1
+#define DDR_DEBUG_RD_CNTL_ADDRESS                                    0x18000118
+
+#define DDR2_CONFIG_DF_ODT_MSB                                       14
+#define DDR2_CONFIG_DF_ODT_LSB                                       14
+#define DDR2_CONFIG_DF_ODT_MASK                                      0x00004000
+#define DDR2_CONFIG_DF_ODT_GET(x)                                    (((x) & DDR2_CONFIG_DF_ODT_MASK) >> DDR2_CONFIG_DF_ODT_LSB)
+#define DDR2_CONFIG_DF_ODT_SET(x)                                    (((x) << DDR2_CONFIG_DF_ODT_LSB) & DDR2_CONFIG_DF_ODT_MASK)
+#define DDR2_CONFIG_DF_ODT_RESET                                     0x0 // 0
+#define DDR2_CONFIG_DDR2_TWL_MSB                                     13
+#define DDR2_CONFIG_DDR2_TWL_LSB                                     10
+#define DDR2_CONFIG_DDR2_TWL_MASK                                    0x00003c00
+#define DDR2_CONFIG_DDR2_TWL_GET(x)                                  (((x) & DDR2_CONFIG_DDR2_TWL_MASK) >> DDR2_CONFIG_DDR2_TWL_LSB)
+#define DDR2_CONFIG_DDR2_TWL_SET(x)                                  (((x) << DDR2_CONFIG_DDR2_TWL_LSB) & DDR2_CONFIG_DDR2_TWL_MASK)
+#define DDR2_CONFIG_DDR2_TWL_RESET                                   0x1 // 1
+#define DDR2_CONFIG_DDR2_ODT_MSB                                     9
+#define DDR2_CONFIG_DDR2_ODT_LSB                                     9
+#define DDR2_CONFIG_DDR2_ODT_MASK                                    0x00000200
+#define DDR2_CONFIG_DDR2_ODT_GET(x)                                  (((x) & DDR2_CONFIG_DDR2_ODT_MASK) >> DDR2_CONFIG_DDR2_ODT_LSB)
+#define DDR2_CONFIG_DDR2_ODT_SET(x)                                  (((x) << DDR2_CONFIG_DDR2_ODT_LSB) & DDR2_CONFIG_DDR2_ODT_MASK)
+#define DDR2_CONFIG_DDR2_ODT_RESET                                   0x1 // 1
+#define DDR2_CONFIG_TFAW_MSB                                         7
+#define DDR2_CONFIG_TFAW_LSB                                         2
+#define DDR2_CONFIG_TFAW_MASK                                        0x000000fc
+#define DDR2_CONFIG_TFAW_GET(x)                                      (((x) & DDR2_CONFIG_TFAW_MASK) >> DDR2_CONFIG_TFAW_LSB)
+#define DDR2_CONFIG_TFAW_SET(x)                                      (((x) << DDR2_CONFIG_TFAW_LSB) & DDR2_CONFIG_TFAW_MASK)
+#define DDR2_CONFIG_TFAW_RESET                                       0x16 // 22
+#define DDR2_CONFIG_ENABLE_DDR2_MSB                                  0
+#define DDR2_CONFIG_ENABLE_DDR2_LSB                                  0
+#define DDR2_CONFIG_ENABLE_DDR2_MASK                                 0x00000001
+#define DDR2_CONFIG_ENABLE_DDR2_GET(x)                               (((x) & DDR2_CONFIG_ENABLE_DDR2_MASK) >> DDR2_CONFIG_ENABLE_DDR2_LSB)
+#define DDR2_CONFIG_ENABLE_DDR2_SET(x)                               (((x) << DDR2_CONFIG_ENABLE_DDR2_LSB) & DDR2_CONFIG_ENABLE_DDR2_MASK)
+#define DDR2_CONFIG_ENABLE_DDR2_RESET                                0x0 // 0
+#define DDR2_CONFIG_ADDRESS                                          0x180000b8
+
+#define DDR_CONTROL_EMR3S_MSB                                        5
+#define DDR_CONTROL_EMR3S_LSB                                        5
+#define DDR_CONTROL_EMR3S_MASK                                       0x00000020
+#define DDR_CONTROL_EMR3S_GET(x)                                     (((x) & DDR_CONTROL_EMR3S_MASK) >> DDR_CONTROL_EMR3S_LSB)
+#define DDR_CONTROL_EMR3S_SET(x)                                     (((x) << DDR_CONTROL_EMR3S_LSB) & DDR_CONTROL_EMR3S_MASK)
+#define DDR_CONTROL_EMR3S_RESET                                      0x0 // 0
+#define DDR_CONTROL_EMR2S_MSB                                        4
+#define DDR_CONTROL_EMR2S_LSB                                        4
+#define DDR_CONTROL_EMR2S_MASK                                       0x00000010
+#define DDR_CONTROL_EMR2S_GET(x)                                     (((x) & DDR_CONTROL_EMR2S_MASK) >> DDR_CONTROL_EMR2S_LSB)
+#define DDR_CONTROL_EMR2S_SET(x)                                     (((x) << DDR_CONTROL_EMR2S_LSB) & DDR_CONTROL_EMR2S_MASK)
+#define DDR_CONTROL_EMR2S_RESET                                      0x0 // 0
+#define DDR_CONTROL_PREA_MSB                                         3
+#define DDR_CONTROL_PREA_LSB                                         3
+#define DDR_CONTROL_PREA_MASK                                        0x00000008
+#define DDR_CONTROL_PREA_GET(x)                                      (((x) & DDR_CONTROL_PREA_MASK) >> DDR_CONTROL_PREA_LSB)
+#define DDR_CONTROL_PREA_SET(x)                                      (((x) << DDR_CONTROL_PREA_LSB) & DDR_CONTROL_PREA_MASK)
+#define DDR_CONTROL_PREA_RESET                                       0x0 // 0
+#define DDR_CONTROL_REF_MSB                                          2
+#define DDR_CONTROL_REF_LSB                                          2
+#define DDR_CONTROL_REF_MASK                                         0x00000004
+#define DDR_CONTROL_REF_GET(x)                                       (((x) & DDR_CONTROL_REF_MASK) >> DDR_CONTROL_REF_LSB)
+#define DDR_CONTROL_REF_SET(x)                                       (((x) << DDR_CONTROL_REF_LSB) & DDR_CONTROL_REF_MASK)
+#define DDR_CONTROL_REF_RESET                                        0x0 // 0
+#define DDR_CONTROL_EMRS_MSB                                         1
+#define DDR_CONTROL_EMRS_LSB                                         1
+#define DDR_CONTROL_EMRS_MASK                                        0x00000002
+#define DDR_CONTROL_EMRS_GET(x)                                      (((x) & DDR_CONTROL_EMRS_MASK) >> DDR_CONTROL_EMRS_LSB)
+#define DDR_CONTROL_EMRS_SET(x)                                      (((x) << DDR_CONTROL_EMRS_LSB) & DDR_CONTROL_EMRS_MASK)
+#define DDR_CONTROL_EMRS_RESET                                       0x0 // 0
+#define DDR_CONTROL_MRS_MSB                                          0
+#define DDR_CONTROL_MRS_LSB                                          0
+#define DDR_CONTROL_MRS_MASK                                         0x00000001
+#define DDR_CONTROL_MRS_GET(x)                                       (((x) & DDR_CONTROL_MRS_MASK) >> DDR_CONTROL_MRS_LSB)
+#define DDR_CONTROL_MRS_SET(x)                                       (((x) << DDR_CONTROL_MRS_LSB) & DDR_CONTROL_MRS_MASK)
+#define DDR_CONTROL_MRS_RESET                                        0x0 // 0
+#define DDR_CONTROL_ADDRESS                                          0x18000010
+
+#define DDR_CONFIG_CAS_LATENCY_MSB_MSB                               31
+#define DDR_CONFIG_CAS_LATENCY_MSB_LSB                               31
+#define DDR_CONFIG_CAS_LATENCY_MSB_MASK                              0x80000000
+#define DDR_CONFIG_CAS_LATENCY_MSB_GET(x)                            (((x) & DDR_CONFIG_CAS_LATENCY_MSB_MASK) >> DDR_CONFIG_CAS_LATENCY_MSB_LSB)
+#define DDR_CONFIG_CAS_LATENCY_MSB_SET(x)                            (((x) << DDR_CONFIG_CAS_LATENCY_MSB_LSB) & DDR_CONFIG_CAS_LATENCY_MSB_MASK)
+#define DDR_CONFIG_CAS_LATENCY_MSB_RESET                             0x0 // 0
+#define DDR_CONFIG_OPEN_PAGE_MSB                                     30
+#define DDR_CONFIG_OPEN_PAGE_LSB                                     30
+#define DDR_CONFIG_OPEN_PAGE_MASK                                    0x40000000
+#define DDR_CONFIG_OPEN_PAGE_GET(x)                                  (((x) & DDR_CONFIG_OPEN_PAGE_MASK) >> DDR_CONFIG_OPEN_PAGE_LSB)
+#define DDR_CONFIG_OPEN_PAGE_SET(x)                                  (((x) << DDR_CONFIG_OPEN_PAGE_LSB) & DDR_CONFIG_OPEN_PAGE_MASK)
+#define DDR_CONFIG_OPEN_PAGE_RESET                                   0x1 // 1
+#define DDR_CONFIG_CAS_LATENCY_MSB                                   29
+#define DDR_CONFIG_CAS_LATENCY_LSB                                   27
+#define DDR_CONFIG_CAS_LATENCY_MASK                                  0x38000000
+#define DDR_CONFIG_CAS_LATENCY_GET(x)                                (((x) & DDR_CONFIG_CAS_LATENCY_MASK) >> DDR_CONFIG_CAS_LATENCY_LSB)
+#define DDR_CONFIG_CAS_LATENCY_SET(x)                                (((x) << DDR_CONFIG_CAS_LATENCY_LSB) & DDR_CONFIG_CAS_LATENCY_MASK)
+#define DDR_CONFIG_CAS_LATENCY_RESET                                 0x6 // 6
+#define DDR_CONFIG_TMRD_MSB                                          26
+#define DDR_CONFIG_TMRD_LSB                                          23
+#define DDR_CONFIG_TMRD_MASK                                         0x07800000
+#define DDR_CONFIG_TMRD_GET(x)                                       (((x) & DDR_CONFIG_TMRD_MASK) >> DDR_CONFIG_TMRD_LSB)
+#define DDR_CONFIG_TMRD_SET(x)                                       (((x) << DDR_CONFIG_TMRD_LSB) & DDR_CONFIG_TMRD_MASK)
+#define DDR_CONFIG_TMRD_RESET                                        0xf // 15
+#define DDR_CONFIG_TRFC_MSB                                          22
+#define DDR_CONFIG_TRFC_LSB                                          17
+#define DDR_CONFIG_TRFC_MASK                                         0x007e0000
+#define DDR_CONFIG_TRFC_GET(x)                                       (((x) & DDR_CONFIG_TRFC_MASK) >> DDR_CONFIG_TRFC_LSB)
+#define DDR_CONFIG_TRFC_SET(x)                                       (((x) << DDR_CONFIG_TRFC_LSB) & DDR_CONFIG_TRFC_MASK)
+#define DDR_CONFIG_TRFC_RESET                                        0x24 // 36
+#define DDR_CONFIG_TRRD_MSB                                          16
+#define DDR_CONFIG_TRRD_LSB                                          13
+#define DDR_CONFIG_TRRD_MASK                                         0x0001e000
+#define DDR_CONFIG_TRRD_GET(x)                                       (((x) & DDR_CONFIG_TRRD_MASK) >> DDR_CONFIG_TRRD_LSB)
+#define DDR_CONFIG_TRRD_SET(x)                                       (((x) << DDR_CONFIG_TRRD_LSB) & DDR_CONFIG_TRRD_MASK)
+#define DDR_CONFIG_TRRD_RESET                                        0x4 // 4
+#define DDR_CONFIG_TRP_MSB                                           12
+#define DDR_CONFIG_TRP_LSB                                           9
+#define DDR_CONFIG_TRP_MASK                                          0x00001e00
+#define DDR_CONFIG_TRP_GET(x)                                        (((x) & DDR_CONFIG_TRP_MASK) >> DDR_CONFIG_TRP_LSB)
+#define DDR_CONFIG_TRP_SET(x)                                        (((x) << DDR_CONFIG_TRP_LSB) & DDR_CONFIG_TRP_MASK)
+#define DDR_CONFIG_TRP_RESET                                         0x6 // 6
+#define DDR_CONFIG_TRCD_MSB                                          8
+#define DDR_CONFIG_TRCD_LSB                                          5
+#define DDR_CONFIG_TRCD_MASK                                         0x000001e0
+#define DDR_CONFIG_TRCD_GET(x)                                       (((x) & DDR_CONFIG_TRCD_MASK) >> DDR_CONFIG_TRCD_LSB)
+#define DDR_CONFIG_TRCD_SET(x)                                       (((x) << DDR_CONFIG_TRCD_LSB) & DDR_CONFIG_TRCD_MASK)
+#define DDR_CONFIG_TRCD_RESET                                        0x6 // 6
+#define DDR_CONFIG_TRAS_MSB                                          4
+#define DDR_CONFIG_TRAS_LSB                                          0
+#define DDR_CONFIG_TRAS_MASK                                         0x0000001f
+#define DDR_CONFIG_TRAS_GET(x)                                       (((x) & DDR_CONFIG_TRAS_MASK) >> DDR_CONFIG_TRAS_LSB)
+#define DDR_CONFIG_TRAS_SET(x)                                       (((x) << DDR_CONFIG_TRAS_LSB) & DDR_CONFIG_TRAS_MASK)
+#define DDR_CONFIG_TRAS_RESET                                        0x10 // 16
+#define DDR_CONFIG_ADDRESS                                           0x18000000
+
+#define DDR_CONFIG2_HALF_WIDTH_LOW_MSB                               31
+#define DDR_CONFIG2_HALF_WIDTH_LOW_LSB                               31
+#define DDR_CONFIG2_HALF_WIDTH_LOW_MASK                              0x80000000
+#define DDR_CONFIG2_HALF_WIDTH_LOW_GET(x)                            (((x) & DDR_CONFIG2_HALF_WIDTH_LOW_MASK) >> DDR_CONFIG2_HALF_WIDTH_LOW_LSB)
+#define DDR_CONFIG2_HALF_WIDTH_LOW_SET(x)                            (((x) << DDR_CONFIG2_HALF_WIDTH_LOW_LSB) & DDR_CONFIG2_HALF_WIDTH_LOW_MASK)
+#define DDR_CONFIG2_HALF_WIDTH_LOW_RESET                             0x1 // 1
+#define DDR_CONFIG2_SWAP_A26_A27_MSB                                 30
+#define DDR_CONFIG2_SWAP_A26_A27_LSB                                 30
+#define DDR_CONFIG2_SWAP_A26_A27_MASK                                0x40000000
+#define DDR_CONFIG2_SWAP_A26_A27_GET(x)                              (((x) & DDR_CONFIG2_SWAP_A26_A27_MASK) >> DDR_CONFIG2_SWAP_A26_A27_LSB)
+#define DDR_CONFIG2_SWAP_A26_A27_SET(x)                              (((x) << DDR_CONFIG2_SWAP_A26_A27_LSB) & DDR_CONFIG2_SWAP_A26_A27_MASK)
+#define DDR_CONFIG2_SWAP_A26_A27_RESET                               0x0 // 0
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_MSB                            29
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_LSB                            26
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_MASK                           0x3c000000
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_GET(x)                         (((x) & DDR_CONFIG2_GATE_OPEN_LATENCY_MASK) >> DDR_CONFIG2_GATE_OPEN_LATENCY_LSB)
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_SET(x)                         (((x) << DDR_CONFIG2_GATE_OPEN_LATENCY_LSB) & DDR_CONFIG2_GATE_OPEN_LATENCY_MASK)
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_RESET                          0x6 // 6
+#define DDR_CONFIG2_TWTR_MSB                                         25
+#define DDR_CONFIG2_TWTR_LSB                                         21
+#define DDR_CONFIG2_TWTR_MASK                                        0x03e00000
+#define DDR_CONFIG2_TWTR_GET(x)                                      (((x) & DDR_CONFIG2_TWTR_MASK) >> DDR_CONFIG2_TWTR_LSB)
+#define DDR_CONFIG2_TWTR_SET(x)                                      (((x) << DDR_CONFIG2_TWTR_LSB) & DDR_CONFIG2_TWTR_MASK)
+#define DDR_CONFIG2_TWTR_RESET                                       0xe // 14
+#define DDR_CONFIG2_TRTP_MSB                                         20
+#define DDR_CONFIG2_TRTP_LSB                                         17
+#define DDR_CONFIG2_TRTP_MASK                                        0x001e0000
+#define DDR_CONFIG2_TRTP_GET(x)                                      (((x) & DDR_CONFIG2_TRTP_MASK) >> DDR_CONFIG2_TRTP_LSB)
+#define DDR_CONFIG2_TRTP_SET(x)                                      (((x) << DDR_CONFIG2_TRTP_LSB) & DDR_CONFIG2_TRTP_MASK)
+#define DDR_CONFIG2_TRTP_RESET                                       0x8 // 8
+#define DDR_CONFIG2_TRTW_MSB                                         16
+#define DDR_CONFIG2_TRTW_LSB                                         12
+#define DDR_CONFIG2_TRTW_MASK                                        0x0001f000
+#define DDR_CONFIG2_TRTW_GET(x)                                      (((x) & DDR_CONFIG2_TRTW_MASK) >> DDR_CONFIG2_TRTW_LSB)
+#define DDR_CONFIG2_TRTW_SET(x)                                      (((x) << DDR_CONFIG2_TRTW_LSB) & DDR_CONFIG2_TRTW_MASK)
+#define DDR_CONFIG2_TRTW_RESET                                       0x10 // 16
+#define DDR_CONFIG2_TWR_MSB                                          11
+#define DDR_CONFIG2_TWR_LSB                                          8
+#define DDR_CONFIG2_TWR_MASK                                         0x00000f00
+#define DDR_CONFIG2_TWR_GET(x)                                       (((x) & DDR_CONFIG2_TWR_MASK) >> DDR_CONFIG2_TWR_LSB)
+#define DDR_CONFIG2_TWR_SET(x)                                       (((x) << DDR_CONFIG2_TWR_LSB) & DDR_CONFIG2_TWR_MASK)
+#define DDR_CONFIG2_TWR_RESET                                        0x6 // 6
+#define DDR_CONFIG2_CKE_MSB                                          7
+#define DDR_CONFIG2_CKE_LSB                                          7
+#define DDR_CONFIG2_CKE_MASK                                         0x00000080
+#define DDR_CONFIG2_CKE_GET(x)                                       (((x) & DDR_CONFIG2_CKE_MASK) >> DDR_CONFIG2_CKE_LSB)
+#define DDR_CONFIG2_CKE_SET(x)                                       (((x) << DDR_CONFIG2_CKE_LSB) & DDR_CONFIG2_CKE_MASK)
+#define DDR_CONFIG2_CKE_RESET                                        0x0 // 0
+#define DDR_CONFIG2_PHASE_SELECT_MSB                                 6
+#define DDR_CONFIG2_PHASE_SELECT_LSB                                 6
+#define DDR_CONFIG2_PHASE_SELECT_MASK                                0x00000040
+#define DDR_CONFIG2_PHASE_SELECT_GET(x)                              (((x) & DDR_CONFIG2_PHASE_SELECT_MASK) >> DDR_CONFIG2_PHASE_SELECT_LSB)
+#define DDR_CONFIG2_PHASE_SELECT_SET(x)                              (((x) << DDR_CONFIG2_PHASE_SELECT_LSB) & DDR_CONFIG2_PHASE_SELECT_MASK)
+#define DDR_CONFIG2_PHASE_SELECT_RESET                               0x0 // 0
+#define DDR_CONFIG2_CNTL_OE_EN_MSB                                   5
+#define DDR_CONFIG2_CNTL_OE_EN_LSB                                   5
+#define DDR_CONFIG2_CNTL_OE_EN_MASK                                  0x00000020
+#define DDR_CONFIG2_CNTL_OE_EN_GET(x)                                (((x) & DDR_CONFIG2_CNTL_OE_EN_MASK) >> DDR_CONFIG2_CNTL_OE_EN_LSB)
+#define DDR_CONFIG2_CNTL_OE_EN_SET(x)                                (((x) << DDR_CONFIG2_CNTL_OE_EN_LSB) & DDR_CONFIG2_CNTL_OE_EN_MASK)
+#define DDR_CONFIG2_CNTL_OE_EN_RESET                                 0x1 // 1
+#define DDR_CONFIG2_BURST_TYPE_MSB                                   4
+#define DDR_CONFIG2_BURST_TYPE_LSB                                   4
+#define DDR_CONFIG2_BURST_TYPE_MASK                                  0x00000010
+#define DDR_CONFIG2_BURST_TYPE_GET(x)                                (((x) & DDR_CONFIG2_BURST_TYPE_MASK) >> DDR_CONFIG2_BURST_TYPE_LSB)
+#define DDR_CONFIG2_BURST_TYPE_SET(x)                                (((x) << DDR_CONFIG2_BURST_TYPE_LSB) & DDR_CONFIG2_BURST_TYPE_MASK)
+#define DDR_CONFIG2_BURST_TYPE_RESET                                 0x0 // 0
+#define DDR_CONFIG2_BURST_LENGTH_MSB                                 3
+#define DDR_CONFIG2_BURST_LENGTH_LSB                                 0
+#define DDR_CONFIG2_BURST_LENGTH_MASK                                0x0000000f
+#define DDR_CONFIG2_BURST_LENGTH_GET(x)                              (((x) & DDR_CONFIG2_BURST_LENGTH_MASK) >> DDR_CONFIG2_BURST_LENGTH_LSB)
+#define DDR_CONFIG2_BURST_LENGTH_SET(x)                              (((x) << DDR_CONFIG2_BURST_LENGTH_LSB) & DDR_CONFIG2_BURST_LENGTH_MASK)
+#define DDR_CONFIG2_BURST_LENGTH_RESET                               0x8 // 8
+#define DDR_CONFIG2_ADDRESS                                          0x18000004
+
+#define DDR_CONFIG_3_SPARE_MSB                                       31
+#define DDR_CONFIG_3_SPARE_LSB                                       4
+#define DDR_CONFIG_3_SPARE_MASK                                      0xfffffff0
+#define DDR_CONFIG_3_SPARE_GET(x)                                    (((x) & DDR_CONFIG_3_SPARE_MASK) >> DDR_CONFIG_3_SPARE_LSB)
+#define DDR_CONFIG_3_SPARE_SET(x)                                    (((x) << DDR_CONFIG_3_SPARE_LSB) & DDR_CONFIG_3_SPARE_MASK)
+#define DDR_CONFIG_3_SPARE_RESET                                     0x0 // 0
+#define DDR_CONFIG_3_TWR_MSB_MSB                                     3
+#define DDR_CONFIG_3_TWR_MSB_LSB                                     3
+#define DDR_CONFIG_3_TWR_MSB_MASK                                    0x00000008
+#define DDR_CONFIG_3_TWR_MSB_GET(x)                                  (((x) & DDR_CONFIG_3_TWR_MSB_MASK) >> DDR_CONFIG_3_TWR_MSB_LSB)
+#define DDR_CONFIG_3_TWR_MSB_SET(x)                                  (((x) << DDR_CONFIG_3_TWR_MSB_LSB) & DDR_CONFIG_3_TWR_MSB_MASK)
+#define DDR_CONFIG_3_TWR_MSB_RESET                                   0x0 // 0
+#define DDR_CONFIG_3_TRAS_MSB_MSB                                    2
+#define DDR_CONFIG_3_TRAS_MSB_LSB                                    2
+#define DDR_CONFIG_3_TRAS_MSB_MASK                                   0x00000004
+#define DDR_CONFIG_3_TRAS_MSB_GET(x)                                 (((x) & DDR_CONFIG_3_TRAS_MSB_MASK) >> DDR_CONFIG_3_TRAS_MSB_LSB)
+#define DDR_CONFIG_3_TRAS_MSB_SET(x)                                 (((x) << DDR_CONFIG_3_TRAS_MSB_LSB) & DDR_CONFIG_3_TRAS_MSB_MASK)
+#define DDR_CONFIG_3_TRAS_MSB_RESET                                  0x0 // 0
+#define DDR_CONFIG_3_TRFC_LSB_MSB                                    1
+#define DDR_CONFIG_3_TRFC_LSB_LSB                                    0
+#define DDR_CONFIG_3_TRFC_LSB_MASK                                   0x00000003
+#define DDR_CONFIG_3_TRFC_LSB_GET(x)                                 (((x) & DDR_CONFIG_3_TRFC_LSB_MASK) >> DDR_CONFIG_3_TRFC_LSB_LSB)
+#define DDR_CONFIG_3_TRFC_LSB_SET(x)                                 (((x) << DDR_CONFIG_3_TRFC_LSB_LSB) & DDR_CONFIG_3_TRFC_LSB_MASK)
+#define DDR_CONFIG_3_TRFC_LSB_RESET                                  0x0 // 0
+#define DDR_CONFIG_3_ADDRESS                                         0x1800015c
+
+#define DDR_MODE_REGISTER_VALUE_MSB                                  13
+#define DDR_MODE_REGISTER_VALUE_LSB                                  0
+#define DDR_MODE_REGISTER_VALUE_MASK                                 0x00003fff
+#define DDR_MODE_REGISTER_VALUE_GET(x)                               (((x) & DDR_MODE_REGISTER_VALUE_MASK) >> DDR_MODE_REGISTER_VALUE_LSB)
+#define DDR_MODE_REGISTER_VALUE_SET(x)                               (((x) << DDR_MODE_REGISTER_VALUE_LSB) & DDR_MODE_REGISTER_VALUE_MASK)
+#define DDR_MODE_REGISTER_VALUE_RESET                                0x133 // 307
+#define DDR_MODE_REGISTER_ADDRESS                                    0x18000008
+
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_MSB                         13
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_LSB                         0
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_MASK                        0x00003fff
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_GET(x)                      (((x) & DDR_EXTENDED_MODE_REGISTER_VALUE_MASK) >> DDR_EXTENDED_MODE_REGISTER_VALUE_LSB)
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_SET(x)                      (((x) << DDR_EXTENDED_MODE_REGISTER_VALUE_LSB) & DDR_EXTENDED_MODE_REGISTER_VALUE_MASK)
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_RESET                       0x2 // 2
+#define DDR_EXTENDED_MODE_REGISTER_ADDRESS                           0x1800000c
+
+#define DDR_REFRESH_ENABLE_MSB                                       14
+#define DDR_REFRESH_ENABLE_LSB                                       14
+#define DDR_REFRESH_ENABLE_MASK                                      0x00004000
+#define DDR_REFRESH_ENABLE_GET(x)                                    (((x) & DDR_REFRESH_ENABLE_MASK) >> DDR_REFRESH_ENABLE_LSB)
+#define DDR_REFRESH_ENABLE_SET(x)                                    (((x) << DDR_REFRESH_ENABLE_LSB) & DDR_REFRESH_ENABLE_MASK)
+#define DDR_REFRESH_ENABLE_RESET                                     0x0 // 0
+#define DDR_REFRESH_PERIOD_MSB                                       13
+#define DDR_REFRESH_PERIOD_LSB                                       0
+#define DDR_REFRESH_PERIOD_MASK                                      0x00003fff
+#define DDR_REFRESH_PERIOD_GET(x)                                    (((x) & DDR_REFRESH_PERIOD_MASK) >> DDR_REFRESH_PERIOD_LSB)
+#define DDR_REFRESH_PERIOD_SET(x)                                    (((x) << DDR_REFRESH_PERIOD_LSB) & DDR_REFRESH_PERIOD_MASK)
+#define DDR_REFRESH_PERIOD_RESET                                     0x12c // 300
+#define DDR_REFRESH_ADDRESS                                          0x18000014
+
+#define DDR_EMR2_ADDRESS                                             0x180000bc
+#define DDR_EMR3_ADDRESS                                             0x180000c0
+
+#define BIAS4_PWD_IC25PLLREG_BB_MSB                                  31
+#define BIAS4_PWD_IC25PLLREG_BB_LSB                                  29
+#define BIAS4_PWD_IC25PLLREG_BB_MASK                                 0xe0000000
+#define BIAS4_PWD_IC25PLLREG_BB_GET(x)                               (((x) & BIAS4_PWD_IC25PLLREG_BB_MASK) >> BIAS4_PWD_IC25PLLREG_BB_LSB)
+#define BIAS4_PWD_IC25PLLREG_BB_SET(x)                               (((x) << BIAS4_PWD_IC25PLLREG_BB_LSB) & BIAS4_PWD_IC25PLLREG_BB_MASK)
+#define BIAS4_PWD_IC25PLLREG_BB_RESET                                0x3
+#define BIAS4_PWD_IC25TESTIQ_MSB                                     28
+#define BIAS4_PWD_IC25TESTIQ_LSB                                     26
+#define BIAS4_PWD_IC25TESTIQ_MASK                                    0x1c000000
+#define BIAS4_PWD_IC25TESTIQ_GET(x)                                  (((x) & BIAS4_PWD_IC25TESTIQ_MASK) >> BIAS4_PWD_IC25TESTIQ_LSB)
+#define BIAS4_PWD_IC25TESTIQ_SET(x)                                  (((x) << BIAS4_PWD_IC25TESTIQ_LSB) & BIAS4_PWD_IC25TESTIQ_MASK)
+#define BIAS4_PWD_IC25TESTIQ_RESET                                   0x3
+#define BIAS4_PWD_IC25XPABIAS_MSB                                    25
+#define BIAS4_PWD_IC25XPABIAS_LSB                                    23
+#define BIAS4_PWD_IC25XPABIAS_MASK                                   0x03800000
+#define BIAS4_PWD_IC25XPABIAS_GET(x)                                 (((x) & BIAS4_PWD_IC25XPABIAS_MASK) >> BIAS4_PWD_IC25XPABIAS_LSB)
+#define BIAS4_PWD_IC25XPABIAS_SET(x)                                 (((x) << BIAS4_PWD_IC25XPABIAS_LSB) & BIAS4_PWD_IC25XPABIAS_MASK)
+#define BIAS4_PWD_IC25XPABIAS_RESET                                  0x3
+#define BIAS4_PWD_IR25PLL_PCIE_MSB                                   22
+#define BIAS4_PWD_IR25PLL_PCIE_LSB                                   20
+#define BIAS4_PWD_IR25PLL_PCIE_MASK                                  0x00700000
+#define BIAS4_PWD_IR25PLL_PCIE_GET(x)                                (((x) & BIAS4_PWD_IR25PLL_PCIE_MASK) >> BIAS4_PWD_IR25PLL_PCIE_LSB)
+#define BIAS4_PWD_IR25PLL_PCIE_SET(x)                                (((x) << BIAS4_PWD_IR25PLL_PCIE_LSB) & BIAS4_PWD_IR25PLL_PCIE_MASK)
+#define BIAS4_PWD_IR25PLL_PCIE_RESET                                 0x3
+#define BIAS4_PWD_IR25THERMADC_MSB                                   19
+#define BIAS4_PWD_IR25THERMADC_LSB                                   17
+#define BIAS4_PWD_IR25THERMADC_MASK                                  0x000e0000
+#define BIAS4_PWD_IR25THERMADC_GET(x)                                (((x) & BIAS4_PWD_IR25THERMADC_MASK) >> BIAS4_PWD_IR25THERMADC_LSB)
+#define BIAS4_PWD_IR25THERMADC_SET(x)                                (((x) << BIAS4_PWD_IR25THERMADC_LSB) & BIAS4_PWD_IR25THERMADC_MASK)
+#define BIAS4_PWD_IR25THERMADC_RESET                                 0x3
+#define BIAS4_IR25XPABIAS_MSB                                        16
+#define BIAS4_IR25XPABIAS_LSB                                        14
+#define BIAS4_IR25XPABIAS_MASK                                       0x0001c000
+#define BIAS4_IR25XPABIAS_GET(x)                                     (((x) & BIAS4_IR25XPABIAS_MASK) >> BIAS4_IR25XPABIAS_LSB)
+#define BIAS4_IR25XPABIAS_SET(x)                                     (((x) << BIAS4_IR25XPABIAS_LSB) & BIAS4_IR25XPABIAS_MASK)
+#define BIAS4_IR25XPABIAS_RESET                                      0x3
+#define BIAS4_PWD_IR25SPARE_MSB                                      13
+#define BIAS4_PWD_IR25SPARE_LSB                                      11
+#define BIAS4_PWD_IR25SPARE_MASK                                     0x00003800
+#define BIAS4_PWD_IR25SPARE_GET(x)                                   (((x) & BIAS4_PWD_IR25SPARE_MASK) >> BIAS4_PWD_IR25SPARE_LSB)
+#define BIAS4_PWD_IR25SPARE_SET(x)                                   (((x) << BIAS4_PWD_IR25SPARE_LSB) & BIAS4_PWD_IR25SPARE_MASK)
+#define BIAS4_PWD_IR25SPARE_RESET                                    0x7
+#define BIAS4_PWD_IR25USB1_MSB                                       10
+#define BIAS4_PWD_IR25USB1_LSB                                       8
+#define BIAS4_PWD_IR25USB1_MASK                                      0x00000700
+#define BIAS4_PWD_IR25USB1_GET(x)                                    (((x) & BIAS4_PWD_IR25USB1_MASK) >> BIAS4_PWD_IR25USB1_LSB)
+#define BIAS4_PWD_IR25USB1_SET(x)                                    (((x) << BIAS4_PWD_IR25USB1_LSB) & BIAS4_PWD_IR25USB1_MASK)
+#define BIAS4_PWD_IR25USB1_RESET                                     0x3
+#define BIAS4_PWD_IR25USB2_MSB                                       7
+#define BIAS4_PWD_IR25USB2_LSB                                       5
+#define BIAS4_PWD_IR25USB2_MASK                                      0x000000e0
+#define BIAS4_PWD_IR25USB2_GET(x)                                    (((x) & BIAS4_PWD_IR25USB2_MASK) >> BIAS4_PWD_IR25USB2_LSB)
+#define BIAS4_PWD_IR25USB2_SET(x)                                    (((x) << BIAS4_PWD_IR25USB2_LSB) & BIAS4_PWD_IR25USB2_MASK)
+#define BIAS4_PWD_IR25USB2_RESET                                     0x3
+#define BIAS4_PWD_IR50SPARE_MSB                                      4
+#define BIAS4_PWD_IR50SPARE_LSB                                      2
+#define BIAS4_PWD_IR50SPARE_MASK                                     0x0000001C
+#define BIAS4_PWD_IR50SPARE_GET(x)                                   (((x) & BIAS4_PWD_IR50SPARE_MASK) >> BIAS4_PWD_IR50SPARE_LSB)
+#define BIAS4_PWD_IR50SPARE_SET(x)                                   (((x) << BIAS4_PWD_IR50SPARE_LSB) & BIAS4_PWD_IR50SPARE_MASK)
+#define BIAS4_PWD_IR50SPARE_RESET                                    0x7
+#define BIAS4_SPARE4_MSB                                             1
+#define BIAS4_SPARE4_LSB                                             0
+#define BIAS4_SPARE4_MASK                                            0x00000003
+#define BIAS4_SPARE4_GET(x)                                          (((x) & BIAS4_SPARE4_MASK) >> BIAS4_SPARE4_LSB)
+#define BIAS4_SPARE4_SET(x)                                          (((x) << BIAS4_SPARE4_LSB) & BIAS4_SPARE4_MASK)
+#define BIAS4_SPARE4_RESET                                           0x0
+#define BIAS4_ADDRESS                                                0x181160cc
+
+#define BIAS5_PWD_IC25SPARED_MSB                                     31
+#define BIAS5_PWD_IC25SPARED_LSB                                     29
+#define BIAS5_PWD_IC25SPARED_MASK                                    0xe0000000
+#define BIAS5_PWD_IC25SPARED_GET(x)                                  (((x) & BIAS5_PWD_IC25SPARED_MASK) >> BIAS5_PWD_IC25SPARED_LSB)
+#define BIAS5_PWD_IC25SPARED_SET(x)                                  (((x) << BIAS5_PWD_IC25SPARED_LSB) & BIAS5_PWD_IC25SPARED_MASK)
+#define BIAS5_PWD_IC25SPARED_RESET                                   0x3
+#define BIAS5_PWD_IC25USB1_MSB                                       28
+#define BIAS5_PWD_IC25USB1_LSB                                       26
+#define BIAS5_PWD_IC25USB1_MASK                                      0x1c000000
+#define BIAS5_PWD_IC25USB1_GET(x)                                    (((x) & BIAS5_PWD_IC25USB1_MASK) >> BIAS5_PWD_IC25USB1_LSB)
+#define BIAS5_PWD_IC25USB1_SET(x)                                    (((x) << BIAS5_PWD_IC25USB1_LSB) & BIAS5_PWD_IC25USB1_MASK)
+#define BIAS5_PWD_IC25USB1_RESET                                     0x3
+#define BIAS5_PWD_IC25USB1_PLL_MSB                                   25
+#define BIAS5_PWD_IC25USB1_PLL_LSB                                   23
+#define BIAS5_PWD_IC25USB1_PLL_MASK                                  0x03800000
+#define BIAS5_PWD_IC25USB1_PLL_GET(x)                                (((x) & BIAS5_PWD_IC25USB1_PLL_MASK) >> BIAS5_PWD_IC25USB1_PLL_LSB)
+#define BIAS5_PWD_IC25USB1_PLL_SET(x)                                (((x) << BIAS5_PWD_IC25USB1_PLL_LSB) & BIAS5_PWD_IC25USB1_PLL_MASK)
+#define BIAS5_PWD_IC25USB1_PLL_RESET                                 0x3
+#define BIAS5_PWD_IC25USB1_PLLGM_MSB                                 22
+#define BIAS5_PWD_IC25USB1_PLLGM_LSB                                 20
+#define BIAS5_PWD_IC25USB1_PLLGM_MASK                                0x00700000
+#define BIAS5_PWD_IC25USB1_PLLGM_GET(x)                              (((x) & BIAS5_PWD_IC25USB1_PLLGM_MASK) >> BIAS5_PWD_IC25USB1_PLLGM_LSB)
+#define BIAS5_PWD_IC25USB1_PLLGM_SET(x)                              (((x) << BIAS5_PWD_IC25USB1_PLLGM_LSB) & BIAS5_PWD_IC25USB1_PLLGM_MASK)
+#define BIAS5_PWD_IC25USB1_PLLGM_RESET                               0x3
+#define BIAS5_PWD_IC25USB2_MSB                                       19
+#define BIAS5_PWD_IC25USB2_LSB                                       17
+#define BIAS5_PWD_IC25USB2_MASK                                      0x000e0000
+#define BIAS5_PWD_IC25USB2_GET(x)                                    (((x) & BIAS5_PWD_IC25USB2_MASK) >> BIAS5_PWD_IC25USB2_LSB)
+#define BIAS5_PWD_IC25USB2_SET(x)                                    (((x) << BIAS5_PWD_IC25USB2_LSB) & BIAS5_PWD_IC25USB2_MASK)
+#define BIAS5_PWD_IC25USB2_RESET                                     0x3
+#define BIAS5_PWD_IC25USB2_PLL_MSB                                   16
+#define BIAS5_PWD_IC25USB2_PLL_LSB                                   14
+#define BIAS5_PWD_IC25USB2_PLL_MASK                                  0x0001c000
+#define BIAS5_PWD_IC25USB2_PLL_GET(x)                                (((x) & BIAS5_PWD_IC25USB2_PLL_MASK) >> BIAS5_PWD_IC25USB2_PLL_LSB)
+#define BIAS5_PWD_IC25USB2_PLL_SET(x)                                (((x) << BIAS5_PWD_IC25USB2_PLL_LSB) & BIAS5_PWD_IC25USB2_PLL_MASK)
+#define BIAS5_PWD_IC25USB2_PLL_RESET                                 0x3
+#define BIAS5_PWD_IC25USB2_PLLGM_MSB                                 13
+#define BIAS5_PWD_IC25USB2_PLLGM_LSB                                 11
+#define BIAS5_PWD_IC25USB2_PLLGM_MASK                                0x00003800
+#define BIAS5_PWD_IC25USB2_PLLGM_GET(x)                              (((x) & BIAS5_PWD_IC25USB2_PLLGM_MASK) >> BIAS5_PWD_IC25USB2_PLLGM_LSB)
+#define BIAS5_PWD_IC25USB2_PLLGM_SET(x)                              (((x) << BIAS5_PWD_IC25USB2_PLLGM_LSB) & BIAS5_PWD_IC25USB2_PLLGM_MASK)
+#define BIAS5_PWD_IC25USB2_PLLGM_RESET                               0x3
+#define BIAS5_PWD_IC100PCIE1_MSB                                     10
+#define BIAS5_PWD_IC100PCIE1_LSB                                     8
+#define BIAS5_PWD_IC100PCIE1_MASK                                    0x00000700
+#define BIAS5_PWD_IC100PCIE1_GET(x)                                  (((x) & BIAS5_PWD_IC100PCIE1_MASK) >> BIAS5_PWD_IC100PCIE1_LSB)
+#define BIAS5_PWD_IC100PCIE1_SET(x)                                  (((x) << BIAS5_PWD_IC100PCIE1_LSB) & BIAS5_PWD_IC100PCIE1_MASK)
+#define BIAS5_PWD_IC100PCIE1_RESET                                   0x2
+#define BIAS5_PWD_IC100PCIE2_MSB                                     7
+#define BIAS5_PWD_IC100PCIE2_LSB                                     5
+#define BIAS5_PWD_IC100PCIE2_MASK                                    0x000000e0
+#define BIAS5_PWD_IC100PCIE2_GET(x)                                  (((x) & BIAS5_PWD_IC100PCIE2_MASK) >> BIAS5_PWD_IC100PCIE2_LSB)
+#define BIAS5_PWD_IC100PCIE2_SET(x)                                  (((x) << BIAS5_PWD_IC100PCIE2_LSB) & BIAS5_PWD_IC100PCIE2_MASK)
+#define BIAS5_PWD_IC100PCIE2_RESET                                   0x2
+#define BIAS5_PWD_IC75PLL_PCIE_MSB                                   4
+#define BIAS5_PWD_IC75PLL_PCIE_LSB                                   2
+#define BIAS5_PWD_IC75PLL_PCIE_MASK                                  0x0000001C
+#define BIAS5_PWD_IC75PLL_PCIE_GET(x)                                (((x) & BIAS5_PWD_IC75PLL_PCIE_MASK) >> BIAS5_PWD_IC75PLL_PCIE_LSB)
+#define BIAS5_PWD_IC75PLL_PCIE_SET(x)                                (((x) << BIAS5_PWD_IC75PLL_PCIE_LSB) & BIAS5_PWD_IC75PLL_PCIE_MASK)
+#define BIAS5_PWD_IC75PLL_PCIE_RESET                                 0x1
+#define BIAS5_SPARE5_MSB                                             1
+#define BIAS5_SPARE5_LSB                                             0
+#define BIAS5_SPARE5_MASK                                            0x00000003
+#define BIAS5_SPARE5_GET(x)                                          (((x) & BIAS5_SPARE5_MASK) >> BIAS5_SPARE5_LSB)
+#define BIAS5_SPARE5_SET(x)                                          (((x) << BIAS5_SPARE5_LSB) & BIAS5_SPARE5_MASK)
+#define BIAS5_SPARE5_RESET                                           0x0
+#define BIAS5_ADDRESS                                                0x181160d0
+
+#define BB_DPLL2_LOCAL_PLL_MSB                                       31
+#define BB_DPLL2_LOCAL_PLL_LSB                                       31
+#define BB_DPLL2_LOCAL_PLL_MASK                                      0x80000000
+#define BB_DPLL2_LOCAL_PLL_GET(x)                                    (((x) & BB_DPLL2_LOCAL_PLL_MASK) >> BB_DPLL2_LOCAL_PLL_LSB)
+#define BB_DPLL2_LOCAL_PLL_SET(x)                                    (((x) << BB_DPLL2_LOCAL_PLL_LSB) & BB_DPLL2_LOCAL_PLL_MASK)
+#define BB_DPLL2_LOCAL_PLL_RESET                                     0x0 // 0
+#define BB_DPLL2_KI_MSB                                              30
+#define BB_DPLL2_KI_LSB                                              29
+#define BB_DPLL2_KI_MASK                                             0x60000000
+#define BB_DPLL2_KI_GET(x)                                           (((x) & BB_DPLL2_KI_MASK) >> BB_DPLL2_KI_LSB)
+#define BB_DPLL2_KI_SET(x)                                           (((x) << BB_DPLL2_KI_LSB) & BB_DPLL2_KI_MASK)
+#define BB_DPLL2_KI_RESET                                            0x2 // 2
+#define BB_DPLL2_KD_MSB                                              28
+#define BB_DPLL2_KD_LSB                                              25
+#define BB_DPLL2_KD_MASK                                             0x1e000000
+#define BB_DPLL2_KD_GET(x)                                           (((x) & BB_DPLL2_KD_MASK) >> BB_DPLL2_KD_LSB)
+#define BB_DPLL2_KD_SET(x)                                           (((x) << BB_DPLL2_KD_LSB) & BB_DPLL2_KD_MASK)
+#define BB_DPLL2_KD_RESET                                            0xa // 10
+#define BB_DPLL2_EN_NEGTRIG_MSB                                      24
+#define BB_DPLL2_EN_NEGTRIG_LSB                                      24
+#define BB_DPLL2_EN_NEGTRIG_MASK                                     0x01000000
+#define BB_DPLL2_EN_NEGTRIG_GET(x)                                   (((x) & BB_DPLL2_EN_NEGTRIG_MASK) >> BB_DPLL2_EN_NEGTRIG_LSB)
+#define BB_DPLL2_EN_NEGTRIG_SET(x)                                   (((x) << BB_DPLL2_EN_NEGTRIG_LSB) & BB_DPLL2_EN_NEGTRIG_MASK)
+#define BB_DPLL2_EN_NEGTRIG_RESET                                    0x0 // 0
+#define BB_DPLL2_SEL_1SDM_MSB                                        23
+#define BB_DPLL2_SEL_1SDM_LSB                                        23
+#define BB_DPLL2_SEL_1SDM_MASK                                       0x00800000
+#define BB_DPLL2_SEL_1SDM_GET(x)                                     (((x) & BB_DPLL2_SEL_1SDM_MASK) >> BB_DPLL2_SEL_1SDM_LSB)
+#define BB_DPLL2_SEL_1SDM_SET(x)                                     (((x) << BB_DPLL2_SEL_1SDM_LSB) & BB_DPLL2_SEL_1SDM_MASK)
+#define BB_DPLL2_SEL_1SDM_RESET                                      0x0 // 0
+#define BB_DPLL2_PLL_PWD_MSB                                         22
+#define BB_DPLL2_PLL_PWD_LSB                                         22
+#define BB_DPLL2_PLL_PWD_MASK                                        0x00400000
+#define BB_DPLL2_PLL_PWD_GET(x)                                      (((x) & BB_DPLL2_PLL_PWD_MASK) >> BB_DPLL2_PLL_PWD_LSB)
+#define BB_DPLL2_PLL_PWD_SET(x)                                      (((x) << BB_DPLL2_PLL_PWD_LSB) & BB_DPLL2_PLL_PWD_MASK)
+#define BB_DPLL2_PLL_PWD_RESET                                       0x1 // 1
+#define BB_DPLL2_OUTDIV_MSB                                          21
+#define BB_DPLL2_OUTDIV_LSB                                          19
+#define BB_DPLL2_OUTDIV_MASK                                         0x00380000
+#define BB_DPLL2_OUTDIV_GET(x)                                       (((x) & BB_DPLL2_OUTDIV_MASK) >> BB_DPLL2_OUTDIV_LSB)
+#define BB_DPLL2_OUTDIV_SET(x)                                       (((x) << BB_DPLL2_OUTDIV_LSB) & BB_DPLL2_OUTDIV_MASK)
+#define BB_DPLL2_OUTDIV_RESET                                        0x1 // 1
+#define BB_DPLL2_PHASE_SHIFT_MSB                                     18
+#define BB_DPLL2_PHASE_SHIFT_LSB                                     12
+#define BB_DPLL2_PHASE_SHIFT_MASK                                    0x0007f000
+#define BB_DPLL2_PHASE_SHIFT_GET(x)                                  (((x) & BB_DPLL2_PHASE_SHIFT_MASK) >> BB_DPLL2_PHASE_SHIFT_LSB)
+#define BB_DPLL2_PHASE_SHIFT_SET(x)                                  (((x) << BB_DPLL2_PHASE_SHIFT_LSB) & BB_DPLL2_PHASE_SHIFT_MASK)
+#define BB_DPLL2_PHASE_SHIFT_RESET                                   0x0 // 0
+#define BB_DPLL2_TESTIN_MSB                                          11
+#define BB_DPLL2_TESTIN_LSB                                          2
+#define BB_DPLL2_TESTIN_MASK                                         0x00000ffc
+#define BB_DPLL2_TESTIN_GET(x)                                       (((x) & BB_DPLL2_TESTIN_MASK) >> BB_DPLL2_TESTIN_LSB)
+#define BB_DPLL2_TESTIN_SET(x)                                       (((x) << BB_DPLL2_TESTIN_LSB) & BB_DPLL2_TESTIN_MASK)
+#define BB_DPLL2_TESTIN_RESET                                        0x0 // 0
+#define BB_DPLL2_SEL_COUNT_MSB                                       1
+#define BB_DPLL2_SEL_COUNT_LSB                                       1
+#define BB_DPLL2_SEL_COUNT_MASK                                      0x00000002
+#define BB_DPLL2_SEL_COUNT_GET(x)                                    (((x) & BB_DPLL2_SEL_COUNT_MASK) >> BB_DPLL2_SEL_COUNT_LSB)
+#define BB_DPLL2_SEL_COUNT_SET(x)                                    (((x) << BB_DPLL2_SEL_COUNT_LSB) & BB_DPLL2_SEL_COUNT_MASK)
+#define BB_DPLL2_SEL_COUNT_RESET                                     0x0 // 0
+#define BB_DPLL2_RESET_TEST_MSB                                      0
+#define BB_DPLL2_RESET_TEST_LSB                                      0
+#define BB_DPLL2_RESET_TEST_MASK                                     0x00000001
+#define BB_DPLL2_RESET_TEST_GET(x)                                   (((x) & BB_DPLL2_RESET_TEST_MASK) >> BB_DPLL2_RESET_TEST_LSB)
+#define BB_DPLL2_RESET_TEST_SET(x)                                   (((x) << BB_DPLL2_RESET_TEST_LSB) & BB_DPLL2_RESET_TEST_MASK)
+#define BB_DPLL2_RESET_TEST_RESET                                    0x0 // 0
+#define BB_DPLL2_ADDRESS                                             0x18116184
+
+#define PCIe_DPLL2_LOCAL_PLL_MSB                                     31
+#define PCIe_DPLL2_LOCAL_PLL_LSB                                     31
+#define PCIe_DPLL2_LOCAL_PLL_MASK                                    0x80000000
+#define PCIe_DPLL2_LOCAL_PLL_GET(x)                                  (((x) & PCIe_DPLL2_LOCAL_PLL_MASK) >> PCIe_DPLL2_LOCAL_PLL_LSB)
+#define PCIe_DPLL2_LOCAL_PLL_SET(x)                                  (((x) << PCIe_DPLL2_LOCAL_PLL_LSB) & PCIe_DPLL2_LOCAL_PLL_MASK)
+#define PCIe_DPLL2_LOCAL_PLL_RESET                                   0x0 // 0
+#define PCIe_DPLL2_KI_MSB                                            30
+#define PCIe_DPLL2_KI_LSB                                            29
+#define PCIe_DPLL2_KI_MASK                                           0x60000000
+#define PCIe_DPLL2_KI_GET(x)                                         (((x) & PCIe_DPLL2_KI_MASK) >> PCIe_DPLL2_KI_LSB)
+#define PCIe_DPLL2_KI_SET(x)                                         (((x) << PCIe_DPLL2_KI_LSB) & PCIe_DPLL2_KI_MASK)
+#define PCIe_DPLL2_KI_RESET                                          0x2 // 2
+#define PCIe_DPLL2_KD_MSB                                            28
+#define PCIe_DPLL2_KD_LSB                                            25
+#define PCIe_DPLL2_KD_MASK                                           0x1e000000
+#define PCIe_DPLL2_KD_GET(x)                                         (((x) & PCIe_DPLL2_KD_MASK) >> PCIe_DPLL2_KD_LSB)
+#define PCIe_DPLL2_KD_SET(x)                                         (((x) << PCIe_DPLL2_KD_LSB) & PCIe_DPLL2_KD_MASK)
+#define PCIe_DPLL2_KD_RESET                                          0xa // 10
+#define PCIe_DPLL2_EN_NEGTRIG_MSB                                    24
+#define PCIe_DPLL2_EN_NEGTRIG_LSB                                    24
+#define PCIe_DPLL2_EN_NEGTRIG_MASK                                   0x01000000
+#define PCIe_DPLL2_EN_NEGTRIG_GET(x)                                 (((x) & PCIe_DPLL2_EN_NEGTRIG_MASK) >> PCIe_DPLL2_EN_NEGTRIG_LSB)
+#define PCIe_DPLL2_EN_NEGTRIG_SET(x)                                 (((x) << PCIe_DPLL2_EN_NEGTRIG_LSB) & PCIe_DPLL2_EN_NEGTRIG_MASK)
+#define PCIe_DPLL2_EN_NEGTRIG_RESET                                  0x0 // 0
+#define PCIe_DPLL2_SEL_1SDM_MSB                                      23
+#define PCIe_DPLL2_SEL_1SDM_LSB                                      23
+#define PCIe_DPLL2_SEL_1SDM_MASK                                     0x00800000
+#define PCIe_DPLL2_SEL_1SDM_GET(x)                                   (((x) & PCIe_DPLL2_SEL_1SDM_MASK) >> PCIe_DPLL2_SEL_1SDM_LSB)
+#define PCIe_DPLL2_SEL_1SDM_SET(x)                                   (((x) << PCIe_DPLL2_SEL_1SDM_LSB) & PCIe_DPLL2_SEL_1SDM_MASK)
+#define PCIe_DPLL2_SEL_1SDM_RESET                                    0x0 // 0
+#define PCIe_DPLL2_PLL_PWD_MSB                                       22
+#define PCIe_DPLL2_PLL_PWD_LSB                                       22
+#define PCIe_DPLL2_PLL_PWD_MASK                                      0x00400000
+#define PCIe_DPLL2_PLL_PWD_GET(x)                                    (((x) & PCIe_DPLL2_PLL_PWD_MASK) >> PCIe_DPLL2_PLL_PWD_LSB)
+#define PCIe_DPLL2_PLL_PWD_SET(x)                                    (((x) << PCIe_DPLL2_PLL_PWD_LSB) & PCIe_DPLL2_PLL_PWD_MASK)
+#define PCIe_DPLL2_PLL_PWD_RESET                                     0x1 // 1
+#define PCIe_DPLL2_OUTDIV_MSB                                        21
+#define PCIe_DPLL2_OUTDIV_LSB                                        19
+#define PCIe_DPLL2_OUTDIV_MASK                                       0x00380000
+#define PCIe_DPLL2_OUTDIV_GET(x)                                     (((x) & PCIe_DPLL2_OUTDIV_MASK) >> PCIe_DPLL2_OUTDIV_LSB)
+#define PCIe_DPLL2_OUTDIV_SET(x)                                     (((x) << PCIe_DPLL2_OUTDIV_LSB) & PCIe_DPLL2_OUTDIV_MASK)
+#define PCIe_DPLL2_OUTDIV_RESET                                      0x1 // 1
+#define PCIe_DPLL2_PHASE_SHIFT_MSB                                   18
+#define PCIe_DPLL2_PHASE_SHIFT_LSB                                   12
+#define PCIe_DPLL2_PHASE_SHIFT_MASK                                  0x0007f000
+#define PCIe_DPLL2_PHASE_SHIFT_GET(x)                                (((x) & PCIe_DPLL2_PHASE_SHIFT_MASK) >> PCIe_DPLL2_PHASE_SHIFT_LSB)
+#define PCIe_DPLL2_PHASE_SHIFT_SET(x)                                (((x) << PCIe_DPLL2_PHASE_SHIFT_LSB) & PCIe_DPLL2_PHASE_SHIFT_MASK)
+#define PCIe_DPLL2_PHASE_SHIFT_RESET                                 0x0 // 0
+#define PCIe_DPLL2_TESTIN_MSB                                        11
+#define PCIe_DPLL2_TESTIN_LSB                                        2
+#define PCIe_DPLL2_TESTIN_MASK                                       0x00000ffc
+#define PCIe_DPLL2_TESTIN_GET(x)                                     (((x) & PCIe_DPLL2_TESTIN_MASK) >> PCIe_DPLL2_TESTIN_LSB)
+#define PCIe_DPLL2_TESTIN_SET(x)                                     (((x) << PCIe_DPLL2_TESTIN_LSB) & PCIe_DPLL2_TESTIN_MASK)
+#define PCIe_DPLL2_TESTIN_RESET                                      0x0 // 0
+#define PCIe_DPLL2_SEL_COUNT_MSB                                     1
+#define PCIe_DPLL2_SEL_COUNT_LSB                                     1
+#define PCIe_DPLL2_SEL_COUNT_MASK                                    0x00000002
+#define PCIe_DPLL2_SEL_COUNT_GET(x)                                  (((x) & PCIe_DPLL2_SEL_COUNT_MASK) >> PCIe_DPLL2_SEL_COUNT_LSB)
+#define PCIe_DPLL2_SEL_COUNT_SET(x)                                  (((x) << PCIe_DPLL2_SEL_COUNT_LSB) & PCIe_DPLL2_SEL_COUNT_MASK)
+#define PCIe_DPLL2_SEL_COUNT_RESET                                   0x0 // 0
+#define PCIe_DPLL2_RESET_TEST_MSB                                    0
+#define PCIe_DPLL2_RESET_TEST_LSB                                    0
+#define PCIe_DPLL2_RESET_TEST_MASK                                   0x00000001
+#define PCIe_DPLL2_RESET_TEST_GET(x)                                 (((x) & PCIe_DPLL2_RESET_TEST_MASK) >> PCIe_DPLL2_RESET_TEST_LSB)
+#define PCIe_DPLL2_RESET_TEST_SET(x)                                 (((x) << PCIe_DPLL2_RESET_TEST_LSB) & PCIe_DPLL2_RESET_TEST_MASK)
+#define PCIe_DPLL2_RESET_TEST_RESET                                  0x0 // 0
+#define PCIe_DPLL2_ADDRESS                                           0x18116c84
+
+#define DDR_DPLL2_LOCAL_PLL_MSB                                      31
+#define DDR_DPLL2_LOCAL_PLL_LSB                                      31
+#define DDR_DPLL2_LOCAL_PLL_MASK                                     0x80000000
+#define DDR_DPLL2_LOCAL_PLL_GET(x)                                   (((x) & DDR_DPLL2_LOCAL_PLL_MASK) >> DDR_DPLL2_LOCAL_PLL_LSB)
+#define DDR_DPLL2_LOCAL_PLL_SET(x)                                   (((x) << DDR_DPLL2_LOCAL_PLL_LSB) & DDR_DPLL2_LOCAL_PLL_MASK)
+#define DDR_DPLL2_LOCAL_PLL_RESET                                    0x0 // 0
+#define DDR_DPLL2_KI_MSB                                             30
+#define DDR_DPLL2_KI_LSB                                             29
+#define DDR_DPLL2_KI_MASK                                            0x60000000
+#define DDR_DPLL2_KI_GET(x)                                          (((x) & DDR_DPLL2_KI_MASK) >> DDR_DPLL2_KI_LSB)
+#define DDR_DPLL2_KI_SET(x)                                          (((x) << DDR_DPLL2_KI_LSB) & DDR_DPLL2_KI_MASK)
+#define DDR_DPLL2_KI_RESET                                           0x2 // 2
+#define DDR_DPLL2_KD_MSB                                             28
+#define DDR_DPLL2_KD_LSB                                             25
+#define DDR_DPLL2_KD_MASK                                            0x1e000000
+#define DDR_DPLL2_KD_GET(x)                                          (((x) & DDR_DPLL2_KD_MASK) >> DDR_DPLL2_KD_LSB)
+#define DDR_DPLL2_KD_SET(x)                                          (((x) << DDR_DPLL2_KD_LSB) & DDR_DPLL2_KD_MASK)
+#define DDR_DPLL2_KD_RESET                                           0xa // 10
+#define DDR_DPLL2_EN_NEGTRIG_MSB                                     24
+#define DDR_DPLL2_EN_NEGTRIG_LSB                                     24
+#define DDR_DPLL2_EN_NEGTRIG_MASK                                    0x01000000
+#define DDR_DPLL2_EN_NEGTRIG_GET(x)                                  (((x) & DDR_DPLL2_EN_NEGTRIG_MASK) >> DDR_DPLL2_EN_NEGTRIG_LSB)
+#define DDR_DPLL2_EN_NEGTRIG_SET(x)                                  (((x) << DDR_DPLL2_EN_NEGTRIG_LSB) & DDR_DPLL2_EN_NEGTRIG_MASK)
+#define DDR_DPLL2_EN_NEGTRIG_RESET                                   0x0 // 0
+#define DDR_DPLL2_SEL_1SDM_MSB                                       23
+#define DDR_DPLL2_SEL_1SDM_LSB                                       23
+#define DDR_DPLL2_SEL_1SDM_MASK                                      0x00800000
+#define DDR_DPLL2_SEL_1SDM_GET(x)                                    (((x) & DDR_DPLL2_SEL_1SDM_MASK) >> DDR_DPLL2_SEL_1SDM_LSB)
+#define DDR_DPLL2_SEL_1SDM_SET(x)                                    (((x) << DDR_DPLL2_SEL_1SDM_LSB) & DDR_DPLL2_SEL_1SDM_MASK)
+#define DDR_DPLL2_SEL_1SDM_RESET                                     0x0 // 0
+#define DDR_DPLL2_PLL_PWD_MSB                                        22
+#define DDR_DPLL2_PLL_PWD_LSB                                        22
+#define DDR_DPLL2_PLL_PWD_MASK                                       0x00400000
+#define DDR_DPLL2_PLL_PWD_GET(x)                                     (((x) & DDR_DPLL2_PLL_PWD_MASK) >> DDR_DPLL2_PLL_PWD_LSB)
+#define DDR_DPLL2_PLL_PWD_SET(x)                                     (((x) << DDR_DPLL2_PLL_PWD_LSB) & DDR_DPLL2_PLL_PWD_MASK)
+#define DDR_DPLL2_PLL_PWD_RESET                                      0x1 // 1
+#define DDR_DPLL2_OUTDIV_MSB                                         21
+#define DDR_DPLL2_OUTDIV_LSB                                         19
+#define DDR_DPLL2_OUTDIV_MASK                                        0x00380000
+#define DDR_DPLL2_OUTDIV_GET(x)                                      (((x) & DDR_DPLL2_OUTDIV_MASK) >> DDR_DPLL2_OUTDIV_LSB)
+#define DDR_DPLL2_OUTDIV_SET(x)                                      (((x) << DDR_DPLL2_OUTDIV_LSB) & DDR_DPLL2_OUTDIV_MASK)
+#define DDR_DPLL2_OUTDIV_RESET                                       0x1 // 1
+#define DDR_DPLL2_PHASE_SHIFT_MSB                                    18
+#define DDR_DPLL2_PHASE_SHIFT_LSB                                    12
+#define DDR_DPLL2_PHASE_SHIFT_MASK                                   0x0007f000
+#define DDR_DPLL2_PHASE_SHIFT_GET(x)                                 (((x) & DDR_DPLL2_PHASE_SHIFT_MASK) >> DDR_DPLL2_PHASE_SHIFT_LSB)
+#define DDR_DPLL2_PHASE_SHIFT_SET(x)                                 (((x) << DDR_DPLL2_PHASE_SHIFT_LSB) & DDR_DPLL2_PHASE_SHIFT_MASK)
+#define DDR_DPLL2_PHASE_SHIFT_RESET                                  0x0 // 0
+#define DDR_DPLL2_TESTIN_MSB                                         11
+#define DDR_DPLL2_TESTIN_LSB                                         2
+#define DDR_DPLL2_TESTIN_MASK                                        0x00000ffc
+#define DDR_DPLL2_TESTIN_GET(x)                                      (((x) & DDR_DPLL2_TESTIN_MASK) >> DDR_DPLL2_TESTIN_LSB)
+#define DDR_DPLL2_TESTIN_SET(x)                                      (((x) << DDR_DPLL2_TESTIN_LSB) & DDR_DPLL2_TESTIN_MASK)
+#define DDR_DPLL2_TESTIN_RESET                                       0x0 // 0
+#define DDR_DPLL2_SEL_COUNT_MSB                                      1
+#define DDR_DPLL2_SEL_COUNT_LSB                                      1
+#define DDR_DPLL2_SEL_COUNT_MASK                                     0x00000002
+#define DDR_DPLL2_SEL_COUNT_GET(x)                                   (((x) & DDR_DPLL2_SEL_COUNT_MASK) >> DDR_DPLL2_SEL_COUNT_LSB)
+#define DDR_DPLL2_SEL_COUNT_SET(x)                                   (((x) << DDR_DPLL2_SEL_COUNT_LSB) & DDR_DPLL2_SEL_COUNT_MASK)
+#define DDR_DPLL2_SEL_COUNT_RESET                                    0x0 // 0
+#define DDR_DPLL2_RESET_TEST_MSB                                     0
+#define DDR_DPLL2_RESET_TEST_LSB                                     0
+#define DDR_DPLL2_RESET_TEST_MASK                                    0x00000001
+#define DDR_DPLL2_RESET_TEST_GET(x)                                  (((x) & DDR_DPLL2_RESET_TEST_MASK) >> DDR_DPLL2_RESET_TEST_LSB)
+#define DDR_DPLL2_RESET_TEST_SET(x)                                  (((x) << DDR_DPLL2_RESET_TEST_LSB) & DDR_DPLL2_RESET_TEST_MASK)
+#define DDR_DPLL2_RESET_TEST_RESET                                   0x0 // 0
+#define DDR_DPLL2_ADDRESS                                            0x18116ec4
+
+#define CPU_DPLL2_LOCAL_PLL_MSB                                      31
+#define CPU_DPLL2_LOCAL_PLL_LSB                                      31
+#define CPU_DPLL2_LOCAL_PLL_MASK                                     0x80000000
+#define CPU_DPLL2_LOCAL_PLL_GET(x)                                   (((x) & CPU_DPLL2_LOCAL_PLL_MASK) >> CPU_DPLL2_LOCAL_PLL_LSB)
+#define CPU_DPLL2_LOCAL_PLL_SET(x)                                   (((x) << CPU_DPLL2_LOCAL_PLL_LSB) & CPU_DPLL2_LOCAL_PLL_MASK)
+#define CPU_DPLL2_LOCAL_PLL_RESET                                    0x0 // 0
+#define CPU_DPLL2_KI_MSB                                             30
+#define CPU_DPLL2_KI_LSB                                             29
+#define CPU_DPLL2_KI_MASK                                            0x60000000
+#define CPU_DPLL2_KI_GET(x)                                          (((x) & CPU_DPLL2_KI_MASK) >> CPU_DPLL2_KI_LSB)
+#define CPU_DPLL2_KI_SET(x)                                          (((x) << CPU_DPLL2_KI_LSB) & CPU_DPLL2_KI_MASK)
+#define CPU_DPLL2_KI_RESET                                           0x2 // 2
+#define CPU_DPLL2_KD_MSB                                             28
+#define CPU_DPLL2_KD_LSB                                             25
+#define CPU_DPLL2_KD_MASK                                            0x1e000000
+#define CPU_DPLL2_KD_GET(x)                                          (((x) & CPU_DPLL2_KD_MASK) >> CPU_DPLL2_KD_LSB)
+#define CPU_DPLL2_KD_SET(x)                                          (((x) << CPU_DPLL2_KD_LSB) & CPU_DPLL2_KD_MASK)
+#define CPU_DPLL2_KD_RESET                                           0xa // 10
+#define CPU_DPLL2_EN_NEGTRIG_MSB                                     24
+#define CPU_DPLL2_EN_NEGTRIG_LSB                                     24
+#define CPU_DPLL2_EN_NEGTRIG_MASK                                    0x01000000
+#define CPU_DPLL2_EN_NEGTRIG_GET(x)                                  (((x) & CPU_DPLL2_EN_NEGTRIG_MASK) >> CPU_DPLL2_EN_NEGTRIG_LSB)
+#define CPU_DPLL2_EN_NEGTRIG_SET(x)                                  (((x) << CPU_DPLL2_EN_NEGTRIG_LSB) & CPU_DPLL2_EN_NEGTRIG_MASK)
+#define CPU_DPLL2_EN_NEGTRIG_RESET                                   0x0 // 0
+#define CPU_DPLL2_SEL_1SDM_MSB                                       23
+#define CPU_DPLL2_SEL_1SDM_LSB                                       23
+#define CPU_DPLL2_SEL_1SDM_MASK                                      0x00800000
+#define CPU_DPLL2_SEL_1SDM_GET(x)                                    (((x) & CPU_DPLL2_SEL_1SDM_MASK) >> CPU_DPLL2_SEL_1SDM_LSB)
+#define CPU_DPLL2_SEL_1SDM_SET(x)                                    (((x) << CPU_DPLL2_SEL_1SDM_LSB) & CPU_DPLL2_SEL_1SDM_MASK)
+#define CPU_DPLL2_SEL_1SDM_RESET                                     0x0 // 0
+#define CPU_DPLL2_PLL_PWD_MSB                                        22
+#define CPU_DPLL2_PLL_PWD_LSB                                        22
+#define CPU_DPLL2_PLL_PWD_MASK                                       0x00400000
+#define CPU_DPLL2_PLL_PWD_GET(x)                                     (((x) & CPU_DPLL2_PLL_PWD_MASK) >> CPU_DPLL2_PLL_PWD_LSB)
+#define CPU_DPLL2_PLL_PWD_SET(x)                                     (((x) << CPU_DPLL2_PLL_PWD_LSB) & CPU_DPLL2_PLL_PWD_MASK)
+#define CPU_DPLL2_PLL_PWD_RESET                                      0x1 // 1
+#define CPU_DPLL2_OUTDIV_MSB                                         21
+#define CPU_DPLL2_OUTDIV_LSB                                         19
+#define CPU_DPLL2_OUTDIV_MASK                                        0x00380000
+#define CPU_DPLL2_OUTDIV_GET(x)                                      (((x) & CPU_DPLL2_OUTDIV_MASK) >> CPU_DPLL2_OUTDIV_LSB)
+#define CPU_DPLL2_OUTDIV_SET(x)                                      (((x) << CPU_DPLL2_OUTDIV_LSB) & CPU_DPLL2_OUTDIV_MASK)
+#define CPU_DPLL2_OUTDIV_RESET                                       0x1 // 1
+#define CPU_DPLL2_PHASE_SHIFT_MSB                                    18
+#define CPU_DPLL2_PHASE_SHIFT_LSB                                    12
+#define CPU_DPLL2_PHASE_SHIFT_MASK                                   0x0007f000
+#define CPU_DPLL2_PHASE_SHIFT_GET(x)                                 (((x) & CPU_DPLL2_PHASE_SHIFT_MASK) >> CPU_DPLL2_PHASE_SHIFT_LSB)
+#define CPU_DPLL2_PHASE_SHIFT_SET(x)                                 (((x) << CPU_DPLL2_PHASE_SHIFT_LSB) & CPU_DPLL2_PHASE_SHIFT_MASK)
+#define CPU_DPLL2_PHASE_SHIFT_RESET                                  0x0 // 0
+#define CPU_DPLL2_TESTIN_MSB                                         11
+#define CPU_DPLL2_TESTIN_LSB                                         2
+#define CPU_DPLL2_TESTIN_MASK                                        0x00000ffc
+#define CPU_DPLL2_TESTIN_GET(x)                                      (((x) & CPU_DPLL2_TESTIN_MASK) >> CPU_DPLL2_TESTIN_LSB)
+#define CPU_DPLL2_TESTIN_SET(x)                                      (((x) << CPU_DPLL2_TESTIN_LSB) & CPU_DPLL2_TESTIN_MASK)
+#define CPU_DPLL2_TESTIN_RESET                                       0x0 // 0
+#define CPU_DPLL2_SEL_COUNT_MSB                                      1
+#define CPU_DPLL2_SEL_COUNT_LSB                                      1
+#define CPU_DPLL2_SEL_COUNT_MASK                                     0x00000002
+#define CPU_DPLL2_SEL_COUNT_GET(x)                                   (((x) & CPU_DPLL2_SEL_COUNT_MASK) >> CPU_DPLL2_SEL_COUNT_LSB)
+#define CPU_DPLL2_SEL_COUNT_SET(x)                                   (((x) << CPU_DPLL2_SEL_COUNT_LSB) & CPU_DPLL2_SEL_COUNT_MASK)
+#define CPU_DPLL2_SEL_COUNT_RESET                                    0x0 // 0
+#define CPU_DPLL2_RESET_TEST_MSB                                     0
+#define CPU_DPLL2_RESET_TEST_LSB                                     0
+#define CPU_DPLL2_RESET_TEST_MASK                                    0x00000001
+#define CPU_DPLL2_RESET_TEST_GET(x)                                  (((x) & CPU_DPLL2_RESET_TEST_MASK) >> CPU_DPLL2_RESET_TEST_LSB)
+#define CPU_DPLL2_RESET_TEST_SET(x)                                  (((x) << CPU_DPLL2_RESET_TEST_LSB) & CPU_DPLL2_RESET_TEST_MASK)
+#define CPU_DPLL2_RESET_TEST_RESET                                   0x0 // 0
+#define CPU_DPLL2_ADDRESS                                            0x18116f04
+
+#define DDR_RD_DATA_THIS_CYCLE_ADDRESS                               0x18000018
+
+#define DDR_FSM_WAIT_CTRL_ADDRESS                                    0x180000e4
+
+#define TAP_CONTROL_0_ADDRESS                                        0x1800001c
+#define TAP_CONTROL_1_ADDRESS                                        0x18000020
+#define TAP_CONTROL_2_ADDRESS                                        0x18000024
+#define TAP_CONTROL_3_ADDRESS                                        0x18000028
+
+#define DDR_BURST_ADDRESS                                            0x180000c4
+#define DDR_BURST2_ADDRESS                                           0x180000c8
+#define DDR_AHB_MASTER_TIMEOUT_MAX_ADDRESS                           0x180000cc
+
+#define PMU1_ADDRESS                                                 0x18116cc0
+
+#define PMU2_SWREGMSB_MSB                                            31
+#define PMU2_SWREGMSB_LSB                                            22
+#define PMU2_SWREGMSB_MASK                                           0xffc00000
+#define PMU2_SWREGMSB_GET(x)                                         (((x) & PMU2_SWREGMSB_MASK) >> PMU2_SWREGMSB_LSB)
+#define PMU2_SWREGMSB_SET(x)                                         (((x) << PMU2_SWREGMSB_LSB) & PMU2_SWREGMSB_MASK)
+#define PMU2_SWREGMSB_RESET                                          0x0 // 0
+#define PMU2_PGM_MSB                                                 21
+#define PMU2_PGM_LSB                                                 21
+#define PMU2_PGM_MASK                                                0x00200000
+#define PMU2_PGM_GET(x)                                              (((x) & PMU2_PGM_MASK) >> PMU2_PGM_LSB)
+#define PMU2_PGM_SET(x)                                              (((x) << PMU2_PGM_LSB) & PMU2_PGM_MASK)
+#define PMU2_PGM_RESET                                               0x0 // 0
+#define PMU2_LDO_TUNE_MSB                                            20
+#define PMU2_LDO_TUNE_LSB                                            19
+#define PMU2_LDO_TUNE_MASK                                           0x00180000
+#define PMU2_LDO_TUNE_GET(x)                                         (((x) & PMU2_LDO_TUNE_MASK) >> PMU2_LDO_TUNE_LSB)
+#define PMU2_LDO_TUNE_SET(x)                                         (((x) << PMU2_LDO_TUNE_LSB) & PMU2_LDO_TUNE_MASK)
+#define PMU2_LDO_TUNE_RESET                                          0x0 // 0
+#define PMU2_PWDLDO_DDR_MSB                                          18
+#define PMU2_PWDLDO_DDR_LSB                                          18
+#define PMU2_PWDLDO_DDR_MASK                                         0x00040000
+#define PMU2_PWDLDO_DDR_GET(x)                                       (((x) & PMU2_PWDLDO_DDR_MASK) >> PMU2_PWDLDO_DDR_LSB)
+#define PMU2_PWDLDO_DDR_SET(x)                                       (((x) << PMU2_PWDLDO_DDR_LSB) & PMU2_PWDLDO_DDR_MASK)
+#define PMU2_PWDLDO_DDR_RESET                                        0x0 // 0
+#define PMU2_LPOPWD_MSB                                              17
+#define PMU2_LPOPWD_LSB                                              17
+#define PMU2_LPOPWD_MASK                                             0x00020000
+#define PMU2_LPOPWD_GET(x)                                           (((x) & PMU2_LPOPWD_MASK) >> PMU2_LPOPWD_LSB)
+#define PMU2_LPOPWD_SET(x)                                           (((x) << PMU2_LPOPWD_LSB) & PMU2_LPOPWD_MASK)
+#define PMU2_LPOPWD_RESET                                            0x0 // 0
+#define PMU2_SPARE_MSB                                               16
+#define PMU2_SPARE_LSB                                               0
+#define PMU2_SPARE_MASK                                              0x0001ffff
+#define PMU2_SPARE_GET(x)                                            (((x) & PMU2_SPARE_MASK) >> PMU2_SPARE_LSB)
+#define PMU2_SPARE_SET(x)                                            (((x) << PMU2_SPARE_LSB) & PMU2_SPARE_MASK)
+#define PMU2_SPARE_RESET                                             0x0 // 0
+#define PMU2_ADDRESS                                                 0x18116cc4
+
+#define CPU_DDR_CLOCK_CONTROL_SPARE_MSB                              31
+#define CPU_DDR_CLOCK_CONTROL_SPARE_LSB                              25
+#define CPU_DDR_CLOCK_CONTROL_SPARE_MASK                             0xfe000000
+#define CPU_DDR_CLOCK_CONTROL_SPARE_GET(x)                           (((x) & CPU_DDR_CLOCK_CONTROL_SPARE_MASK) >> CPU_DDR_CLOCK_CONTROL_SPARE_LSB)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_SET(x)                           (((x) << CPU_DDR_CLOCK_CONTROL_SPARE_LSB) & CPU_DDR_CLOCK_CONTROL_SPARE_MASK)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_RESET                            0
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MSB                 24
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB                 24
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK                0x01000000
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB) & CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_RESET               1
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MSB            23
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB            23
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK           0x00800000
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_GET(x)         (((x) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_SET(x)         (((x) << CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_RESET          0
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MSB               22
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB               22
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK              0x00400000
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_GET(x)            (((x) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_SET(x)            (((x) << CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_RESET             0x0
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_MSB            21
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_LSB            21
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_MASK           0x00200000
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_GET(x)         (((x) & CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(x)         (((x) << CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_RESET          0x0
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_MSB            20
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_LSB            20
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_MASK           0x00100000
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_GET(x)         (((x) & CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(x)         (((x) << CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_RESET          0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MSB                       19
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB                       15
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK                      0x000f8000
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MSB                       14
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB                       10
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK                      0x00007c00
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MSB                       9
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB                       5
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK                      0x000003e0
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MSB                     4
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB                     4
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK                    0x00000010
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MSB                     3
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB                     3
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK                    0x00000008
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MSB                     2
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB                     2
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK                    0x00000004
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MSB                       1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB                       1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK                      0x00000002
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK) >> CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB)
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB) & CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK)
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MSB                       0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB                       0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK                      0x00000001
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK) >> CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB) & CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_ADDRESS                                0x18050010
+
+#define PCIE_PLL_CONFIG_UPDATING_MSB                                 31
+#define PCIE_PLL_CONFIG_UPDATING_LSB                                 31
+#define PCIE_PLL_CONFIG_UPDATING_MASK                                0x80000000
+#define PCIE_PLL_CONFIG_UPDATING_GET(x)                              (((x) & PCIE_PLL_CONFIG_UPDATING_MASK) >> PCIE_PLL_CONFIG_UPDATING_LSB)
+#define PCIE_PLL_CONFIG_UPDATING_SET(x)                              (((x) << PCIE_PLL_CONFIG_UPDATING_LSB) & PCIE_PLL_CONFIG_UPDATING_MASK)
+#define PCIE_PLL_CONFIG_UPDATING_RESET                               0x0 // 0
+#define PCIE_PLL_CONFIG_PLLPWD_MSB                                   30
+#define PCIE_PLL_CONFIG_PLLPWD_LSB                                   30
+#define PCIE_PLL_CONFIG_PLLPWD_MASK                                  0x40000000
+#define PCIE_PLL_CONFIG_PLLPWD_GET(x)                                (((x) & PCIE_PLL_CONFIG_PLLPWD_MASK) >> PCIE_PLL_CONFIG_PLLPWD_LSB)
+#define PCIE_PLL_CONFIG_PLLPWD_SET(x)                                (((x) << PCIE_PLL_CONFIG_PLLPWD_LSB) & PCIE_PLL_CONFIG_PLLPWD_MASK)
+#define PCIE_PLL_CONFIG_PLLPWD_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_BYPASS_MSB                                   16
+#define PCIE_PLL_CONFIG_BYPASS_LSB                                   16
+#define PCIE_PLL_CONFIG_BYPASS_MASK                                  0x00010000
+#define PCIE_PLL_CONFIG_BYPASS_GET(x)                                (((x) & PCIE_PLL_CONFIG_BYPASS_MASK) >> PCIE_PLL_CONFIG_BYPASS_LSB)
+#define PCIE_PLL_CONFIG_BYPASS_SET(x)                                (((x) << PCIE_PLL_CONFIG_BYPASS_LSB) & PCIE_PLL_CONFIG_BYPASS_MASK)
+#define PCIE_PLL_CONFIG_BYPASS_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_REFDIV_MSB                                   14
+#define PCIE_PLL_CONFIG_REFDIV_LSB                                   10
+#define PCIE_PLL_CONFIG_REFDIV_MASK                                  0x00007c00
+#define PCIE_PLL_CONFIG_REFDIV_GET(x)                                (((x) & PCIE_PLL_CONFIG_REFDIV_MASK) >> PCIE_PLL_CONFIG_REFDIV_LSB)
+#define PCIE_PLL_CONFIG_REFDIV_SET(x)                                (((x) << PCIE_PLL_CONFIG_REFDIV_LSB) & PCIE_PLL_CONFIG_REFDIV_MASK)
+#define PCIE_PLL_CONFIG_REFDIV_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_ADDRESS                                      0x18050014
+
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MSB                        31
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB                        31
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK                       0x80000000
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_GET(x)                     (((x) & PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK) >> PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_SET(x)                     (((x) << PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB) & PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_RESET                      0x1 // 1
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MSB                          30
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB                          30
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK                         0x40000000
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_GET(x)                       (((x) & PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK) >> PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(x)                       (((x) << PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB) & PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_RESET                        0x1 // 1
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MSB                      20
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB                      15
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK                     0x001f8000
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_GET(x)                   (((x) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK) >> PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(x)                   (((x) << PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_RESET                    0x13 // 19
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MSB                     14
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB                     1
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK                    0x00007ffe
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_GET(x)                  (((x) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK) >> PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(x)                  (((x) << PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_RESET                   0x3fff // 16383
+#define PCIE_PLL_DITHER_DIV_MAX_ADDRESS                              0x18050018
+
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MSB                      20
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB                      15
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK                     0x001f8000
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_GET(x)                   (((x) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK) >> PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_SET(x)                   (((x) << PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_RESET                    0x13 // 19
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MSB                     14
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB                     1
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK                    0x00007ffe
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_GET(x)                  (((x) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK) >> PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_SET(x)                  (((x) << PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_RESET                   0x399d // 14749
+#define PCIE_PLL_DITHER_DIV_MIN_ADDRESS                              0x1805001c
+
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_MSB                          31
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB                          28
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK                         0xf0000000
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_GET(x)                       (((x) & PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK) >> PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_SET(x)                       (((x) << PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB) & PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_RESET                        0x0 // 0
+#define PCIE_PLL_DITHER_STEP_STEP_INT_MSB                            24
+#define PCIE_PLL_DITHER_STEP_STEP_INT_LSB                            15
+#define PCIE_PLL_DITHER_STEP_STEP_INT_MASK                           0x01ff8000
+#define PCIE_PLL_DITHER_STEP_STEP_INT_GET(x)                         (((x) & PCIE_PLL_DITHER_STEP_STEP_INT_MASK) >> PCIE_PLL_DITHER_STEP_STEP_INT_LSB)
+#define PCIE_PLL_DITHER_STEP_STEP_INT_SET(x)                         (((x) << PCIE_PLL_DITHER_STEP_STEP_INT_LSB) & PCIE_PLL_DITHER_STEP_STEP_INT_MASK)
+#define PCIE_PLL_DITHER_STEP_STEP_INT_RESET                          0x0 // 0
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_MSB                           14
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB                           1
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK                          0x00007ffe
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_GET(x)                        (((x) & PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK) >> PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB)
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_SET(x)                        (((x) << PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB) & PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK)
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_RESET                         0xa // 10
+#define PCIE_PLL_DITHER_STEP_ADDRESS                                 0x18050020
+
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MSB                          31
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB                          31
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK                         0x80000000
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_GET(x)                       (((x) & PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK) >> PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB)
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_SET(x)                       (((x) << PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB) & PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK)
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MSB                          30
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB                          29
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK                         0x60000000
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_GET(x)                       (((x) & PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK) >> PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB)
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_SET(x)                       (((x) << PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB) & PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK)
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_PERSTDELAY_MSB                                28
+#define PCIE_PHY_REG_1_PERSTDELAY_LSB                                27
+#define PCIE_PHY_REG_1_PERSTDELAY_MASK                               0x18000000
+#define PCIE_PHY_REG_1_PERSTDELAY_GET(x)                             (((x) & PCIE_PHY_REG_1_PERSTDELAY_MASK) >> PCIE_PHY_REG_1_PERSTDELAY_LSB)
+#define PCIE_PHY_REG_1_PERSTDELAY_SET(x)                             (((x) << PCIE_PHY_REG_1_PERSTDELAY_LSB) & PCIE_PHY_REG_1_PERSTDELAY_MASK)
+#define PCIE_PHY_REG_1_PERSTDELAY_RESET                              0x2 // 2
+#define PCIE_PHY_REG_1_CLKOBSSEL_MSB                                 26
+#define PCIE_PHY_REG_1_CLKOBSSEL_LSB                                 25
+#define PCIE_PHY_REG_1_CLKOBSSEL_MASK                                0x06000000
+#define PCIE_PHY_REG_1_CLKOBSSEL_GET(x)                              (((x) & PCIE_PHY_REG_1_CLKOBSSEL_MASK) >> PCIE_PHY_REG_1_CLKOBSSEL_LSB)
+#define PCIE_PHY_REG_1_CLKOBSSEL_SET(x)                              (((x) << PCIE_PHY_REG_1_CLKOBSSEL_LSB) & PCIE_PHY_REG_1_CLKOBSSEL_MASK)
+#define PCIE_PHY_REG_1_CLKOBSSEL_RESET                               0x0 // 0
+#define PCIE_PHY_REG_1_DATAOBSEN_MSB                                 24
+#define PCIE_PHY_REG_1_DATAOBSEN_LSB                                 24
+#define PCIE_PHY_REG_1_DATAOBSEN_MASK                                0x01000000
+#define PCIE_PHY_REG_1_DATAOBSEN_GET(x)                              (((x) & PCIE_PHY_REG_1_DATAOBSEN_MASK) >> PCIE_PHY_REG_1_DATAOBSEN_LSB)
+#define PCIE_PHY_REG_1_DATAOBSEN_SET(x)                              (((x) << PCIE_PHY_REG_1_DATAOBSEN_LSB) & PCIE_PHY_REG_1_DATAOBSEN_MASK)
+#define PCIE_PHY_REG_1_DATAOBSEN_RESET                               0x0 // 0
+#define PCIE_PHY_REG_1_FUNCTESTEN_MSB                                23
+#define PCIE_PHY_REG_1_FUNCTESTEN_LSB                                23
+#define PCIE_PHY_REG_1_FUNCTESTEN_MASK                               0x00800000
+#define PCIE_PHY_REG_1_FUNCTESTEN_GET(x)                             (((x) & PCIE_PHY_REG_1_FUNCTESTEN_MASK) >> PCIE_PHY_REG_1_FUNCTESTEN_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTEN_SET(x)                             (((x) << PCIE_PHY_REG_1_FUNCTESTEN_LSB) & PCIE_PHY_REG_1_FUNCTESTEN_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTEN_RESET                              0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_DISABLE_MSB                            22
+#define PCIE_PHY_REG_1_SERDES_DISABLE_LSB                            22
+#define PCIE_PHY_REG_1_SERDES_DISABLE_MASK                           0x00400000
+#define PCIE_PHY_REG_1_SERDES_DISABLE_GET(x)                         (((x) & PCIE_PHY_REG_1_SERDES_DISABLE_MASK) >> PCIE_PHY_REG_1_SERDES_DISABLE_LSB)
+#define PCIE_PHY_REG_1_SERDES_DISABLE_SET(x)                         (((x) << PCIE_PHY_REG_1_SERDES_DISABLE_LSB) & PCIE_PHY_REG_1_SERDES_DISABLE_MASK)
+#define PCIE_PHY_REG_1_SERDES_DISABLE_RESET                          0x0 // 0
+#define PCIE_PHY_REG_1_RXCLKINV_MSB                                  21
+#define PCIE_PHY_REG_1_RXCLKINV_LSB                                  21
+#define PCIE_PHY_REG_1_RXCLKINV_MASK                                 0x00200000
+#define PCIE_PHY_REG_1_RXCLKINV_GET(x)                               (((x) & PCIE_PHY_REG_1_RXCLKINV_MASK) >> PCIE_PHY_REG_1_RXCLKINV_LSB)
+#define PCIE_PHY_REG_1_RXCLKINV_SET(x)                               (((x) << PCIE_PHY_REG_1_RXCLKINV_LSB) & PCIE_PHY_REG_1_RXCLKINV_MASK)
+#define PCIE_PHY_REG_1_RXCLKINV_RESET                                0x1 // 1
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MSB                          20
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB                          20
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK                         0x00100000
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_GET(x)                       (((x) & PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK) >> PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_SET(x)                       (((x) << PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB) & PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MSB                          19
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB                          19
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK                         0x00080000
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_GET(x)                       (((x) & PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK) >> PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_SET(x)                       (((x) << PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB) & PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_ENABLECLKREQ_MSB                              18
+#define PCIE_PHY_REG_1_ENABLECLKREQ_LSB                              18
+#define PCIE_PHY_REG_1_ENABLECLKREQ_MASK                             0x00040000
+#define PCIE_PHY_REG_1_ENABLECLKREQ_GET(x)                           (((x) & PCIE_PHY_REG_1_ENABLECLKREQ_MASK) >> PCIE_PHY_REG_1_ENABLECLKREQ_LSB)
+#define PCIE_PHY_REG_1_ENABLECLKREQ_SET(x)                           (((x) << PCIE_PHY_REG_1_ENABLECLKREQ_LSB) & PCIE_PHY_REG_1_ENABLECLKREQ_MASK)
+#define PCIE_PHY_REG_1_ENABLECLKREQ_RESET                            0x0 // 0
+#define PCIE_PHY_REG_1_FORCELOOPBACK_MSB                             17
+#define PCIE_PHY_REG_1_FORCELOOPBACK_LSB                             17
+#define PCIE_PHY_REG_1_FORCELOOPBACK_MASK                            0x00020000
+#define PCIE_PHY_REG_1_FORCELOOPBACK_GET(x)                          (((x) & PCIE_PHY_REG_1_FORCELOOPBACK_MASK) >> PCIE_PHY_REG_1_FORCELOOPBACK_LSB)
+#define PCIE_PHY_REG_1_FORCELOOPBACK_SET(x)                          (((x) << PCIE_PHY_REG_1_FORCELOOPBACK_LSB) & PCIE_PHY_REG_1_FORCELOOPBACK_MASK)
+#define PCIE_PHY_REG_1_FORCELOOPBACK_RESET                           0x0 // 0
+#define PCIE_PHY_REG_1_SEL_CLK_MSB                                   16
+#define PCIE_PHY_REG_1_SEL_CLK_LSB                                   15
+#define PCIE_PHY_REG_1_SEL_CLK_MASK                                  0x00018000
+#define PCIE_PHY_REG_1_SEL_CLK_GET(x)                                (((x) & PCIE_PHY_REG_1_SEL_CLK_MASK) >> PCIE_PHY_REG_1_SEL_CLK_LSB)
+#define PCIE_PHY_REG_1_SEL_CLK_SET(x)                                (((x) << PCIE_PHY_REG_1_SEL_CLK_LSB) & PCIE_PHY_REG_1_SEL_CLK_MASK)
+#define PCIE_PHY_REG_1_SEL_CLK_RESET                                 0x2 // 2
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_MSB                              14
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_LSB                              14
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_MASK                             0x00004000
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_GET(x)                           (((x) & PCIE_PHY_REG_1_SERDES_RX_EQ_MASK) >> PCIE_PHY_REG_1_SERDES_RX_EQ_LSB)
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_SET(x)                           (((x) << PCIE_PHY_REG_1_SERDES_RX_EQ_LSB) & PCIE_PHY_REG_1_SERDES_RX_EQ_MASK)
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_RESET                            0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_MSB                           13
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB                           13
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK                          0x00002000
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK) >> PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB)
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB) & PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK)
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_RESET                         0x1 // 1
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MSB                     12
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB                     12
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK                    0x00001000
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_GET(x)                  (((x) & PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK) >> PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB)
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_SET(x)                  (((x) << PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB) & PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK)
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_RESET                   0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_MSB                         11
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB                         11
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK                        0x00000800
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_GET(x)                      (((x) & PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK) >> PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB)
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_SET(x)                      (((x) << PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB) & PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK)
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_RESET                       0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_MSB                             10
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_LSB                             9
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_MASK                            0x00000600
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_GET(x)                          (((x) & PCIE_PHY_REG_1_SERDES_CDR_BW_MASK) >> PCIE_PHY_REG_1_SERDES_CDR_BW_LSB)
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_SET(x)                          (((x) << PCIE_PHY_REG_1_SERDES_CDR_BW_LSB) & PCIE_PHY_REG_1_SERDES_CDR_BW_MASK)
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_RESET                           0x3 // 3
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_MSB                             8
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_LSB                             7
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_MASK                            0x00000180
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_GET(x)                          (((x) & PCIE_PHY_REG_1_SERDES_TH_LOS_MASK) >> PCIE_PHY_REG_1_SERDES_TH_LOS_LSB)
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_SET(x)                          (((x) << PCIE_PHY_REG_1_SERDES_TH_LOS_LSB) & PCIE_PHY_REG_1_SERDES_TH_LOS_MASK)
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_RESET                           0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_MSB                           6
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB                           6
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK                          0x00000040
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK) >> PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB)
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB) & PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK)
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_RESET                         0x1 // 1
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_MSB                           5
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB                           5
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK                          0x00000020
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK) >> PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB)
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB) & PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK)
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_RESET                         0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_MSB                            4
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB                            4
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK                           0x00000010
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_GET(x)                         (((x) & PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK) >> PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB)
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_SET(x)                         (((x) << PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB) & PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK)
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_RESET                          0x1 // 1
+#define PCIE_PHY_REG_1_S_MSB                                         3
+#define PCIE_PHY_REG_1_S_LSB                                         0
+#define PCIE_PHY_REG_1_S_MASK                                        0x0000000f
+#define PCIE_PHY_REG_1_S_GET(x)                                      (((x) & PCIE_PHY_REG_1_S_MASK) >> PCIE_PHY_REG_1_S_LSB)
+#define PCIE_PHY_REG_1_S_SET(x)                                      (((x) << PCIE_PHY_REG_1_S_LSB) & PCIE_PHY_REG_1_S_MASK)
+#define PCIE_PHY_REG_1_S_RESET                                       0x7 // 7
+#define PCIE_PHY_REG_1_ADDRESS                                       0x18116e00
+#define PCIE_PHY_REG_1_OFFSET                                        0x0000
+// SW modifiable bits
+#define PCIE_PHY_REG_1_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define PCIE_PHY_REG_1_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PHY_REG_1_RESET                                         0x1021265e
+#define PCIE_PHY_REG_1_RESET_1                                       0x0061060e  
+
+#define LDO_POWER_CONTROL_PKG_SEL_MSB                                5
+#define LDO_POWER_CONTROL_PKG_SEL_LSB                                5
+#define LDO_POWER_CONTROL_PKG_SEL_MASK                               0x00000020
+#define LDO_POWER_CONTROL_PKG_SEL_GET(x)                             (((x) & LDO_POWER_CONTROL_PKG_SEL_MASK) >> LDO_POWER_CONTROL_PKG_SEL_LSB)
+#define LDO_POWER_CONTROL_PKG_SEL_SET(x)                             (((x) << LDO_POWER_CONTROL_PKG_SEL_LSB) & LDO_POWER_CONTROL_PKG_SEL_MASK)
+#define LDO_POWER_CONTROL_PKG_SEL_RESET                              0x0 // 0
+#define LDO_POWER_CONTROL_PWDLDO_CPU_MSB                             4
+#define LDO_POWER_CONTROL_PWDLDO_CPU_LSB                             4
+#define LDO_POWER_CONTROL_PWDLDO_CPU_MASK                            0x00000010
+#define LDO_POWER_CONTROL_PWDLDO_CPU_GET(x)                          (((x) & LDO_POWER_CONTROL_PWDLDO_CPU_MASK) >> LDO_POWER_CONTROL_PWDLDO_CPU_LSB)
+#define LDO_POWER_CONTROL_PWDLDO_CPU_SET(x)                          (((x) << LDO_POWER_CONTROL_PWDLDO_CPU_LSB) & LDO_POWER_CONTROL_PWDLDO_CPU_MASK)
+#define LDO_POWER_CONTROL_PWDLDO_CPU_RESET                           0x0 // 0
+#define LDO_POWER_CONTROL_PWDLDO_DDR_MSB                             3
+#define LDO_POWER_CONTROL_PWDLDO_DDR_LSB                             3
+#define LDO_POWER_CONTROL_PWDLDO_DDR_MASK                            0x00000008
+#define LDO_POWER_CONTROL_PWDLDO_DDR_GET(x)                          (((x) & LDO_POWER_CONTROL_PWDLDO_DDR_MASK) >> LDO_POWER_CONTROL_PWDLDO_DDR_LSB)
+#define LDO_POWER_CONTROL_PWDLDO_DDR_SET(x)                          (((x) << LDO_POWER_CONTROL_PWDLDO_DDR_LSB) & LDO_POWER_CONTROL_PWDLDO_DDR_MASK)
+#define LDO_POWER_CONTROL_PWDLDO_DDR_RESET                           0x0 // 0
+#define LDO_POWER_CONTROL_CPU_REFSEL_MSB                             2
+#define LDO_POWER_CONTROL_CPU_REFSEL_LSB                             1
+#define LDO_POWER_CONTROL_CPU_REFSEL_MASK                            0x00000006
+#define LDO_POWER_CONTROL_CPU_REFSEL_GET(x)                          (((x) & LDO_POWER_CONTROL_CPU_REFSEL_MASK) >> LDO_POWER_CONTROL_CPU_REFSEL_LSB)
+#define LDO_POWER_CONTROL_CPU_REFSEL_SET(x)                          (((x) << LDO_POWER_CONTROL_CPU_REFSEL_LSB) & LDO_POWER_CONTROL_CPU_REFSEL_MASK)
+#define LDO_POWER_CONTROL_CPU_REFSEL_RESET                           0x3 // 3
+#define LDO_POWER_CONTROL_SELECT_DDR1_MSB                            0
+#define LDO_POWER_CONTROL_SELECT_DDR1_LSB                            0
+#define LDO_POWER_CONTROL_SELECT_DDR1_MASK                           0x00000001
+#define LDO_POWER_CONTROL_SELECT_DDR1_GET(x)                         (((x) & LDO_POWER_CONTROL_SELECT_DDR1_MASK) >> LDO_POWER_CONTROL_SELECT_DDR1_LSB)
+#define LDO_POWER_CONTROL_SELECT_DDR1_SET(x)                         (((x) << LDO_POWER_CONTROL_SELECT_DDR1_LSB) & LDO_POWER_CONTROL_SELECT_DDR1_MASK)
+#define LDO_POWER_CONTROL_SELECT_DDR1_RESET                          0x0 // 0
+#define LDO_POWER_CONTROL_ADDRESS                                    0x18050024
+
+#define SWITCH_CLOCK_SPARE_SPARE_MSB                                 31
+#define SWITCH_CLOCK_SPARE_SPARE_LSB                                 20
+#define SWITCH_CLOCK_SPARE_SPARE_MASK                                0xfff00000
+#define SWITCH_CLOCK_SPARE_SPARE_GET(x)                              (((x) & SWITCH_CLOCK_SPARE_SPARE_MASK) >> SWITCH_CLOCK_SPARE_SPARE_LSB)
+#define SWITCH_CLOCK_SPARE_SPARE_SET(x)                              (((x) << SWITCH_CLOCK_SPARE_SPARE_LSB) & SWITCH_CLOCK_SPARE_SPARE_MASK)
+#define SWITCH_CLOCK_SPARE_SPARE_RESET                               0x0 // 0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MSB                         19
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB                         19
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK                        0x00080000
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_GET(x)                      (((x) & SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_SET(x)                      (((x) << SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB) & SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_RESET                       0x1 // 1
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MSB                       18
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB                       18
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK                      0x00040000
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK) >> SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB)
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB) & SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK)
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_RESET                     0x1 // 1
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_MSB                            17
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB                            17
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK                           0x00020000
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_GET(x)                         (((x) & SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK) >> SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB)
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_SET(x)                         (((x) << SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB) & SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK)
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_RESET                          0x0 // 0
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MSB                  16
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB                  16
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK                 0x00010000
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_GET(x)               (((x) & SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK) >> SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB)
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_SET(x)               (((x) << SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB) & SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK)
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_RESET                0x0 // 0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_MSB                       15
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_LSB                       15
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_MASK                      0x00008000
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_RESET                     0x0 // 0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_MSB                       14
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_LSB                       14
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_MASK                      0x00004000
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_RESET                     0x0 // 0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_MSB                       13
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_LSB                       13
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_MASK                      0x00002000
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_RESET                     0x0 // 0
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_MSB                            12
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB                            12
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK                           0x00001000
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_GET(x)                         (((x) & SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK) >> SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB)
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_SET(x)                         (((x) << SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB) & SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK)
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_RESET                          0x1 // 1
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MSB                   11
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB                   8
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK                  0x00000f00
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_GET(x)                (((x) & SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK) >> SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(x)                (((x) << SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB) & SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_RESET                 0x5 // 5
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MSB                         7
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB                         7
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK                        0x00000080
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_GET(x)                      (((x) & SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_SET(x)                      (((x) << SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_RESET                       0x0 // 0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_MSB                       6
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_LSB                       6
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_MASK                      0x00000040
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_RESET                     0x0 // 0
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_MSB                           5
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_LSB                           5
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_MASK                          0x00000020
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_GET(x)                        (((x) & SWITCH_CLOCK_SPARE_I2C_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_I2C_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_SET(x)                        (((x) << SWITCH_CLOCK_SPARE_I2C_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_I2C_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_RESET                         0x0 // 0
+#define SWITCH_CLOCK_SPARE_SPARE_0_MSB                               4
+#define SWITCH_CLOCK_SPARE_SPARE_0_LSB                               0
+#define SWITCH_CLOCK_SPARE_SPARE_0_MASK                              0x0000001f
+#define SWITCH_CLOCK_SPARE_SPARE_0_GET(x)                            (((x) & SWITCH_CLOCK_SPARE_SPARE_0_MASK) >> SWITCH_CLOCK_SPARE_SPARE_0_LSB)
+#define SWITCH_CLOCK_SPARE_SPARE_0_SET(x)                            (((x) << SWITCH_CLOCK_SPARE_SPARE_0_LSB) & SWITCH_CLOCK_SPARE_SPARE_0_MASK)
+#define SWITCH_CLOCK_SPARE_SPARE_0_RESET                             0x0 // 0
+#define SWITCH_CLOCK_SPARE_ADDRESS                                   0x18050028
+
+#define CURRENT_PCIE_PLL_DITHER_INT_MSB                              20
+#define CURRENT_PCIE_PLL_DITHER_INT_LSB                              15
+#define CURRENT_PCIE_PLL_DITHER_INT_MASK                             0x001f8000
+#define CURRENT_PCIE_PLL_DITHER_INT_GET(x)                           (((x) & CURRENT_PCIE_PLL_DITHER_INT_MASK) >> CURRENT_PCIE_PLL_DITHER_INT_LSB)
+#define CURRENT_PCIE_PLL_DITHER_INT_SET(x)                           (((x) << CURRENT_PCIE_PLL_DITHER_INT_LSB) & CURRENT_PCIE_PLL_DITHER_INT_MASK)
+#define CURRENT_PCIE_PLL_DITHER_INT_RESET                            0x1 // 1
+#define CURRENT_PCIE_PLL_DITHER_FRAC_MSB                             13
+#define CURRENT_PCIE_PLL_DITHER_FRAC_LSB                             0
+#define CURRENT_PCIE_PLL_DITHER_FRAC_MASK                            0x00003fff
+#define CURRENT_PCIE_PLL_DITHER_FRAC_GET(x)                          (((x) & CURRENT_PCIE_PLL_DITHER_FRAC_MASK) >> CURRENT_PCIE_PLL_DITHER_FRAC_LSB)
+#define CURRENT_PCIE_PLL_DITHER_FRAC_SET(x)                          (((x) << CURRENT_PCIE_PLL_DITHER_FRAC_LSB) & CURRENT_PCIE_PLL_DITHER_FRAC_MASK)
+#define CURRENT_PCIE_PLL_DITHER_FRAC_RESET                           0x0 // 0
+#define CURRENT_PCIE_PLL_DITHER_ADDRESS                              0x1805002c
+
+#define ETH_XMII_TX_INVERT_MSB                                       31
+#define ETH_XMII_TX_INVERT_LSB                                       31
+#define ETH_XMII_TX_INVERT_MASK                                      0x80000000
+#define ETH_XMII_TX_INVERT_GET(x)                                    (((x) & ETH_XMII_TX_INVERT_MASK) >> ETH_XMII_TX_INVERT_LSB)
+#define ETH_XMII_TX_INVERT_SET(x)                                    (((x) << ETH_XMII_TX_INVERT_LSB) & ETH_XMII_TX_INVERT_MASK)
+#define ETH_XMII_TX_INVERT_RESET                                     0x0 // 0
+#define ETH_XMII_GIGE_QUAD_MSB                                       30
+#define ETH_XMII_GIGE_QUAD_LSB                                       30
+#define ETH_XMII_GIGE_QUAD_MASK                                      0x40000000
+#define ETH_XMII_GIGE_QUAD_GET(x)                                    (((x) & ETH_XMII_GIGE_QUAD_MASK) >> ETH_XMII_GIGE_QUAD_LSB)
+#define ETH_XMII_GIGE_QUAD_SET(x)                                    (((x) << ETH_XMII_GIGE_QUAD_LSB) & ETH_XMII_GIGE_QUAD_MASK)
+#define ETH_XMII_GIGE_QUAD_RESET                                     0x0 // 0
+#define ETH_XMII_RX_DELAY_MSB                                        29
+#define ETH_XMII_RX_DELAY_LSB                                        28
+#define ETH_XMII_RX_DELAY_MASK                                       0x30000000
+#define ETH_XMII_RX_DELAY_GET(x)                                     (((x) & ETH_XMII_RX_DELAY_MASK) >> ETH_XMII_RX_DELAY_LSB)
+#define ETH_XMII_RX_DELAY_SET(x)                                     (((x) << ETH_XMII_RX_DELAY_LSB) & ETH_XMII_RX_DELAY_MASK)
+#define ETH_XMII_RX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_TX_DELAY_MSB                                        27
+#define ETH_XMII_TX_DELAY_LSB                                        26
+#define ETH_XMII_TX_DELAY_MASK                                       0x0c000000
+#define ETH_XMII_TX_DELAY_GET(x)                                     (((x) & ETH_XMII_TX_DELAY_MASK) >> ETH_XMII_TX_DELAY_LSB)
+#define ETH_XMII_TX_DELAY_SET(x)                                     (((x) << ETH_XMII_TX_DELAY_LSB) & ETH_XMII_TX_DELAY_MASK)
+#define ETH_XMII_TX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_GIGE_MSB                                            25
+#define ETH_XMII_GIGE_LSB                                            25
+#define ETH_XMII_GIGE_MASK                                           0x02000000
+#define ETH_XMII_GIGE_GET(x)                                         (((x) & ETH_XMII_GIGE_MASK) >> ETH_XMII_GIGE_LSB)
+#define ETH_XMII_GIGE_SET(x)                                         (((x) << ETH_XMII_GIGE_LSB) & ETH_XMII_GIGE_MASK)
+#define ETH_XMII_GIGE_RESET                                          0x0 // 0
+#define ETH_XMII_OFFSET_PHASE_MSB                                    24
+#define ETH_XMII_OFFSET_PHASE_LSB                                    24
+#define ETH_XMII_OFFSET_PHASE_MASK                                   0x01000000
+#define ETH_XMII_OFFSET_PHASE_GET(x)                                 (((x) & ETH_XMII_OFFSET_PHASE_MASK) >> ETH_XMII_OFFSET_PHASE_LSB)
+#define ETH_XMII_OFFSET_PHASE_SET(x)                                 (((x) << ETH_XMII_OFFSET_PHASE_LSB) & ETH_XMII_OFFSET_PHASE_MASK)
+#define ETH_XMII_OFFSET_PHASE_RESET                                  0x0 // 0
+#define ETH_XMII_OFFSET_COUNT_MSB                                    23
+#define ETH_XMII_OFFSET_COUNT_LSB                                    16
+#define ETH_XMII_OFFSET_COUNT_MASK                                   0x00ff0000
+#define ETH_XMII_OFFSET_COUNT_GET(x)                                 (((x) & ETH_XMII_OFFSET_COUNT_MASK) >> ETH_XMII_OFFSET_COUNT_LSB)
+#define ETH_XMII_OFFSET_COUNT_SET(x)                                 (((x) << ETH_XMII_OFFSET_COUNT_LSB) & ETH_XMII_OFFSET_COUNT_MASK)
+#define ETH_XMII_OFFSET_COUNT_RESET                                  0x0 // 0
+#define ETH_XMII_PHASE1_COUNT_MSB                                    15
+#define ETH_XMII_PHASE1_COUNT_LSB                                    8
+#define ETH_XMII_PHASE1_COUNT_MASK                                   0x0000ff00
+#define ETH_XMII_PHASE1_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE1_COUNT_MASK) >> ETH_XMII_PHASE1_COUNT_LSB)
+#define ETH_XMII_PHASE1_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE1_COUNT_LSB) & ETH_XMII_PHASE1_COUNT_MASK)
+#define ETH_XMII_PHASE1_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_PHASE0_COUNT_MSB                                    7
+#define ETH_XMII_PHASE0_COUNT_LSB                                    0
+#define ETH_XMII_PHASE0_COUNT_MASK                                   0x000000ff
+#define ETH_XMII_PHASE0_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE0_COUNT_MASK) >> ETH_XMII_PHASE0_COUNT_LSB)
+#define ETH_XMII_PHASE0_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE0_COUNT_LSB) & ETH_XMII_PHASE0_COUNT_MASK)
+#define ETH_XMII_PHASE0_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_ADDRESS                                             0x18050030
+
+#define BB_PLL_CONFIG_UPDATING_MSB                                   31
+#define BB_PLL_CONFIG_UPDATING_LSB                                   31
+#define BB_PLL_CONFIG_UPDATING_MASK                                  0x80000000
+#define BB_PLL_CONFIG_UPDATING_GET(x)                                (((x) & BB_PLL_CONFIG_UPDATING_MASK) >> BB_PLL_CONFIG_UPDATING_LSB)
+#define BB_PLL_CONFIG_UPDATING_SET(x)                                (((x) << BB_PLL_CONFIG_UPDATING_LSB) & BB_PLL_CONFIG_UPDATING_MASK)
+#define BB_PLL_CONFIG_UPDATING_RESET                                 0x1 // 1
+#define BB_PLL_CONFIG_PLLPWD_MSB                                     30
+#define BB_PLL_CONFIG_PLLPWD_LSB                                     30
+#define BB_PLL_CONFIG_PLLPWD_MASK                                    0x40000000
+#define BB_PLL_CONFIG_PLLPWD_GET(x)                                  (((x) & BB_PLL_CONFIG_PLLPWD_MASK) >> BB_PLL_CONFIG_PLLPWD_LSB)
+#define BB_PLL_CONFIG_PLLPWD_SET(x)                                  (((x) << BB_PLL_CONFIG_PLLPWD_LSB) & BB_PLL_CONFIG_PLLPWD_MASK)
+#define BB_PLL_CONFIG_PLLPWD_RESET                                   0x1 // 1
+#define BB_PLL_CONFIG_SPARE_MSB                                      29
+#define BB_PLL_CONFIG_SPARE_LSB                                      29
+#define BB_PLL_CONFIG_SPARE_MASK                                     0x20000000
+#define BB_PLL_CONFIG_SPARE_GET(x)                                   (((x) & BB_PLL_CONFIG_SPARE_MASK) >> BB_PLL_CONFIG_SPARE_LSB)
+#define BB_PLL_CONFIG_SPARE_SET(x)                                   (((x) << BB_PLL_CONFIG_SPARE_LSB) & BB_PLL_CONFIG_SPARE_MASK)
+#define BB_PLL_CONFIG_SPARE_RESET                                    0x0 // 0
+#define BB_PLL_CONFIG_REFDIV_MSB                                     28
+#define BB_PLL_CONFIG_REFDIV_LSB                                     24
+#define BB_PLL_CONFIG_REFDIV_MASK                                    0x1f000000
+#define BB_PLL_CONFIG_REFDIV_GET(x)                                  (((x) & BB_PLL_CONFIG_REFDIV_MASK) >> BB_PLL_CONFIG_REFDIV_LSB)
+#define BB_PLL_CONFIG_REFDIV_SET(x)                                  (((x) << BB_PLL_CONFIG_REFDIV_LSB) & BB_PLL_CONFIG_REFDIV_MASK)
+#define BB_PLL_CONFIG_REFDIV_RESET                                   0x1 // 1
+#define BB_PLL_CONFIG_NINT_MSB                                       21
+#define BB_PLL_CONFIG_NINT_LSB                                       16
+#define BB_PLL_CONFIG_NINT_MASK                                      0x003f0000
+#define BB_PLL_CONFIG_NINT_GET(x)                                    (((x) & BB_PLL_CONFIG_NINT_MASK) >> BB_PLL_CONFIG_NINT_LSB)
+#define BB_PLL_CONFIG_NINT_SET(x)                                    (((x) << BB_PLL_CONFIG_NINT_LSB) & BB_PLL_CONFIG_NINT_MASK)
+#define BB_PLL_CONFIG_NINT_RESET                                     0x2 // 2
+#define BB_PLL_CONFIG_NFRAC_MSB                                      13
+#define BB_PLL_CONFIG_NFRAC_LSB                                      0
+#define BB_PLL_CONFIG_NFRAC_MASK                                     0x00003fff
+#define BB_PLL_CONFIG_NFRAC_GET(x)                                   (((x) & BB_PLL_CONFIG_NFRAC_MASK) >> BB_PLL_CONFIG_NFRAC_LSB)
+#define BB_PLL_CONFIG_NFRAC_SET(x)                                   (((x) << BB_PLL_CONFIG_NFRAC_LSB) & BB_PLL_CONFIG_NFRAC_MASK)
+#define BB_PLL_CONFIG_NFRAC_RESET                                    0xccc // 3276
+#define BB_PLL_CONFIG_ADDRESS                                        0x18050034
+
+#define DDR_PLL_DITHER1_DITHER_EN_MSB                                31
+#define DDR_PLL_DITHER1_DITHER_EN_LSB                                31
+#define DDR_PLL_DITHER1_DITHER_EN_MASK                               0x80000000
+#define DDR_PLL_DITHER1_DITHER_EN_GET(x)                             (((x) & DDR_PLL_DITHER1_DITHER_EN_MASK) >> DDR_PLL_DITHER1_DITHER_EN_LSB)
+#define DDR_PLL_DITHER1_DITHER_EN_SET(x)                             (((x) << DDR_PLL_DITHER1_DITHER_EN_LSB) & DDR_PLL_DITHER1_DITHER_EN_MASK)
+#define DDR_PLL_DITHER1_DITHER_EN_RESET                              0x0 // 0
+#define DDR_PLL_DITHER1_UPDATE_COUNT_MSB                             30
+#define DDR_PLL_DITHER1_UPDATE_COUNT_LSB                             27
+#define DDR_PLL_DITHER1_UPDATE_COUNT_MASK                            0x78000000
+#define DDR_PLL_DITHER1_UPDATE_COUNT_GET(x)                          (((x) & DDR_PLL_DITHER1_UPDATE_COUNT_MASK) >> DDR_PLL_DITHER1_UPDATE_COUNT_LSB)
+#define DDR_PLL_DITHER1_UPDATE_COUNT_SET(x)                          (((x) << DDR_PLL_DITHER1_UPDATE_COUNT_LSB) & DDR_PLL_DITHER1_UPDATE_COUNT_MASK)
+#define DDR_PLL_DITHER1_UPDATE_COUNT_RESET                           0xf // 15
+#define DDR_PLL_DITHER1_NFRAC_STEP_MSB                               26
+#define DDR_PLL_DITHER1_NFRAC_STEP_LSB                               20
+#define DDR_PLL_DITHER1_NFRAC_STEP_MASK                              0x07f00000
+#define DDR_PLL_DITHER1_NFRAC_STEP_GET(x)                            (((x) & DDR_PLL_DITHER1_NFRAC_STEP_MASK) >> DDR_PLL_DITHER1_NFRAC_STEP_LSB)
+#define DDR_PLL_DITHER1_NFRAC_STEP_SET(x)                            (((x) << DDR_PLL_DITHER1_NFRAC_STEP_LSB) & DDR_PLL_DITHER1_NFRAC_STEP_MASK)
+#define DDR_PLL_DITHER1_NFRAC_STEP_RESET                             0x1 // 1
+#define DDR_PLL_DITHER1_NFRAC_MIN_MSB                                17
+#define DDR_PLL_DITHER1_NFRAC_MIN_LSB                                0
+#define DDR_PLL_DITHER1_NFRAC_MIN_MASK                               0x0003ffff
+#define DDR_PLL_DITHER1_NFRAC_MIN_GET(x)                             (((x) & DDR_PLL_DITHER1_NFRAC_MIN_MASK) >> DDR_PLL_DITHER1_NFRAC_MIN_LSB)
+#define DDR_PLL_DITHER1_NFRAC_MIN_SET(x)                             (((x) << DDR_PLL_DITHER1_NFRAC_MIN_LSB) & DDR_PLL_DITHER1_NFRAC_MIN_MASK)
+#define DDR_PLL_DITHER1_NFRAC_MIN_RESET                              0x1900 // 6400
+#define DDR_PLL_DITHER1_ADDRESS                                      0x18050038
+
+#define DDR_PLL_DITHER2_NFRAC_MAX_MSB                                17
+#define DDR_PLL_DITHER2_NFRAC_MAX_LSB                                0
+#define DDR_PLL_DITHER2_NFRAC_MAX_MASK                               0x0003ffff
+#define DDR_PLL_DITHER2_NFRAC_MAX_GET(x)                             (((x) & DDR_PLL_DITHER2_NFRAC_MAX_MASK) >> DDR_PLL_DITHER2_NFRAC_MAX_LSB)
+#define DDR_PLL_DITHER2_NFRAC_MAX_SET(x)                             (((x) << DDR_PLL_DITHER2_NFRAC_MAX_LSB) & DDR_PLL_DITHER2_NFRAC_MAX_MASK)
+#define DDR_PLL_DITHER2_NFRAC_MAX_RESET                              0x3e800 // 256000                              
+#define DDR_PLL_DITHER2_ADDRESS                                      0x1805003c
+
+#define CPU_PLL_DITHER1_DITHER_EN_MSB                                31
+#define CPU_PLL_DITHER1_DITHER_EN_LSB                                31
+#define CPU_PLL_DITHER1_DITHER_EN_MASK                               0x80000000
+#define CPU_PLL_DITHER1_DITHER_EN_GET(x)                             (((x) & CPU_PLL_DITHER1_DITHER_EN_MASK) >> CPU_PLL_DITHER1_DITHER_EN_LSB)
+#define CPU_PLL_DITHER1_DITHER_EN_SET(x)                             (((x) << CPU_PLL_DITHER1_DITHER_EN_LSB) & CPU_PLL_DITHER1_DITHER_EN_MASK)
+#define CPU_PLL_DITHER1_DITHER_EN_RESET                              0x0 // 0
+#define CPU_PLL_DITHER1_UPDATE_COUNT_MSB                             29
+#define CPU_PLL_DITHER1_UPDATE_COUNT_LSB                             24
+#define CPU_PLL_DITHER1_UPDATE_COUNT_MASK                            0x3f000000
+#define CPU_PLL_DITHER1_UPDATE_COUNT_GET(x)                          (((x) & CPU_PLL_DITHER1_UPDATE_COUNT_MASK) >> CPU_PLL_DITHER1_UPDATE_COUNT_LSB)
+#define CPU_PLL_DITHER1_UPDATE_COUNT_SET(x)                          (((x) << CPU_PLL_DITHER1_UPDATE_COUNT_LSB) & CPU_PLL_DITHER1_UPDATE_COUNT_MASK)
+#define CPU_PLL_DITHER1_UPDATE_COUNT_RESET                           0x14 // 20
+#define CPU_PLL_DITHER1_NFRAC_STEP_MSB                               23
+#define CPU_PLL_DITHER1_NFRAC_STEP_LSB                               18
+#define CPU_PLL_DITHER1_NFRAC_STEP_MASK                              0x00fc0000
+#define CPU_PLL_DITHER1_NFRAC_STEP_GET(x)                            (((x) & CPU_PLL_DITHER1_NFRAC_STEP_MASK) >> CPU_PLL_DITHER1_NFRAC_STEP_LSB)
+#define CPU_PLL_DITHER1_NFRAC_STEP_SET(x)                            (((x) << CPU_PLL_DITHER1_NFRAC_STEP_LSB) & CPU_PLL_DITHER1_NFRAC_STEP_MASK)
+#define CPU_PLL_DITHER1_NFRAC_STEP_RESET                             0x1 // 1
+#define CPU_PLL_DITHER1_NFRAC_MIN_MSB                                17
+#define CPU_PLL_DITHER1_NFRAC_MIN_LSB                                0
+#define CPU_PLL_DITHER1_NFRAC_MIN_MASK                               0x0003ffff
+#define CPU_PLL_DITHER1_NFRAC_MIN_GET(x)                             (((x) & CPU_PLL_DITHER1_NFRAC_MIN_MASK) >> CPU_PLL_DITHER1_NFRAC_MIN_LSB)
+#define CPU_PLL_DITHER1_NFRAC_MIN_SET(x)                             (((x) << CPU_PLL_DITHER1_NFRAC_MIN_LSB) & CPU_PLL_DITHER1_NFRAC_MIN_MASK)
+#define CPU_PLL_DITHER1_NFRAC_MIN_RESET                              0x3000 // 12288
+#define CPU_PLL_DITHER1_ADDRESS                                      0x18050040
+
+#define CPU_PLL_DITHER2_NFRAC_MAX_MSB                                17
+#define CPU_PLL_DITHER2_NFRAC_MAX_LSB                                0
+#define CPU_PLL_DITHER2_NFRAC_MAX_MASK                               0x0003ffff
+#define CPU_PLL_DITHER2_NFRAC_MAX_GET(x)                             (((x) & CPU_PLL_DITHER2_NFRAC_MAX_MASK) >> CPU_PLL_DITHER2_NFRAC_MAX_LSB)
+#define CPU_PLL_DITHER2_NFRAC_MAX_SET(x)                             (((x) << CPU_PLL_DITHER2_NFRAC_MAX_LSB) & CPU_PLL_DITHER2_NFRAC_MAX_MASK)
+#define CPU_PLL_DITHER2_NFRAC_MAX_RESET                              0x3c000 // 245760
+#define CPU_PLL_DITHER2_ADDRESS                                      0x18050044
+
+#define RST_RESET_HOST_RESET_MSB                                     31
+#define RST_RESET_HOST_RESET_LSB                                     31
+#define RST_RESET_HOST_RESET_MASK                                    0x80000000
+#define RST_RESET_HOST_RESET_GET(x)                                  (((x) & RST_RESET_HOST_RESET_MASK) >> RST_RESET_HOST_RESET_LSB)
+#define RST_RESET_HOST_RESET_SET(x)                                  (((x) << RST_RESET_HOST_RESET_LSB) & RST_RESET_HOST_RESET_MASK)
+#define RST_RESET_HOST_RESET_RESET                                   0x0 // 0
+#define RST_RESET_EXTERNAL_RESET_MSB                                 28
+#define RST_RESET_EXTERNAL_RESET_LSB                                 28
+#define RST_RESET_EXTERNAL_RESET_MASK                                0x10000000
+#define RST_RESET_EXTERNAL_RESET_GET(x)                              (((x) & RST_RESET_EXTERNAL_RESET_MASK) >> RST_RESET_EXTERNAL_RESET_LSB)
+#define RST_RESET_EXTERNAL_RESET_SET(x)                              (((x) << RST_RESET_EXTERNAL_RESET_LSB) & RST_RESET_EXTERNAL_RESET_MASK)
+#define RST_RESET_EXTERNAL_RESET_RESET                               0x0 // 0
+#define RST_RESET_RTC_RESET_MSB                                      27
+#define RST_RESET_RTC_RESET_LSB                                      27
+#define RST_RESET_RTC_RESET_MASK                                     0x08000000
+#define RST_RESET_RTC_RESET_GET(x)                                   (((x) & RST_RESET_RTC_RESET_MASK) >> RST_RESET_RTC_RESET_LSB)
+#define RST_RESET_RTC_RESET_SET(x)                                   (((x) << RST_RESET_RTC_RESET_LSB) & RST_RESET_RTC_RESET_MASK)
+#define RST_RESET_RTC_RESET_RESET                                    0x1 // 1
+#define RST_RESET_PCIEEP_RST_INT_MSB                                 26
+#define RST_RESET_PCIEEP_RST_INT_LSB                                 26
+#define RST_RESET_PCIEEP_RST_INT_MASK                                0x04000000
+#define RST_RESET_PCIEEP_RST_INT_GET(x)                              (((x) & RST_RESET_PCIEEP_RST_INT_MASK) >> RST_RESET_PCIEEP_RST_INT_LSB)
+#define RST_RESET_PCIEEP_RST_INT_SET(x)                              (((x) << RST_RESET_PCIEEP_RST_INT_LSB) & RST_RESET_PCIEEP_RST_INT_MASK)
+#define RST_RESET_PCIEEP_RST_INT_RESET                               0x0 // 0
+#define RST_RESET_CHKSUM_ACC_RESET_MSB                               25
+#define RST_RESET_CHKSUM_ACC_RESET_LSB                               25
+#define RST_RESET_CHKSUM_ACC_RESET_MASK                              0x02000000
+#define RST_RESET_CHKSUM_ACC_RESET_GET(x)                            (((x) & RST_RESET_CHKSUM_ACC_RESET_MASK) >> RST_RESET_CHKSUM_ACC_RESET_LSB)
+#define RST_RESET_CHKSUM_ACC_RESET_SET(x)                            (((x) << RST_RESET_CHKSUM_ACC_RESET_LSB) & RST_RESET_CHKSUM_ACC_RESET_MASK)
+#define RST_RESET_CHKSUM_ACC_RESET_RESET                             0x0 // 0
+#define RST_RESET_FULL_CHIP_RESET_MSB                                24
+#define RST_RESET_FULL_CHIP_RESET_LSB                                24
+#define RST_RESET_FULL_CHIP_RESET_MASK                               0x01000000
+#define RST_RESET_FULL_CHIP_RESET_GET(x)                             (((x) & RST_RESET_FULL_CHIP_RESET_MASK) >> RST_RESET_FULL_CHIP_RESET_LSB)
+#define RST_RESET_FULL_CHIP_RESET_SET(x)                             (((x) << RST_RESET_FULL_CHIP_RESET_LSB) & RST_RESET_FULL_CHIP_RESET_MASK)
+#define RST_RESET_FULL_CHIP_RESET_RESET                              0x0 // 0
+#define RST_RESET_GE1_MDIO_RESET_MSB                                 23
+#define RST_RESET_GE1_MDIO_RESET_LSB                                 23
+#define RST_RESET_GE1_MDIO_RESET_MASK                                0x00800000
+#define RST_RESET_GE1_MDIO_RESET_GET(x)                              (((x) & RST_RESET_GE1_MDIO_RESET_MASK) >> RST_RESET_GE1_MDIO_RESET_LSB)
+#define RST_RESET_GE1_MDIO_RESET_SET(x)                              (((x) << RST_RESET_GE1_MDIO_RESET_LSB) & RST_RESET_GE1_MDIO_RESET_MASK)
+#define RST_RESET_GE1_MDIO_RESET_RESET                               0x1 // 1
+#define RST_RESET_GE0_MDIO_RESET_MSB                                 22
+#define RST_RESET_GE0_MDIO_RESET_LSB                                 22
+#define RST_RESET_GE0_MDIO_RESET_MASK                                0x00400000
+#define RST_RESET_GE0_MDIO_RESET_GET(x)                              (((x) & RST_RESET_GE0_MDIO_RESET_MASK) >> RST_RESET_GE0_MDIO_RESET_LSB)
+#define RST_RESET_GE0_MDIO_RESET_SET(x)                              (((x) << RST_RESET_GE0_MDIO_RESET_LSB) & RST_RESET_GE0_MDIO_RESET_MASK)
+#define RST_RESET_GE0_MDIO_RESET_RESET                               0x1 // 1
+#define RST_RESET_CPU_NMI_MSB                                        21
+#define RST_RESET_CPU_NMI_LSB                                        21
+#define RST_RESET_CPU_NMI_MASK                                       0x00200000
+#define RST_RESET_CPU_NMI_GET(x)                                     (((x) & RST_RESET_CPU_NMI_MASK) >> RST_RESET_CPU_NMI_LSB)
+#define RST_RESET_CPU_NMI_SET(x)                                     (((x) << RST_RESET_CPU_NMI_LSB) & RST_RESET_CPU_NMI_MASK)
+#define RST_RESET_CPU_NMI_RESET                                      0x0 // 0
+#define RST_RESET_CPU_COLD_RESET_MSB                                 20
+#define RST_RESET_CPU_COLD_RESET_LSB                                 20
+#define RST_RESET_CPU_COLD_RESET_MASK                                0x00100000
+#define RST_RESET_CPU_COLD_RESET_GET(x)                              (((x) & RST_RESET_CPU_COLD_RESET_MASK) >> RST_RESET_CPU_COLD_RESET_LSB)
+#define RST_RESET_CPU_COLD_RESET_SET(x)                              (((x) << RST_RESET_CPU_COLD_RESET_LSB) & RST_RESET_CPU_COLD_RESET_MASK)
+#define RST_RESET_CPU_COLD_RESET_RESET                               0x0 // 0
+#define RST_RESET_HOST_RESET_INT_MSB                                 19
+#define RST_RESET_HOST_RESET_INT_LSB                                 19
+#define RST_RESET_HOST_RESET_INT_MASK                                0x00080000
+#define RST_RESET_HOST_RESET_INT_GET(x)                              (((x) & RST_RESET_HOST_RESET_INT_MASK) >> RST_RESET_HOST_RESET_INT_LSB)
+#define RST_RESET_HOST_RESET_INT_SET(x)                              (((x) << RST_RESET_HOST_RESET_INT_LSB) & RST_RESET_HOST_RESET_INT_MASK)
+#define RST_RESET_HOST_RESET_INT_RESET                               0x0 // 0
+#define RST_RESET_PCIEEP_RESET_MSB                                   18
+#define RST_RESET_PCIEEP_RESET_LSB                                   18
+#define RST_RESET_PCIEEP_RESET_MASK                                  0x00040000
+#define RST_RESET_PCIEEP_RESET_GET(x)                                (((x) & RST_RESET_PCIEEP_RESET_MASK) >> RST_RESET_PCIEEP_RESET_LSB)
+#define RST_RESET_PCIEEP_RESET_SET(x)                                (((x) << RST_RESET_PCIEEP_RESET_LSB) & RST_RESET_PCIEEP_RESET_MASK)
+#define RST_RESET_PCIEEP_RESET_RESET                                 0x0 // 0
+#define RST_RESET_UART1_RESET_MSB                                    17
+#define RST_RESET_UART1_RESET_LSB                                    17
+#define RST_RESET_UART1_RESET_MASK                                   0x00020000
+#define RST_RESET_UART1_RESET_GET(x)                                 (((x) & RST_RESET_UART1_RESET_MASK) >> RST_RESET_UART1_RESET_LSB)
+#define RST_RESET_UART1_RESET_SET(x)                                 (((x) << RST_RESET_UART1_RESET_LSB) & RST_RESET_UART1_RESET_MASK)
+#define RST_RESET_UART1_RESET_RESET                                  0x0 // 0
+#define RST_RESET_DDR_RESET_MSB                                      16
+#define RST_RESET_DDR_RESET_LSB                                      16
+#define RST_RESET_DDR_RESET_MASK                                     0x00010000
+#define RST_RESET_DDR_RESET_GET(x)                                   (((x) & RST_RESET_DDR_RESET_MASK) >> RST_RESET_DDR_RESET_LSB)
+#define RST_RESET_DDR_RESET_SET(x)                                   (((x) << RST_RESET_DDR_RESET_LSB) & RST_RESET_DDR_RESET_MASK)
+#define RST_RESET_DDR_RESET_RESET                                    0x0 // 0
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_MSB                            15
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_LSB                            15
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_MASK                           0x00008000
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_GET(x)                         (((x) & RST_RESET_USB_PHY_PLL_PWD_EXT_MASK) >> RST_RESET_USB_PHY_PLL_PWD_EXT_LSB)
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_SET(x)                         (((x) << RST_RESET_USB_PHY_PLL_PWD_EXT_LSB) & RST_RESET_USB_PHY_PLL_PWD_EXT_MASK)
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_RESET                          0x0 // 0
+#define RST_RESET_GE1_MAC_RESET_MSB                                  13
+#define RST_RESET_GE1_MAC_RESET_LSB                                  13
+#define RST_RESET_GE1_MAC_RESET_MASK                                 0x00002000
+#define RST_RESET_GE1_MAC_RESET_GET(x)                               (((x) & RST_RESET_GE1_MAC_RESET_MASK) >> RST_RESET_GE1_MAC_RESET_LSB)
+#define RST_RESET_GE1_MAC_RESET_SET(x)                               (((x) << RST_RESET_GE1_MAC_RESET_LSB) & RST_RESET_GE1_MAC_RESET_MASK)
+#define RST_RESET_GE1_MAC_RESET_RESET                                0x1 // 1
+#define RST_RESET_ETH_SGMII_ARESET_MSB                               12
+#define RST_RESET_ETH_SGMII_ARESET_LSB                               12
+#define RST_RESET_ETH_SGMII_ARESET_MASK                              0x00001000
+#define RST_RESET_ETH_SGMII_ARESET_GET(x)                            (((x) & RST_RESET_ETH_SGMII_ARESET_MASK) >> RST_RESET_ETH_SGMII_ARESET_LSB)
+#define RST_RESET_ETH_SGMII_ARESET_SET(x)                            (((x) << RST_RESET_ETH_SGMII_ARESET_LSB) & RST_RESET_ETH_SGMII_ARESET_MASK)
+#define RST_RESET_ETH_SGMII_ARESET_RESET                             0x1 // 1
+#define RST_RESET_USB_PHY_ARESET_MSB                                 11
+#define RST_RESET_USB_PHY_ARESET_LSB                                 11
+#define RST_RESET_USB_PHY_ARESET_MASK                                0x00000800
+#define RST_RESET_USB_PHY_ARESET_GET(x)                              (((x) & RST_RESET_USB_PHY_ARESET_MASK) >> RST_RESET_USB_PHY_ARESET_LSB)
+#define RST_RESET_USB_PHY_ARESET_SET(x)                              (((x) << RST_RESET_USB_PHY_ARESET_LSB) & RST_RESET_USB_PHY_ARESET_MASK)
+#define RST_RESET_USB_PHY_ARESET_RESET                               0x1 // 1
+#define RST_RESET_HOST_DMA_INT_MSB                                   10
+#define RST_RESET_HOST_DMA_INT_LSB                                   10
+#define RST_RESET_HOST_DMA_INT_MASK                                  0x00000400
+#define RST_RESET_HOST_DMA_INT_GET(x)                                (((x) & RST_RESET_HOST_DMA_INT_MASK) >> RST_RESET_HOST_DMA_INT_LSB)
+#define RST_RESET_HOST_DMA_INT_SET(x)                                (((x) << RST_RESET_HOST_DMA_INT_LSB) & RST_RESET_HOST_DMA_INT_MASK)
+#define RST_RESET_HOST_DMA_INT_RESET                                 0x0 // 0
+#define RST_RESET_GE0_MAC_RESET_MSB                                  9
+#define RST_RESET_GE0_MAC_RESET_LSB                                  9
+#define RST_RESET_GE0_MAC_RESET_MASK                                 0x00000200
+#define RST_RESET_GE0_MAC_RESET_GET(x)                               (((x) & RST_RESET_GE0_MAC_RESET_MASK) >> RST_RESET_GE0_MAC_RESET_LSB)
+#define RST_RESET_GE0_MAC_RESET_SET(x)                               (((x) << RST_RESET_GE0_MAC_RESET_LSB) & RST_RESET_GE0_MAC_RESET_MASK)
+#define RST_RESET_GE0_MAC_RESET_RESET                                0x1 // 1
+#define RST_RESET_ETH_SGMII_RESET_MSB                                8
+#define RST_RESET_ETH_SGMII_RESET_LSB                                8
+#define RST_RESET_ETH_SGMII_RESET_MASK                               0x00000100
+#define RST_RESET_ETH_SGMII_RESET_GET(x)                             (((x) & RST_RESET_ETH_SGMII_RESET_MASK) >> RST_RESET_ETH_SGMII_RESET_LSB)
+#define RST_RESET_ETH_SGMII_RESET_SET(x)                             (((x) << RST_RESET_ETH_SGMII_RESET_LSB) & RST_RESET_ETH_SGMII_RESET_MASK)
+#define RST_RESET_ETH_SGMII_RESET_RESET                              0x1 // 1
+#define RST_RESET_PCIE_PHY_RESET_MSB                                 7
+#define RST_RESET_PCIE_PHY_RESET_LSB                                 7
+#define RST_RESET_PCIE_PHY_RESET_MASK                                0x00000080
+#define RST_RESET_PCIE_PHY_RESET_GET(x)                              (((x) & RST_RESET_PCIE_PHY_RESET_MASK) >> RST_RESET_PCIE_PHY_RESET_LSB)
+#define RST_RESET_PCIE_PHY_RESET_SET(x)                              (((x) << RST_RESET_PCIE_PHY_RESET_LSB) & RST_RESET_PCIE_PHY_RESET_MASK)
+#define RST_RESET_PCIE_PHY_RESET_RESET                               0x1 // 1
+#define RST_RESET_PCIE_RESET_MSB                                     6
+#define RST_RESET_PCIE_RESET_LSB                                     6
+#define RST_RESET_PCIE_RESET_MASK                                    0x00000040
+#define RST_RESET_PCIE_RESET_GET(x)                                  (((x) & RST_RESET_PCIE_RESET_MASK) >> RST_RESET_PCIE_RESET_LSB)
+#define RST_RESET_PCIE_RESET_SET(x)                                  (((x) << RST_RESET_PCIE_RESET_LSB) & RST_RESET_PCIE_RESET_MASK)
+#define RST_RESET_PCIE_RESET_RESET                                   0x1 // 1
+#define RST_RESET_USB_HOST_RESET_MSB                                 5
+#define RST_RESET_USB_HOST_RESET_LSB                                 5
+#define RST_RESET_USB_HOST_RESET_MASK                                0x00000020
+#define RST_RESET_USB_HOST_RESET_GET(x)                              (((x) & RST_RESET_USB_HOST_RESET_MASK) >> RST_RESET_USB_HOST_RESET_LSB)
+#define RST_RESET_USB_HOST_RESET_SET(x)                              (((x) << RST_RESET_USB_HOST_RESET_LSB) & RST_RESET_USB_HOST_RESET_MASK)
+#define RST_RESET_USB_HOST_RESET_RESET                               0x1 // 1
+#define RST_RESET_USB_PHY_RESET_MSB                                  4
+#define RST_RESET_USB_PHY_RESET_LSB                                  4
+#define RST_RESET_USB_PHY_RESET_MASK                                 0x00000010
+#define RST_RESET_USB_PHY_RESET_GET(x)                               (((x) & RST_RESET_USB_PHY_RESET_MASK) >> RST_RESET_USB_PHY_RESET_LSB)
+#define RST_RESET_USB_PHY_RESET_SET(x)                               (((x) << RST_RESET_USB_PHY_RESET_LSB) & RST_RESET_USB_PHY_RESET_MASK)
+#define RST_RESET_USB_PHY_RESET_RESET                                0x1 // 1
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MSB                       3
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB                       3
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK                      0x00000008
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_GET(x)                    (((x) & RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK) >> RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB)
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(x)                    (((x) << RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB) & RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK)
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_RESET                     0x0 // 0
+#define RST_RESET_ETH_SWITCH_ANALOG_RESET_MSB                        2
+#define RST_RESET_ETH_SWITCH_ANALOG_RESET_LSB                        2
+#define RST_RESET_ETH_SWITCH_ANALOG_RESET_MASK                       0x00000004
+#define RST_RESET_ETH_SWITCH_ANALOG_RESET_GET(x)                     (((x) & RST_RESET_ETH_SWITCH_ANALOG_RESET_MASK) >> RST_RESET_ETH_SWITCH_ANALOG_RESET_LSB)
+#define RST_RESET_ETH_SWITCH_ANALOG_RESET_SET(x)                     (((x) << RST_RESET_ETH_SWITCH_ANALOG_RESET_LSB) & RST_RESET_ETH_SWITCH_ANALOG_RESET_MASK)
+#define RST_RESET_ETH_SWITCH_ANALOG_RESET_RESET                      0x1 // 1
+#define RST_RESET_MBOX_RESET_MSB                                     1
+#define RST_RESET_MBOX_RESET_LSB                                     1
+#define RST_RESET_MBOX_RESET_MASK                                    0x00000002
+#define RST_RESET_MBOX_RESET_GET(x)                                  (((x) & RST_RESET_MBOX_RESET_MASK) >> RST_RESET_MBOX_RESET_LSB)
+#define RST_RESET_MBOX_RESET_SET(x)                                  (((x) << RST_RESET_MBOX_RESET_LSB) & RST_RESET_MBOX_RESET_MASK)
+#define RST_RESET_MBOX_RESET_RESET                                   0x0 // 0
+#define RST_RESET_ETH_SWITCH_RESET_MSB                               0
+#define RST_RESET_ETH_SWITCH_RESET_LSB                               0
+#define RST_RESET_ETH_SWITCH_RESET_MASK                              0x00000001
+#define RST_RESET_ETH_SWITCH_RESET_GET(x)                            (((x) & RST_RESET_ETH_SWITCH_RESET_MASK) >> RST_RESET_ETH_SWITCH_RESET_LSB)
+#define RST_RESET_ETH_SWITCH_RESET_SET(x)                            (((x) << RST_RESET_ETH_SWITCH_RESET_LSB) & RST_RESET_ETH_SWITCH_RESET_MASK)
+#define RST_RESET_ETH_SWITCH_RESET_RESET                             0x1 // 1
+#define RST_RESET_ADDRESS                                            0x1806001c
+
+#define RST_MISC2_PCIEEP_LINK_UP_MSB                                 30
+#define RST_MISC2_PCIEEP_LINK_UP_LSB                                 30
+#define RST_MISC2_PCIEEP_LINK_UP_MASK                                0x40000000
+#define RST_MISC2_PCIEEP_LINK_UP_GET(x)                              (((x) & RST_MISC2_PCIEEP_LINK_UP_MASK) >> RST_MISC2_PCIEEP_LINK_UP_LSB)
+#define RST_MISC2_PCIEEP_LINK_UP_SET(x)                              (((x) << RST_MISC2_PCIEEP_LINK_UP_LSB) & RST_MISC2_PCIEEP_LINK_UP_MASK)
+#define RST_MISC2_PCIEEP_LINK_UP_RESET                               0x0 // 0
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_MSB                             29
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_LSB                             29
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_MASK                            0x20000000
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_GET(x)                          (((x) & RST_MISC2_PCIEEP_CLKOBS2_SEL_MASK) >> RST_MISC2_PCIEEP_CLKOBS2_SEL_LSB)
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_SET(x)                          (((x) << RST_MISC2_PCIEEP_CLKOBS2_SEL_LSB) & RST_MISC2_PCIEEP_CLKOBS2_SEL_MASK)
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_RESET                           0x0 // 0
+#define RST_MISC2_PCIE_CLKOBS1_SEL_MSB                               28
+#define RST_MISC2_PCIE_CLKOBS1_SEL_LSB                               28
+#define RST_MISC2_PCIE_CLKOBS1_SEL_MASK                              0x10000000
+#define RST_MISC2_PCIE_CLKOBS1_SEL_GET(x)                            (((x) & RST_MISC2_PCIE_CLKOBS1_SEL_MASK) >> RST_MISC2_PCIE_CLKOBS1_SEL_LSB)
+#define RST_MISC2_PCIE_CLKOBS1_SEL_SET(x)                            (((x) << RST_MISC2_PCIE_CLKOBS1_SEL_LSB) & RST_MISC2_PCIE_CLKOBS1_SEL_MASK)
+#define RST_MISC2_PCIE_CLKOBS1_SEL_RESET                             0x0 // 0
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_MSB                     27
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_LSB                     27
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_MASK                    0x08000000
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_GET(x)                  (((x) & RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_MASK) >> RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_LSB)
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_SET(x)                  (((x) << RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_LSB) & RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_MASK)
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_RESET                   0x0 // 0
+#define RST_MISC2_WOW_STATUS_MSB                                     26
+#define RST_MISC2_WOW_STATUS_LSB                                     26
+#define RST_MISC2_WOW_STATUS_MASK                                    0x04000000
+#define RST_MISC2_WOW_STATUS_GET(x)                                  (((x) & RST_MISC2_WOW_STATUS_MASK) >> RST_MISC2_WOW_STATUS_LSB)
+#define RST_MISC2_WOW_STATUS_SET(x)                                  (((x) << RST_MISC2_WOW_STATUS_LSB) & RST_MISC2_WOW_STATUS_MASK)
+#define RST_MISC2_WOW_STATUS_RESET                                   0x0 // 0
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_MSB                             25
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_LSB                             25
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_MASK                            0x02000000
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L2_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L2_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L2_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L2_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_MSB                             24
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_LSB                             24
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_MASK                            0x01000000
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L2_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L2_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L2_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L2_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_MSB                             23
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_LSB                             23
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_MASK                            0x00800000
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L1_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L1_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L1_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L1_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_MSB                             22
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_LSB                             22
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_MASK                            0x00400000
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L1_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L1_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L1_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L1_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_MSB                            21
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB                            21
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK                           0x00200000
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_GET(x)                         (((x) & RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_SET(x)                         (((x) << RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_RESET                          0x0 // 0
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_MSB                            20
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB                            20
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK                           0x00100000
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_GET(x)                         (((x) & RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_SET(x)                         (((x) << RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_RESET                          0x0 // 0
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_MSB                           18
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_LSB                           18
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_MASK                          0x00040000
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_GET(x)                        (((x) & RST_MISC2_EXT_HOST_WASP_RST_EN_MASK) >> RST_MISC2_EXT_HOST_WASP_RST_EN_LSB)
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_SET(x)                        (((x) << RST_MISC2_EXT_HOST_WASP_RST_EN_LSB) & RST_MISC2_EXT_HOST_WASP_RST_EN_MASK)
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_RESET                         0x0 // 0
+#define RST_MISC2_PCIEEP_RST_INT_MSB                                 17
+#define RST_MISC2_PCIEEP_RST_INT_LSB                                 17
+#define RST_MISC2_PCIEEP_RST_INT_MASK                                0x00020000
+#define RST_MISC2_PCIEEP_RST_INT_GET(x)                              (((x) & RST_MISC2_PCIEEP_RST_INT_MASK) >> RST_MISC2_PCIEEP_RST_INT_LSB)
+#define RST_MISC2_PCIEEP_RST_INT_SET(x)                              (((x) << RST_MISC2_PCIEEP_RST_INT_LSB) & RST_MISC2_PCIEEP_RST_INT_MASK)
+#define RST_MISC2_PCIEEP_RST_INT_RESET                               0x0 // 0
+#define RST_MISC2_HOST_RESET_INT_MSB                                 16
+#define RST_MISC2_HOST_RESET_INT_LSB                                 16
+#define RST_MISC2_HOST_RESET_INT_MASK                                0x00010000
+#define RST_MISC2_HOST_RESET_INT_GET(x)                              (((x) & RST_MISC2_HOST_RESET_INT_MASK) >> RST_MISC2_HOST_RESET_INT_LSB)
+#define RST_MISC2_HOST_RESET_INT_SET(x)                              (((x) << RST_MISC2_HOST_RESET_INT_LSB) & RST_MISC2_HOST_RESET_INT_MASK)
+#define RST_MISC2_HOST_RESET_INT_RESET                               0x0 // 0
+#define RST_MISC2_CPU_HOST_WA_MSB                                    15
+#define RST_MISC2_CPU_HOST_WA_LSB                                    15
+#define RST_MISC2_CPU_HOST_WA_MASK                                   0x00008000
+#define RST_MISC2_CPU_HOST_WA_GET(x)                                 (((x) & RST_MISC2_CPU_HOST_WA_MASK) >> RST_MISC2_CPU_HOST_WA_LSB)
+#define RST_MISC2_CPU_HOST_WA_SET(x)                                 (((x) << RST_MISC2_CPU_HOST_WA_LSB) & RST_MISC2_CPU_HOST_WA_MASK)
+#define RST_MISC2_CPU_HOST_WA_RESET                                  0x0 // 0
+#define RST_MISC2_PERSTN_RCPHY2_MSB                                  14
+#define RST_MISC2_PERSTN_RCPHY2_LSB                                  14
+#define RST_MISC2_PERSTN_RCPHY2_MASK                                 0x00004000
+#define RST_MISC2_PERSTN_RCPHY2_GET(x)                               (((x) & RST_MISC2_PERSTN_RCPHY2_MASK) >> RST_MISC2_PERSTN_RCPHY2_LSB)
+#define RST_MISC2_PERSTN_RCPHY2_SET(x)                               (((x) << RST_MISC2_PERSTN_RCPHY2_LSB) & RST_MISC2_PERSTN_RCPHY2_MASK)
+#define RST_MISC2_PERSTN_RCPHY2_RESET                                0x1 // 1
+#define RST_MISC2_PERSTN_RCPHY_MSB                                   13
+#define RST_MISC2_PERSTN_RCPHY_LSB                                   13
+#define RST_MISC2_PERSTN_RCPHY_MASK                                  0x00002000
+#define RST_MISC2_PERSTN_RCPHY_GET(x)                                (((x) & RST_MISC2_PERSTN_RCPHY_MASK) >> RST_MISC2_PERSTN_RCPHY_LSB)
+#define RST_MISC2_PERSTN_RCPHY_SET(x)                                (((x) << RST_MISC2_PERSTN_RCPHY_LSB) & RST_MISC2_PERSTN_RCPHY_MASK)
+#define RST_MISC2_PERSTN_RCPHY_RESET                                 0x1 // 1
+#define RST_MISC2_PCIEEP_LTSSM_STATE_MSB                             12
+#define RST_MISC2_PCIEEP_LTSSM_STATE_LSB                             8
+#define RST_MISC2_PCIEEP_LTSSM_STATE_MASK                            0x00001f00
+#define RST_MISC2_PCIEEP_LTSSM_STATE_GET(x)                          (((x) & RST_MISC2_PCIEEP_LTSSM_STATE_MASK) >> RST_MISC2_PCIEEP_LTSSM_STATE_LSB)
+#define RST_MISC2_PCIEEP_LTSSM_STATE_SET(x)                          (((x) << RST_MISC2_PCIEEP_LTSSM_STATE_LSB) & RST_MISC2_PCIEEP_LTSSM_STATE_MASK)
+#define RST_MISC2_PCIEEP_LTSSM_STATE_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_LINK_STATUS_MSB                             4
+#define RST_MISC2_PCIEEP_LINK_STATUS_LSB                             4
+#define RST_MISC2_PCIEEP_LINK_STATUS_MASK                            0x00000010
+#define RST_MISC2_PCIEEP_LINK_STATUS_GET(x)                          (((x) & RST_MISC2_PCIEEP_LINK_STATUS_MASK) >> RST_MISC2_PCIEEP_LINK_STATUS_LSB)
+#define RST_MISC2_PCIEEP_LINK_STATUS_SET(x)                          (((x) << RST_MISC2_PCIEEP_LINK_STATUS_LSB) & RST_MISC2_PCIEEP_LINK_STATUS_MASK)
+#define RST_MISC2_PCIEEP_LINK_STATUS_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_MSB                           2
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_LSB                           2
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_MASK                          0x00000004
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_GET(x)                        (((x) & RST_MISC2_PCIEEP_RXDETECT_DONE_MASK) >> RST_MISC2_PCIEEP_RXDETECT_DONE_LSB)
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_SET(x)                        (((x) << RST_MISC2_PCIEEP_RXDETECT_DONE_LSB) & RST_MISC2_PCIEEP_RXDETECT_DONE_MASK)
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_RESET                         0x0 // 0
+#define RST_MISC2_PCIEEP_WOW_INT_MSB                                 1
+#define RST_MISC2_PCIEEP_WOW_INT_LSB                                 1
+#define RST_MISC2_PCIEEP_WOW_INT_MASK                                0x00000002
+#define RST_MISC2_PCIEEP_WOW_INT_GET(x)                              (((x) & RST_MISC2_PCIEEP_WOW_INT_MASK) >> RST_MISC2_PCIEEP_WOW_INT_LSB)
+#define RST_MISC2_PCIEEP_WOW_INT_SET(x)                              (((x) << RST_MISC2_PCIEEP_WOW_INT_LSB) & RST_MISC2_PCIEEP_WOW_INT_MASK)
+#define RST_MISC2_PCIEEP_WOW_INT_RESET                               0x0 // 0
+#define RST_MISC2_PCIEEP_CFG_DONE_MSB                                0
+#define RST_MISC2_PCIEEP_CFG_DONE_LSB                                0
+#define RST_MISC2_PCIEEP_CFG_DONE_MASK                               0x00000001
+#define RST_MISC2_PCIEEP_CFG_DONE_GET(x)                             (((x) & RST_MISC2_PCIEEP_CFG_DONE_MASK) >> RST_MISC2_PCIEEP_CFG_DONE_LSB)
+#define RST_MISC2_PCIEEP_CFG_DONE_SET(x)                             (((x) << RST_MISC2_PCIEEP_CFG_DONE_LSB) & RST_MISC2_PCIEEP_CFG_DONE_MASK)
+#define RST_MISC2_PCIEEP_CFG_DONE_RESET                              0x0 // 0
+#define RST_MISC2_ADDRESS                                            0x180600b8
+
+#define PCIE_APP_CFG_TYPE_MSB                                        21
+#define PCIE_APP_CFG_TYPE_LSB                                        20
+#define PCIE_APP_CFG_TYPE_MASK                                       0x00300000
+#define PCIE_APP_CFG_TYPE_GET(x)                                     (((x) & PCIE_APP_CFG_TYPE_MASK) >> PCIE_APP_CFG_TYPE_LSB)
+#define PCIE_APP_CFG_TYPE_SET(x)                                     (((x) << PCIE_APP_CFG_TYPE_LSB) & PCIE_APP_CFG_TYPE_MASK)
+#define PCIE_APP_CFG_TYPE_RESET                                      0x0 // 0
+#define PCIE_APP_PCIE_BAR_MSN_MSB                                    19
+#define PCIE_APP_PCIE_BAR_MSN_LSB                                    16
+#define PCIE_APP_PCIE_BAR_MSN_MASK                                   0x000f0000
+#define PCIE_APP_PCIE_BAR_MSN_GET(x)                                 (((x) & PCIE_APP_PCIE_BAR_MSN_MASK) >> PCIE_APP_PCIE_BAR_MSN_LSB)
+#define PCIE_APP_PCIE_BAR_MSN_SET(x)                                 (((x) << PCIE_APP_PCIE_BAR_MSN_LSB) & PCIE_APP_PCIE_BAR_MSN_MASK)
+#define PCIE_APP_PCIE_BAR_MSN_RESET                                  0x1 // 1
+#define PCIE_APP_CFG_BE_MSB                                          15
+#define PCIE_APP_CFG_BE_LSB                                          12
+#define PCIE_APP_CFG_BE_MASK                                         0x0000f000
+#define PCIE_APP_CFG_BE_GET(x)                                       (((x) & PCIE_APP_CFG_BE_MASK) >> PCIE_APP_CFG_BE_LSB)
+#define PCIE_APP_CFG_BE_SET(x)                                       (((x) << PCIE_APP_CFG_BE_LSB) & PCIE_APP_CFG_BE_MASK)
+#define PCIE_APP_CFG_BE_RESET                                        0xf // 15
+#define PCIE_APP_SLV_RESP_ERR_MAP_MSB                                11
+#define PCIE_APP_SLV_RESP_ERR_MAP_LSB                                6
+#define PCIE_APP_SLV_RESP_ERR_MAP_MASK                               0x00000fc0
+#define PCIE_APP_SLV_RESP_ERR_MAP_GET(x)                             (((x) & PCIE_APP_SLV_RESP_ERR_MAP_MASK) >> PCIE_APP_SLV_RESP_ERR_MAP_LSB)
+#define PCIE_APP_SLV_RESP_ERR_MAP_SET(x)                             (((x) << PCIE_APP_SLV_RESP_ERR_MAP_LSB) & PCIE_APP_SLV_RESP_ERR_MAP_MASK)
+#define PCIE_APP_SLV_RESP_ERR_MAP_RESET                              0x3f // 63
+#define PCIE_APP_MSTR_RESP_ERR_MAP_MSB                               5
+#define PCIE_APP_MSTR_RESP_ERR_MAP_LSB                               4
+#define PCIE_APP_MSTR_RESP_ERR_MAP_MASK                              0x00000030
+#define PCIE_APP_MSTR_RESP_ERR_MAP_GET(x)                            (((x) & PCIE_APP_MSTR_RESP_ERR_MAP_MASK) >> PCIE_APP_MSTR_RESP_ERR_MAP_LSB)
+#define PCIE_APP_MSTR_RESP_ERR_MAP_SET(x)                            (((x) << PCIE_APP_MSTR_RESP_ERR_MAP_LSB) & PCIE_APP_MSTR_RESP_ERR_MAP_MASK)
+#define PCIE_APP_MSTR_RESP_ERR_MAP_RESET                             0x0 // 0
+#define PCIE_APP_INIT_RST_MSB                                        3
+#define PCIE_APP_INIT_RST_LSB                                        3
+#define PCIE_APP_INIT_RST_MASK                                       0x00000008
+#define PCIE_APP_INIT_RST_GET(x)                                     (((x) & PCIE_APP_INIT_RST_MASK) >> PCIE_APP_INIT_RST_LSB)
+#define PCIE_APP_INIT_RST_SET(x)                                     (((x) << PCIE_APP_INIT_RST_LSB) & PCIE_APP_INIT_RST_MASK)
+#define PCIE_APP_INIT_RST_RESET                                      0x0 // 0
+#define PCIE_APP_PM_XMT_TURNOFF_MSB                                  2
+#define PCIE_APP_PM_XMT_TURNOFF_LSB                                  2
+#define PCIE_APP_PM_XMT_TURNOFF_MASK                                 0x00000004
+#define PCIE_APP_PM_XMT_TURNOFF_GET(x)                               (((x) & PCIE_APP_PM_XMT_TURNOFF_MASK) >> PCIE_APP_PM_XMT_TURNOFF_LSB)
+#define PCIE_APP_PM_XMT_TURNOFF_SET(x)                               (((x) << PCIE_APP_PM_XMT_TURNOFF_LSB) & PCIE_APP_PM_XMT_TURNOFF_MASK)
+#define PCIE_APP_PM_XMT_TURNOFF_RESET                                0x0 // 0
+#define PCIE_APP_UNLOCK_MSG_MSB                                      1
+#define PCIE_APP_UNLOCK_MSG_LSB                                      1
+#define PCIE_APP_UNLOCK_MSG_MASK                                     0x00000002
+#define PCIE_APP_UNLOCK_MSG_GET(x)                                   (((x) & PCIE_APP_UNLOCK_MSG_MASK) >> PCIE_APP_UNLOCK_MSG_LSB)
+#define PCIE_APP_UNLOCK_MSG_SET(x)                                   (((x) << PCIE_APP_UNLOCK_MSG_LSB) & PCIE_APP_UNLOCK_MSG_MASK)
+#define PCIE_APP_UNLOCK_MSG_RESET                                    0x0 // 0
+#define PCIE_APP_LTSSM_ENABLE_MSB                                    0
+#define PCIE_APP_LTSSM_ENABLE_LSB                                    0
+#define PCIE_APP_LTSSM_ENABLE_MASK                                   0x00000001
+#define PCIE_APP_LTSSM_ENABLE_GET(x)                                 (((x) & PCIE_APP_LTSSM_ENABLE_MASK) >> PCIE_APP_LTSSM_ENABLE_LSB)
+#define PCIE_APP_LTSSM_ENABLE_SET(x)                                 (((x) << PCIE_APP_LTSSM_ENABLE_LSB) & PCIE_APP_LTSSM_ENABLE_MASK)
+#define PCIE_APP_LTSSM_ENABLE_RESET                                  0x0 // 0
+#define PCIE_APP_ADDRESS                                             0x18280000
+
+#define XTAL_TCXODET_MSB                                             31
+#define XTAL_TCXODET_LSB                                             31
+#define XTAL_TCXODET_MASK                                            0x80000000
+#define XTAL_TCXODET_GET(x)                                          (((x) & XTAL_TCXODET_MASK) >> XTAL_TCXODET_LSB)
+#define XTAL_TCXODET_SET(x)                                          (((x) << XTAL_TCXODET_LSB) & XTAL_TCXODET_MASK)
+#define XTAL_TCXODET_RESET                                           0x0 // 0
+#define XTAL_XTAL_CAPINDAC_MSB                                       30
+#define XTAL_XTAL_CAPINDAC_LSB                                       24
+#define XTAL_XTAL_CAPINDAC_MASK                                      0x7f000000
+#define XTAL_XTAL_CAPINDAC_GET(x)                                    (((x) & XTAL_XTAL_CAPINDAC_MASK) >> XTAL_XTAL_CAPINDAC_LSB)
+#define XTAL_XTAL_CAPINDAC_SET(x)                                    (((x) << XTAL_XTAL_CAPINDAC_LSB) & XTAL_XTAL_CAPINDAC_MASK)
+#define XTAL_XTAL_CAPINDAC_RESET                                     0x4b // 75
+#define XTAL_XTAL_CAPOUTDAC_MSB                                      23
+#define XTAL_XTAL_CAPOUTDAC_LSB                                      17
+#define XTAL_XTAL_CAPOUTDAC_MASK                                     0x00fe0000
+#define XTAL_XTAL_CAPOUTDAC_GET(x)                                   (((x) & XTAL_XTAL_CAPOUTDAC_MASK) >> XTAL_XTAL_CAPOUTDAC_LSB)
+#define XTAL_XTAL_CAPOUTDAC_SET(x)                                   (((x) << XTAL_XTAL_CAPOUTDAC_LSB) & XTAL_XTAL_CAPOUTDAC_MASK)
+#define XTAL_XTAL_CAPOUTDAC_RESET                                    0x4b // 75
+#define XTAL_XTAL_DRVSTR_MSB                                         16
+#define XTAL_XTAL_DRVSTR_LSB                                         15
+#define XTAL_XTAL_DRVSTR_MASK                                        0x00018000
+#define XTAL_XTAL_DRVSTR_GET(x)                                      (((x) & XTAL_XTAL_DRVSTR_MASK) >> XTAL_XTAL_DRVSTR_LSB)
+#define XTAL_XTAL_DRVSTR_SET(x)                                      (((x) << XTAL_XTAL_DRVSTR_LSB) & XTAL_XTAL_DRVSTR_MASK)
+#define XTAL_XTAL_DRVSTR_RESET                                       0x0 // 0
+#define XTAL_XTAL_SHORTXIN_MSB                                       14
+#define XTAL_XTAL_SHORTXIN_LSB                                       14
+#define XTAL_XTAL_SHORTXIN_MASK                                      0x00004000
+#define XTAL_XTAL_SHORTXIN_GET(x)                                    (((x) & XTAL_XTAL_SHORTXIN_MASK) >> XTAL_XTAL_SHORTXIN_LSB)
+#define XTAL_XTAL_SHORTXIN_SET(x)                                    (((x) << XTAL_XTAL_SHORTXIN_LSB) & XTAL_XTAL_SHORTXIN_MASK)
+#define XTAL_XTAL_SHORTXIN_RESET                                     0x0 // 0
+#define XTAL_XTAL_LOCALBIAS_MSB                                      13
+#define XTAL_XTAL_LOCALBIAS_LSB                                      13
+#define XTAL_XTAL_LOCALBIAS_MASK                                     0x00002000
+#define XTAL_XTAL_LOCALBIAS_GET(x)                                   (((x) & XTAL_XTAL_LOCALBIAS_MASK) >> XTAL_XTAL_LOCALBIAS_LSB)
+#define XTAL_XTAL_LOCALBIAS_SET(x)                                   (((x) << XTAL_XTAL_LOCALBIAS_LSB) & XTAL_XTAL_LOCALBIAS_MASK)
+#define XTAL_XTAL_LOCALBIAS_RESET                                    0x1 // 1
+#define XTAL_XTAL_PWDCLKD_MSB                                        12
+#define XTAL_XTAL_PWDCLKD_LSB                                        12
+#define XTAL_XTAL_PWDCLKD_MASK                                       0x00001000
+#define XTAL_XTAL_PWDCLKD_GET(x)                                     (((x) & XTAL_XTAL_PWDCLKD_MASK) >> XTAL_XTAL_PWDCLKD_LSB)
+#define XTAL_XTAL_PWDCLKD_SET(x)                                     (((x) << XTAL_XTAL_PWDCLKD_LSB) & XTAL_XTAL_PWDCLKD_MASK)
+#define XTAL_XTAL_PWDCLKD_RESET                                      0x0 // 0
+#define XTAL_XTAL_BIAS2X_MSB                                         11
+#define XTAL_XTAL_BIAS2X_LSB                                         11
+#define XTAL_XTAL_BIAS2X_MASK                                        0x00000800
+#define XTAL_XTAL_BIAS2X_GET(x)                                      (((x) & XTAL_XTAL_BIAS2X_MASK) >> XTAL_XTAL_BIAS2X_LSB)
+#define XTAL_XTAL_BIAS2X_SET(x)                                      (((x) << XTAL_XTAL_BIAS2X_LSB) & XTAL_XTAL_BIAS2X_MASK)
+#define XTAL_XTAL_BIAS2X_RESET                                       0x1 // 1
+#define XTAL_XTAL_LBIAS2X_MSB                                        10
+#define XTAL_XTAL_LBIAS2X_LSB                                        10
+#define XTAL_XTAL_LBIAS2X_MASK                                       0x00000400
+#define XTAL_XTAL_LBIAS2X_GET(x)                                     (((x) & XTAL_XTAL_LBIAS2X_MASK) >> XTAL_XTAL_LBIAS2X_LSB)
+#define XTAL_XTAL_LBIAS2X_SET(x)                                     (((x) << XTAL_XTAL_LBIAS2X_LSB) & XTAL_XTAL_LBIAS2X_MASK)
+#define XTAL_XTAL_LBIAS2X_RESET                                      0x1 // 1
+//#define XTAL_XTAL_ATBVREG_MSB                                        9
+//#define XTAL_XTAL_ATBVREG_LSB                                        9
+//#define XTAL_XTAL_ATBVREG_MASK                                       0x00000200
+//#define XTAL_XTAL_ATBVREG_GET(x)                                     (((x) & XTAL_XTAL_ATBVREG_MASK) >> XTAL_XTAL_ATBVREG_LSB)
+//#define XTAL_XTAL_ATBVREG_SET(x)                                     (((x) << XTAL_XTAL_ATBVREG_LSB) & XTAL_XTAL_ATBVREG_MASK)
+//#define XTAL_XTAL_ATBVREG_RESET                                      0x0 // 0
+#define XTAL_XTAL_SELVREG_MSB                                        9
+#define XTAL_XTAL_SELVREG_LSB                                        9
+#define XTAL_XTAL_SELVREG_MASK                                       0x00000200
+#define XTAL_XTAL_SELVREG_GET(x)                                     (((x) & XTAL_XTAL_SELVREG_MASK) >> XTAL_XTAL_SELVREG_LSB)
+#define XTAL_XTAL_SELVREG_SET(x)                                     (((x) << XTAL_XTAL_SELVREG_LSB) & XTAL_XTAL_SELVREG_MASK)
+#define XTAL_XTAL_SELVREG_RESET                                      0x0 // 0
+#define XTAL_XTAL_OSCON_MSB                                          8
+#define XTAL_XTAL_OSCON_LSB                                          8
+#define XTAL_XTAL_OSCON_MASK                                         0x00000100
+#define XTAL_XTAL_OSCON_GET(x)                                       (((x) & XTAL_XTAL_OSCON_MASK) >> XTAL_XTAL_OSCON_LSB)
+#define XTAL_XTAL_OSCON_SET(x)                                       (((x) << XTAL_XTAL_OSCON_LSB) & XTAL_XTAL_OSCON_MASK)
+#define XTAL_XTAL_OSCON_RESET                                        0x1 // 1
+#define XTAL_XTAL_PWDCLKIN_MSB                                       7
+#define XTAL_XTAL_PWDCLKIN_LSB                                       7
+#define XTAL_XTAL_PWDCLKIN_MASK                                      0x00000080
+#define XTAL_XTAL_PWDCLKIN_GET(x)                                    (((x) & XTAL_XTAL_PWDCLKIN_MASK) >> XTAL_XTAL_PWDCLKIN_LSB)
+#define XTAL_XTAL_PWDCLKIN_SET(x)                                    (((x) << XTAL_XTAL_PWDCLKIN_LSB) & XTAL_XTAL_PWDCLKIN_MASK)
+#define XTAL_XTAL_PWDCLKIN_RESET                                     0x0 // 0
+#define XTAL_LOCAL_XTAL_MSB                                          6
+#define XTAL_LOCAL_XTAL_LSB                                          6
+#define XTAL_LOCAL_XTAL_MASK                                         0x00000040
+#define XTAL_LOCAL_XTAL_GET(x)                                       (((x) & XTAL_LOCAL_XTAL_MASK) >> XTAL_LOCAL_XTAL_LSB)
+#define XTAL_LOCAL_XTAL_SET(x)                                       (((x) << XTAL_LOCAL_XTAL_LSB) & XTAL_LOCAL_XTAL_MASK)
+#define XTAL_LOCAL_XTAL_RESET                                        0x0 // 0
+#define XTAL_PWD_SWREGCLK_MSB                                        5
+#define XTAL_PWD_SWREGCLK_LSB                                        5
+#define XTAL_PWD_SWREGCLK_MASK                                       0x00000020
+#define XTAL_PWD_SWREGCLK_GET(x)                                     (((x) & XTAL_PWD_SWREGCLK_MASK) >> XTAL_PWD_SWREGCLK_LSB)
+#define XTAL_PWD_SWREGCLK_SET(x)                                     (((x) << XTAL_PWD_SWREGCLK_LSB) & XTAL_PWD_SWREGCLK_MASK)
+#define XTAL_PWD_SWREGCLK_RESET                                      0x0 // 0
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_MSB                                4
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_LSB                                4
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_MASK                               0x00000010
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_GET(x)                             (((x) & XTAL_LOCAL_EXT_CLK_OUT_EN_MASK) >> XTAL_LOCAL_EXT_CLK_OUT_EN_LSB)
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_SET(x)                             (((x) << XTAL_LOCAL_EXT_CLK_OUT_EN_LSB) & XTAL_LOCAL_EXT_CLK_OUT_EN_MASK)
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_RESET                              0x0 // 0
+#define XTAL_EXT_CLK_OUT_EN_MSB                                      3
+#define XTAL_EXT_CLK_OUT_EN_LSB                                      3
+#define XTAL_EXT_CLK_OUT_EN_MASK                                     0x00000008
+#define XTAL_EXT_CLK_OUT_EN_GET(x)                                   (((x) & XTAL_EXT_CLK_OUT_EN_MASK) >> XTAL_EXT_CLK_OUT_EN_LSB)
+#define XTAL_EXT_CLK_OUT_EN_SET(x)                                   (((x) << XTAL_EXT_CLK_OUT_EN_LSB) & XTAL_EXT_CLK_OUT_EN_MASK)
+#define XTAL_EXT_CLK_OUT_EN_RESET                                    0x0 // 0
+#define XTAL_XTAL_SVREG_MSB                                          2
+#define XTAL_XTAL_SVREG_LSB                                          2
+#define XTAL_XTAL_SVREG_MASK                                         0x00000004
+#define XTAL_XTAL_SVREG_GET(x)                                       (((x) & XTAL_XTAL_SVREG_MASK) >> XTAL_XTAL_SVREG_LSB)
+#define XTAL_XTAL_SVREG_SET(x)                                       (((x) << XTAL_XTAL_SVREG_LSB) & XTAL_XTAL_SVREG_MASK)
+#define XTAL_XTAL_SVREG_RESET                                        0x0 // 0
+#define XTAL_RBK_UDSEL_MSB                                           1
+#define XTAL_RBK_UDSEL_LSB                                           1
+#define XTAL_RBK_UDSEL_MASK                                          0x00000002
+#define XTAL_RBK_UDSEL_GET(x)                                        (((x) & XTAL_RBK_UDSEL_MASK) >> XTAL_RBK_UDSEL_LSB)
+#define XTAL_RBK_UDSEL_SET(x)                                        (((x) << XTAL_RBK_UDSEL_LSB) & XTAL_RBK_UDSEL_MASK)
+#define XTAL_RBK_UDSEL_RESET                                         0x0 // 0
+#define XTAL_SPARE_MSB                                               0
+#define XTAL_SPARE_LSB                                               0
+#define XTAL_SPARE_MASK                                              0x00000001
+#define XTAL_SPARE_GET(x)                                            (((x) & XTAL_SPARE_MASK) >> XTAL_SPARE_LSB)
+#define XTAL_SPARE_SET(x)                                            (((x) << XTAL_SPARE_LSB) & XTAL_SPARE_MASK)
+#define XTAL_SPARE_RESET                                             0x0 // 0	
+#define XTAL_ADDRESS                                                 0x181162c0
+
+#define XTAL2_TDC_COUNT_MSB                                          31
+#define XTAL2_TDC_COUNT_LSB                                          26
+#define XTAL2_TDC_COUNT_MASK                                         0xfc000000
+#define XTAL2_TDC_COUNT_GET(x)                                       (((x) & XTAL2_TDC_COUNT_MASK) >> XTAL2_TDC_COUNT_LSB)
+#define XTAL2_TDC_COUNT_SET(x)                                       (((x) << XTAL2_TDC_COUNT_LSB) & XTAL2_TDC_COUNT_MASK)
+#define XTAL2_TDC_COUNT_RESET                                        0x0 // 0
+#define XTAL2_TDC_PH_COUNT_MSB                                       25
+#define XTAL2_TDC_PH_COUNT_LSB                                       21
+#define XTAL2_TDC_PH_COUNT_MASK                                      0x3e00000
+#define XTAL2_TDC_PH_COUNT_GET(x)                                    (((x) & XTAL2_TDC_PH_COUNT_MASK) >> XTAL2_TDC_PH_COUNT_LSB)
+#define XTAL2_TDC_PH_COUNT_SET(x)                                    (((x) << XTAL2_TDC_PH_COUNT_LSB) & XTAL2_TDC_PH_COUNT_MASK)
+#define XTAL2_TDC_PH_COUNT_RESET                                     0x0 // 0
+#define XTAL2_DUTY_UP_MSB                                            20
+#define XTAL2_DUTY_UP_LSB                                            16
+#define XTAL2_DUTY_UP_MASK                                           0x1f0000
+#define XTAL2_DUTY_UP_GET(x)                                         (((x) & XTAL2_DUTY_UP_MASK) >> XTAL2_DUTY_UP_LSB)
+#define XTAL2_DUTY_UP_SET(x)                                         (((x) << XTAL2_DUTY_UP_LSB) & XTAL2_DUTY_UP_MASK)
+#define XTAL2_DUTY_UP_RESET                                          0x0 // 0
+#define XTAL2_DUTY_DN_MSB                                            15
+#define XTAL2_DUTY_DN_LSB                                            11
+#define XTAL2_DUTY_DN_MASK                                           0xf800
+#define XTAL2_DUTY_DN_GET(x)                                         (((x) & XTAL2_DUTY_DN_MASK) >> XTAL2_DUTY_DN_LSB)
+#define XTAL2_DUTY_DN_SET(x)                                         (((x) << XTAL2_DUTY_DN_LSB) & XTAL2_DUTY_DN_MASK)
+#define XTAL2_DUTY_DN_RESET                                          0x0 // 0
+#define XTAL2_DCA_BYPASS_MSB                                         10
+#define XTAL2_DCA_BYPASS_LSB                                         10
+#define XTAL2_DCA_BYPASS_MASK                                        0x400
+#define XTAL2_DCA_BYPASS_GET(x)                                      (((x) & XTAL2_DCA_BYPASS_MASK) >> XTAL2_DCA_BYPASS_LSB)
+#define XTAL2_DCA_BYPASS_SET(x)                                      (((x) << XTAL2_DCA_BYPASS_LSB) & XTAL2_DCA_BYPASS_MASK)
+#define XTAL2_DCA_BYPASS_RESET                                       0x1 // 1
+#define XTAL2_DCA_SWCAL_MSB                                          9
+#define XTAL2_DCA_SWCAL_LSB                                          9
+#define XTAL2_DCA_SWCAL_MASK                                         0x200
+#define XTAL2_DCA_SWCAL_GET(x)                                       (((x) & XTAL2_DCA_SWCAL_MASK) >> XTAL2_DCA_SWCAL_LSB)
+#define XTAL2_DCA_SWCAL_SET(x)                                       (((x) << XTAL2_DCA_SWCAL_LSB) & XTAL2_DCA_SWCAL_MASK)
+#define XTAL2_DCA_SWCAL_RESET                                        0x0 // 0
+#define XTAL2_FSM_UD_HOLD_MSB                                        8
+#define XTAL2_FSM_UD_HOLD_LSB                                        8
+#define XTAL2_FSM_UD_HOLD_MASK                                       0x100
+#define XTAL2_FSM_UD_HOLD_GET(x)                                     (((x) & XTAL2_FSM_UD_HOLD_MASK) >> XTAL2_FSM_UD_HOLD_LSB)
+#define XTAL2_FSM_UD_HOLD_SET(x)                                     (((x) << XTAL2_FSM_UD_HOLD_LSB) & XTAL2_FSM_UD_HOLD_MASK)
+#define XTAL2_FSM_UD_HOLD_RESET                                      0x0 // 0
+#define XTAL2_FSM_START_L_MSB                                        7
+#define XTAL2_FSM_START_L_LSB                                        7
+#define XTAL2_FSM_START_L_MASK                                       0x80
+#define XTAL2_FSM_START_L_GET(x)                                     (((x) & XTAL2_FSM_START_L_MASK) >> XTAL2_FSM_START_L_LSB)
+#define XTAL2_FSM_START_L_SET(x)                                     (((x) << XTAL2_FSM_START_L_LSB) & XTAL2_FSM_START_L_MASK)
+#define XTAL2_FSM_START_L_RESET                                      0x1 // 1
+#define XTAL2_FSM_DN_READBACK_MSB                                    6
+#define XTAL2_FSM_DN_READBACK_LSB                                    2
+#define XTAL2_FSM_DN_READBACK_MASK                                   0x7c
+#define XTAL2_FSM_DN_READBACK_GET(x)                                 (((x) & XTAL2_FSM_DN_READBACK_MASK) >> XTAL2_FSM_DN_READBACK_LSB)
+#define XTAL2_FSM_DN_READBACK_SET(x)                                 (((x) << XTAL2_FSM_DN_READBACK_LSB) & XTAL2_FSM_DN_READBACK_MASK)
+#define XTAL2_FSM_DN_READBACK_RESET                                  0x0 // 0
+#define XTAL2_TDC_SAT_FLAG_MSB                                       1
+#define XTAL2_TDC_SAT_FLAG_LSB                                       1
+#define XTAL2_TDC_SAT_FLAG_MASK                                      0x2
+#define XTAL2_TDC_SAT_FLAG_GET(x)                                    (((x) & XTAL2_TDC_SAT_FLAG_MASK) >> XTAL2_TDC_SAT_FLAG_LSB)
+#define XTAL2_TDC_SAT_FLAG_SET(x)                                    (((x) << XTAL2_TDC_SAT_FLAG_LSB) & XTAL2_TDC_SAT_FLAG_MASK)
+#define XTAL2_TDC_SAT_FLAG_RESET                                     0x0 // 0
+#define XTAL2_FSM_READY_MSB                                          0
+#define XTAL2_FSM_READY_LSB                                          0
+#define XTAL2_FSM_READY_MASK                                         0x1
+#define XTAL2_FSM_READY_GET(x)                                       (((x) & XTAL2_FSM_READY_MASK) >> XTAL2_FSM_READY_LSB)
+#define XTAL2_FSM_READY_SET(x)                                       (((x) << XTAL2_FSM_READY_LSB) & XTAL2_FSM_READY_MASK)
+#define XTAL2_FSM_READY_RESET                                        0x0 // 0
+#define XTAL2_ADDRESS                                                0x181162c4
+
+#define XTAL3_FSM_UP_READBACK_MSB                                    31
+#define XTAL3_FSM_UP_READBACK_LSB                                    27
+#define XTAL3_FSM_UP_READBACK_MASK                                   0xf8000000
+#define XTAL3_FSM_UP_READBACK_GET(x)                                 (((x) & XTAL3_FSM_UP_READBACK_MASK) >> XTAL3_FSM_UP_READBACK_LSB)
+#define XTAL3_FSM_UP_READBACK_SET(x)                                 (((x) << XTAL3_FSM_UP_READBACK_LSB) & XTAL3_FSM_UP_READBACK_MASK)
+#define XTAL3_FSM_UP_READBACK_RESET                                  0x0 // 0
+#define XTAL3_EVAL_LENGTH_MSB                                        26
+#define XTAL3_EVAL_LENGTH_LSB                                        16
+#define XTAL3_EVAL_LENGTH_MASK                                       0x7ff0000
+#define XTAL3_EVAL_LENGTH_GET(x)                                     (((x) & XTAL3_EVAL_LENGTH_MASK) >> XTAL3_EVAL_LENGTH_LSB)
+#define XTAL3_EVAL_LENGTH_SET(x)                                     (((x) << XTAL3_EVAL_LENGTH_LSB) & XTAL3_EVAL_LENGTH_MASK)
+#define XTAL3_EVAL_LENGTH_RESET                                      0x400 // 0x400
+#define XTAL3_TDC_ERROR_FLAG_MSB                                     15
+#define XTAL3_TDC_ERROR_FLAG_LSB                                     15
+#define XTAL3_TDC_ERROR_FLAG_MASK                                    0x8000
+#define XTAL3_TDC_ERROR_FLAG_GET(x)                                  (((x) & XTAL3_TDC_ERROR_FLAG_MASK) >> XTAL3_TDC_ERROR_FLAG_LSB)
+#define XTAL3_TDC_ERROR_FLAG_SET(x)                                  (((x) << XTAL3_TDC_ERROR_FLAG_LSB) & XTAL3_TDC_ERROR_FLAG_MASK)
+#define XTAL3_TDC_ERROR_FLAG_RESET                                   0x0 // 0
+#define XTAL3_HARMONIC_NUMBER_MSB                                    14
+#define XTAL3_HARMONIC_NUMBER_LSB                                    2
+#define XTAL3_HARMONIC_NUMBER_MASK                                   0x7ffc
+#define XTAL3_HARMONIC_NUMBER_GET(x)                                 (((x) & XTAL3_HARMONIC_NUMBER_MASK) >> XTAL3_HARMONIC_NUMBER_LSB)
+#define XTAL3_HARMONIC_NUMBER_SET(x)                                 (((x) << XTAL3_HARMONIC_NUMBER_LSB) & XTAL3_HARMONIC_NUMBER_MASK)
+#define XTAL3_HARMONIC_NUMBER_RESET                                  0x51 // 0x51
+#define XTAL3_SPARE_MSB                                              1
+#define XTAL3_SPARE_LSB                                              0
+#define XTAL3_SPARE_MASK                                             0x3
+#define XTAL3_SPARE_GET(x)                                           (((x) & XTAL3_SPARE_MASK) >> XTAL3_SPARE_LSB)
+#define XTAL3_SPARE_SET(x)                                           (((x) << XTAL3_SPARE_LSB) & XTAL3_SPARE_MASK)
+#define XTAL3_SPARE_RESET                                            0x0 // 0x0
+#define XTAL3_ADDRESS                                                0x181162c8
+
+
+#define RST_REVISION_ID_ADDRESS                                      0x18060090
+#define is_drqfn()  (!(ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0x1000))
+
+
+#define RST_BOOTSTRAP_DDR_WIDTH_GET(x)                               0  //0: DDR WIDTH 16, Dragonfly only support 16bit
+
+#if 1 //This define is not exist in 956x, keep it just for pci common code. Need to modify
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MSB                          6
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_LSB                          6
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MASK                         0x00000040
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_GET(x)                       (((x) & RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MASK) >> RST_BOOTSTRAP_PCIE_RC_EP_SELECT_LSB)
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_SET(x)                       (((x) << RST_BOOTSTRAP_PCIE_RC_EP_SELECT_LSB) & RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MASK)
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_RESET                        0x0 // 0
+#endif
+
+#define RST_BOOTSTRAP_RES0_MSB                                       15
+#define RST_BOOTSTRAP_RES0_LSB                                       13
+#define RST_BOOTSTRAP_RES0_MASK                                      0x0000e000
+#define RST_BOOTSTRAP_RES0_GET(x)                                    (((x) & RST_BOOTSTRAP_RES0_MASK) >> RST_BOOTSTRAP_RES0_LSB)
+#define RST_BOOTSTRAP_RES0_SET(x)                                    (((x) << RST_BOOTSTRAP_RES0_LSB) & RST_BOOTSTRAP_RES0_MASK)
+#define RST_BOOTSTRAP_RES0_RESET                                     0x0 // 0
+#define RST_BOOTSTRAP_SW_OPTION2_MSB                                 12
+#define RST_BOOTSTRAP_SW_OPTION2_LSB                                 12
+#define RST_BOOTSTRAP_SW_OPTION2_MASK                                0x00001000
+#define RST_BOOTSTRAP_SW_OPTION2_GET(x)                              (((x) & RST_BOOTSTRAP_SW_OPTION2_MASK) >> RST_BOOTSTRAP_SW_OPTION2_LSB)
+#define RST_BOOTSTRAP_SW_OPTION2_SET(x)                              (((x) << RST_BOOTSTRAP_SW_OPTION2_LSB) & RST_BOOTSTRAP_SW_OPTION2_MASK)
+#define RST_BOOTSTRAP_SW_OPTION2_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_SW_OPTION1_MSB                                 11
+#define RST_BOOTSTRAP_SW_OPTION1_LSB                                 11
+#define RST_BOOTSTRAP_SW_OPTION1_MASK                                0x00000800
+#define RST_BOOTSTRAP_SW_OPTION1_GET(x)                              (((x) & RST_BOOTSTRAP_SW_OPTION1_MASK) >> RST_BOOTSTRAP_SW_OPTION1_LSB)
+#define RST_BOOTSTRAP_SW_OPTION1_SET(x)                              (((x) << RST_BOOTSTRAP_SW_OPTION1_LSB) & RST_BOOTSTRAP_SW_OPTION1_MASK)
+#define RST_BOOTSTRAP_SW_OPTION1_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_TESTROM_DISABLE_MSB                            10
+#define RST_BOOTSTRAP_TESTROM_DISABLE_LSB                            10
+#define RST_BOOTSTRAP_TESTROM_DISABLE_MASK                           0x00000400
+#define RST_BOOTSTRAP_TESTROM_DISABLE_GET(x)                         (((x) & RST_BOOTSTRAP_TESTROM_DISABLE_MASK) >> RST_BOOTSTRAP_TESTROM_DISABLE_LSB)
+#define RST_BOOTSTRAP_TESTROM_DISABLE_SET(x)                         (((x) << RST_BOOTSTRAP_TESTROM_DISABLE_LSB) & RST_BOOTSTRAP_TESTROM_DISABLE_MASK)
+#define RST_BOOTSTRAP_TESTROM_DISABLE_RESET                          0x1 // 1
+#define RST_BOOTSTRAP_SRIF_ENABLE_MSB                                6
+#define RST_BOOTSTRAP_SRIF_ENABLE_LSB                                6
+#define RST_BOOTSTRAP_SRIF_ENABLE_MASK                               0x00000040
+#define RST_BOOTSTRAP_SRIF_ENABLE_GET(x)                             (((x) & RST_BOOTSTRAP_SRIF_ENABLE_MASK) >> RST_BOOTSTRAP_SRIF_ENABLE_LSB)
+#define RST_BOOTSTRAP_SRIF_ENABLE_SET(x)                             (((x) << RST_BOOTSTRAP_SRIF_ENABLE_LSB) & RST_BOOTSTRAP_SRIF_ENABLE_MASK)
+#define RST_BOOTSTRAP_SRIF_ENABLE_RESET                              0x0 // 0
+#define RST_BOOTSTRAP_CHAIN2_DISABLE_MSB                             5
+#define RST_BOOTSTRAP_CHAIN2_DISABLE_LSB                             5
+#define RST_BOOTSTRAP_CHAIN2_DISABLE_MASK                            0x00000020
+#define RST_BOOTSTRAP_CHAIN2_DISABLE_GET(x)                          (((x) & RST_BOOTSTRAP_CHAIN2_DISABLE_MASK) >> RST_BOOTSTRAP_CHAIN2_DISABLE_LSB)
+#define RST_BOOTSTRAP_CHAIN2_DISABLE_SET(x)                          (((x) << RST_BOOTSTRAP_CHAIN2_DISABLE_LSB) & RST_BOOTSTRAP_CHAIN2_DISABLE_MASK)
+#define RST_BOOTSTRAP_CHAIN2_DISABLE_RESET                           0x0 // 0
+#define RST_BOOTSTRAP_PKG_SEL_MSB                                    4
+#define RST_BOOTSTRAP_PKG_SEL_LSB                                    4
+#define RST_BOOTSTRAP_PKG_SEL_MASK                                   0x00000010
+#define RST_BOOTSTRAP_PKG_SEL_GET(x)                                 (((x) & RST_BOOTSTRAP_PKG_SEL_MASK) >> RST_BOOTSTRAP_PKG_SEL_LSB)
+#define RST_BOOTSTRAP_PKG_SEL_SET(x)                                 (((x) << RST_BOOTSTRAP_PKG_SEL_LSB) & RST_BOOTSTRAP_PKG_SEL_MASK)
+#define RST_BOOTSTRAP_PKG_SEL_RESET                                  0x0 // 0
+#define RST_BOOTSTRAP_JTAG_MODE_MSB                                  3
+#define RST_BOOTSTRAP_JTAG_MODE_LSB                                  3
+#define RST_BOOTSTRAP_JTAG_MODE_MASK                                 0x00000008
+#define RST_BOOTSTRAP_JTAG_MODE_GET(x)                               (((x) & RST_BOOTSTRAP_JTAG_MODE_MASK) >> RST_BOOTSTRAP_JTAG_MODE_LSB)
+#define RST_BOOTSTRAP_JTAG_MODE_SET(x)                               (((x) << RST_BOOTSTRAP_JTAG_MODE_LSB) & RST_BOOTSTRAP_JTAG_MODE_MASK)
+#define RST_BOOTSTRAP_JTAG_MODE_RESET                                0x1 // 1
+#define RST_BOOTSTRAP_REF_CLK_MSB                                    2
+#define RST_BOOTSTRAP_REF_CLK_LSB                                    2
+#define RST_BOOTSTRAP_REF_CLK_MASK                                   0x00000004
+#define RST_BOOTSTRAP_REF_CLK_GET(x)                                 (((x) & RST_BOOTSTRAP_REF_CLK_MASK) >> RST_BOOTSTRAP_REF_CLK_LSB)
+#define RST_BOOTSTRAP_REF_CLK_SET(x)                                 (((x) << RST_BOOTSTRAP_REF_CLK_LSB) & RST_BOOTSTRAP_REF_CLK_MASK)
+#define RST_BOOTSTRAP_REF_CLK_RESET                                  0x0 // 0
+#define RST_BOOTSTRAP_E_SWITCH_EN_MSB                                1
+#define RST_BOOTSTRAP_E_SWITCH_EN_LSB                                1
+#define RST_BOOTSTRAP_E_SWITCH_EN_MASK                               0x00000002
+#define RST_BOOTSTRAP_E_SWITCH_EN_GET(x)                             (((x) & RST_BOOTSTRAP_E_SWITCH_EN_MASK) >> RST_BOOTSTRAP_E_SWITCH_EN_LSB)
+#define RST_BOOTSTRAP_E_SWITCH_EN_SET(x)                             (((x) << RST_BOOTSTRAP_E_SWITCH_EN_LSB) & RST_BOOTSTRAP_E_SWITCH_EN_MASK)
+#define RST_BOOTSTRAP_E_SWITCH_EN_RESET                              0x0 // 0
+#define RST_BOOTSTRAP_DDR_SELECT_MSB                                 0
+#define RST_BOOTSTRAP_DDR_SELECT_LSB                                 0
+#define RST_BOOTSTRAP_DDR_SELECT_MASK                                0x00000001
+#define RST_BOOTSTRAP_DDR_SELECT_GET(x)                              (((x) & RST_BOOTSTRAP_DDR_SELECT_MASK) >> RST_BOOTSTRAP_DDR_SELECT_LSB)
+#define RST_BOOTSTRAP_DDR_SELECT_SET(x)                              (((x) << RST_BOOTSTRAP_DDR_SELECT_LSB) & RST_BOOTSTRAP_DDR_SELECT_MASK)
+#define RST_BOOTSTRAP_DDR_SELECT_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_ADDRESS                                        0x180600b0
+
+#define GPIO_OE_ADDRESS                                              0x18040000
+#define GPIO_OUT_ADDRESS                                             0x18040008
+#define GPIO_SPARE_ADDRESS                                           0x18040028
+
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_MSB                         31
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_LSB                         24
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_MASK                        0xff000000
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_GET(x)                      (((x) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_MASK) >> GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_LSB)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_SET(x)                      (((x) << GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_LSB) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_MASK)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_MSB                         23
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_LSB                         16
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_MASK                        0x00ff0000
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_GET(x)                      (((x) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_MASK) >> GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_LSB)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_SET(x)                      (((x) << GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_LSB) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_MASK)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_MSB                         15
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_LSB                         8
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_GET(x)                      (((x) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_MASK) >> GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_LSB)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_SET(x)                      (((x) << GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_LSB) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_MASK)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_MSB                         7
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_LSB                         0
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_GET(x)                      (((x) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_MASK) >> GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_LSB)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_SET(x)                      (((x) << GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_LSB) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_MASK)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION0_ADDRESS                                   0x1804002c
+
+
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MSB                         31
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB                         24
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK                        0xff000000
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_RESET                       0xb // 11
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MSB                         23
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB                         16
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK                        0x00ff0000
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_RESET                       0xa // 10
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MSB                         15
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB                         8
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_RESET                       0x9 // 9
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MSB                         7
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB                         0
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_RESET                       0x14 // 20
+#define GPIO_OUT_FUNCTION1_ADDRESS                                   0x18040030
+
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MSB                        31
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB                        24
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_GET(x)                     (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_SET(x)                     (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MSB                        23
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB                        16
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK                       0x00ff0000
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_GET(x)                     (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_SET(x)                     (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MSB                         15
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB                         8
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_GET(x)                      (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_SET(x)                      (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MSB                         7
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB                         0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_GET(x)                      (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_SET(x)                      (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION2_ADDRESS                                   0x18040034
+
+#define GPIO_IN_ENABLE0_UART_SIN_MSB                                 15
+#define GPIO_IN_ENABLE0_UART_SIN_LSB                                 8
+#define GPIO_IN_ENABLE0_UART_SIN_MASK                                0x0000ff00
+#define GPIO_IN_ENABLE0_UART_SIN_GET(x)                              (((x) & GPIO_IN_ENABLE0_UART_SIN_MASK) >> GPIO_IN_ENABLE0_UART_SIN_LSB)
+#define GPIO_IN_ENABLE0_UART_SIN_SET(x)                              (((x) << GPIO_IN_ENABLE0_UART_SIN_LSB) & GPIO_IN_ENABLE0_UART_SIN_MASK)
+#define GPIO_IN_ENABLE0_UART_SIN_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE0_ADDRESS                                      0x18040044
+
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_MSB                              23
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_LSB                              16
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_MASK                             0x00ff0000
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_GET(x)                           (((x) & GPIO_IN_ENABLE3_MII_GE1_MDI_MASK) >> GPIO_IN_ENABLE3_MII_GE1_MDI_LSB)
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_SET(x)                           (((x) << GPIO_IN_ENABLE3_MII_GE1_MDI_LSB) & GPIO_IN_ENABLE3_MII_GE1_MDI_MASK)
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_RESET                            0x80 // 128
+#define GPIO_IN_ENABLE3_ADDRESS                                      0x18040050
+
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MSB                        31
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB                        24
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MSB                        23
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB                        16
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK                       0x00ff0000
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MSB                        15
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB                        8
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK                       0x0000ff00
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MSB                        7
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB                        0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK                       0x000000ff
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ADDRESS                   0x18040038
+
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MSB                        31
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_LSB                        24
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MSB                        23
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_LSB                        16
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MASK                       0x00ff0000
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MSB                        15
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB                        8
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK                       0x0000ff00
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MSB                        7
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB                        0
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK                       0x000000ff
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION4_ADDRESS                                   0x1804003c
+
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_22_MSB                        23
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_22_LSB                        16
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_22_MASK                       0x00ff0000
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_22_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_LSB)
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_22_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MASK)
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_22_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_21_MSB                        15
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_21_LSB                        8
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_21_MASK                       0x0000ff00
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_21_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB)
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_21_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK)
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_21_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_20_MSB                        7
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_20_LSB                        0
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_20_MASK                       0x000000ff
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_20_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB)
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_20_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK)
+#define GPIO_OUT_FUNCTION5_ENABLE_GPIO_20_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION5_ADDRESS                                   0x18040040
+
+
+#define GPIO_FUNCTION_DISABLE_XPA_XLNA_MSB                           15
+#define GPIO_FUNCTION_DISABLE_XPA_XLNA_LSB                           15
+#define GPIO_FUNCTION_DISABLE_XPA_XLNA_MASK                          0x00008000
+#define GPIO_FUNCTION_DISABLE_XPA_XLNA_GET(x)                        (((x) & GPIO_FUNCTION_DISABLE_XPA_XLNA_MASK) >> GPIO_FUNCTION_DISABLE_XPA_XLNA_LSB)
+#define GPIO_FUNCTION_DISABLE_XPA_XLNA_SET(x)                        (((x) << GPIO_FUNCTION_DISABLE_XPA_XLNA_LSB) & GPIO_FUNCTION_DISABLE_XPA_XLNA_MASK)
+#define GPIO_FUNCTION_DISABLE_XPA_XLNA_RESET                         0x0 // 0
+#define GPIO_FUNCTION_DISABLE_SWCOM_MSB                              14
+#define GPIO_FUNCTION_DISABLE_SWCOM_LSB                              14
+#define GPIO_FUNCTION_DISABLE_SWCOM_MASK                             0x00004000
+#define GPIO_FUNCTION_DISABLE_SWCOM_GET(x)                           (((x) & GPIO_FUNCTION_DISABLE_SWCOM_MASK) >> GPIO_FUNCTION_DISABLE_SWCOM_LSB)
+#define GPIO_FUNCTION_DISABLE_SWCOM_SET(x)                           (((x) << GPIO_FUNCTION_DISABLE_SWCOM_LSB) & GPIO_FUNCTION_DISABLE_SWCOM_MASK)
+#define GPIO_FUNCTION_DISABLE_SWCOM_RESET                            0x0 // 0
+#define GPIO_FUNCTION_EXT_MDIO_SEL_MSB                               13
+#define GPIO_FUNCTION_EXT_MDIO_SEL_LSB                               13
+#define GPIO_FUNCTION_EXT_MDIO_SEL_MASK                              0x00002000
+#define GPIO_FUNCTION_EXT_MDIO_SEL_GET(x)                            (((x) & GPIO_FUNCTION_EXT_MDIO_SEL_MASK) >> GPIO_FUNCTION_EXT_MDIO_SEL_LSB)
+#define GPIO_FUNCTION_EXT_MDIO_SEL_SET(x)                            (((x) << GPIO_FUNCTION_EXT_MDIO_SEL_LSB) & GPIO_FUNCTION_EXT_MDIO_SEL_MASK)
+#define GPIO_FUNCTION_EXT_MDIO_SEL_RESET                             0x0 // 0   
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_MSB                            11
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_LSB                            11
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_MASK                           0x00000800
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS9_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS9_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS9_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS9_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_MSB                            10
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_LSB                            10
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_MASK                           0x00000400
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS8_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS8_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS8_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS8_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_MSB                            9
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_LSB                            9
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_MASK                           0x00000200
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS7_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS7_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS7_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS7_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_MSB                            8
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB                            8
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK                           0x00000100
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_MSB                            7
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB                            7
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK                           0x00000080
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_RESET                          0x1 // 1
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_MSB                            6
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB                            6
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK                           0x00000040
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_MSB                            5
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB                            5
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK                           0x00000020
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_MSB                            4
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB                            4
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK                           0x00000010
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_MSB                            3
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB                            3
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK                           0x00000008
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_MSB                            2
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB                            2
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK                           0x00000004
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_DISABLE_JTAG_MSB                               1
+#define GPIO_FUNCTION_DISABLE_JTAG_LSB                               1
+#define GPIO_FUNCTION_DISABLE_JTAG_MASK                              0x00000002
+#define GPIO_FUNCTION_DISABLE_JTAG_GET(x)                            (((x) & GPIO_FUNCTION_DISABLE_JTAG_MASK) >> GPIO_FUNCTION_DISABLE_JTAG_LSB)
+#define GPIO_FUNCTION_DISABLE_JTAG_SET(x)                            (((x) << GPIO_FUNCTION_DISABLE_JTAG_LSB) & GPIO_FUNCTION_DISABLE_JTAG_MASK)
+#define GPIO_FUNCTION_DISABLE_JTAG_RESET                             0x0 // 0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_MSB                           0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB                           0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK                          0x00000001
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_GET(x)                        (((x) & GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK) >> GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB)
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_SET(x)                        (((x) << GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB) & GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK)
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_RESET                         0x0 // 0
+#define GPIO_FUNCTION_ADDRESS                                        0x1804006c
+
+#define PCIE_RESET_EP_RESET_L_MSB                                    2
+#define PCIE_RESET_EP_RESET_L_LSB                                    2
+#define PCIE_RESET_EP_RESET_L_MASK                                   0x00000004
+#define PCIE_RESET_EP_RESET_L_GET(x)                                 (((x) & PCIE_RESET_EP_RESET_L_MASK) >> PCIE_RESET_EP_RESET_L_LSB)
+#define PCIE_RESET_EP_RESET_L_SET(x)                                 (((x) << PCIE_RESET_EP_RESET_L_LSB) & PCIE_RESET_EP_RESET_L_MASK)
+#define PCIE_RESET_EP_RESET_L_RESET                                  0x0 // 0
+#define PCIE_RESET_LINK_REQ_RESET_MSB                                1
+#define PCIE_RESET_LINK_REQ_RESET_LSB                                1
+#define PCIE_RESET_LINK_REQ_RESET_MASK                               0x00000002
+#define PCIE_RESET_LINK_REQ_RESET_GET(x)                             (((x) & PCIE_RESET_LINK_REQ_RESET_MASK) >> PCIE_RESET_LINK_REQ_RESET_LSB)
+#define PCIE_RESET_LINK_REQ_RESET_SET(x)                             (((x) << PCIE_RESET_LINK_REQ_RESET_LSB) & PCIE_RESET_LINK_REQ_RESET_MASK)
+#define PCIE_RESET_LINK_REQ_RESET_RESET                              0x0 // 0
+#define PCIE_RESET_LINK_UP_MSB                                       0
+#define PCIE_RESET_LINK_UP_LSB                                       0
+#define PCIE_RESET_LINK_UP_MASK                                      0x00000001
+#define PCIE_RESET_LINK_UP_GET(x)                                    (((x) & PCIE_RESET_LINK_UP_MASK) >> PCIE_RESET_LINK_UP_LSB)
+#define PCIE_RESET_LINK_UP_SET(x)                                    (((x) << PCIE_RESET_LINK_UP_LSB) & PCIE_RESET_LINK_UP_MASK)
+#define PCIE_RESET_LINK_UP_RESET                                     0x0 // 0
+#define PCIE_RESET_ADDRESS                                           0x18280018
+
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_MSB                          2
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_LSB                          2
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_MASK                         0x00000004
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_GET(x)                       (((x) & ETH_SGMII_SERDES_EN_LOCK_DETECT_MASK) >> ETH_SGMII_SERDES_EN_LOCK_DETECT_LSB)
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_SET(x)                       (((x) << ETH_SGMII_SERDES_EN_LOCK_DETECT_LSB) & ETH_SGMII_SERDES_EN_LOCK_DETECT_MASK)
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_RESET                        0x0 // 0
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_MSB                          1
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_LSB                          1
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_MASK                         0x00000002
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_GET(x)                       (((x) & ETH_SGMII_SERDES_PLL_REFCLK_SEL_MASK) >> ETH_SGMII_SERDES_PLL_REFCLK_SEL_LSB)
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_SET(x)                       (((x) << ETH_SGMII_SERDES_PLL_REFCLK_SEL_LSB) & ETH_SGMII_SERDES_PLL_REFCLK_SEL_MASK)
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_RESET                        0x0 // 0
+#define ETH_SGMII_SERDES_EN_PLL_MSB                                  0
+#define ETH_SGMII_SERDES_EN_PLL_LSB                                  0
+#define ETH_SGMII_SERDES_EN_PLL_MASK                                 0x00000001
+#define ETH_SGMII_SERDES_EN_PLL_GET(x)                               (((x) & ETH_SGMII_SERDES_EN_PLL_MASK) >> ETH_SGMII_SERDES_EN_PLL_LSB)
+#define ETH_SGMII_SERDES_EN_PLL_SET(x)                               (((x) << ETH_SGMII_SERDES_EN_PLL_LSB) & ETH_SGMII_SERDES_EN_PLL_MASK)
+#define ETH_SGMII_SERDES_EN_PLL_RESET                                0x1 // 1
+#define ETH_SGMII_SERDES_ADDRESS                                     0x1805004c
+
+#define ETH_CFG_ETH_SPARE_MSB                                        31
+#define ETH_CFG_ETH_SPARE_LSB                                        22
+#define ETH_CFG_ETH_SPARE_MASK                                       0xffc00000
+#define ETH_CFG_ETH_SPARE_GET(x)                                     (((x) & ETH_CFG_ETH_SPARE_MASK) >> ETH_CFG_ETH_SPARE_LSB)
+#define ETH_CFG_ETH_SPARE_SET(x)                                     (((x) << ETH_CFG_ETH_SPARE_LSB) & ETH_CFG_ETH_SPARE_MASK)
+#define ETH_CFG_ETH_SPARE_RESET                                      0x0 // 0
+#define ETH_CFG_ETH_TXEN_DELAY_MSB                                   21
+#define ETH_CFG_ETH_TXEN_DELAY_LSB                                   20
+#define ETH_CFG_ETH_TXEN_DELAY_MASK                                  0x00300000
+#define ETH_CFG_ETH_TXEN_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_TXEN_DELAY_MASK) >> ETH_CFG_ETH_TXEN_DELAY_LSB)
+#define ETH_CFG_ETH_TXEN_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_TXEN_DELAY_LSB) & ETH_CFG_ETH_TXEN_DELAY_MASK)
+#define ETH_CFG_ETH_TXEN_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_TXD_DELAY_MSB                                    19
+#define ETH_CFG_ETH_TXD_DELAY_LSB                                    18
+#define ETH_CFG_ETH_TXD_DELAY_MASK                                   0x000c0000
+#define ETH_CFG_ETH_TXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_TXD_DELAY_MASK) >> ETH_CFG_ETH_TXD_DELAY_LSB)
+#define ETH_CFG_ETH_TXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_TXD_DELAY_LSB) & ETH_CFG_ETH_TXD_DELAY_MASK)
+#define ETH_CFG_ETH_TXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_ETH_RXDV_DELAY_MSB                                   17
+#define ETH_CFG_ETH_RXDV_DELAY_LSB                                   16
+#define ETH_CFG_ETH_RXDV_DELAY_MASK                                  0x00030000
+#define ETH_CFG_ETH_RXDV_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_RXDV_DELAY_MASK) >> ETH_CFG_ETH_RXDV_DELAY_LSB)
+#define ETH_CFG_ETH_RXDV_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_RXDV_DELAY_LSB) & ETH_CFG_ETH_RXDV_DELAY_MASK)
+#define ETH_CFG_ETH_RXDV_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_RXD_DELAY_MSB                                    15
+#define ETH_CFG_ETH_RXD_DELAY_LSB                                    14
+#define ETH_CFG_ETH_RXD_DELAY_MASK                                   0x0000c000
+#define ETH_CFG_ETH_RXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_RXD_DELAY_MASK) >> ETH_CFG_ETH_RXD_DELAY_LSB)
+#define ETH_CFG_ETH_RXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_RXD_DELAY_LSB) & ETH_CFG_ETH_RXD_DELAY_MASK)
+#define ETH_CFG_ETH_RXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_SW_ACC_MSB_FIRST_MSB                                 13
+#define ETH_CFG_SW_ACC_MSB_FIRST_LSB                                 13
+#define ETH_CFG_SW_ACC_MSB_FIRST_MASK                                0x00002000
+#define ETH_CFG_SW_ACC_MSB_FIRST_GET(x)                              (((x) & ETH_CFG_SW_ACC_MSB_FIRST_MASK) >> ETH_CFG_SW_ACC_MSB_FIRST_LSB)
+#define ETH_CFG_SW_ACC_MSB_FIRST_SET(x)                              (((x) << ETH_CFG_SW_ACC_MSB_FIRST_LSB) & ETH_CFG_SW_ACC_MSB_FIRST_MASK)
+#define ETH_CFG_SW_ACC_MSB_FIRST_RESET                               0x1 // 1
+#define ETH_CFG_RMII_GE0_MASTER_MSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_LSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_MASK                                 0x00001000
+#define ETH_CFG_RMII_GE0_MASTER_GET(x)                               (((x) & ETH_CFG_RMII_GE0_MASTER_MASK) >> ETH_CFG_RMII_GE0_MASTER_LSB)
+#define ETH_CFG_RMII_GE0_MASTER_SET(x)                               (((x) << ETH_CFG_RMII_GE0_MASTER_LSB) & ETH_CFG_RMII_GE0_MASTER_MASK)
+#define ETH_CFG_RMII_GE0_MASTER_RESET                                0x1 // 1
+#define ETH_CFG_MII_CNTL_SPEED_MSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_LSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_MASK                                  0x00000800
+#define ETH_CFG_MII_CNTL_SPEED_GET(x)                                (((x) & ETH_CFG_MII_CNTL_SPEED_MASK) >> ETH_CFG_MII_CNTL_SPEED_LSB)
+#define ETH_CFG_MII_CNTL_SPEED_SET(x)                                (((x) << ETH_CFG_MII_CNTL_SPEED_LSB) & ETH_CFG_MII_CNTL_SPEED_MASK)
+#define ETH_CFG_MII_CNTL_SPEED_RESET                                 0x0 // 0
+#define ETH_CFG_SW_APB_ACCESS_MSB                                    10
+#define ETH_CFG_SW_APB_ACCESS_LSB                                    10
+#define ETH_CFG_SW_APB_ACCESS_MASK                                   0x00000400
+#define ETH_CFG_SW_APB_ACCESS_GET(x)                                 (((x) & ETH_CFG_SW_APB_ACCESS_MASK) >> ETH_CFG_SW_APB_ACCESS_LSB)
+#define ETH_CFG_SW_APB_ACCESS_SET(x)                                 (((x) << ETH_CFG_SW_APB_ACCESS_LSB) & ETH_CFG_SW_APB_ACCESS_MASK)
+#define ETH_CFG_SW_APB_ACCESS_RESET                                  0x0 // 0
+#define ETH_CFG_SW_PHY_ADDR_SWAP_MSB                                 9
+#define ETH_CFG_SW_PHY_ADDR_SWAP_LSB                                 9
+#define ETH_CFG_SW_PHY_ADDR_SWAP_MASK                                0x00000200
+#define ETH_CFG_SW_PHY_ADDR_SWAP_GET(x)                              (((x) & ETH_CFG_SW_PHY_ADDR_SWAP_MASK) >> ETH_CFG_SW_PHY_ADDR_SWAP_LSB)
+#define ETH_CFG_SW_PHY_ADDR_SWAP_SET(x)                              (((x) << ETH_CFG_SW_PHY_ADDR_SWAP_LSB) & ETH_CFG_SW_PHY_ADDR_SWAP_MASK)
+#define ETH_CFG_SW_PHY_ADDR_SWAP_RESET                               0x0 // 0
+#define ETH_CFG_SW_PHY_SWAP_MSB                                      8
+#define ETH_CFG_SW_PHY_SWAP_LSB                                      8
+#define ETH_CFG_SW_PHY_SWAP_MASK                                     0x00000100
+#define ETH_CFG_SW_PHY_SWAP_GET(x)                                   (((x) & ETH_CFG_SW_PHY_SWAP_MASK) >> ETH_CFG_SW_PHY_SWAP_LSB)
+#define ETH_CFG_SW_PHY_SWAP_SET(x)                                   (((x) << ETH_CFG_SW_PHY_SWAP_LSB) & ETH_CFG_SW_PHY_SWAP_MASK)
+#define ETH_CFG_SW_PHY_SWAP_RESET                                    0x0 // 0
+#define ETH_CFG_SW_ONLY_MODE_MSB                                     7
+#define ETH_CFG_SW_ONLY_MODE_LSB                                     7
+#define ETH_CFG_SW_ONLY_MODE_MASK                                    0x00000080
+#define ETH_CFG_SW_ONLY_MODE_GET(x)                                  (((x) & ETH_CFG_SW_ONLY_MODE_MASK) >> ETH_CFG_SW_ONLY_MODE_LSB)
+#define ETH_CFG_SW_ONLY_MODE_SET(x)                                  (((x) << ETH_CFG_SW_ONLY_MODE_LSB) & ETH_CFG_SW_ONLY_MODE_MASK)
+#define ETH_CFG_SW_ONLY_MODE_RESET                                   0x0 // 0
+#define ETH_CFG_GE0_SGMII_MSB                                        6
+#define ETH_CFG_GE0_SGMII_LSB                                        6
+#define ETH_CFG_GE0_SGMII_MASK                                       0x00000040
+#define ETH_CFG_GE0_SGMII_GET(x)                                     (((x) & ETH_CFG_GE0_SGMII_MASK) >> ETH_CFG_GE0_SGMII_LSB)
+#define ETH_CFG_GE0_SGMII_SET(x)                                     (((x) << ETH_CFG_GE0_SGMII_LSB) & ETH_CFG_GE0_SGMII_MASK)
+#define ETH_CFG_GE0_SGMII_RESET                                      0x0 // 0
+#define ETH_CFG_GE0_ERR_EN_MSB                                       5
+#define ETH_CFG_GE0_ERR_EN_LSB                                       5
+#define ETH_CFG_GE0_ERR_EN_MASK                                      0x00000020
+#define ETH_CFG_GE0_ERR_EN_GET(x)                                    (((x) & ETH_CFG_GE0_ERR_EN_MASK) >> ETH_CFG_GE0_ERR_EN_LSB)
+#define ETH_CFG_GE0_ERR_EN_SET(x)                                    (((x) << ETH_CFG_GE0_ERR_EN_LSB) & ETH_CFG_GE0_ERR_EN_MASK)
+#define ETH_CFG_GE0_ERR_EN_RESET                                     0x0 // 0
+#define ETH_CFG_MII_GE0_SLAVE_MSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_LSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_MASK                                   0x00000010
+#define ETH_CFG_MII_GE0_SLAVE_GET(x)                                 (((x) & ETH_CFG_MII_GE0_SLAVE_MASK) >> ETH_CFG_MII_GE0_SLAVE_LSB)
+#define ETH_CFG_MII_GE0_SLAVE_SET(x)                                 (((x) << ETH_CFG_MII_GE0_SLAVE_LSB) & ETH_CFG_MII_GE0_SLAVE_MASK)
+#define ETH_CFG_MII_GE0_SLAVE_RESET                                  0x0 // 0
+#define ETH_CFG_MII_GE0_MASTER_MSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_LSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_MASK                                  0x00000008
+#define ETH_CFG_MII_GE0_MASTER_GET(x)                                (((x) & ETH_CFG_MII_GE0_MASTER_MASK) >> ETH_CFG_MII_GE0_MASTER_LSB)
+#define ETH_CFG_MII_GE0_MASTER_SET(x)                                (((x) << ETH_CFG_MII_GE0_MASTER_LSB) & ETH_CFG_MII_GE0_MASTER_MASK)
+#define ETH_CFG_MII_GE0_MASTER_RESET                                 0x0 // 0
+#define ETH_CFG_GMII_GE0_MSB                                         2
+#define ETH_CFG_GMII_GE0_LSB                                         2
+#define ETH_CFG_GMII_GE0_MASK                                        0x00000004
+#define ETH_CFG_GMII_GE0_GET(x)                                      (((x) & ETH_CFG_GMII_GE0_MASK) >> ETH_CFG_GMII_GE0_LSB)
+#define ETH_CFG_GMII_GE0_SET(x)                                      (((x) << ETH_CFG_GMII_GE0_LSB) & ETH_CFG_GMII_GE0_MASK)
+#define ETH_CFG_GMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_MII_GE0_MSB                                          1
+#define ETH_CFG_MII_GE0_LSB                                          1
+#define ETH_CFG_MII_GE0_MASK                                         0x00000002
+#define ETH_CFG_MII_GE0_GET(x)                                       (((x) & ETH_CFG_MII_GE0_MASK) >> ETH_CFG_MII_GE0_LSB)
+#define ETH_CFG_MII_GE0_SET(x)                                       (((x) << ETH_CFG_MII_GE0_LSB) & ETH_CFG_MII_GE0_MASK)
+#define ETH_CFG_MII_GE0_RESET                                        0x0 // 0
+#define ETH_CFG_RGMII_GE0_MSB                                        0
+#define ETH_CFG_RGMII_GE0_LSB                                        0
+#define ETH_CFG_RGMII_GE0_MASK                                       0x00000001
+#define ETH_CFG_RGMII_GE0_GET(x)                                     (((x) & ETH_CFG_RGMII_GE0_MASK) >> ETH_CFG_RGMII_GE0_LSB)
+#define ETH_CFG_RGMII_GE0_SET(x)                                     (((x) << ETH_CFG_RGMII_GE0_LSB) & ETH_CFG_RGMII_GE0_MASK)
+#define ETH_CFG_RGMII_GE0_RESET                                      0x0 // 0
+#define ETH_CFG_ADDRESS                                              0x18070000
+
+#define SGMII_SERDES_VCO_REG_MSB                                     30
+#define SGMII_SERDES_VCO_REG_LSB                                     27
+#define SGMII_SERDES_VCO_REG_MASK                                    0x78000000
+#define SGMII_SERDES_VCO_REG_GET(x)                                  (((x) & SGMII_SERDES_VCO_REG_MASK) >> SGMII_SERDES_VCO_REG_LSB)
+#define SGMII_SERDES_VCO_REG_SET(x)                                  (((x) << SGMII_SERDES_VCO_REG_LSB) & SGMII_SERDES_VCO_REG_MASK)
+#define SGMII_SERDES_VCO_REG_RESET                                   0x3 // 3
+#define SGMII_SERDES_RES_CALIBRATION_MSB                             26
+#define SGMII_SERDES_RES_CALIBRATION_LSB                             23
+#define SGMII_SERDES_RES_CALIBRATION_MASK                            0x07800000
+#define SGMII_SERDES_RES_CALIBRATION_GET(x)                          (((x) & SGMII_SERDES_RES_CALIBRATION_MASK) >> SGMII_SERDES_RES_CALIBRATION_LSB)
+#define SGMII_SERDES_RES_CALIBRATION_SET(x)                          (((x) << SGMII_SERDES_RES_CALIBRATION_LSB) & SGMII_SERDES_RES_CALIBRATION_MASK)
+#define SGMII_SERDES_RES_CALIBRATION_RESET                           0x0 // 0
+#define SGMII_SERDES_FIBER_MODE_MSB                                  21
+#define SGMII_SERDES_FIBER_MODE_LSB                                  20
+#define SGMII_SERDES_FIBER_MODE_MASK                                 0x00300000
+#define SGMII_SERDES_FIBER_MODE_GET(x)                               (((x) & SGMII_SERDES_FIBER_MODE_MASK) >> SGMII_SERDES_FIBER_MODE_LSB)
+#define SGMII_SERDES_FIBER_MODE_SET(x)                               (((x) << SGMII_SERDES_FIBER_MODE_LSB) & SGMII_SERDES_FIBER_MODE_MASK)
+#define SGMII_SERDES_FIBER_MODE_RESET                                0x0 // 0
+#define SGMII_SERDES_THRESHOLD_CTRL_MSB                              19
+#define SGMII_SERDES_THRESHOLD_CTRL_LSB                              18
+#define SGMII_SERDES_THRESHOLD_CTRL_MASK                             0x000c0000
+#define SGMII_SERDES_THRESHOLD_CTRL_GET(x)                           (((x) & SGMII_SERDES_THRESHOLD_CTRL_MASK) >> SGMII_SERDES_THRESHOLD_CTRL_LSB)
+#define SGMII_SERDES_THRESHOLD_CTRL_SET(x)                           (((x) << SGMII_SERDES_THRESHOLD_CTRL_LSB) & SGMII_SERDES_THRESHOLD_CTRL_MASK)
+#define SGMII_SERDES_THRESHOLD_CTRL_RESET                            0x0 // 0
+#define SGMII_SERDES_FIBER_SDO_MSB                                   17
+#define SGMII_SERDES_FIBER_SDO_LSB                                   17
+#define SGMII_SERDES_FIBER_SDO_MASK                                  0x00020000
+#define SGMII_SERDES_FIBER_SDO_GET(x)                                (((x) & SGMII_SERDES_FIBER_SDO_MASK) >> SGMII_SERDES_FIBER_SDO_LSB)
+#define SGMII_SERDES_FIBER_SDO_SET(x)                                (((x) << SGMII_SERDES_FIBER_SDO_LSB) & SGMII_SERDES_FIBER_SDO_MASK)
+#define SGMII_SERDES_FIBER_SDO_RESET                                 0x0 // 0
+#define SGMII_SERDES_EN_SIGNAL_DETECT_MSB                            16
+#define SGMII_SERDES_EN_SIGNAL_DETECT_LSB                            16
+#define SGMII_SERDES_EN_SIGNAL_DETECT_MASK                           0x00010000
+#define SGMII_SERDES_EN_SIGNAL_DETECT_GET(x)                         (((x) & SGMII_SERDES_EN_SIGNAL_DETECT_MASK) >> SGMII_SERDES_EN_SIGNAL_DETECT_LSB)
+#define SGMII_SERDES_EN_SIGNAL_DETECT_SET(x)                         (((x) << SGMII_SERDES_EN_SIGNAL_DETECT_LSB) & SGMII_SERDES_EN_SIGNAL_DETECT_MASK)
+#define SGMII_SERDES_EN_SIGNAL_DETECT_RESET                          0x1 // 1
+#define SGMII_SERDES_LOCK_DETECT_STATUS_MSB                          15
+#define SGMII_SERDES_LOCK_DETECT_STATUS_LSB                          15
+#define SGMII_SERDES_LOCK_DETECT_STATUS_MASK                         0x00008000
+#define SGMII_SERDES_LOCK_DETECT_STATUS_GET(x)                       (((x) & SGMII_SERDES_LOCK_DETECT_STATUS_MASK) >> SGMII_SERDES_LOCK_DETECT_STATUS_LSB)
+#define SGMII_SERDES_LOCK_DETECT_STATUS_SET(x)                       (((x) << SGMII_SERDES_LOCK_DETECT_STATUS_LSB) & SGMII_SERDES_LOCK_DETECT_STATUS_MASK)
+#define SGMII_SERDES_LOCK_DETECT_STATUS_RESET                        0x0 // 0
+#define SGMII_SERDES_SPARE0_MSB                                      14
+#define SGMII_SERDES_SPARE0_LSB                                      11
+#define SGMII_SERDES_SPARE0_MASK                                     0x00007800
+#define SGMII_SERDES_SPARE0_GET(x)                                   (((x) & SGMII_SERDES_SPARE0_MASK) >> SGMII_SERDES_SPARE0_LSB)
+#define SGMII_SERDES_SPARE0_SET(x)                                   (((x) << SGMII_SERDES_SPARE0_LSB) & SGMII_SERDES_SPARE0_MASK)
+#define SGMII_SERDES_SPARE0_RESET                                    0x0 // 0
+#define SGMII_SERDES_VCO_SLOW_MSB                                    10
+#define SGMII_SERDES_VCO_SLOW_LSB                                    10
+#define SGMII_SERDES_VCO_SLOW_MASK                                   0x00000400
+#define SGMII_SERDES_VCO_SLOW_GET(x)                                 (((x) & SGMII_SERDES_VCO_SLOW_MASK) >> SGMII_SERDES_VCO_SLOW_LSB)
+#define SGMII_SERDES_VCO_SLOW_SET(x)                                 (((x) << SGMII_SERDES_VCO_SLOW_LSB) & SGMII_SERDES_VCO_SLOW_MASK)
+#define SGMII_SERDES_VCO_SLOW_RESET                                  0x0 // 0
+#define SGMII_SERDES_VCO_FAST_MSB                                    9
+#define SGMII_SERDES_VCO_FAST_LSB                                    9
+#define SGMII_SERDES_VCO_FAST_MASK                                   0x00000200
+#define SGMII_SERDES_VCO_FAST_GET(x)                                 (((x) & SGMII_SERDES_VCO_FAST_MASK) >> SGMII_SERDES_VCO_FAST_LSB)
+#define SGMII_SERDES_VCO_FAST_SET(x)                                 (((x) << SGMII_SERDES_VCO_FAST_LSB) & SGMII_SERDES_VCO_FAST_MASK)
+#define SGMII_SERDES_VCO_FAST_RESET                                  0x0 // 0
+#define SGMII_SERDES_PLL_BW_MSB                                      8
+#define SGMII_SERDES_PLL_BW_LSB                                      8
+#define SGMII_SERDES_PLL_BW_MASK                                     0x00000100
+#define SGMII_SERDES_PLL_BW_GET(x)                                   (((x) & SGMII_SERDES_PLL_BW_MASK) >> SGMII_SERDES_PLL_BW_LSB)
+#define SGMII_SERDES_PLL_BW_SET(x)                                   (((x) << SGMII_SERDES_PLL_BW_LSB) & SGMII_SERDES_PLL_BW_MASK)
+#define SGMII_SERDES_PLL_BW_RESET                                    0x1 // 1
+#define SGMII_SERDES_TX_IMPEDANCE_MSB                                7
+#define SGMII_SERDES_TX_IMPEDANCE_LSB                                7
+#define SGMII_SERDES_TX_IMPEDANCE_MASK                               0x00000080
+#define SGMII_SERDES_TX_IMPEDANCE_GET(x)                             (((x) & SGMII_SERDES_TX_IMPEDANCE_MASK) >> SGMII_SERDES_TX_IMPEDANCE_LSB)
+#define SGMII_SERDES_TX_IMPEDANCE_SET(x)                             (((x) << SGMII_SERDES_TX_IMPEDANCE_LSB) & SGMII_SERDES_TX_IMPEDANCE_MASK)
+#define SGMII_SERDES_TX_IMPEDANCE_RESET                              0x0 // 0
+#define SGMII_SERDES_TX_DR_CTRL_MSB                                  6
+#define SGMII_SERDES_TX_DR_CTRL_LSB                                  4
+#define SGMII_SERDES_TX_DR_CTRL_MASK                                 0x00000070
+#define SGMII_SERDES_TX_DR_CTRL_GET(x)                               (((x) & SGMII_SERDES_TX_DR_CTRL_MASK) >> SGMII_SERDES_TX_DR_CTRL_LSB)
+#define SGMII_SERDES_TX_DR_CTRL_SET(x)                               (((x) << SGMII_SERDES_TX_DR_CTRL_LSB) & SGMII_SERDES_TX_DR_CTRL_MASK)
+#define SGMII_SERDES_TX_DR_CTRL_RESET                                0x1 // 1
+#define SGMII_SERDES_HALF_TX_MSB                                     3
+#define SGMII_SERDES_HALF_TX_LSB                                     3
+#define SGMII_SERDES_HALF_TX_MASK                                    0x00000008
+#define SGMII_SERDES_HALF_TX_GET(x)                                  (((x) & SGMII_SERDES_HALF_TX_MASK) >> SGMII_SERDES_HALF_TX_LSB)
+#define SGMII_SERDES_HALF_TX_SET(x)                                  (((x) << SGMII_SERDES_HALF_TX_LSB) & SGMII_SERDES_HALF_TX_MASK)
+#define SGMII_SERDES_HALF_TX_RESET                                   0x0 // 0
+#define SGMII_SERDES_CDR_BW_MSB                                      2
+#define SGMII_SERDES_CDR_BW_LSB                                      1
+#define SGMII_SERDES_CDR_BW_MASK                                     0x00000006
+#define SGMII_SERDES_CDR_BW_GET(x)                                   (((x) & SGMII_SERDES_CDR_BW_MASK) >> SGMII_SERDES_CDR_BW_LSB)
+#define SGMII_SERDES_CDR_BW_SET(x)                                   (((x) << SGMII_SERDES_CDR_BW_LSB) & SGMII_SERDES_CDR_BW_MASK)
+#define SGMII_SERDES_CDR_BW_RESET                                    0x3 // 3
+#define SGMII_SERDES_RX_IMPEDANCE_MSB                                0
+#define SGMII_SERDES_RX_IMPEDANCE_LSB                                0
+#define SGMII_SERDES_RX_IMPEDANCE_MASK                               0x00000001
+#define SGMII_SERDES_RX_IMPEDANCE_GET(x)                             (((x) & SGMII_SERDES_RX_IMPEDANCE_MASK) >> SGMII_SERDES_RX_IMPEDANCE_LSB)
+#define SGMII_SERDES_RX_IMPEDANCE_SET(x)                             (((x) << SGMII_SERDES_RX_IMPEDANCE_LSB) & SGMII_SERDES_RX_IMPEDANCE_MASK)
+#define SGMII_SERDES_RX_IMPEDANCE_RESET                              0x0 // 0
+#define SGMII_SERDES_ADDRESS                                         0x18070018
+
+#define RST_RESET2_SPARE_MSB                                         31
+#define RST_RESET2_SPARE_LSB                                         19
+#define RST_RESET2_SPARE_MASK                                        0xfff80000
+#define RST_RESET2_SPARE_GET(x)                                      (((x) & RST_RESET2_SPARE_MASK) >> RST_RESET2_SPARE_LSB)
+#define RST_RESET2_SPARE_SET(x)                                      (((x) << RST_RESET2_SPARE_LSB) & RST_RESET2_SPARE_MASK)
+#define RST_RESET2_SPARE_RESET                                       0x0 // 0
+#define RST_RESET2_EP_MODE_MSB                                       18
+#define RST_RESET2_EP_MODE_LSB                                       18
+#define RST_RESET2_EP_MODE_MASK                                      0x00040000
+#define RST_RESET2_EP_MODE_GET(x)                                    (((x) & RST_RESET2_EP_MODE_MASK) >> RST_RESET2_EP_MODE_LSB)
+#define RST_RESET2_EP_MODE_SET(x)                                    (((x) << RST_RESET2_EP_MODE_LSB) & RST_RESET2_EP_MODE_MASK)
+#define RST_RESET2_EP_MODE_RESET                                     0x0 // 0
+#define RST_RESET2_USB2_EXT_PWR_SEQ_MSB                              17
+#define RST_RESET2_USB2_EXT_PWR_SEQ_LSB                              17
+#define RST_RESET2_USB2_EXT_PWR_SEQ_MASK                             0x00020000
+#define RST_RESET2_USB2_EXT_PWR_SEQ_GET(x)                           (((x) & RST_RESET2_USB2_EXT_PWR_SEQ_MASK) >> RST_RESET2_USB2_EXT_PWR_SEQ_LSB)
+#define RST_RESET2_USB2_EXT_PWR_SEQ_SET(x)                           (((x) << RST_RESET2_USB2_EXT_PWR_SEQ_LSB) & RST_RESET2_USB2_EXT_PWR_SEQ_MASK)
+#define RST_RESET2_USB2_EXT_PWR_SEQ_RESET                            0x1 // 1
+#define RST_RESET2_USB1_EXT_PWR_SEQ_MSB                              16
+#define RST_RESET2_USB1_EXT_PWR_SEQ_LSB                              16
+#define RST_RESET2_USB1_EXT_PWR_SEQ_MASK                             0x00010000
+#define RST_RESET2_USB1_EXT_PWR_SEQ_GET(x)                           (((x) & RST_RESET2_USB1_EXT_PWR_SEQ_MASK) >> RST_RESET2_USB1_EXT_PWR_SEQ_LSB)
+#define RST_RESET2_USB1_EXT_PWR_SEQ_SET(x)                           (((x) << RST_RESET2_USB1_EXT_PWR_SEQ_LSB) & RST_RESET2_USB1_EXT_PWR_SEQ_MASK)
+#define RST_RESET2_USB1_EXT_PWR_SEQ_RESET                            0x1 // 1
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_MSB                          15
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_LSB                          15
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_MASK                         0x00008000
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_GET(x)                       (((x) & RST_RESET2_USB_PHY2_PLL_PWD_EXT_MASK) >> RST_RESET2_USB_PHY2_PLL_PWD_EXT_LSB)
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_SET(x)                       (((x) << RST_RESET2_USB_PHY2_PLL_PWD_EXT_LSB) & RST_RESET2_USB_PHY2_PLL_PWD_EXT_MASK)
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_RESET                        0x0 // 0
+#define RST_RESET2_USB_PHY2_ARESET_MSB                               11
+#define RST_RESET2_USB_PHY2_ARESET_LSB                               11
+#define RST_RESET2_USB_PHY2_ARESET_MASK                              0x00000800
+#define RST_RESET2_USB_PHY2_ARESET_GET(x)                            (((x) & RST_RESET2_USB_PHY2_ARESET_MASK) >> RST_RESET2_USB_PHY2_ARESET_LSB)
+#define RST_RESET2_USB_PHY2_ARESET_SET(x)                            (((x) << RST_RESET2_USB_PHY2_ARESET_LSB) & RST_RESET2_USB_PHY2_ARESET_MASK)
+#define RST_RESET2_USB_PHY2_ARESET_RESET                             0x1 // 1
+#define RST_RESET2_PCIE2_PHY_RESET_MSB                               7
+#define RST_RESET2_PCIE2_PHY_RESET_LSB                               7
+#define RST_RESET2_PCIE2_PHY_RESET_MASK                              0x00000080
+#define RST_RESET2_PCIE2_PHY_RESET_GET(x)                            (((x) & RST_RESET2_PCIE2_PHY_RESET_MASK) >> RST_RESET2_PCIE2_PHY_RESET_LSB)
+#define RST_RESET2_PCIE2_PHY_RESET_SET(x)                            (((x) << RST_RESET2_PCIE2_PHY_RESET_LSB) & RST_RESET2_PCIE2_PHY_RESET_MASK)
+#define RST_RESET2_PCIE2_PHY_RESET_RESET                             0x1 // 1
+#define RST_RESET2_PCIE2_RESET_MSB                                   6
+#define RST_RESET2_PCIE2_RESET_LSB                                   6
+#define RST_RESET2_PCIE2_RESET_MASK                                  0x00000040
+#define RST_RESET2_PCIE2_RESET_GET(x)                                (((x) & RST_RESET2_PCIE2_RESET_MASK) >> RST_RESET2_PCIE2_RESET_LSB)
+#define RST_RESET2_PCIE2_RESET_SET(x)                                (((x) << RST_RESET2_PCIE2_RESET_LSB) & RST_RESET2_PCIE2_RESET_MASK)
+#define RST_RESET2_PCIE2_RESET_RESET                                 0x1 // 1
+#define RST_RESET2_USB_HOST2_RESET_MSB                               5
+#define RST_RESET2_USB_HOST2_RESET_LSB                               5
+#define RST_RESET2_USB_HOST2_RESET_MASK                              0x00000020
+#define RST_RESET2_USB_HOST2_RESET_GET(x)                            (((x) & RST_RESET2_USB_HOST2_RESET_MASK) >> RST_RESET2_USB_HOST2_RESET_LSB)
+#define RST_RESET2_USB_HOST2_RESET_SET(x)                            (((x) << RST_RESET2_USB_HOST2_RESET_LSB) & RST_RESET2_USB_HOST2_RESET_MASK)
+#define RST_RESET2_USB_HOST2_RESET_RESET                             0x1 // 1
+#define RST_RESET2_USB_PHY2_RESET_MSB                                4
+#define RST_RESET2_USB_PHY2_RESET_LSB                                4
+#define RST_RESET2_USB_PHY2_RESET_MASK                               0x00000010
+#define RST_RESET2_USB_PHY2_RESET_GET(x)                             (((x) & RST_RESET2_USB_PHY2_RESET_MASK) >> RST_RESET2_USB_PHY2_RESET_LSB)
+#define RST_RESET2_USB_PHY2_RESET_SET(x)                             (((x) << RST_RESET2_USB_PHY2_RESET_LSB) & RST_RESET2_USB_PHY2_RESET_MASK)
+#define RST_RESET2_USB_PHY2_RESET_RESET                              0x1 // 1
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_MSB                     3
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_LSB                     3
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_MASK                    0x00000008
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_GET(x)                  (((x) & RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_MASK) >> RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_LSB)
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_SET(x)                  (((x) << RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_LSB) & RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_MASK)
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_RESET                   0x0 // 0
+#define RST_RESET2_USB2_MODE_MSB                                     0
+#define RST_RESET2_USB2_MODE_LSB                                     0
+#define RST_RESET2_USB2_MODE_MASK                                    0x00000001
+#define RST_RESET2_USB2_MODE_GET(x)                                  (((x) & RST_RESET2_USB2_MODE_MASK) >> RST_RESET2_USB2_MODE_LSB)
+#define RST_RESET2_USB2_MODE_SET(x)                                  (((x) << RST_RESET2_USB2_MODE_LSB) & RST_RESET2_USB2_MODE_MASK)
+#define RST_RESET2_USB2_MODE_RESET                                   0x1 // 1
+#define RST_RESET2_ADDRESS                                           0x180600c0
+
+#define RST_CLKGAT_EN_WMAC_MSB                                          9
+#define RST_CLKGAT_EN_WMAC_LSB                                          9
+#define RST_CLKGAT_EN_WMAC_MASK                                         0x00000200
+#define RST_CLKGAT_EN_WMAC_GET(x)                                       (((x) & RST_CLKGAT_EN_WMAC_MASK) >> RST_CLKGAT_EN_WMAC_LSB)
+#define RST_CLKGAT_EN_WMAC_SET(x)                                       (((x) << RST_CLKGAT_EN_WMAC_LSB) & RST_CLKGAT_EN_WMAC_MASK)
+#define RST_CLKGAT_EN_WMAC_RESET                                        0x1 // 1
+#define RST_CLKGAT_EN_USB2_MSB                                          8
+#define RST_CLKGAT_EN_USB2_LSB                                          8
+#define RST_CLKGAT_EN_USB2_MASK                                         0x00000100
+#define RST_CLKGAT_EN_USB2_GET(x)                                       (((x) & RST_CLKGAT_EN_USB2_MASK) >> RST_CLKGAT_EN_USB2_LSB)
+#define RST_CLKGAT_EN_USB2_SET(x)                                       (((x) << RST_CLKGAT_EN_USB2_LSB) & RST_CLKGAT_EN_USB2_MASK)
+#define RST_CLKGAT_EN_USB2_RESET                                        0x1 // 1
+#define RST_CLKGAT_EN_USB1_MSB                                          7
+#define RST_CLKGAT_EN_USB1_LSB                                          7
+#define RST_CLKGAT_EN_USB1_MASK                                         0x00000080
+#define RST_CLKGAT_EN_USB1_GET(x)                                       (((x) & RST_CLKGAT_EN_USB1_MASK) >> RST_CLKGAT_EN_USB1_LSB)
+#define RST_CLKGAT_EN_USB1_SET(x)                                       (((x) << RST_CLKGAT_EN_USB1_LSB) & RST_CLKGAT_EN_USB1_MASK)
+#define RST_CLKGAT_EN_USB1_RESET                                        0x1 // 1
+#define RST_CLKGAT_EN_GE1_MSB                                           6
+#define RST_CLKGAT_EN_GE1_LSB                                           6
+#define RST_CLKGAT_EN_GE1_MASK                                          0x00000040
+#define RST_CLKGAT_EN_GE1_GET(x)                                        (((x) & RST_CLKGAT_EN_GE1_MASK) >> RST_CLKGAT_EN_GE1_LSB)
+#define RST_CLKGAT_EN_GE1_SET(x)                                        (((x) << RST_CLKGAT_EN_GE1_LSB) & RST_CLKGAT_EN_GE1_MASK)
+#define RST_CLKGAT_EN_GE1_RESET                                         0x1 // 1
+#define RST_CLKGAT_EN_GE0_MSB                                           5
+#define RST_CLKGAT_EN_GE0_LSB                                           5
+#define RST_CLKGAT_EN_GE0_MASK                                          0x00000020
+#define RST_CLKGAT_EN_GE0_GET(x)                                        (((x) & RST_CLKGAT_EN_GE0_MASK) >> RST_CLKGAT_EN_GE0_LSB)
+#define RST_CLKGAT_EN_GE0_SET(x)                                        (((x) << RST_CLKGAT_EN_GE0_LSB) & RST_CLKGAT_EN_GE0_MASK)
+#define RST_CLKGAT_EN_GE0_RESET                                         0x1 // 1
+#define RST_CLKGAT_EN_CLK100_PCIERC2_MSB                                4
+#define RST_CLKGAT_EN_CLK100_PCIERC2_LSB                                4
+#define RST_CLKGAT_EN_CLK100_PCIERC2_MASK                               0x00000010
+#define RST_CLKGAT_EN_CLK100_PCIERC2_GET(x)                             (((x) & RST_CLKGAT_EN_CLK100_PCIERC2_MASK) >> RST_CLKGAT_EN_CLK100_PCIERC2_LSB)
+#define RST_CLKGAT_EN_CLK100_PCIERC2_SET(x)                             (((x) << RST_CLKGAT_EN_CLK100_PCIERC2_LSB) & RST_CLKGAT_EN_CLK100_PCIERC2_MASK)
+#define RST_CLKGAT_EN_CLK100_PCIERC2_RESET                              0x1 // 1
+#define RST_CLKGAT_EN_CLK100_PCIERC_MSB                                 3
+#define RST_CLKGAT_EN_CLK100_PCIERC_LSB                                 3
+#define RST_CLKGAT_EN_CLK100_PCIERC_MASK                                0x00000008
+#define RST_CLKGAT_EN_CLK100_PCIERC_GET(x)                              (((x) & RST_CLKGAT_EN_CLK100_PCIERC_MASK) >> RST_CLKGAT_EN_CLK100_PCIERC_LSB)
+#define RST_CLKGAT_EN_CLK100_PCIERC_SET(x)                              (((x) << RST_CLKGAT_EN_CLK100_PCIERC_LSB) & RST_CLKGAT_EN_CLK100_PCIERC_MASK)
+#define RST_CLKGAT_EN_CLK100_PCIERC_RESET                               0x1 // 1
+#define RST_CLKGAT_EN_PCIE_RC2_MSB                                      2
+#define RST_CLKGAT_EN_PCIE_RC2_LSB                                      2
+#define RST_CLKGAT_EN_PCIE_RC2_MASK                                     0x00000004
+#define RST_CLKGAT_EN_PCIE_RC2_GET(x)                                   (((x) & RST_CLKGAT_EN_PCIE_RC2_MASK) >> RST_CLKGAT_EN_PCIE_RC2_LSB)
+#define RST_CLKGAT_EN_PCIE_RC2_SET(x)                                   (((x) << RST_CLKGAT_EN_PCIE_RC2_LSB) & RST_CLKGAT_EN_PCIE_RC2_MASK)
+#define RST_CLKGAT_EN_PCIE_RC2_RESET                                    0x1 // 1
+#define RST_CLKGAT_EN_PCIE_RC_MSB                                       1
+#define RST_CLKGAT_EN_PCIE_RC_LSB                                       1
+#define RST_CLKGAT_EN_PCIE_RC_MASK                                      0x00000002
+#define RST_CLKGAT_EN_PCIE_RC_GET(x)                                    (((x) & RST_CLKGAT_EN_PCIE_RC_MASK) >> RST_CLKGAT_EN_PCIE_RC_LSB)
+#define RST_CLKGAT_EN_PCIE_RC_SET(x)                                    (((x) << RST_CLKGAT_EN_PCIE_RC_LSB) & RST_CLKGAT_EN_PCIE_RC_MASK)
+#define RST_CLKGAT_EN_PCIE_RC_RESET                                     0x1 // 1
+#define RST_CLKGAT_EN_PCIE_EP_MSB                                       0
+#define RST_CLKGAT_EN_PCIE_EP_LSB                                       0
+#define RST_CLKGAT_EN_PCIE_EP_MASK                                      0x00000001
+#define RST_CLKGAT_EN_PCIE_EP_GET(x)                                    (((x) & RST_CLKGAT_EN_PCIE_EP_MASK) >> RST_CLKGAT_EN_PCIE_EP_LSB)
+#define RST_CLKGAT_EN_PCIE_EP_SET(x)                                    (((x) << RST_CLKGAT_EN_PCIE_EP_LSB) & RST_CLKGAT_EN_PCIE_EP_MASK)
+#define RST_CLKGAT_EN_PCIE_EP_RESET                                     0x1 // 1
+#define RST_CLKGAT_EN_ADDRESS                                        0x180600c8
+
+// blueprint don't have this address the define the same with PCIRC
+#if 1 
+#define PCIE2_RESET_EP_RESET_L_MSB                                   2
+#define PCIE2_RESET_EP_RESET_L_LSB                                   2
+#define PCIE2_RESET_EP_RESET_L_MASK                                  0x00000004
+#define PCIE2_RESET_EP_RESET_L_GET(x)                                (((x) & PCIE2_RESET_EP_RESET_L_MASK) >> PCIE2_RESET_EP_RESET_L_LSB)
+#define PCIE2_RESET_EP_RESET_L_SET(x)                                (((x) << PCIE2_RESET_EP_RESET_L_LSB) & PCIE2_RESET_EP_RESET_L_MASK)
+#define PCIE2_RESET_EP_RESET_L_RESET                                 0x0 // 0
+#define PCIE2_RESET_LINK_REQ_RESET_MSB                               1
+#define PCIE2_RESET_LINK_REQ_RESET_LSB                               1
+#define PCIE2_RESET_LINK_REQ_RESET_MASK                              0x00000002
+#define PCIE2_RESET_LINK_REQ_RESET_GET(x)                            (((x) & PCIE2_RESET_LINK_REQ_RESET_MASK) >> PCIE2_RESET_LINK_REQ_RESET_LSB)
+#define PCIE2_RESET_LINK_REQ_RESET_SET(x)                            (((x) << PCIE2_RESET_LINK_REQ_RESET_LSB) & PCIE2_RESET_LINK_REQ_RESET_MASK)
+#define PCIE2_RESET_LINK_REQ_RESET_RESET                             0x0 // 0
+#define PCIE2_RESET_LINK_UP_MSB                                      0
+#define PCIE2_RESET_LINK_UP_LSB                                      0
+#define PCIE2_RESET_LINK_UP_MASK                                     0x00000001
+#define PCIE2_RESET_LINK_UP_GET(x)                                   (((x) & PCIE2_RESET_LINK_UP_MASK) >> PCIE2_RESET_LINK_UP_LSB)
+#define PCIE2_RESET_LINK_UP_SET(x)                                   (((x) << PCIE2_RESET_LINK_UP_LSB) & PCIE2_RESET_LINK_UP_MASK)
+#define PCIE2_RESET_LINK_UP_RESET                                    0x0 // 0
+#define PCIE2_RESET_ADDRESS                                          0x18280018
+
+#define PCIE2_APP_CFG_TYPE_MSB                                       21
+#define PCIE2_APP_CFG_TYPE_LSB                                       20
+#define PCIE2_APP_CFG_TYPE_MASK                                      0x00300000
+#define PCIE2_APP_CFG_TYPE_GET(x)                                    (((x) & PCIE2_APP_CFG_TYPE_MASK) >> PCIE2_APP_CFG_TYPE_LSB)
+#define PCIE2_APP_CFG_TYPE_SET(x)                                    (((x) << PCIE2_APP_CFG_TYPE_LSB) & PCIE2_APP_CFG_TYPE_MASK)
+#define PCIE2_APP_CFG_TYPE_RESET                                     0x0 // 0
+#define PCIE2_APP_PCIE2_BAR_MSN_MSB                                  19
+#define PCIE2_APP_PCIE2_BAR_MSN_LSB                                  16
+#define PCIE2_APP_PCIE2_BAR_MSN_MASK                                 0x000f0000
+#define PCIE2_APP_PCIE2_BAR_MSN_GET(x)                               (((x) & PCIE2_APP_PCIE2_BAR_MSN_MASK) >> PCIE2_APP_PCIE2_BAR_MSN_LSB)
+#define PCIE2_APP_PCIE2_BAR_MSN_SET(x)                               (((x) << PCIE2_APP_PCIE2_BAR_MSN_LSB) & PCIE2_APP_PCIE2_BAR_MSN_MASK)
+#define PCIE2_APP_PCIE2_BAR_MSN_RESET                                0x1 // 1
+#define PCIE2_APP_CFG_BE_MSB                                         15
+#define PCIE2_APP_CFG_BE_LSB                                         12
+#define PCIE2_APP_CFG_BE_MASK                                        0x0000f000
+#define PCIE2_APP_CFG_BE_GET(x)                                      (((x) & PCIE2_APP_CFG_BE_MASK) >> PCIE2_APP_CFG_BE_LSB)
+#define PCIE2_APP_CFG_BE_SET(x)                                      (((x) << PCIE2_APP_CFG_BE_LSB) & PCIE2_APP_CFG_BE_MASK)
+#define PCIE2_APP_CFG_BE_RESET                                       0xf // 15
+#define PCIE2_APP_SLV_RESP_ERR_MAP_MSB                               11
+#define PCIE2_APP_SLV_RESP_ERR_MAP_LSB                               6
+#define PCIE2_APP_SLV_RESP_ERR_MAP_MASK                              0x00000fc0
+#define PCIE2_APP_SLV_RESP_ERR_MAP_GET(x)                            (((x) & PCIE2_APP_SLV_RESP_ERR_MAP_MASK) >> PCIE2_APP_SLV_RESP_ERR_MAP_LSB)
+#define PCIE2_APP_SLV_RESP_ERR_MAP_SET(x)                            (((x) << PCIE2_APP_SLV_RESP_ERR_MAP_LSB) & PCIE2_APP_SLV_RESP_ERR_MAP_MASK)
+#define PCIE2_APP_SLV_RESP_ERR_MAP_RESET                             0x3f // 63
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_MSB                              5
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_LSB                              4
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_MASK                             0x00000030
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_GET(x)                           (((x) & PCIE2_APP_MSTR_RESP_ERR_MAP_MASK) >> PCIE2_APP_MSTR_RESP_ERR_MAP_LSB)
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_SET(x)                           (((x) << PCIE2_APP_MSTR_RESP_ERR_MAP_LSB) & PCIE2_APP_MSTR_RESP_ERR_MAP_MASK)
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_RESET                            0x0 // 0
+#define PCIE2_APP_INIT_RST_MSB                                       3
+#define PCIE2_APP_INIT_RST_LSB                                       3
+#define PCIE2_APP_INIT_RST_MASK                                      0x00000008
+#define PCIE2_APP_INIT_RST_GET(x)                                    (((x) & PCIE2_APP_INIT_RST_MASK) >> PCIE2_APP_INIT_RST_LSB)
+#define PCIE2_APP_INIT_RST_SET(x)                                    (((x) << PCIE2_APP_INIT_RST_LSB) & PCIE2_APP_INIT_RST_MASK)
+#define PCIE2_APP_INIT_RST_RESET                                     0x0 // 0
+#define PCIE2_APP_PM_XMT_TURNOFF_MSB                                 2
+#define PCIE2_APP_PM_XMT_TURNOFF_LSB                                 2
+#define PCIE2_APP_PM_XMT_TURNOFF_MASK                                0x00000004
+#define PCIE2_APP_PM_XMT_TURNOFF_GET(x)                              (((x) & PCIE2_APP_PM_XMT_TURNOFF_MASK) >> PCIE2_APP_PM_XMT_TURNOFF_LSB)
+#define PCIE2_APP_PM_XMT_TURNOFF_SET(x)                              (((x) << PCIE2_APP_PM_XMT_TURNOFF_LSB) & PCIE2_APP_PM_XMT_TURNOFF_MASK)
+#define PCIE2_APP_PM_XMT_TURNOFF_RESET                               0x0 // 0
+#define PCIE2_APP_UNLOCK_MSG_MSB                                     1
+#define PCIE2_APP_UNLOCK_MSG_LSB                                     1
+#define PCIE2_APP_UNLOCK_MSG_MASK                                    0x00000002
+#define PCIE2_APP_UNLOCK_MSG_GET(x)                                  (((x) & PCIE2_APP_UNLOCK_MSG_MASK) >> PCIE2_APP_UNLOCK_MSG_LSB)
+#define PCIE2_APP_UNLOCK_MSG_SET(x)                                  (((x) << PCIE2_APP_UNLOCK_MSG_LSB) & PCIE2_APP_UNLOCK_MSG_MASK)
+#define PCIE2_APP_UNLOCK_MSG_RESET                                   0x0 // 0
+#define PCIE2_APP_LTSSM_ENABLE_MSB                                   0
+#define PCIE2_APP_LTSSM_ENABLE_LSB                                   0
+#define PCIE2_APP_LTSSM_ENABLE_MASK                                  0x00000001
+#define PCIE2_APP_LTSSM_ENABLE_GET(x)                                (((x) & PCIE2_APP_LTSSM_ENABLE_MASK) >> PCIE2_APP_LTSSM_ENABLE_LSB)
+#define PCIE2_APP_LTSSM_ENABLE_SET(x)                                (((x) << PCIE2_APP_LTSSM_ENABLE_LSB) & PCIE2_APP_LTSSM_ENABLE_MASK)
+#define PCIE2_APP_LTSSM_ENABLE_RESET                                 0x0 // 0
+#define PCIE2_APP_ADDRESS                                            0x18280000
+#endif
+
+#define PCIE_INT_MASK_LINK_DOWN_MSB                                  27
+#define PCIE_INT_MASK_LINK_DOWN_LSB                                  27
+#define PCIE_INT_MASK_LINK_DOWN_MASK                                 0x08000000
+#define PCIE_INT_MASK_LINK_DOWN_GET(x)                               (((x) & PCIE_INT_MASK_LINK_DOWN_MASK) >> PCIE_INT_MASK_LINK_DOWN_LSB)
+#define PCIE_INT_MASK_LINK_DOWN_SET(x)                               (((x) << PCIE_INT_MASK_LINK_DOWN_LSB) & PCIE_INT_MASK_LINK_DOWN_MASK)
+#define PCIE_INT_MASK_LINK_DOWN_RESET                                0x0 // 0
+#define PCIE_INT_MASK_LINK_REQ_RST_MSB                               26
+#define PCIE_INT_MASK_LINK_REQ_RST_LSB                               26
+#define PCIE_INT_MASK_LINK_REQ_RST_MASK                              0x04000000
+#define PCIE_INT_MASK_LINK_REQ_RST_GET(x)                            (((x) & PCIE_INT_MASK_LINK_REQ_RST_MASK) >> PCIE_INT_MASK_LINK_REQ_RST_LSB)
+#define PCIE_INT_MASK_LINK_REQ_RST_SET(x)                            (((x) << PCIE_INT_MASK_LINK_REQ_RST_LSB) & PCIE_INT_MASK_LINK_REQ_RST_MASK)
+#define PCIE_INT_MASK_LINK_REQ_RST_RESET                             0x0 // 0
+#define PCIE_INT_MASK_INTDL_MSB                                      17
+#define PCIE_INT_MASK_INTDL_LSB                                      17
+#define PCIE_INT_MASK_INTDL_MASK                                     0x00020000
+#define PCIE_INT_MASK_INTDL_GET(x)                                   (((x) & PCIE_INT_MASK_INTDL_MASK) >> PCIE_INT_MASK_INTDL_LSB)
+#define PCIE_INT_MASK_INTDL_SET(x)                                   (((x) << PCIE_INT_MASK_INTDL_LSB) & PCIE_INT_MASK_INTDL_MASK)
+#define PCIE_INT_MASK_INTDL_RESET                                    0x0 // 0
+#define PCIE_INT_MASK_INTCL_MSB                                      16
+#define PCIE_INT_MASK_INTCL_LSB                                      16
+#define PCIE_INT_MASK_INTCL_MASK                                     0x00010000
+#define PCIE_INT_MASK_INTCL_GET(x)                                   (((x) & PCIE_INT_MASK_INTCL_MASK) >> PCIE_INT_MASK_INTCL_LSB)
+#define PCIE_INT_MASK_INTCL_SET(x)                                   (((x) << PCIE_INT_MASK_INTCL_LSB) & PCIE_INT_MASK_INTCL_MASK)
+#define PCIE_INT_MASK_INTCL_RESET                                    0x0 // 0
+#define PCIE_INT_MASK_INTBL_MSB                                      15
+#define PCIE_INT_MASK_INTBL_LSB                                      15
+#define PCIE_INT_MASK_INTBL_MASK                                     0x00008000
+#define PCIE_INT_MASK_INTBL_GET(x)                                   (((x) & PCIE_INT_MASK_INTBL_MASK) >> PCIE_INT_MASK_INTBL_LSB)
+#define PCIE_INT_MASK_INTBL_SET(x)                                   (((x) << PCIE_INT_MASK_INTBL_LSB) & PCIE_INT_MASK_INTBL_MASK)
+#define PCIE_INT_MASK_INTBL_RESET                                    0x0 // 0
+#define PCIE_INT_MASK_INTAL_MSB                                      14
+#define PCIE_INT_MASK_INTAL_LSB                                      14
+#define PCIE_INT_MASK_INTAL_MASK                                     0x00004000
+#define PCIE_INT_MASK_INTAL_GET(x)                                   (((x) & PCIE_INT_MASK_INTAL_MASK) >> PCIE_INT_MASK_INTAL_LSB)
+#define PCIE_INT_MASK_INTAL_SET(x)                                   (((x) << PCIE_INT_MASK_INTAL_LSB) & PCIE_INT_MASK_INTAL_MASK)
+#define PCIE_INT_MASK_INTAL_RESET                                    0x0 // 0
+#define PCIE_INT_MASK_SYS_ERR_MSB                                    13
+#define PCIE_INT_MASK_SYS_ERR_LSB                                    13
+#define PCIE_INT_MASK_SYS_ERR_MASK                                   0x00002000
+#define PCIE_INT_MASK_SYS_ERR_GET(x)                                 (((x) & PCIE_INT_MASK_SYS_ERR_MASK) >> PCIE_INT_MASK_SYS_ERR_LSB)
+#define PCIE_INT_MASK_SYS_ERR_SET(x)                                 (((x) << PCIE_INT_MASK_SYS_ERR_LSB) & PCIE_INT_MASK_SYS_ERR_MASK)
+#define PCIE_INT_MASK_SYS_ERR_RESET                                  0x0 // 0
+#define PCIE_INT_MASK_AER_MSI_MSB                                    12
+#define PCIE_INT_MASK_AER_MSI_LSB                                    12
+#define PCIE_INT_MASK_AER_MSI_MASK                                   0x00001000
+#define PCIE_INT_MASK_AER_MSI_GET(x)                                 (((x) & PCIE_INT_MASK_AER_MSI_MASK) >> PCIE_INT_MASK_AER_MSI_LSB)
+#define PCIE_INT_MASK_AER_MSI_SET(x)                                 (((x) << PCIE_INT_MASK_AER_MSI_LSB) & PCIE_INT_MASK_AER_MSI_MASK)
+#define PCIE_INT_MASK_AER_MSI_RESET                                  0x0 // 0
+#define PCIE_INT_MASK_AER_INT_MSB                                    11
+#define PCIE_INT_MASK_AER_INT_LSB                                    11
+#define PCIE_INT_MASK_AER_INT_MASK                                   0x00000800
+#define PCIE_INT_MASK_AER_INT_GET(x)                                 (((x) & PCIE_INT_MASK_AER_INT_MASK) >> PCIE_INT_MASK_AER_INT_LSB)
+#define PCIE_INT_MASK_AER_INT_SET(x)                                 (((x) << PCIE_INT_MASK_AER_INT_LSB) & PCIE_INT_MASK_AER_INT_MASK)
+#define PCIE_INT_MASK_AER_INT_RESET                                  0x0 // 0
+#define PCIE_INT_MASK_MSI_ERR_MSB                                    10
+#define PCIE_INT_MASK_MSI_ERR_LSB                                    10
+#define PCIE_INT_MASK_MSI_ERR_MASK                                   0x00000400
+#define PCIE_INT_MASK_MSI_ERR_GET(x)                                 (((x) & PCIE_INT_MASK_MSI_ERR_MASK) >> PCIE_INT_MASK_MSI_ERR_LSB)
+#define PCIE_INT_MASK_MSI_ERR_SET(x)                                 (((x) << PCIE_INT_MASK_MSI_ERR_LSB) & PCIE_INT_MASK_MSI_ERR_MASK)
+#define PCIE_INT_MASK_MSI_ERR_RESET                                  0x0 // 0
+#define PCIE_INT_MASK_MSI_MSB                                        9
+#define PCIE_INT_MASK_MSI_LSB                                        9
+#define PCIE_INT_MASK_MSI_MASK                                       0x00000200
+#define PCIE_INT_MASK_MSI_GET(x)                                     (((x) & PCIE_INT_MASK_MSI_MASK) >> PCIE_INT_MASK_MSI_LSB)
+#define PCIE_INT_MASK_MSI_SET(x)                                     (((x) << PCIE_INT_MASK_MSI_LSB) & PCIE_INT_MASK_MSI_MASK)
+#define PCIE_INT_MASK_MSI_RESET                                      0x0 // 0
+#define PCIE_INT_MASK_INTD_MSB                                       8
+#define PCIE_INT_MASK_INTD_LSB                                       8
+#define PCIE_INT_MASK_INTD_MASK                                      0x00000100
+#define PCIE_INT_MASK_INTD_GET(x)                                    (((x) & PCIE_INT_MASK_INTD_MASK) >> PCIE_INT_MASK_INTD_LSB)
+#define PCIE_INT_MASK_INTD_SET(x)                                    (((x) << PCIE_INT_MASK_INTD_LSB) & PCIE_INT_MASK_INTD_MASK)
+#define PCIE_INT_MASK_INTD_RESET                                     0x0 // 0
+#define PCIE_INT_MASK_INTC_MSB                                       7
+#define PCIE_INT_MASK_INTC_LSB                                       7
+#define PCIE_INT_MASK_INTC_MASK                                      0x00000080
+#define PCIE_INT_MASK_INTC_GET(x)                                    (((x) & PCIE_INT_MASK_INTC_MASK) >> PCIE_INT_MASK_INTC_LSB)
+#define PCIE_INT_MASK_INTC_SET(x)                                    (((x) << PCIE_INT_MASK_INTC_LSB) & PCIE_INT_MASK_INTC_MASK)
+#define PCIE_INT_MASK_INTC_RESET                                     0x0 // 0
+#define PCIE_INT_MASK_INTB_MSB                                       6
+#define PCIE_INT_MASK_INTB_LSB                                       6
+#define PCIE_INT_MASK_INTB_MASK                                      0x00000040
+#define PCIE_INT_MASK_INTB_GET(x)                                    (((x) & PCIE_INT_MASK_INTB_MASK) >> PCIE_INT_MASK_INTB_LSB)
+#define PCIE_INT_MASK_INTB_SET(x)                                    (((x) << PCIE_INT_MASK_INTB_LSB) & PCIE_INT_MASK_INTB_MASK)
+#define PCIE_INT_MASK_INTB_RESET                                     0x0 // 0
+#define PCIE_INT_MASK_INTA_MSB                                       5
+#define PCIE_INT_MASK_INTA_LSB                                       5
+#define PCIE_INT_MASK_INTA_MASK                                      0x00000020
+#define PCIE_INT_MASK_INTA_GET(x)                                    (((x) & PCIE_INT_MASK_INTA_MASK) >> PCIE_INT_MASK_INTA_LSB)
+#define PCIE_INT_MASK_INTA_SET(x)                                    (((x) << PCIE_INT_MASK_INTA_LSB) & PCIE_INT_MASK_INTA_MASK)
+#define PCIE_INT_MASK_INTA_RESET                                     0x0 // 0
+#define PCIE_INT_MASK_RADMX_COMP_LOOKUP_ERR_MSB                      4
+#define PCIE_INT_MASK_RADMX_COMP_LOOKUP_ERR_LSB                      4
+#define PCIE_INT_MASK_RADMX_COMP_LOOKUP_ERR_MASK                     0x00000010
+#define PCIE_INT_MASK_RADMX_COMP_LOOKUP_ERR_GET(x)                   (((x) & PCIE_INT_MASK_RADMX_COMP_LOOKUP_ERR_MASK) >> PCIE_INT_MASK_RADMX_COMP_LOOKUP_ERR_LSB)
+#define PCIE_INT_MASK_RADMX_COMP_LOOKUP_ERR_SET(x)                   (((x) << PCIE_INT_MASK_RADMX_COMP_LOOKUP_ERR_LSB) & PCIE_INT_MASK_RADMX_COMP_LOOKUP_ERR_MASK)
+#define PCIE_INT_MASK_RADMX_COMP_LOOKUP_ERR_RESET                    0x0 // 0
+#define PCIE_INT_MASK_GM_COMP_LOOKUP_ERR_MSB                         3
+#define PCIE_INT_MASK_GM_COMP_LOOKUP_ERR_LSB                         3
+#define PCIE_INT_MASK_GM_COMP_LOOKUP_ERR_MASK                        0x00000008
+#define PCIE_INT_MASK_GM_COMP_LOOKUP_ERR_GET(x)                      (((x) & PCIE_INT_MASK_GM_COMP_LOOKUP_ERR_MASK) >> PCIE_INT_MASK_GM_COMP_LOOKUP_ERR_LSB)
+#define PCIE_INT_MASK_GM_COMP_LOOKUP_ERR_SET(x)                      (((x) << PCIE_INT_MASK_GM_COMP_LOOKUP_ERR_LSB) & PCIE_INT_MASK_GM_COMP_LOOKUP_ERR_MASK)
+#define PCIE_INT_MASK_GM_COMP_LOOKUP_ERR_RESET                       0x0 // 0
+#define PCIE_INT_MASK_FATAL_ERR_MSB                                  2
+#define PCIE_INT_MASK_FATAL_ERR_LSB                                  2
+#define PCIE_INT_MASK_FATAL_ERR_MASK                                 0x00000004
+#define PCIE_INT_MASK_FATAL_ERR_GET(x)                               (((x) & PCIE_INT_MASK_FATAL_ERR_MASK) >> PCIE_INT_MASK_FATAL_ERR_LSB)
+#define PCIE_INT_MASK_FATAL_ERR_SET(x)                               (((x) << PCIE_INT_MASK_FATAL_ERR_LSB) & PCIE_INT_MASK_FATAL_ERR_MASK)
+#define PCIE_INT_MASK_FATAL_ERR_RESET                                0x0 // 0
+#define PCIE_INT_MASK_NONFATAL_ERR_MSB                               1
+#define PCIE_INT_MASK_NONFATAL_ERR_LSB                               1
+#define PCIE_INT_MASK_NONFATAL_ERR_MASK                              0x00000002
+#define PCIE_INT_MASK_NONFATAL_ERR_GET(x)                            (((x) & PCIE_INT_MASK_NONFATAL_ERR_MASK) >> PCIE_INT_MASK_NONFATAL_ERR_LSB)
+#define PCIE_INT_MASK_NONFATAL_ERR_SET(x)                            (((x) << PCIE_INT_MASK_NONFATAL_ERR_LSB) & PCIE_INT_MASK_NONFATAL_ERR_MASK)
+#define PCIE_INT_MASK_NONFATAL_ERR_RESET                             0x0 // 0
+#define PCIE_INT_MASK_CORR_ERR_MSB                                   0
+#define PCIE_INT_MASK_CORR_ERR_LSB                                   0
+#define PCIE_INT_MASK_CORR_ERR_MASK                                  0x00000001
+#define PCIE_INT_MASK_CORR_ERR_GET(x)                                (((x) & PCIE_INT_MASK_CORR_ERR_MASK) >> PCIE_INT_MASK_CORR_ERR_LSB)
+#define PCIE_INT_MASK_CORR_ERR_SET(x)                                (((x) << PCIE_INT_MASK_CORR_ERR_LSB) & PCIE_INT_MASK_CORR_ERR_MASK)
+#define PCIE_INT_MASK_CORR_ERR_RESET                                 0x0 // 0
+#define PCIE_INT_MASK_ADDRESS                                        0x18280050
+
+#define PCIE_DEBUG_AHB_MSTR_DATA_SWAP_EN_MSB                         17
+#define PCIE_DEBUG_AHB_MSTR_DATA_SWAP_EN_LSB                         17
+#define PCIE_DEBUG_AHB_MSTR_DATA_SWAP_EN_MASK                        0x00020000
+#define PCIE_DEBUG_AHB_MSTR_DATA_SWAP_EN_GET(x)                      (((x) & PCIE_DEBUG_AHB_MSTR_DATA_SWAP_EN_MASK) >> PCIE_DEBUG_AHB_MSTR_DATA_SWAP_EN_LSB)
+#define PCIE_DEBUG_AHB_MSTR_DATA_SWAP_EN_SET(x)                      (((x) << PCIE_DEBUG_AHB_MSTR_DATA_SWAP_EN_LSB) & PCIE_DEBUG_AHB_MSTR_DATA_SWAP_EN_MASK)
+#define PCIE_DEBUG_AHB_MSTR_DATA_SWAP_EN_RESET                       0x0 // 0
+#define PCIE_DEBUG_PCIE_PHY_READY_MSB                                16
+#define PCIE_DEBUG_PCIE_PHY_READY_LSB                                16
+#define PCIE_DEBUG_PCIE_PHY_READY_MASK                               0x00010000
+#define PCIE_DEBUG_PCIE_PHY_READY_GET(x)                             (((x) & PCIE_DEBUG_PCIE_PHY_READY_MASK) >> PCIE_DEBUG_PCIE_PHY_READY_LSB)
+#define PCIE_DEBUG_PCIE_PHY_READY_SET(x)                             (((x) << PCIE_DEBUG_PCIE_PHY_READY_LSB) & PCIE_DEBUG_PCIE_PHY_READY_MASK)
+#define PCIE_DEBUG_PCIE_PHY_READY_RESET                              0x0 // 0
+#define PCIE_DEBUG_RXVALID_EXT_ENABLE_MSB                            15
+#define PCIE_DEBUG_RXVALID_EXT_ENABLE_LSB                            15
+#define PCIE_DEBUG_RXVALID_EXT_ENABLE_MASK                           0x00008000
+#define PCIE_DEBUG_RXVALID_EXT_ENABLE_GET(x)                         (((x) & PCIE_DEBUG_RXVALID_EXT_ENABLE_MASK) >> PCIE_DEBUG_RXVALID_EXT_ENABLE_LSB)
+#define PCIE_DEBUG_RXVALID_EXT_ENABLE_SET(x)                         (((x) << PCIE_DEBUG_RXVALID_EXT_ENABLE_LSB) & PCIE_DEBUG_RXVALID_EXT_ENABLE_MASK)
+#define PCIE_DEBUG_RXVALID_EXT_ENABLE_RESET                          0x0 // 0
+#define PCIE_DEBUG_BYTESWAP_MSB                                      14
+#define PCIE_DEBUG_BYTESWAP_LSB                                      14
+#define PCIE_DEBUG_BYTESWAP_MASK                                     0x00004000
+#define PCIE_DEBUG_BYTESWAP_GET(x)                                   (((x) & PCIE_DEBUG_BYTESWAP_MASK) >> PCIE_DEBUG_BYTESWAP_LSB)
+#define PCIE_DEBUG_BYTESWAP_SET(x)                                   (((x) << PCIE_DEBUG_BYTESWAP_LSB) & PCIE_DEBUG_BYTESWAP_MASK)
+#define PCIE_DEBUG_BYTESWAP_RESET                                    0x0 // 0
+#define PCIE_DEBUG_PM_STATUS_MSB                                     13
+#define PCIE_DEBUG_PM_STATUS_LSB                                     13
+#define PCIE_DEBUG_PM_STATUS_MASK                                    0x00002000
+#define PCIE_DEBUG_PM_STATUS_GET(x)                                  (((x) & PCIE_DEBUG_PM_STATUS_MASK) >> PCIE_DEBUG_PM_STATUS_LSB)
+#define PCIE_DEBUG_PM_STATUS_SET(x)                                  (((x) << PCIE_DEBUG_PM_STATUS_LSB) & PCIE_DEBUG_PM_STATUS_MASK)
+#define PCIE_DEBUG_PM_STATUS_RESET                                   0x0 // 0
+#define PCIE_DEBUG_PM_PME_EN_MSB                                     12
+#define PCIE_DEBUG_PM_PME_EN_LSB                                     12
+#define PCIE_DEBUG_PM_PME_EN_MASK                                    0x00001000
+#define PCIE_DEBUG_PM_PME_EN_GET(x)                                  (((x) & PCIE_DEBUG_PM_PME_EN_MASK) >> PCIE_DEBUG_PM_PME_EN_LSB)
+#define PCIE_DEBUG_PM_PME_EN_SET(x)                                  (((x) << PCIE_DEBUG_PM_PME_EN_LSB) & PCIE_DEBUG_PM_PME_EN_MASK)
+#define PCIE_DEBUG_PM_PME_EN_RESET                                   0x0 // 0
+#define PCIE_DEBUG_PM_DSTATE_MSB                                     11
+#define PCIE_DEBUG_PM_DSTATE_LSB                                     9
+#define PCIE_DEBUG_PM_DSTATE_MASK                                    0x00000e00
+#define PCIE_DEBUG_PM_DSTATE_GET(x)                                  (((x) & PCIE_DEBUG_PM_DSTATE_MASK) >> PCIE_DEBUG_PM_DSTATE_LSB)
+#define PCIE_DEBUG_PM_DSTATE_SET(x)                                  (((x) << PCIE_DEBUG_PM_DSTATE_LSB) & PCIE_DEBUG_PM_DSTATE_MASK)
+#define PCIE_DEBUG_PM_DSTATE_RESET                                   0x0 // 0
+#define PCIE_DEBUG_XMLH_LTSSM_STATE_MSB                              8
+#define PCIE_DEBUG_XMLH_LTSSM_STATE_LSB                              4
+#define PCIE_DEBUG_XMLH_LTSSM_STATE_MASK                             0x000001f0
+#define PCIE_DEBUG_XMLH_LTSSM_STATE_GET(x)                           (((x) & PCIE_DEBUG_XMLH_LTSSM_STATE_MASK) >> PCIE_DEBUG_XMLH_LTSSM_STATE_LSB)
+#define PCIE_DEBUG_XMLH_LTSSM_STATE_SET(x)                           (((x) << PCIE_DEBUG_XMLH_LTSSM_STATE_LSB) & PCIE_DEBUG_XMLH_LTSSM_STATE_MASK)
+#define PCIE_DEBUG_XMLH_LTSSM_STATE_RESET                            0x0 // 0
+#define PCIE_DEBUG_PM_CURNT_STATE_MSB                                3
+#define PCIE_DEBUG_PM_CURNT_STATE_LSB                                1
+#define PCIE_DEBUG_PM_CURNT_STATE_MASK                               0x0000000e
+#define PCIE_DEBUG_PM_CURNT_STATE_GET(x)                             (((x) & PCIE_DEBUG_PM_CURNT_STATE_MASK) >> PCIE_DEBUG_PM_CURNT_STATE_LSB)
+#define PCIE_DEBUG_PM_CURNT_STATE_SET(x)                             (((x) << PCIE_DEBUG_PM_CURNT_STATE_LSB) & PCIE_DEBUG_PM_CURNT_STATE_MASK)
+#define PCIE_DEBUG_PM_CURNT_STATE_RESET                              0x0 // 0
+#define PCIE_DEBUG_RDLH_LINK_UP_MSB                                  0
+#define PCIE_DEBUG_RDLH_LINK_UP_LSB                                  0
+#define PCIE_DEBUG_RDLH_LINK_UP_MASK                                 0x00000001
+#define PCIE_DEBUG_RDLH_LINK_UP_GET(x)                               (((x) & PCIE_DEBUG_RDLH_LINK_UP_MASK) >> PCIE_DEBUG_RDLH_LINK_UP_LSB)
+#define PCIE_DEBUG_RDLH_LINK_UP_SET(x)                               (((x) << PCIE_DEBUG_RDLH_LINK_UP_LSB) & PCIE_DEBUG_RDLH_LINK_UP_MASK)
+#define PCIE_DEBUG_RDLH_LINK_UP_RESET                                0x0 // 0
+#define PCIE_DEBUG_ADDRESS                                           0x1828001c
+
+#define XTAL2_SEC_TDC_COUNT_MSB                                          31
+#define XTAL2_SEC_TDC_COUNT_LSB                                          27
+#define XTAL2_SEC_TDC_COUNT_MASK                                         0xF8000000
+#define XTAL2_SEC_TDC_COUNT_GET(x)                                       (((x) & XTAL2_SEC_TDC_COUNT_MASK) >> XTAL2_SEC_TDC_COUNT_LSB)
+#define XTAL2_SEC_TDC_COUNT_SET(x)                                       (((x) << XTAL2_SEC_TDC_COUNT_LSB) & XTAL2_SEC_TDC_COUNT_MASK)
+#define XTAL2_SEC_TDC_COUNT_RESET                                        0x0 // 0
+#define XTAL2_SEC_TDC_PH_COUNT_MSB                                       26
+#define XTAL2_SEC_TDC_PH_COUNT_LSB                                       22
+#define XTAL2_SEC_TDC_PH_COUNT_MASK                                      0x007C0000
+#define XTAL2_SEC_TDC_PH_COUNT_GET(x)                                    (((x) & XTAL2_SEC_TDC_PH_COUNT_MASK) >> XTAL2_SEC_TDC_PH_COUNT_LSB)
+#define XTAL2_SEC_TDC_PH_COUNT_SET(x)                                    (((x) << XTAL2_SEC_TDC_PH_COUNT_LSB) & XTAL2_SEC_TDC_PH_COUNT_MASK)
+#define XTAL2_SEC_TDC_PH_COUNT_RESET                                     0x0 // 0
+#define XTAL2_SEC_DUTY_UP_MSB                                            21
+#define XTAL2_SEC_DUTY_UP_LSB                                            17
+#define XTAL2_SEC_DUTY_UP_MASK                                           0x0003E0000
+#define XTAL2_SEC_DUTY_UP_GET(x)                                         (((x) & XTAL2_SEC_DUTY_UP_MASK) >> XTAL2_SEC_DUTY_UP_LSB)
+#define XTAL2_SEC_DUTY_UP_SET(x)                                         (((x) << XTAL2_SEC_DUTY_UP_LSB) & XTAL2_SEC_DUTY_UP_MASK)
+#define XTAL2_SEC_DUTY_UP_RESET                                          0x0 // 0
+#define XTAL2_SEC_DUTY_DN_MSB                                            16
+#define XTAL2_SEC_DUTY_DN_LSB                                            12
+#define XTAL2_SEC_DUTY_DN_MASK                                           0x0001F000
+#define XTAL2_SEC_DUTY_DN_GET(x)                                         (((x) & XTAL2_SEC_DUTY_DN_MASK) >> XTAL2_SEC_DUTY_DN_LSB)
+#define XTAL2_SEC_DUTY_DN_SET(x)                                         (((x) << XTAL2_SEC_DUTY_DN_LSB) & XTAL2_SEC_DUTY_DN_MASK)
+#define XTAL2_SEC_DUTY_DN_RESET                                          0x0 // 0
+#define XTAL2_SEC_DCA_BYPASS_MSB                                         11
+#define XTAL2_SEC_DCA_BYPASS_LSB                                         11
+#define XTAL2_SEC_DCA_BYPASS_MASK                                        0x00000800
+#define XTAL2_SEC_DCA_BYPASS_GET(x)                                      (((x) & XTAL2_SEC_DCA_BYPASS_MASK) >> XTAL2_SEC_DCA_BYPASS_LSB)
+#define XTAL2_SEC_DCA_BYPASS_SET(x)                                      (((x) << XTAL2_SEC_DCA_BYPASS_LSB) & XTAL2_SEC_DCA_BYPASS_MASK)
+#define XTAL2_SEC_DCA_BYPASS_RESET                                       0x1 // 1
+#define XTAL2_SEC_DCA_SWCAL_MSB                                          10
+#define XTAL2_SEC_DCA_SWCAL_LSB                                          10
+#define XTAL2_SEC_DCA_SWCAL_MASK                                         0x00000400
+#define XTAL2_SEC_DCA_SWCAL_GET(x)                                       (((x) & XTAL2_SEC_DCA_SWCAL_MASK) >> XTAL2_SEC_DCA_SWCAL_LSB)
+#define XTAL2_SEC_DCA_SWCAL_SET(x)                                       (((x) << XTAL2_SEC_DCA_SWCAL_LSB) & XTAL2_SEC_DCA_SWCAL_MASK)
+#define XTAL2_SEC_DCA_SWCAL_RESET                                        0x0 // 0
+#define XTAL2_SEC_DCA_COUNT_LIMIT_MSB                                    9
+#define XTAL2_SEC_DCA_COUNT_LIMIT_LSB                                    9
+#define XTAL2_SEC_DCA_COUNT_LIMIT_MASK                                   0x00000200
+#define XTAL2_SEC_DCA_COUNT_LIMIT_GET(x)                                 (((x) & XTAL2_SEC_DCA_COUNT_LIMIT_MASK) >> XTAL2_SEC_DCA_COUNT_LIMIT_LSB)
+#define XTAL2_SEC_DCA_COUNT_LIMIT_SET(x)                                 (((x) << XTAL2_SEC_DCA_COUNT_LIMIT_LSB) & XTAL2_SEC_DCA_COUNT_LIMIT_MASK)
+#define XTAL2_SEC_DCA_COUNT_LIMIT_RESET                                  0x1 // 1
+#define XTAL2_SEC_DCA_COUNT_EN_MSB                                       8
+#define XTAL2_SEC_DCA_COUNT_EN_LSB                                       8
+#define XTAL2_SEC_DCA_COUNT_EN_MASK                                      0x00000100
+#define XTAL2_SEC_DCA_COUNT_EN_GET(x)                                    (((x) & XTAL2_SEC_DCA_COUNT_EN_MASK) >> XTAL2_SEC_DCA_COUNT_EN_LSB)
+#define XTAL2_SEC_DCA_COUNT_EN_SET(x)                                    (((x) << XTAL2_SEC_DCA_COUNT_EN_LSB) & XTAL2_SEC_DCA_COUNT_EN_MASK)
+#define XTAL2_SEC_DCA_COUNT_EN_RESET                                     0x1 // 1
+#define XTAL2_SEC_SPARE_MSB                                              7
+#define XTAL2_SEC_SPARE_LSB                                              0
+#define XTAL2_SEC_SPARE_MASK                                             0x000000FF
+#define XTAL2_SEC_SPARE_GET(x)                                           (((x) & XTAL2_SEC_SPARE_MASK) >> XTAL2_SEC_SPARE_LSB)
+#define XTAL2_SEC_SPARE_SET(x)                                           (((x) << XTAL2_SEC_SPARE_LSB) & XTAL2_SEC_SPARE_MASK)
+#define XTAL2_SEC_SPARE_RESET                                            0x0 // 0
+#define XTAL2_SEC_ADDRESS                                                0x18116294
+
+#define CONFIG_MIPS32       1   /* MIPS32 CPU core  */
+
+#define CONFIG_BOOTDELAY    2   /* autoboot after 4 seconds */
+
+#define CONFIG_BAUDRATE     115200
+#define CFG_BAUDRATE_TABLE  {115200}
+
+#define CONFIG_TIMESTAMP        /* Print image info with timestamp */
+
+#define CONFIG_ROOTFS_RD
+
+#define CONFIG_BOOTARGS_RD     "console=ttyS0,115200 root=01:00 rd_start=0x802d0000 rd_size=5242880 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),4096k(rootfs),2048k(uImage)"
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),2048k(uImage)"
+
+#ifdef CONFIG_ROOTFS_FLASH
+#define CONFIG_BOOTARGS CONFIG_BOOTARGS_FL
+#else
+#define CONFIG_BOOTARGS ""
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CFG_LONGHELP                /* undef to save memory      */
+#define CFG_PROMPT      "ath> "     /* Monitor Command Prompt    */
+#define CFG_CBSIZE      512     /* Console I/O Buffer Size   */
+#define CFG_PBSIZE      (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define CFG_MAXARGS     16      /* max number of command args*/
+
+#define CFG_MALLOC_LEN      (128*1024)
+
+#define CFG_BOOTPARAMS_LEN  (128*1024)
+
+#define CFG_SDRAM_BASE      0x80000000     /* Cached addr */
+//#define CFG_SDRAM_BASE    0xa0000000     /* Cached addr */
+
+#define CFG_LOAD_ADDR       0x81000000     /* default load address  */
+//#define CFG_LOAD_ADDR     0xa1000000     /* default load address  */
+
+#define CFG_MEMTEST_START   0x80100000
+#undef CFG_MEMTEST_START
+#define CFG_MEMTEST_START       0x80200000
+#define CFG_MEMTEST_END     0x83800000
+
+/*------------------------------------------------------------------------
+ * *  * JFFS2
+ */
+#define CFG_JFFS_CUSTOM_PART            /* board defined part   */
+#define CONFIG_JFFS2_CMDLINE
+#define MTDIDS_DEFAULT      "nor0=ath-nor0"
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#define CFG_RX_ETH_BUFFER   16
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE     32768
+#define CFG_ICACHE_SIZE     65536
+#define CFG_CACHELINE_SIZE  32
+
+/*
+ * Address map
+ */
+#define ATH_PCI_MEM_BASE        0x10000000  /* 128M */
+#define ATH_APB_BASE            0x18000000  /* 384M */
+#define ATH_GE0_BASE            0x19000000  /* 16M */
+#define ATH_GE1_BASE            0x1a000000  /* 16M */
+#define ATH_USB_OHCI_BASE       0x1b000000
+#define ATH_USB_EHCI_BASE       0x1b000000
+#define ATH_USB_EHCI_BASE_1     0x1b000000
+#define ATH_USB_EHCI_BASE_2     0x1b400000
+#define ATH_SPI_BASE            0x1f000000
+
+/*
+ * Added the PCI LCL RESET register from u-boot
+ * ath_soc.h so that we can query the PCI LCL RESET
+ * register for the presence of WLAN H/W.
+ */
+
+#define ATH_PCI_LCL_BASE        (ATH_APB_BASE+0x00280000)
+#define ATH_PCI_LCL_APP         (ATH_PCI_LCL_BASE+0x00)
+#define ATH_PCI_LCL_RESET       (ATH_PCI_LCL_BASE+0x18)
+
+/*
+ * APB block
+ */
+#define ATH_DDR_CTL_BASE        ATH_APB_BASE+0x00000000
+#define ATH_CPU_BASE            ATH_APB_BASE+0x00010000
+#define ATH_UART_BASE           ATH_APB_BASE+0x00020000
+#define ATH_USB_CONFIG_BASE     ATH_APB_BASE+0x00030000
+#define ATH_GPIO_BASE           ATH_APB_BASE+0x00040000
+#define ATH_PLL_BASE            ATH_APB_BASE+0x00050000
+#define ATH_RESET_BASE          ATH_APB_BASE+0x00060000
+#define ATH_DMA_BASE            ATH_APB_BASE+0x000A0000
+#define ATH_PCI_CTLR_BASE       ATH_APB_BASE+0x00280000
+
+#define ATH_NAND_FLASH_BASE     0x1b800000u
+
+
+/*
+ * DDR Config values
+ */
+#define ATH_DDR_CONFIG_16BIT        (1 << 31)
+#define ATH_DDR_CONFIG_PAGE_OPEN    (1 << 30)
+#define ATH_DDR_CONFIG_CAS_LAT_SHIFT    27
+#define ATH_DDR_CONFIG_TMRD_SHIFT   23
+#define ATH_DDR_CONFIG_TRFC_SHIFT   17
+#define ATH_DDR_CONFIG_TRRD_SHIFT   13
+#define ATH_DDR_CONFIG_TRP_SHIFT    9
+#define ATH_DDR_CONFIG_TRCD_SHIFT   5
+#define ATH_DDR_CONFIG_TRAS_SHIFT   0
+
+#define ATH_DDR_CONFIG2_BL2     (2 << 0)
+#define ATH_DDR_CONFIG2_BL4     (4 << 0)
+#define ATH_DDR_CONFIG2_BL8     (8 << 0)
+
+#define ATH_DDR_CONFIG2_BT_IL       (1 << 4)
+#define ATH_DDR_CONFIG2_CNTL_OE_EN  (1 << 5)
+#define ATH_DDR_CONFIG2_PHASE_SEL   (1 << 6)
+#define ATH_DDR_CONFIG2_DRAM_CKE    (1 << 7)
+#define ATH_DDR_CONFIG2_TWR_SHIFT   8
+#define ATH_DDR_CONFIG2_TRTW_SHIFT  12
+#define ATH_DDR_CONFIG2_TRTP_SHIFT  17
+#define ATH_DDR_CONFIG2_TWTR_SHIFT  21
+#define ATH_DDR_CONFIG2_HALF_WIDTH_L    (1 << 31)
+
+#define ATH_DDR_TAP_DEFAULT     0x10
+
+/*
+ * DDR block, gmac flushing
+ */
+#define ATH_DDR_GE0_FLUSH       ATH_DDR_CTL_BASE+0x9c
+#define ATH_DDR_GE1_FLUSH       ATH_DDR_CTL_BASE+0xa0
+#define ATH_DDR_USB_FLUSH       ATH_DDR_CTL_BASE+0xa4
+#define ATH_DDR_PCIE_FLUSH      ATH_DDR_CTL_BASE+0xa8
+
+#define ATH_EEPROM_GE0_MAC_ADDR     0xbfff1000
+#define ATH_EEPROM_GE1_MAC_ADDR     0xbfff1006
+
+/*
+ * PLL block/CPU
+ */
+
+#define ATH_PLL_CONFIG          ATH_PLL_BASE+0x0
+#define ATH_PLL_CONFIG1         ATH_PLL_BASE+0x4
+#define ATH_DDR_CLK_CTRL        ATH_PLL_BASE+0x10
+
+#define ATH_DDR_PLL_CONFIG      ATH_PLL_BASE+0x8
+#define ATH_DDR_PLL_CONFIG1     ATH_PLL_BASE+0xc
+#define ATH_ETH_XMII_CONFIG     ATH_PLL_BASE+0x30
+
+
+/*
+ * USB block
+ */
+#define ATH_USB_FLADJ_VAL       ATH_USB_CONFIG_BASE
+#define ATH_USB_CONFIG          ATH_USB_CONFIG_BASE+0x4
+#define ATH_USB_WINDOW          0x10000
+#define ATH_USB_MODE            ATH_USB_EHCI_BASE+0x1a8
+
+/*
+ * PCI block
+ */
+#define ATH_PCI_WINDOW          0x8000000 /* 128MB */
+#define ATH_PCI_WINDOW0_OFFSET      ATH_DDR_CTL_BASE+0x7c
+#define ATH_PCI_WINDOW1_OFFSET      ATH_DDR_CTL_BASE+0x80
+#define ATH_PCI_WINDOW2_OFFSET      ATH_DDR_CTL_BASE+0x84
+#define ATH_PCI_WINDOW3_OFFSET      ATH_DDR_CTL_BASE+0x88
+#define ATH_PCI_WINDOW4_OFFSET      ATH_DDR_CTL_BASE+0x8c
+#define ATH_PCI_WINDOW5_OFFSET      ATH_DDR_CTL_BASE+0x90
+#define ATH_PCI_WINDOW6_OFFSET      ATH_DDR_CTL_BASE+0x94
+#define ATH_PCI_WINDOW7_OFFSET      ATH_DDR_CTL_BASE+0x98
+
+#define ATH_PCI_WINDOW0_VAL     0x10000000
+#define ATH_PCI_WINDOW1_VAL     0x11000000
+#define ATH_PCI_WINDOW2_VAL     0x12000000
+#define ATH_PCI_WINDOW3_VAL     0x13000000
+#define ATH_PCI_WINDOW4_VAL     0x14000000
+#define ATH_PCI_WINDOW5_VAL     0x15000000
+#define ATH_PCI_WINDOW6_VAL     0x16000000
+#define ATH_PCI_WINDOW7_VAL     0x07000000
+
+#define ath_write_pci_window(_no)   \
+    ath_reg_wr(ATH_PCI_WINDOW##_no##_OFFSET, ATH_PCI_WINDOW##_no##_VAL);
+
+/*
+ * CRP. To access the host controller config and status registers
+ */
+
+//#define ATH_PCI_CRP           0x180c0000
+//#define ATH_PCI_DEV_CFGBASE   0x14000000
+#define ATH_PCI_CRP             0x18250000
+#define ATH_PCI_DEV_CFGBASE     0x16000000
+#define ATH_PCI_CRP_AD_CBE      ATH_PCI_CRP
+#define ATH_PCI_CRP_WRDATA      ATH_PCI_CRP+0x4
+#define ATH_PCI_CRP_RDDATA      ATH_PCI_CRP+0x8
+#define ATH_PCI_ERROR           ATH_PCI_CRP+0x1c
+#define ATH_PCI_ERROR_ADDRESS       ATH_PCI_CRP+0x20
+#define ATH_PCI_AHB_ERROR       ATH_PCI_CRP+0x24
+#define ATH_PCI_AHB_ERROR_ADDRESS   ATH_PCI_CRP+0x28
+
+#define ATH_CRP_CMD_WRITE       0x00010000
+#define ATH_CRP_CMD_READ        0x00000000
+
+/*
+ * PCI CFG. To generate config cycles
+ */
+#define ATH_PCI_CFG_AD          ATH_PCI_CRP+0xc
+#define ATH_PCI_CFG_CBE         ATH_PCI_CRP+0x10
+#define ATH_PCI_CFG_WRDATA      ATH_PCI_CRP+0x14
+#define ATH_PCI_CFG_RDDATA      ATH_PCI_CRP+0x18
+#define ATH_CFG_CMD_READ        0x0000000a
+#define ATH_CFG_CMD_WRITE       0x0000000b
+
+#define ATH_PCI_IDSEL_ADLINE_START  17
+
+#define ATH_SPI_FS      (ATH_SPI_BASE+0x00)
+#define ATH_SPI_READ        (ATH_SPI_BASE+0x00)
+#define ATH_SPI_CLOCK       (ATH_SPI_BASE+0x04)
+#define ATH_SPI_WRITE       (ATH_SPI_BASE+0x08)
+#define ATH_SPI_RD_STATUS   (ATH_SPI_BASE+0x0c)
+#define ATH_SPI_SHIFT_DO    (ATH_SPI_BASE+0x10)
+#define ATH_SPI_SHIFT_CNT   (ATH_SPI_BASE+0x14)
+#define ATH_SPI_SHIFT_DI    (ATH_SPI_BASE+0x18)
+#define ATH_SPI_D0_HIGH     (1<<0)  /* Pin spi_do */
+#define ATH_SPI_CLK_HIGH    (1<<8)  /* Pin spi_clk */
+
+#define ATH_SPI_CS_ENABLE_0 (6<<16) /* Pin gpio/cs0 (active low) */
+#define ATH_SPI_CS_ENABLE_1 (5<<16) /* Pin gpio/cs1 (active low) */
+#define ATH_SPI_CS_ENABLE_2 (3<<16) /* Pin gpio/cs2 (active low) */
+#define ATH_SPI_CS_DIS      0x70000
+#define ATH_SPI_CE_LOW      0x60000
+#define ATH_SPI_CE_HIGH     0x60100
+
+#define ATH_SPI_SECTOR_SIZE (1024*64)
+#define ATH_SPI_PAGE_SIZE   256
+
+#define ATH_RESET_GE0_MAC   RST_RESET_GE0_MAC_RESET_SET(1)
+#define ATH_RESET_GE0_PHY   (0) // Nothing similar to wasp??
+#define ATH_RESET_GE1_MAC   RST_RESET_GE1_MAC_RESET_SET(1)
+#define ATH_RESET_GE1_PHY   (0) // Nothing similar to wasp??
+#define ATH_RESET_GE0_MDIO  RST_RESET_GE0_MDIO_RESET_SET(1)
+#define ATH_RESET_GE1_MDIO  RST_RESET_GE1_MDIO_RESET_SET(1)
+
+/*
+ * SOC
+ */
+#define ATH_SPI_CMD_WRITE_SR        0x01
+#define ATH_SPI_CMD_WREN        0x06
+#define ATH_SPI_CMD_RD_STATUS       0x05
+#define ATH_SPI_CMD_FAST_READ       0x0b
+#define ATH_SPI_CMD_PAGE_PROG       0x02
+#define ATH_SPI_CMD_SECTOR_ERASE    0xd8
+#define ATH_SPI_CMD_CHIP_ERASE      0xc7
+#define ATH_SPI_CMD_RDID        0x9f
+
+#if defined(CFG_ATH_EMULATION)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(2) // 80 MHz
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(1) // 40 MHz
+
+#elif (CFG_PLL_FREQ == CFG_PLL_750_400_250) //DDR1 CAL = 3
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x1e)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0x1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0x1)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa24
+
+#elif (CFG_PLL_FREQ == CFG_PLL_775_650_258) //DDR2 CAL = 5
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x1f)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+                        
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x1a)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa12
+
+#elif (CFG_PLL_FREQ == CFG_PLL_800_450_266) //DDR2 CAL = 4
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+                        
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x24)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0x1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0x1)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa12
+
+#elif (CFG_PLL_FREQ == CFG_PLL_800_533_266) //DDR2 CAL = 5
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+                        
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x2a)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0x1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0x1)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0x28f56) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa12
+
+#elif (CFG_PLL_FREQ == CFG_PLL_800_600_266) //DDR2 CAL = 5
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+                        
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x18)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa12
+
+#elif (CFG_PLL_FREQ == CFG_PLL_800_600_300) //DDR2 CAL = 5
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+                        
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x18)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0x1)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa12
+
+#elif (CFG_PLL_FREQ == CFG_PLL_800_666_266) //DDR2 CAL = 5
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+                        
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x1a)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0x28f56) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa12
+
+#elif (CFG_PLL_FREQ == CFG_PLL_800_667_266) //DDR2 CAL = 6
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+                        
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x1a)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0x2b84e) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa12
+
+#elif (CFG_PLL_FREQ == CFG_PLL_750_667_250) //DDR2 CAL = 6
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x1e)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+                        
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x1a)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0x2b84e) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa12
+
+#elif (CFG_PLL_FREQ == CFG_PLL_800_700_266) //DDR2 CAL = 6
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+                        
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x1c)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0x0) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa12
+
+#elif (CFG_PLL_FREQ == CFG_PLL_810_666_270) //DDR2 CAL = 5
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0x19994) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+                        
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x1a)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0x28f56) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa12
+
+#elif (CFG_PLL_FREQ == CFG_PLL_810_700_270) //DDR2 CAL = 6
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0x19994) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+                        
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x1c)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0x0) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa12
+
+#elif (CFG_PLL_FREQ == CFG_PLL_750_393_196) //DDR1 CAL = 3
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x1e)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x1f)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0x1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0x1)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0x1c28c) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0x1)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa24
+
+#elif (CFG_PLL_FREQ == CFG_PLL_810_400_270) //DDR1 CAL = 3
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0x19994) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0x1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0x1)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa24
+
+#elif (CFG_PLL_FREQ == CFG_PLL_800_333_266) //DDR1 CAL = 3
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x1a)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0x1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0x1)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0x28f56) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa24
+
+#elif (CFG_PLL_FREQ == CFG_PLL_800_400_266) //DDR1 CAL = 3
+
+#define CPU_DDR_SYNC_MODE                   DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG1_NINT_VAL            CPU_PLL_CONFIG1_NINT_SET(0x20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL          CPU_PLL_CONFIG_REFDIV_SET(0x1)
+#define CPU_PLL_CONFIG_RANGE_VAL            CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2         CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER1_VAL                 CPU_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            CPU_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            CPU_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define CPU_PLL_DITHER2_VAL                 CPU_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define DDR_PLL_CONFIG1_NINT_VAL            DDR_PLL_CONFIG1_NINT_SET(0x20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL          DDR_PLL_CONFIG_REFDIV_SET(0x1)
+#define DDR_PLL_CONFIG_RANGE_VAL            DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1         DDR_PLL_CONFIG_OUTDIV_SET(0x1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2         DDR_PLL_CONFIG_OUTDIV_SET(0x1)
+#define DDR_PLL_DITHER1_VAL                 DDR_PLL_DITHER1_DITHER_EN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_MIN_SET(0) | \
+                                            DDR_PLL_DITHER1_NFRAC_STEP_SET(0) | \
+                                            DDR_PLL_DITHER1_UPDATE_COUNT_SET(0x0)
+
+#define DDR_PLL_DITHER2_VAL                 DDR_PLL_DITHER2_NFRAC_MAX_SET(0x0)
+
+#define AHB_CLK_FROM_DDR                    CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU            CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL   CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0x2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV  CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV  CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#define DDR_FSM_WAIT_CTRL_VAL				0xa24
+
+#else
+#   error "CFG_PLL_FREQ not set"
+#endif  // CFG_PLL_FREQ
+
+#if CPU_AND_DDR_CLK_FROM_DDR && CPU_AND_DDR_CLK_FROM_CPU
+#   error "Incorrect settings. Both 'from CPU' and 'from DDR' set"
+#endif
+
+
+
+#define __nint_to_mhz(n, ref)   ((n) * (ref) * 1000000)
+#define __cpu_hz_40(pll)    (__nint_to_mhz(CPU_PLL_CONFIG1_NINT_GET(pll), 40))
+#define __cpu_hz_25(pll)    (__nint_to_mhz(CPU_PLL_CONFIG1_NINT_GET(pll), 25))
+
+/* Since the count is incremented every other tick, divide by 2 */
+#define CFG_HZ          (__cpu_hz_25(CPU_PLL_CONFIG1_NINT_VAL) / 2)
+
+/* SGMII DEFINES */
+
+// 32'h18070034 (SGMII_CONFIG)
+#define SGMII_CONFIG_BERT_ENABLE_MSB                                 14
+#define SGMII_CONFIG_BERT_ENABLE_LSB                                 14
+#define SGMII_CONFIG_BERT_ENABLE_MASK                                0x00004000
+#define SGMII_CONFIG_BERT_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_BERT_ENABLE_MASK) >> SGMII_CONFIG_BERT_ENABLE_LSB)
+#define SGMII_CONFIG_BERT_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_BERT_ENABLE_LSB) & SGMII_CONFIG_BERT_ENABLE_MASK)
+#define SGMII_CONFIG_BERT_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_PRBS_ENABLE_MSB                                 13
+#define SGMII_CONFIG_PRBS_ENABLE_LSB                                 13
+#define SGMII_CONFIG_PRBS_ENABLE_MASK                                0x00002000
+#define SGMII_CONFIG_PRBS_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_PRBS_ENABLE_MASK) >> SGMII_CONFIG_PRBS_ENABLE_LSB)
+#define SGMII_CONFIG_PRBS_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_PRBS_ENABLE_LSB) & SGMII_CONFIG_PRBS_ENABLE_MASK)
+#define SGMII_CONFIG_PRBS_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_MDIO_COMPLETE_MSB                               12
+#define SGMII_CONFIG_MDIO_COMPLETE_LSB                               12
+#define SGMII_CONFIG_MDIO_COMPLETE_MASK                              0x00001000
+#define SGMII_CONFIG_MDIO_COMPLETE_GET(x)                            (((x) & SGMII_CONFIG_MDIO_COMPLETE_MASK) >> SGMII_CONFIG_MDIO_COMPLETE_LSB)
+#define SGMII_CONFIG_MDIO_COMPLETE_SET(x)                            (((x) << SGMII_CONFIG_MDIO_COMPLETE_LSB) & SGMII_CONFIG_MDIO_COMPLETE_MASK)
+#define SGMII_CONFIG_MDIO_COMPLETE_RESET                             0x0 // 0
+#define SGMII_CONFIG_MDIO_PULSE_MSB                                  11
+#define SGMII_CONFIG_MDIO_PULSE_LSB                                  11
+#define SGMII_CONFIG_MDIO_PULSE_MASK                                 0x00000800
+#define SGMII_CONFIG_MDIO_PULSE_GET(x)                               (((x) & SGMII_CONFIG_MDIO_PULSE_MASK) >> SGMII_CONFIG_MDIO_PULSE_LSB)
+#define SGMII_CONFIG_MDIO_PULSE_SET(x)                               (((x) << SGMII_CONFIG_MDIO_PULSE_LSB) & SGMII_CONFIG_MDIO_PULSE_MASK)
+#define SGMII_CONFIG_MDIO_PULSE_RESET                                0x0 // 0
+#define SGMII_CONFIG_MDIO_ENABLE_MSB                                 10
+#define SGMII_CONFIG_MDIO_ENABLE_LSB                                 10
+#define SGMII_CONFIG_MDIO_ENABLE_MASK                                0x00000400
+#define SGMII_CONFIG_MDIO_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_MDIO_ENABLE_MASK) >> SGMII_CONFIG_MDIO_ENABLE_LSB)
+#define SGMII_CONFIG_MDIO_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_MDIO_ENABLE_LSB) & SGMII_CONFIG_MDIO_ENABLE_MASK)
+#define SGMII_CONFIG_MDIO_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_MSB                            9
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_LSB                            9
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_MASK                           0x00000200
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_GET(x)                         (((x) & SGMII_CONFIG_NEXT_PAGE_LOADED_MASK) >> SGMII_CONFIG_NEXT_PAGE_LOADED_LSB)
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_SET(x)                         (((x) << SGMII_CONFIG_NEXT_PAGE_LOADED_LSB) & SGMII_CONFIG_NEXT_PAGE_LOADED_MASK)
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_RESET                          0x0 // 0
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MSB                         8
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB                         8
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK                        0x00000100
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_GET(x)                      (((x) & SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK) >> SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB)
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_SET(x)                      (((x) << SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB) & SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK)
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_RESET                       0x0 // 0
+#define SGMII_CONFIG_SPEED_MSB                                       7
+#define SGMII_CONFIG_SPEED_LSB                                       6
+#define SGMII_CONFIG_SPEED_MASK                                      0x000000c0
+#define SGMII_CONFIG_SPEED_GET(x)                                    (((x) & SGMII_CONFIG_SPEED_MASK) >> SGMII_CONFIG_SPEED_LSB)
+#define SGMII_CONFIG_SPEED_SET(x)                                    (((x) << SGMII_CONFIG_SPEED_LSB) & SGMII_CONFIG_SPEED_MASK)
+#define SGMII_CONFIG_SPEED_RESET                                     0x0 // 0
+#define SGMII_CONFIG_FORCE_SPEED_MSB                                 5
+#define SGMII_CONFIG_FORCE_SPEED_LSB                                 5
+#define SGMII_CONFIG_FORCE_SPEED_MASK                                0x00000020
+#define SGMII_CONFIG_FORCE_SPEED_GET(x)                              (((x) & SGMII_CONFIG_FORCE_SPEED_MASK) >> SGMII_CONFIG_FORCE_SPEED_LSB)
+#define SGMII_CONFIG_FORCE_SPEED_SET(x)                              (((x) << SGMII_CONFIG_FORCE_SPEED_LSB) & SGMII_CONFIG_FORCE_SPEED_MASK)
+#define SGMII_CONFIG_FORCE_SPEED_RESET                               0x0 // 0
+#define SGMII_CONFIG_MR_REG4_CHANGED_MSB                             4
+#define SGMII_CONFIG_MR_REG4_CHANGED_LSB                             4
+#define SGMII_CONFIG_MR_REG4_CHANGED_MASK                            0x00000010
+#define SGMII_CONFIG_MR_REG4_CHANGED_GET(x)                          (((x) & SGMII_CONFIG_MR_REG4_CHANGED_MASK) >> SGMII_CONFIG_MR_REG4_CHANGED_LSB)
+#define SGMII_CONFIG_MR_REG4_CHANGED_SET(x)                          (((x) << SGMII_CONFIG_MR_REG4_CHANGED_LSB) & SGMII_CONFIG_MR_REG4_CHANGED_MASK)
+#define SGMII_CONFIG_MR_REG4_CHANGED_RESET                           0x0 // 0
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MSB                       3
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB                       3
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK                      0x00000008
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_GET(x)                    (((x) & SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK) >> SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB)
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_SET(x)                    (((x) << SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB) & SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK)
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_RESET                     0x0 // 0
+#define SGMII_CONFIG_MODE_CTRL_MSB                                   2
+#define SGMII_CONFIG_MODE_CTRL_LSB                                   0
+#define SGMII_CONFIG_MODE_CTRL_MASK                                  0x00000007
+#define SGMII_CONFIG_MODE_CTRL_GET(x)                                (((x) & SGMII_CONFIG_MODE_CTRL_MASK) >> SGMII_CONFIG_MODE_CTRL_LSB)
+#define SGMII_CONFIG_MODE_CTRL_SET(x)                                (((x) << SGMII_CONFIG_MODE_CTRL_LSB) & SGMII_CONFIG_MODE_CTRL_MASK)
+#define SGMII_CONFIG_MODE_CTRL_RESET                                 0x0 // 0
+#define SGMII_CONFIG_ADDRESS                                         0x18070034
+
+
+
+// 32'h1807001c (MR_AN_CONTROL)
+#define MR_AN_CONTROL_PHY_RESET_MSB                                  15
+#define MR_AN_CONTROL_PHY_RESET_LSB                                  15
+#define MR_AN_CONTROL_PHY_RESET_MASK                                 0x00008000
+#define MR_AN_CONTROL_PHY_RESET_GET(x)                               (((x) & MR_AN_CONTROL_PHY_RESET_MASK) >> MR_AN_CONTROL_PHY_RESET_LSB)
+#define MR_AN_CONTROL_PHY_RESET_SET(x)                               (((x) << MR_AN_CONTROL_PHY_RESET_LSB) & MR_AN_CONTROL_PHY_RESET_MASK)
+#define MR_AN_CONTROL_PHY_RESET_RESET                                0x0 // 0
+#define MR_AN_CONTROL_LOOPBACK_MSB                                   14
+#define MR_AN_CONTROL_LOOPBACK_LSB                                   14
+#define MR_AN_CONTROL_LOOPBACK_MASK                                  0x00004000
+#define MR_AN_CONTROL_LOOPBACK_GET(x)                                (((x) & MR_AN_CONTROL_LOOPBACK_MASK) >> MR_AN_CONTROL_LOOPBACK_LSB)
+#define MR_AN_CONTROL_LOOPBACK_SET(x)                                (((x) << MR_AN_CONTROL_LOOPBACK_LSB) & MR_AN_CONTROL_LOOPBACK_MASK)
+#define MR_AN_CONTROL_LOOPBACK_RESET                                 0x0 // 0
+#define MR_AN_CONTROL_SPEED_SEL0_MSB                                 13
+#define MR_AN_CONTROL_SPEED_SEL0_LSB                                 13
+#define MR_AN_CONTROL_SPEED_SEL0_MASK                                0x00002000
+#define MR_AN_CONTROL_SPEED_SEL0_GET(x)                              (((x) & MR_AN_CONTROL_SPEED_SEL0_MASK) >> MR_AN_CONTROL_SPEED_SEL0_LSB)
+#define MR_AN_CONTROL_SPEED_SEL0_SET(x)                              (((x) << MR_AN_CONTROL_SPEED_SEL0_LSB) & MR_AN_CONTROL_SPEED_SEL0_MASK)
+#define MR_AN_CONTROL_SPEED_SEL0_RESET                               0x0 // 0
+#define MR_AN_CONTROL_AN_ENABLE_MSB                                  12
+#define MR_AN_CONTROL_AN_ENABLE_LSB                                  12
+#define MR_AN_CONTROL_AN_ENABLE_MASK                                 0x00001000
+#define MR_AN_CONTROL_AN_ENABLE_GET(x)                               (((x) & MR_AN_CONTROL_AN_ENABLE_MASK) >> MR_AN_CONTROL_AN_ENABLE_LSB)
+#define MR_AN_CONTROL_AN_ENABLE_SET(x)                               (((x) << MR_AN_CONTROL_AN_ENABLE_LSB) & MR_AN_CONTROL_AN_ENABLE_MASK)
+#define MR_AN_CONTROL_AN_ENABLE_RESET                                0x1 // 1
+#define MR_AN_CONTROL_POWER_DOWN_MSB                                 11
+#define MR_AN_CONTROL_POWER_DOWN_LSB                                 11
+#define MR_AN_CONTROL_POWER_DOWN_MASK                                0x00000800
+#define MR_AN_CONTROL_POWER_DOWN_GET(x)                              (((x) & MR_AN_CONTROL_POWER_DOWN_MASK) >> MR_AN_CONTROL_POWER_DOWN_LSB)
+#define MR_AN_CONTROL_POWER_DOWN_SET(x)                              (((x) << MR_AN_CONTROL_POWER_DOWN_LSB) & MR_AN_CONTROL_POWER_DOWN_MASK)
+#define MR_AN_CONTROL_POWER_DOWN_RESET                               0x0 // 0
+#define MR_AN_CONTROL_RESTART_AN_MSB                                 9
+#define MR_AN_CONTROL_RESTART_AN_LSB                                 9
+#define MR_AN_CONTROL_RESTART_AN_MASK                                0x00000200
+#define MR_AN_CONTROL_RESTART_AN_GET(x)                              (((x) & MR_AN_CONTROL_RESTART_AN_MASK) >> MR_AN_CONTROL_RESTART_AN_LSB)
+#define MR_AN_CONTROL_RESTART_AN_SET(x)                              (((x) << MR_AN_CONTROL_RESTART_AN_LSB) & MR_AN_CONTROL_RESTART_AN_MASK)
+#define MR_AN_CONTROL_RESTART_AN_RESET                               0x0 // 0
+#define MR_AN_CONTROL_DUPLEX_MODE_MSB                                8
+#define MR_AN_CONTROL_DUPLEX_MODE_LSB                                8
+#define MR_AN_CONTROL_DUPLEX_MODE_MASK                               0x00000100
+#define MR_AN_CONTROL_DUPLEX_MODE_GET(x)                             (((x) & MR_AN_CONTROL_DUPLEX_MODE_MASK) >> MR_AN_CONTROL_DUPLEX_MODE_LSB)
+#define MR_AN_CONTROL_DUPLEX_MODE_SET(x)                             (((x) << MR_AN_CONTROL_DUPLEX_MODE_LSB) & MR_AN_CONTROL_DUPLEX_MODE_MASK)
+#define MR_AN_CONTROL_DUPLEX_MODE_RESET                              0x1 // 1
+#define MR_AN_CONTROL_SPEED_SEL1_MSB                                 6
+#define MR_AN_CONTROL_SPEED_SEL1_LSB                                 6
+#define MR_AN_CONTROL_SPEED_SEL1_MASK                                0x00000040
+#define MR_AN_CONTROL_SPEED_SEL1_GET(x)                              (((x) & MR_AN_CONTROL_SPEED_SEL1_MASK) >> MR_AN_CONTROL_SPEED_SEL1_LSB)
+#define MR_AN_CONTROL_SPEED_SEL1_SET(x)                              (((x) << MR_AN_CONTROL_SPEED_SEL1_LSB) & MR_AN_CONTROL_SPEED_SEL1_MASK)
+#define MR_AN_CONTROL_SPEED_SEL1_RESET                               0x1 // 1
+#define MR_AN_CONTROL_ADDRESS                                        0x1807001c
+
+
+
+
+
+// 32'h18070014 (SGMII_RESET)
+#define SGMII_RESET_HW_RX_125M_N_MSB                                 4
+#define SGMII_RESET_HW_RX_125M_N_LSB                                 4
+#define SGMII_RESET_HW_RX_125M_N_MASK                                0x00000010
+#define SGMII_RESET_HW_RX_125M_N_GET(x)                              (((x) & SGMII_RESET_HW_RX_125M_N_MASK) >> SGMII_RESET_HW_RX_125M_N_LSB)
+#define SGMII_RESET_HW_RX_125M_N_SET(x)                              (((x) << SGMII_RESET_HW_RX_125M_N_LSB) & SGMII_RESET_HW_RX_125M_N_MASK)
+#define SGMII_RESET_HW_RX_125M_N_RESET                               0x0 // 0
+#define SGMII_RESET_TX_125M_N_MSB                                    3
+#define SGMII_RESET_TX_125M_N_LSB                                    3
+#define SGMII_RESET_TX_125M_N_MASK                                   0x00000008
+#define SGMII_RESET_TX_125M_N_GET(x)                                 (((x) & SGMII_RESET_TX_125M_N_MASK) >> SGMII_RESET_TX_125M_N_LSB)
+#define SGMII_RESET_TX_125M_N_SET(x)                                 (((x) << SGMII_RESET_TX_125M_N_LSB) & SGMII_RESET_TX_125M_N_MASK)
+#define SGMII_RESET_TX_125M_N_RESET                                  0x0 // 0
+#define SGMII_RESET_RX_125M_N_MSB                                    2
+#define SGMII_RESET_RX_125M_N_LSB                                    2
+#define SGMII_RESET_RX_125M_N_MASK                                   0x00000004
+#define SGMII_RESET_RX_125M_N_GET(x)                                 (((x) & SGMII_RESET_RX_125M_N_MASK) >> SGMII_RESET_RX_125M_N_LSB)
+#define SGMII_RESET_RX_125M_N_SET(x)                                 (((x) << SGMII_RESET_RX_125M_N_LSB) & SGMII_RESET_RX_125M_N_MASK)
+#define SGMII_RESET_RX_125M_N_RESET                                  0x0 // 0
+#define SGMII_RESET_TX_CLK_N_MSB                                     1
+#define SGMII_RESET_TX_CLK_N_LSB                                     1
+#define SGMII_RESET_TX_CLK_N_MASK                                    0x00000002
+#define SGMII_RESET_TX_CLK_N_GET(x)                                  (((x) & SGMII_RESET_TX_CLK_N_MASK) >> SGMII_RESET_TX_CLK_N_LSB)
+#define SGMII_RESET_TX_CLK_N_SET(x)                                  (((x) << SGMII_RESET_TX_CLK_N_LSB) & SGMII_RESET_TX_CLK_N_MASK)
+#define SGMII_RESET_TX_CLK_N_RESET                                   0x0 // 0
+#define SGMII_RESET_RX_CLK_N_MSB                                     0
+#define SGMII_RESET_RX_CLK_N_LSB                                     0
+#define SGMII_RESET_RX_CLK_N_MASK                                    0x00000001
+#define SGMII_RESET_RX_CLK_N_GET(x)                                  (((x) & SGMII_RESET_RX_CLK_N_MASK) >> SGMII_RESET_RX_CLK_N_LSB)
+#define SGMII_RESET_RX_CLK_N_SET(x)                                  (((x) << SGMII_RESET_RX_CLK_N_LSB) & SGMII_RESET_RX_CLK_N_MASK)
+#define SGMII_RESET_RX_CLK_N_RESET                                   0x0 // 0
+#define SGMII_RESET_ADDRESS                                          0x18070014
+
+
+
+// 32'h18070038 (SGMII_MAC_RX_CONFIG)
+#define SGMII_MAC_RX_CONFIG_LINK_MSB                                 15
+#define SGMII_MAC_RX_CONFIG_LINK_LSB                                 15
+#define SGMII_MAC_RX_CONFIG_LINK_MASK                                0x00008000
+#define SGMII_MAC_RX_CONFIG_LINK_GET(x)                              (((x) & SGMII_MAC_RX_CONFIG_LINK_MASK) >> SGMII_MAC_RX_CONFIG_LINK_LSB)
+#define SGMII_MAC_RX_CONFIG_LINK_SET(x)                              (((x) << SGMII_MAC_RX_CONFIG_LINK_LSB) & SGMII_MAC_RX_CONFIG_LINK_MASK)
+#define SGMII_MAC_RX_CONFIG_LINK_RESET                               0x0 // 0
+#define SGMII_MAC_RX_CONFIG_ACK_MSB                                  14
+#define SGMII_MAC_RX_CONFIG_ACK_LSB                                  14
+#define SGMII_MAC_RX_CONFIG_ACK_MASK                                 0x00004000
+#define SGMII_MAC_RX_CONFIG_ACK_GET(x)                               (((x) & SGMII_MAC_RX_CONFIG_ACK_MASK) >> SGMII_MAC_RX_CONFIG_ACK_LSB)
+#define SGMII_MAC_RX_CONFIG_ACK_SET(x)                               (((x) << SGMII_MAC_RX_CONFIG_ACK_LSB) & SGMII_MAC_RX_CONFIG_ACK_MASK)
+#define SGMII_MAC_RX_CONFIG_ACK_RESET                                0x0 // 0
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MSB                          12
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB                          12
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK                         0x00001000
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_GET(x)                       (((x) & SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK) >> SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB)
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_SET(x)                       (((x) << SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB) & SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK)
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_RESET                        0x0 // 0
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_MSB                           11
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB                           10
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK                          0x00000c00
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_GET(x)                        (((x) & SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK) >> SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB)
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_SET(x)                        (((x) << SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB) & SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK)
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_RESET                         0x0 // 0
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_MSB                            8
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB                            8
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK                           0x00000100
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_GET(x)                         (((x) & SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK) >> SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB)
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_SET(x)                         (((x) << SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB) & SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK)
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_RESET                          0x0 // 0
+#define SGMII_MAC_RX_CONFIG_PAUSE_MSB                                7
+#define SGMII_MAC_RX_CONFIG_PAUSE_LSB                                7
+#define SGMII_MAC_RX_CONFIG_PAUSE_MASK                               0x00000080
+#define SGMII_MAC_RX_CONFIG_PAUSE_GET(x)                             (((x) & SGMII_MAC_RX_CONFIG_PAUSE_MASK) >> SGMII_MAC_RX_CONFIG_PAUSE_LSB)
+#define SGMII_MAC_RX_CONFIG_PAUSE_SET(x)                             (((x) << SGMII_MAC_RX_CONFIG_PAUSE_LSB) & SGMII_MAC_RX_CONFIG_PAUSE_MASK)
+#define SGMII_MAC_RX_CONFIG_PAUSE_RESET                              0x0 // 0
+#define SGMII_MAC_RX_CONFIG_RES0_MSB                                 0
+#define SGMII_MAC_RX_CONFIG_RES0_LSB                                 0
+#define SGMII_MAC_RX_CONFIG_RES0_MASK                                0x00000001
+#define SGMII_MAC_RX_CONFIG_RES0_GET(x)                              (((x) & SGMII_MAC_RX_CONFIG_RES0_MASK) >> SGMII_MAC_RX_CONFIG_RES0_LSB)
+#define SGMII_MAC_RX_CONFIG_RES0_SET(x)                              (((x) << SGMII_MAC_RX_CONFIG_RES0_LSB) & SGMII_MAC_RX_CONFIG_RES0_MASK)
+#define SGMII_MAC_RX_CONFIG_RES0_RESET                               0x1 // 1
+#define SGMII_MAC_RX_CONFIG_ADDRESS                                  0x18070038
+
+// 32'h18070058 (SGMII_DEBUG)
+#define SGMII_DEBUG_ARB_STATE_MSB                                    27
+#define SGMII_DEBUG_ARB_STATE_LSB                                    24
+#define SGMII_DEBUG_ARB_STATE_MASK                                   0x0f000000
+#define SGMII_DEBUG_ARB_STATE_GET(x)                                 (((x) & SGMII_DEBUG_ARB_STATE_MASK) >> SGMII_DEBUG_ARB_STATE_LSB)
+#define SGMII_DEBUG_ARB_STATE_SET(x)                                 (((x) << SGMII_DEBUG_ARB_STATE_LSB) & SGMII_DEBUG_ARB_STATE_MASK)
+#define SGMII_DEBUG_ARB_STATE_RESET                                  0x0 // 0
+#define SGMII_DEBUG_RX_SYNC_STATE_MSB                                23
+#define SGMII_DEBUG_RX_SYNC_STATE_LSB                                16
+#define SGMII_DEBUG_RX_SYNC_STATE_MASK                               0x00ff0000
+#define SGMII_DEBUG_RX_SYNC_STATE_GET(x)                             (((x) & SGMII_DEBUG_RX_SYNC_STATE_MASK) >> SGMII_DEBUG_RX_SYNC_STATE_LSB)
+#define SGMII_DEBUG_RX_SYNC_STATE_SET(x)                             (((x) << SGMII_DEBUG_RX_SYNC_STATE_LSB) & SGMII_DEBUG_RX_SYNC_STATE_MASK)
+#define SGMII_DEBUG_RX_SYNC_STATE_RESET                              0x0 // 0
+#define SGMII_DEBUG_RX_STATE_MSB                                     15
+#define SGMII_DEBUG_RX_STATE_LSB                                     8
+#define SGMII_DEBUG_RX_STATE_MASK                                    0x0000ff00
+#define SGMII_DEBUG_RX_STATE_GET(x)                                  (((x) & SGMII_DEBUG_RX_STATE_MASK) >> SGMII_DEBUG_RX_STATE_LSB)
+#define SGMII_DEBUG_RX_STATE_SET(x)                                  (((x) << SGMII_DEBUG_RX_STATE_LSB) & SGMII_DEBUG_RX_STATE_MASK)
+#define SGMII_DEBUG_RX_STATE_RESET                                   0x0 // 0
+#define SGMII_DEBUG_TX_STATE_MSB                                     7
+#define SGMII_DEBUG_TX_STATE_LSB                                     0
+#define SGMII_DEBUG_TX_STATE_MASK                                    0x000000ff
+#define SGMII_DEBUG_TX_STATE_GET(x)                                  (((x) & SGMII_DEBUG_TX_STATE_MASK) >> SGMII_DEBUG_TX_STATE_LSB)
+#define SGMII_DEBUG_TX_STATE_SET(x)                                  (((x) << SGMII_DEBUG_TX_STATE_LSB) & SGMII_DEBUG_TX_STATE_MASK)
+#define SGMII_DEBUG_TX_STATE_RESET                                   0x0 // 0
+#define SGMII_DEBUG_ADDRESS                                          0x18070058
+#define SGMII_DEBUG_OFFSET                                           0x0058
+
+// 32'h18070060 (SGMII_INTERRUPT_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_MSB                                7
+#define SGMII_INTERRUPT_MASK_MASK_LSB                                0
+#define SGMII_INTERRUPT_MASK_MASK_MASK                               0x000000ff
+#define SGMII_INTERRUPT_MASK_MASK_GET(x)                             (((x) & SGMII_INTERRUPT_MASK_MASK_MASK) >> SGMII_INTERRUPT_MASK_MASK_LSB)
+#define SGMII_INTERRUPT_MASK_MASK_SET(x)                             (((x) << SGMII_INTERRUPT_MASK_MASK_LSB) & SGMII_INTERRUPT_MASK_MASK_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_RESET                              0x0 // 0
+#define SGMII_INTERRUPT_MASK_ADDRESS                                 0x18070060
+
+
+// 32'h1807005c (SGMII_INTERRUPT)
+#define SGMII_INTERRUPT_INTR_MSB                                     7
+#define SGMII_INTERRUPT_INTR_LSB                                     0
+#define SGMII_INTERRUPT_INTR_MASK                                    0x000000ff
+#define SGMII_INTERRUPT_INTR_GET(x)                                  (((x) & SGMII_INTERRUPT_INTR_MASK) >> SGMII_INTERRUPT_INTR_LSB)
+#define SGMII_INTERRUPT_INTR_SET(x)                                  (((x) << SGMII_INTERRUPT_INTR_LSB) & SGMII_INTERRUPT_INTR_MASK)
+#define SGMII_INTERRUPT_INTR_RESET                                   0x0 // 0
+#define SGMII_INTERRUPT_ADDRESS                                      0x1807005c
+#define SGMII_INTERRUPT_OFFSET                                       0x005c
+// SW modifiable bits
+#define SGMII_INTERRUPT_SW_MASK                                      0x000000ff
+// bits defined at reset
+#define SGMII_INTERRUPT_RSTMASK                                      0xffffffff
+// reset value (ignore bits undefined at reset)
+#define SGMII_INTERRUPT_RESET                                        0x00000000
+
+
+#define SGMII_LINK_FAIL             (1 << 0)
+#define SGMII_DUPLEX_ERR            (1 << 1)
+#define SGMII_MR_AN_COMPLETE            (1 << 2)
+#define SGMII_LINK_MAC_CHANGE           (1 << 3)
+#define SGMII_DUPLEX_MODE_CHANGE        (1 << 4)
+#define SGMII_SPEED_MODE_MAC_CHANGE     (1 << 5)
+#define SGMII_RX_QUIET_CHANGE           (1 << 6)
+#define SGMII_RX_MDIO_COMP_CHANGE       (1 << 7)
+
+#define SGMII_INTR              SGMII_LINK_FAIL | \
+                        SGMII_LINK_MAC_CHANGE | \
+                        SGMII_DUPLEX_MODE_CHANGE | \
+                        SGMII_SPEED_MODE_MAC_CHANGE
+
+
+// 32'h18050048 (ETH_SGMII)
+#define ETH_SGMII_TX_INVERT_MSB                                      31
+#define ETH_SGMII_TX_INVERT_LSB                                      31
+#define ETH_SGMII_TX_INVERT_MASK                                     0x80000000
+#define ETH_SGMII_TX_INVERT_GET(x)                                   (((x) & ETH_SGMII_TX_INVERT_MASK) >> ETH_SGMII_TX_INVERT_LSB)
+#define ETH_SGMII_TX_INVERT_SET(x)                                   (((x) << ETH_SGMII_TX_INVERT_LSB) & ETH_SGMII_TX_INVERT_MASK)
+#define ETH_SGMII_TX_INVERT_RESET                                    0x0 // 0
+#define ETH_SGMII_GIGE_QUAD_MSB                                      30
+#define ETH_SGMII_GIGE_QUAD_LSB                                      30
+#define ETH_SGMII_GIGE_QUAD_MASK                                     0x40000000
+#define ETH_SGMII_GIGE_QUAD_GET(x)                                   (((x) & ETH_SGMII_GIGE_QUAD_MASK) >> ETH_SGMII_GIGE_QUAD_LSB)
+#define ETH_SGMII_GIGE_QUAD_SET(x)                                   (((x) << ETH_SGMII_GIGE_QUAD_LSB) & ETH_SGMII_GIGE_QUAD_MASK)
+#define ETH_SGMII_GIGE_QUAD_RESET                                    0x0 // 0
+#define ETH_SGMII_RX_DELAY_MSB                                       29
+#define ETH_SGMII_RX_DELAY_LSB                                       28
+#define ETH_SGMII_RX_DELAY_MASK                                      0x30000000
+#define ETH_SGMII_RX_DELAY_GET(x)                                    (((x) & ETH_SGMII_RX_DELAY_MASK) >> ETH_SGMII_RX_DELAY_LSB)
+#define ETH_SGMII_RX_DELAY_SET(x)                                    (((x) << ETH_SGMII_RX_DELAY_LSB) & ETH_SGMII_RX_DELAY_MASK)
+#define ETH_SGMII_RX_DELAY_RESET                                     0x0 // 0
+#define ETH_SGMII_TX_DELAY_MSB                                       27
+#define ETH_SGMII_TX_DELAY_LSB                                       26
+#define ETH_SGMII_TX_DELAY_MASK                                      0x0c000000
+#define ETH_SGMII_TX_DELAY_GET(x)                                    (((x) & ETH_SGMII_TX_DELAY_MASK) >> ETH_SGMII_TX_DELAY_LSB)
+#define ETH_SGMII_TX_DELAY_SET(x)                                    (((x) << ETH_SGMII_TX_DELAY_LSB) & ETH_SGMII_TX_DELAY_MASK)
+#define ETH_SGMII_TX_DELAY_RESET                                     0x0 // 0
+#define ETH_SGMII_CLK_SEL_MSB                                        25
+#define ETH_SGMII_CLK_SEL_LSB                                        25
+#define ETH_SGMII_CLK_SEL_MASK                                       0x02000000
+#define ETH_SGMII_CLK_SEL_GET(x)                                     (((x) & ETH_SGMII_CLK_SEL_MASK) >> ETH_SGMII_CLK_SEL_LSB)
+#define ETH_SGMII_CLK_SEL_SET(x)                                     (((x) << ETH_SGMII_CLK_SEL_LSB) & ETH_SGMII_CLK_SEL_MASK)
+#define ETH_SGMII_CLK_SEL_RESET                                      0x1 // 1
+#define ETH_SGMII_GIGE_MSB                                           24
+#define ETH_SGMII_GIGE_LSB                                           24
+#define ETH_SGMII_GIGE_MASK                                          0x01000000
+#define ETH_SGMII_GIGE_GET(x)                                        (((x) & ETH_SGMII_GIGE_MASK) >> ETH_SGMII_GIGE_LSB)
+#define ETH_SGMII_GIGE_SET(x)                                        (((x) << ETH_SGMII_GIGE_LSB) & ETH_SGMII_GIGE_MASK)
+#define ETH_SGMII_GIGE_RESET                                         0x1 // 1
+#define ETH_SGMII_PHASE1_COUNT_MSB                                   15
+#define ETH_SGMII_PHASE1_COUNT_LSB                                   8
+#define ETH_SGMII_PHASE1_COUNT_MASK                                  0x0000ff00
+#define ETH_SGMII_PHASE1_COUNT_GET(x)                                (((x) & ETH_SGMII_PHASE1_COUNT_MASK) >> ETH_SGMII_PHASE1_COUNT_LSB)
+#define ETH_SGMII_PHASE1_COUNT_SET(x)                                (((x) << ETH_SGMII_PHASE1_COUNT_LSB) & ETH_SGMII_PHASE1_COUNT_MASK)
+#define ETH_SGMII_PHASE1_COUNT_RESET                                 0x1 // 1
+#define ETH_SGMII_PHASE0_COUNT_MSB                                   7
+#define ETH_SGMII_PHASE0_COUNT_LSB                                   0
+#define ETH_SGMII_PHASE0_COUNT_MASK                                  0x000000ff
+#define ETH_SGMII_PHASE0_COUNT_GET(x)                                (((x) & ETH_SGMII_PHASE0_COUNT_MASK) >> ETH_SGMII_PHASE0_COUNT_LSB)
+#define ETH_SGMII_PHASE0_COUNT_SET(x)                                (((x) << ETH_SGMII_PHASE0_COUNT_LSB) & ETH_SGMII_PHASE0_COUNT_MASK)
+#define ETH_SGMII_PHASE0_COUNT_RESET                                 0x1 // 1
+#define ETH_SGMII_ADDRESS                                            0x18050048
+
+
+#endif /* _QCA956X_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/ar7240_soc.h u-boot_1.1//include/ar7240_soc.h
--- u-boot//include/ar7240_soc.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/ar7240_soc.h	2014-02-18 01:46:27.611052889 -0800
@@ -0,0 +1,768 @@
+/*
+ * Atheror AR7240 series processor SOC registers
+ *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _AR7240_SOC_H
+#define _AR7240_SOC_H
+
+#include <config.h>
+
+#ifdef CONFIG_WASP_SUPPORT
+#include <ar934x_soc.h>
+#endif
+
+#ifdef CONFIG_AR7240_EMU
+#define AR7240_EMU 1
+#endif
+
+#ifdef CONFIG_WASP_EMU
+#define WASP_EMU 1
+#endif
+/*
+ * Address map
+ */
+#define AR7240_PCI_MEM_BASE             0x10000000  /* 128M */
+#define AR7240_APB_BASE                 0x18000000  /* 384M */
+#define AR7240_GE0_BASE                 0x19000000  /* 16M */
+#define AR7240_GE1_BASE                 0x1a000000  /* 16M */
+#define AR7240_USB_EHCI_BASE            0x1b000000
+#define AR7240_USB_OHCI_BASE            0x1c000000
+#define AR7240_SPI_BASE                 0x1f000000
+#define ATH_NAND_FLASH_BASE		0x1b000000u
+
+
+/*
+ * APB block
+ */
+#define AR7240_DDR_CTL_BASE             AR7240_APB_BASE+0x00000000
+#define AR7240_CPU_BASE                 AR7240_APB_BASE+0x00010000
+#define AR7240_UART_BASE                AR7240_APB_BASE+0x00020000
+#define AR7240_USB_CONFIG_BASE          AR7240_APB_BASE+0x00030000
+#define AR7240_GPIO_BASE                AR7240_APB_BASE+0x00040000
+#define AR7240_PLL_BASE                 AR7240_APB_BASE+0x00050000
+#define AR7240_RESET_BASE               AR7240_APB_BASE+0x00060000
+#define AR7240_PCI_LCL_BASE             AR7240_APB_BASE+0x000f0000
+
+/*
+ * DDR block
+ */
+
+#define AR7240_DDR_CONFIG               AR7240_DDR_CTL_BASE+0
+#define AR7240_DDR_CONFIG2              AR7240_DDR_CTL_BASE+4
+#define AR7240_DDR_MODE                 AR7240_DDR_CTL_BASE+0x08
+#define AR7240_DDR_EXT_MODE             AR7240_DDR_CTL_BASE+0x0c
+#define AR7240_DDR_CONTROL              AR7240_DDR_CTL_BASE+0x10
+#define AR7240_DDR_REFRESH              AR7240_DDR_CTL_BASE+0x14
+#define AR7240_DDR_RD_DATA_THIS_CYCLE   AR7240_DDR_CTL_BASE+0x18
+#define AR7240_DDR_TAP_CONTROL0         AR7240_DDR_CTL_BASE+0x1c
+#define AR7240_DDR_TAP_CONTROL1         AR7240_DDR_CTL_BASE+0x20
+#define AR7240_DDR_TAP_CONTROL2         AR7240_DDR_CTL_BASE+0x24
+#define AR7240_DDR_TAP_CONTROL3         AR7240_DDR_CTL_BASE+0x28
+#ifdef CONFIG_WASP
+#define AR7240_DDR_DDR2_CONFIG          AR7240_DDR_CTL_BASE+0xb8
+#else
+#define AR7240_DDR_DDR2_CONFIG          AR7240_DDR_CTL_BASE+0x8c
+#endif
+#define AR7240_DDR_BURST                AR7240_DDR_CTL_BASE+0xc4
+#define AR7240_DDR_BURST2               AR7240_DDR_CTL_BASE+0xc8
+#define AR7240_AHB_MASTER_TIMEOUT       AR7240_DDR_CTL_BASE+0xcc
+#define AR7240_DDR_CTL_CONFIG           AR7240_DDR_CTL_BASE+0x108
+#define AR7240_DDR_DEBUG_RD_CNTL	AR7240_DDR_CTL_BASE+0x118
+
+#define AR7240_DDR_CONFIG_16BIT             (1 << 31)
+#define AR7240_DDR_CONFIG_PAGE_OPEN         (1 << 30)
+#define AR7240_DDR_CONFIG_CAS_LAT_SHIFT      27
+#define AR7240_DDR_CONFIG_TMRD_SHIFT         23
+#define AR7240_DDR_CONFIG_TRFC_SHIFT         17
+#define AR7240_DDR_CONFIG_TRRD_SHIFT         13
+#define AR7240_DDR_CONFIG_TRP_SHIFT          9
+#define AR7240_DDR_CONFIG_TRCD_SHIFT         5
+#define AR7240_DDR_CONFIG_TRAS_SHIFT         0
+
+#define AR7240_DDR_CONFIG2_BL2          (2 << 0)
+#define AR7240_DDR_CONFIG2_BL4          (4 << 0)
+#define AR7240_DDR_CONFIG2_BL8          (8 << 0)
+
+#define AR7240_DDR_CONFIG2_BT_IL        (1 << 4)
+#define AR7240_DDR_CONFIG2_CNTL_OE_EN   (1 << 5)
+#define AR7240_DDR_CONFIG2_PHASE_SEL    (1 << 6)
+#define AR7240_DDR_CONFIG2_DRAM_CKE     (1 << 7)
+#define AR7240_DDR_CONFIG2_TWR_SHIFT    8
+#define AR7240_DDR_CONFIG2_TRTW_SHIFT   12
+#define AR7240_DDR_CONFIG2_TRTP_SHIFT   17
+#define AR7240_DDR_CONFIG2_TWTR_SHIFT   21
+#define AR7240_DDR_CONFIG2_HALF_WIDTH_L (1 << 31)
+
+#define AR7240_DDR_TAP_DEFAULT          0x18
+
+/*
+ * PLL
+ */
+#define AR7240_CPU_PLL_CONFIG           AR7240_PLL_BASE
+#define AR7240_USB_PLL_CONFIG           AR7240_PLL_BASE+0x4
+#define AR7240_PCIE_PLL_CONFIG          AR7240_PLL_BASE+0x10
+#define AR7240_CPU_CLOCK_CONTROL        AR7240_PLL_BASE+8
+
+#ifndef CONFIG_WASP_SUPPORT
+#define AR7240_USB_PLL_GE0_OFFSET       AR7240_PLL_BASE+0x10
+#define AR7240_USB_PLL_GE1_OFFSET       AR7240_PLL_BASE+0x14
+#define AR7240_S26_CLK_CTRL_OFFSET      AR7240_PLL_BASE+0x24
+#endif
+#define AR7242_ETH_XMII_CONFIG          AR7240_PLL_BASE+0x2c
+
+#define AR934X_CPU_PLL_DITHER                 AR7240_PLL_BASE+0x0048
+#define AR934X_DDR_PLL_DITHER                 AR7240_PLL_BASE+0x0044
+#define AR934X_BB_PLL_CONFIG                  AR7240_PLL_BASE+0x0040
+#define AR934X_CURRENT_AUDIO_PLL_MODULATION   AR7240_PLL_BASE+0x003c
+#define AR934X_AUDIO_PLL_MOD_STEP             AR7240_PLL_BASE+0x0038
+#define AR934X_AUDIO_PLL_MODULATION           AR7240_PLL_BASE+0x0034
+#define AR934X_AUDIO_PLL_CONFIG               AR7240_PLL_BASE+0x0030
+#define AR934X_ETH_XMII                       AR7240_PLL_BASE+0x002c
+#define AR934X_CURRENT_PCIE_PLL_DITHER        AR7240_PLL_BASE+0x0028
+#define AR934X_SWITCH_CLOCK_SPARE             AR7240_PLL_BASE+0x0024
+#define AR934X_LDO_POWER_CONTROL              AR7240_PLL_BASE+0x0020
+#define AR934X_PCIE_PLL_DITHER_STEP           AR7240_PLL_BASE+0x001c
+#define AR934X_PCIE_PLL_DITHER_DIV_MIN        AR7240_PLL_BASE+0x0018
+#define AR934X_PCIE_PLL_DITHER_DIV_MAX        AR7240_PLL_BASE+0x0014
+#define AR934X_PCIE_PLL_CONFIG                AR7240_PLL_BASE+0x0010
+#define AR934X_CPU_SYNC                       AR7240_PLL_BASE+0x000c
+#define AR934X_CPU_DDR_CLOCK_CONTROL          AR7240_PLL_BASE+0x0008
+#define AR934X_DDR_PLL_CONFIG                 AR7240_PLL_BASE+0x0004
+#define AR934X_CPU_PLL_CONFIG                 AR7240_PLL_BASE+0x0000
+
+#define PLL_CONFIG_PLL_DIV_SHIFT        0
+#define PLL_CONFIG_PLL_DIV_MASK         (0x3ff<< PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_SHIFT    10
+#define PLL_CONFIG_PLL_REF_DIV_MASK     (0xf << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+#define PLL_CONFIG_PLL_BYPASS_SHIFT     16
+#define PLL_CONFIG_PLL_BYPASS_MASK      (0x1 << PLL_CONFIG_PLL_BYPASS_SHIFT)
+#define PLL_CONFIG_PLL_UPDATE_SHIFT     17
+#define PLL_CONFIG_PLL_UPDATE_MASK      (0x1 << PLL_CONFIG_PLL_UPDATE_SHIFT)
+#define PLL_CONFIG_PLL_NOPWD_SHIFT      18
+#define PLL_CONFIG_PLL_NOPWD_MASK       (0x1 << PLL_CONFIG_PLL_NOPWD_SHIFT)
+#define PLL_CONFIG_AHB_DIV_SHIFT        19
+#define PLL_CONFIG_AHB_DIV_MASK         (0x1 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_DDR_DIV_SHIFT        22
+#define PLL_CONFIG_DDR_DIV_MASK         (0x1 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_PLL_RESET_SHIFT      25
+#define PLL_CONFIG_PLL_RESET_MASK       (0x1 << PLL_CONFIG_PLL_RESET_SHIFT)
+
+/* Hornet's CPU PLL Configuration Register */
+#define HORNET_PLL_CONFIG_NINT_SHIFT            10
+#define HORNET_PLL_CONFIG_NINT_MASK             (0x3f << HORNET_PLL_CONFIG_NINT_SHIFT)
+#define HORNET_PLL_CONFIG_REFDIV_SHIFT          16
+#define HORNET_PLL_CONFIG_REFDIV_MASK           (0x1f << HORNET_PLL_CONFIG_REFDIV_SHIFT)
+#define HORNET_PLL_CONFIG_OUTDIV_SHIFT          23
+#define HORNET_PLL_CONFIG_OUTDIV_MASK           (0x7 << HORNET_PLL_CONFIG_OUTDIV_SHIFT)
+#define HORNET_PLL_CONFIG_PLLPWD_SHIFT          30
+#define HORNET_PLL_CONFIG_PLLPWD_MASK           (0x1 << HORNET_PLL_CONFIG_PLLPWD_SHIFT)
+#define HORNET_PLL_CONFIG_UPDATING_SHIFT        31
+#define HORNET_PLL_CONFIG_UPDATING_MASK         (0x1 << HORNET_PLL_CONFIG_UPDATING_SHIFT)
+/* Hornet's CPU PLL Configuration 2 Register */
+#define HORNET_PLL_CONFIG2_SETTLE_TIME_SHIFT    0
+#define HORNET_PLL_CONFIG2_SETTLE_TIME_MASK     (0xfff << HORNET_PLL_CONFIG2_SETTLE_TIME_SHIFT)
+/* Hornet's CPU Clock Control Register */
+#define HORNET_CLOCK_CONTROL_BYPASS_SHIFT       2
+#define HORNET_CLOCK_CONTROL_BYPASS_MASK        (0x1 << HORNET_CLOCK_CONTROL_BYPASS_SHIFT)
+#define HORNET_CLOCK_CONTROL_CPU_POST_DIV_SHIFT 5
+#define HORNET_CLOCK_CONTROL_CPU_POST_DIV_MASK  (0x3 << HORNET_CLOCK_CONTROL_CPU_POST_DIV_SHIFT)
+#define HORNET_CLOCK_CONTROL_DDR_POST_DIV_SFIFT 10
+#define HORNET_CLOCK_CONTROL_DDR_POST_DIV_MASK  (0x3 << HORNET_CLOCK_CONTROL_DDR_POST_DIV_SFIFT)
+#define HORNET_CLOCK_CONTROL_AHB_POST_DIV_SFIFT 15
+#define HORNET_CLOCK_CONTROL_AHB_POST_DIV_MASK  (0x3 << HORNET_CLOCK_CONTROL_AHB_POST_DIV_SFIFT)
+
+#define CLOCK_CONTROL_CLOCK_SWITCH_SHIFT  0
+#define CLOCK_CONTROL_CLOCK_SWITCH_MASK  (1 << CLOCK_CONTROL_CLOCK_SWITCH_SHIFT)
+#define CLOCK_CONTROL_RST_SWITCH_SHIFT    1
+#define CLOCK_CONTROL_RST_SWITCH_MASK    (1 << CLOCK_CONTROL_RST_SWITCH_SHIFT)
+
+/*
+** PLL config for different CPU/DDR/AHB frequencies
+*/
+#define PLL_CONFIG_PLL_NOPWD_VAL        (1 << PLL_CONFIG_PLL_NOPWD_SHIFT)
+
+
+#define UBOOT_SIZE			(256 * 1024)
+#define PLL_FLASH_ADDR  		(CFG_FLASH_BASE + UBOOT_SIZE)
+#define PLL_CONFIG_VAL_F		(PLL_FLASH_ADDR + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define PLL_MAGIC  			 0xaabbccdd
+#define SRIF_PLL_CONFIG_VAL_F		(PLL_CONFIG_VAL_F - 12)
+#define SRIF_PLL_MAGIC 			0x73726966 /* srif */
+
+#ifndef CONFIG_WASP_SUPPORT
+#if (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x28 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x1 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x28 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_360_360_180)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x24 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x23 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+
+#elif (CFG_PLL_FREQ == CFG_PLL_340_340_170)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x22 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x20 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x1 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x20 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x1e << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_75)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x1 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x1e << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+
+#define PLL_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL    (0x14 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+
+#define PLL_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL    (0x18 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+
+#define PLL_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL    (0x10 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x1 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x28 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#else /* default is 400/400/200 */
+
+#define PLL_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL    (0x28 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#endif
+#ifdef CONFIG_SUPPORT_AR7241
+#if (CFG_AR7241_PLL_FREQ == CFG_PLL_400_200_200)
+
+#define PLL_7241_CONFIG_DDR_DIV_VAL     (0x1 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_7241_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_DIV_VAL     (0x28 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_AR7241_PLL_FREQ == CFG_PLL_280_280_130)
+
+#define PLL_7241_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_7241_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_DIV_VAL     (0x1c << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_AR7241_PLL_FREQ == CFG_PLL_260_260_130)
+
+#define PLL_7241_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_7241_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_DIV_VAL     (0x1a << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+
+#else /* default is 400/400/200 */
+
+#define PLL_7241_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_7241_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_DIV_VAL    (0x28 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#endif
+#endif
+#endif
+
+
+/*
+ * PLL block
+ */
+#define AR7240_PLL_CONFIG               AR7240_PLL_BASE+0x0
+
+/*
+ * CLOCK
+ */
+#define AR7240_CPU_CLOCK_CONTROL        AR7240_PLL_BASE+8
+
+/*
+ * FIFO flushes
+ */
+#define AR7240_DDR_GE0_FLUSH            AR7240_DDR_CTL_BASE+0x9c
+#define AR7240_DDR_GE1_FLUSH            AR7240_DDR_CTL_BASE+0xa0
+#define AR7240_DDR_PCI_FLUSH            AR7240_DDR_CTL_BASE+0xa8
+
+/*
+ * USB block
+ */
+#define AR7240_USB_FLADJ_VAL            AR7240_USB_CONFIG_BASE
+#define AR7240_USB_CONFIG               AR7240_USB_CONFIG_BASE+0x4
+#define AR7240_USB_WINDOW               0x1000000
+
+/*
+ * PCI block
+ */
+#define AR7240_PCI_WINDOW           0x8000000       /* 128MB */
+#define AR7240_PCI_WINDOW0_OFFSET   AR7240_DDR_CTL_BASE+0x7c
+#define AR7240_PCI_WINDOW1_OFFSET   AR7240_DDR_CTL_BASE+0x80
+#define AR7240_PCI_WINDOW2_OFFSET   AR7240_DDR_CTL_BASE+0x84
+#define AR7240_PCI_WINDOW3_OFFSET   AR7240_DDR_CTL_BASE+0x88
+#define AR7240_PCI_WINDOW4_OFFSET   AR7240_DDR_CTL_BASE+0x8c
+#define AR7240_PCI_WINDOW5_OFFSET   AR7240_DDR_CTL_BASE+0x90
+#define AR7240_PCI_WINDOW6_OFFSET   AR7240_DDR_CTL_BASE+0x94
+#define AR7240_PCI_WINDOW7_OFFSET   AR7240_DDR_CTL_BASE+0x98
+
+#define AR7240_PCI_WINDOW0_VAL      0x10000000
+#define AR7240_PCI_WINDOW1_VAL      0x11000000
+#define AR7240_PCI_WINDOW2_VAL      0x12000000
+#define AR7240_PCI_WINDOW3_VAL      0x13000000
+#define AR7240_PCI_WINDOW4_VAL      0x14000000
+#define AR7240_PCI_WINDOW5_VAL      0x15000000
+#define AR7240_PCI_WINDOW6_VAL      0x16000000
+#define AR7240_PCI_WINDOW7_VAL      0x07000000
+
+
+/*
+ * CRP. To access the host controller config and status registers
+ */
+#define AR7240_PCI_CRP   	   0x180c0000
+#define AR7240_PCI_DEV_CFGBASE     0x14000000
+
+#define AR7240_PCI_CRP_AD_CBE               AR7240_PCI_CRP
+#define AR7240_PCI_CRP_WRDATA               AR7240_PCI_CRP+0x4
+#define AR7240_PCI_CRP_RDDATA               AR7240_PCI_CRP+0x8
+#define AR7240_PCI_ERROR            AR7240_PCI_CRP+0x1c
+#define AR7240_PCI_ERROR_ADDRESS    AR7240_PCI_CRP+0x20
+#define AR7240_PCI_AHB_ERROR            AR7240_PCI_CRP+0x24
+#define AR7240_PCI_AHB_ERROR_ADDRESS    AR7240_PCI_CRP+0x28
+
+#define AR7240_CRP_CMD_WRITE             0x00010000
+#define AR7240_CRP_CMD_READ              0x00000000
+
+/*
+ * PCI CFG. To generate config cycles
+ */
+#define AR7240_PCI_CFG_AD           AR7240_PCI_CRP+0xc
+#define AR7240_PCI_CFG_CBE          AR7240_PCI_CRP+0x10
+#define AR7240_PCI_CFG_WRDATA       AR7240_PCI_CRP+0x14
+#define AR7240_PCI_CFG_RDDATA       AR7240_PCI_CRP+0x18
+#define AR7240_CFG_CMD_READ         0x0000000a
+#define AR7240_CFG_CMD_WRITE        0x0000000b
+
+#define AR7240_PCI_IDSEL_ADLINE_START           17
+
+#define AR7240_PCI_LCL_RESET        AR7240_PCI_LCL_BASE+0x18
+
+/*
+ * gpio configs
+ */
+#define AR7240_GPIO_OE                  AR7240_GPIO_BASE+0x0
+#define AR7240_GPIO_IN                  AR7240_GPIO_BASE+0x4
+#define AR7240_GPIO_OUT                 AR7240_GPIO_BASE+0x8
+#define AR7240_GPIO_SET                 AR7240_GPIO_BASE+0xc
+#define AR7240_GPIO_CLEAR               AR7240_GPIO_BASE+0x10
+#define AR7240_GPIO_INT_ENABLE          AR7240_GPIO_BASE+0x14
+#define AR7240_GPIO_INT_TYPE            AR7240_GPIO_BASE+0x18
+#define AR7240_GPIO_INT_POLARITY        AR7240_GPIO_BASE+0x1c
+#define AR7240_GPIO_INT_PENDING         AR7240_GPIO_BASE+0x20
+#define AR7240_GPIO_INT_MASK            AR7240_GPIO_BASE+0x24
+#define AR7240_GPIO_FUNC                AR7240_GPIO_BASE+0x28
+#define AR7240_GPIO_FUNC4               AR7240_GPIO_BASE+0x3c
+#define AR7240_GPIO_FUNC5               AR7240_GPIO_BASE+0x40
+
+/*
+ * IRQ Map.
+ * There are 4 conceptual ICs in the system. We generally give a block of 16
+ * irqs to each IC.
+ * CPU:                     0    - 0xf
+ *      MISC:               0x10 - 0x1f
+ *          GPIO:           0x20 - 0x2f
+ *      PCI :               0x30 - 0x40
+ *
+ */
+#define AR7240_CPU_IRQ_BASE         0x00
+#define AR7240_MISC_IRQ_BASE        0x10
+#define AR7240_GPIO_IRQ_BASE        0x20
+#define AR7240_PCI_IRQ_BASE         0x30
+
+/*
+ * The IPs. Connected to CPU (hardware IP's; the first two are software)
+ */
+#define AR7240_CPU_IRQ_PCI                  AR7240_CPU_IRQ_BASE+2
+#define AR7240_CPU_IRQ_USB                  AR7240_CPU_IRQ_BASE+3
+#define AR7240_CPU_IRQ_GE0                  AR7240_CPU_IRQ_BASE+4
+#define AR7240_CPU_IRQ_GE1                  AR7240_CPU_IRQ_BASE+5
+#define AR7240_CPU_IRQ_MISC                 AR7240_CPU_IRQ_BASE+6
+#define AR7240_CPU_IRQ_TIMER                AR7240_CPU_IRQ_BASE+7
+
+/*
+ * Interrupts connected to the CPU->Misc line.
+ */
+#define AR7240_MISC_IRQ_TIMER               AR7240_MISC_IRQ_BASE+0
+#define AR7240_MISC_IRQ_ERROR               AR7240_MISC_IRQ_BASE+1
+#define AR7240_MISC_IRQ_GPIO                AR7240_MISC_IRQ_BASE+2
+#define AR7240_MISC_IRQ_UART                AR7240_MISC_IRQ_BASE+3
+#define AR7240_MISC_IRQ_WATCHDOG            AR7240_MISC_IRQ_BASE+4
+#define AR7240_MISC_IRQ_COUNT                 5
+
+#define MIMR_TIMER                          0x01
+#define MIMR_ERROR                          0x02
+#define MIMR_GPIO                           0x04
+#define MIMR_UART                           0x08
+#define MIMR_WATCHDOG                       0x10
+
+#define MISR_TIMER                          MIMR_TIMER
+#define MISR_ERROR                          MIMR_ERROR
+#define MISR_GPIO                           MIMR_GPIO
+#define MISR_UART                           MIMR_UART
+#define MISR_WATCHDOG                       MIMR_WATCHDOG
+
+/*
+ * Interrupts connected to the Misc->GPIO line
+ */
+#define AR7240_GPIO_IRQn(_gpio)             AR7240_GPIO_IRQ_BASE+(_gpio)
+#define AR7240_GPIO_IRQ_COUNT                 16
+
+/*
+ * Interrupts connected to CPU->PCI
+ */
+#define AR7240_PCI_IRQ_DEV0                  AR7240_PCI_IRQ_BASE+0
+#define AR7240_PCI_IRQ_DEV1                  AR7240_PCI_IRQ_BASE+1
+#define AR7240_PCI_IRQ_DEV2                  AR7240_PCI_IRQ_BASE+2
+#define AR7240_PCI_IRQ_CORE                  AR7240_PCI_IRQ_BASE+3
+#define AR7240_PCI_IRQ_COUNT                 4
+
+/*
+ * PCI interrupt mask and status
+ */
+#define PIMR_DEV0                           0x01
+#define PIMR_DEV1                           0x02
+#define PIMR_DEV2                           0x04
+#define PIMR_CORE                           0x10
+
+#define PISR_DEV0                           PIMR_DEV0
+#define PISR_DEV1                           PIMR_DEV1
+#define PISR_DEV2                           PIMR_DEV2
+#define PISR_CORE                           PIMR_CORE
+
+#define AR7240_GPIO_COUNT                   16
+
+/*
+ * Reset block
+ */
+#define AR7240_GENERAL_TMR            AR7240_RESET_BASE+0
+#define AR7240_GENERAL_TMR_RELOAD     AR7240_RESET_BASE+4
+#define AR7240_WATCHDOG_TMR_CONTROL   AR7240_RESET_BASE+8
+#define AR7240_WATCHDOG_TMR           AR7240_RESET_BASE+0xc
+#define AR7240_MISC_INT_STATUS        AR7240_RESET_BASE+0x10
+#define AR7240_MISC_INT_MASK          AR7240_RESET_BASE+0x14
+#define AR7240_GLOBAL_INT_STATUS      AR7240_RESET_BASE+0x18
+#define AR7240_RESET                  AR7240_RESET_BASE+0x1c
+#define HORNET_BOOTSTRAP_STATUS       AR7240_RESET_BASE+0xac /* Hornet's bootstrap register */
+#define AR7240_REV_ID                 (AR7240_RESET_BASE + 0x90)
+#define AR7240_REV_ID_MASK            0xffff
+#define AR7240_REV_ID_MASK_MINOR      0xfu
+#define HORNET_REV_ID_MASK            0xfff
+#define AR9344_REV_ID_MASK            0xfff0	/* Ignore minor id */
+#define HORNET_BOOTSTRAP_SEL_25M_40M_MASK   0x00000001 /* Hornet's bootstrap register */
+#define HORNET_BOOTSTRAP_MEM_TYPE_MASK      0x00003000 /* Hornet's bootstrap register */
+#define HORNET_BOOTSTRAP_MDIO_SLAVE_MASK    0x00020000 /* Hornet's bootstrap register */
+
+// WASP BootStrap Register
+#define WASP_BOOTSTRAP_REG		(AR7240_RESET_BASE + 0xb0)
+#define WASP_REF_CLK_25			(1 << 4) /* 0 - 25MHz	1 - 40 MHz */
+#define WASP_RAM_TYPE(a)		((a) & 0x3)
+
+#define CFG_934X_SDRAM_CONFIG_VAL	0x7fbe8cd0
+#define CFG_934X_SDRAM_MODE_VAL_INIT	0x133
+#define CFG_934X_SDRAM_MODE_VAL		0x33
+#define CFG_934X_SDRAM_CONFIG2_VAL	0x959f66a8
+#define CFG_934X_SDRAM_TAP_VAL		0x1f1f
+
+#define CFG_934X_DDR1_CONFIG_VAL	0x7fd48cd0
+#define CFG_934X_DDR1_MODE_VAL_INIT	0x133
+#define CFG_934X_DDR1_EXT_MODE_VAL	0x2
+#define CFG_934X_DDR1_MODE_VAL		0x33
+#define CFG_934X_DDR1_CONFIG2_VAL	0x99d0e6a8
+
+#if (CFG_PLL_FREQ == CFG_PLL_500_500_250)
+#define CFG_934X_DDR2_CONFIG_VAL	0xcfbc8cd0
+#define CFG_934X_DDR2_MODE_VAL_INIT	0x143
+#define CFG_934X_DDR2_EXT_MODE_VAL	0x402
+#define CFG_934X_DDR2_MODE_VAL		0x43
+#define CFG_934X_DDR2_CONFIG2_VAL	0xa5d0e6a8
+#define CFG_934X_DDR2_EN_TWL_VAL	0x1659
+#define CFG_934X_DDR2_TAP_VAL		0
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_575_287)
+
+#define CFG_934X_DDR2_CONFIG_VAL	0xcfd48cd0
+#define CFG_934X_DDR2_MODE_VAL_INIT	0x143
+#define CFG_934X_DDR2_EXT_MODE_VAL	0x402
+#define CFG_934X_DDR2_MODE_VAL		0x43
+#define CFG_934X_DDR2_CONFIG2_VAL	0xa1d0e6a8
+#define CFG_934X_DDR2_EN_TWL_VAL	0x1659
+#define CFG_934X_DDR2_TAP_VAL		0x5
+#else
+#ifdef CONFIG_MI124
+#define CFG_934X_DDR2_CONFIG_VAL	0x7fd48cd0
+#define CFG_934X_DDR2_MODE_VAL_INIT	0x133
+#define CFG_934X_DDR2_EXT_MODE_VAL_INIT	0x382
+#define CFG_934X_DDR2_EXT_MODE_VAL	0x402
+#define CFG_934X_DDR2_MODE_VAL		0x33
+#define CFG_934X_DDR2_CONFIG2_VAL	0x99d0e6a8
+#define CFG_934X_DDR2_EN_TWL_VAL	0xe59
+#define CFG_934X_DDR2_TAP_VAL		0x10012
+#else // db12x
+#define CFG_934X_DDR2_CONFIG_VAL	0xc7d48cd0
+#define CFG_934X_DDR2_MODE_VAL_INIT	0x133
+#define CFG_934X_DDR2_EXT_MODE_VAL_INIT	0x382
+#define CFG_934X_DDR2_EXT_MODE_VAL	0x402
+#define CFG_934X_DDR2_MODE_VAL		0x33
+#define CFG_934X_DDR2_CONFIG2_VAL	0x9dd0e6a8
+#define CFG_934X_DDR2_EN_TWL_VAL	0xe59
+#define CFG_934X_DDR2_TAP_VAL		0x10012
+#endif
+#endif
+
+#define CFG_934X_DDR1_TAP_VAL		0x14
+
+#define AR7240_REV_ID_AR7130    0xa0
+#define AR7240_REV_ID_AR7141    0xa1
+#define AR7240_REV_ID_AR7161    0xa2
+#define AR7240_REV_1_0          0xc0
+#define AR7240_REV_1_1          0xc1
+#define AR7240_REV_1_2          0xc2
+#define AR7241_REV_1_0          0x0100
+#define AR7242_REV_1_0          0x1100
+#define AR7241_REV_1_1          0x0101
+#define AR7242_REV_1_1          0x1101
+
+#define AR9330_REV_1_0			0x0110                  /* 5-port:0x110, 4-port 0x1110 */
+#define AR9331_REV_1_0			0x1110
+#define AR9330_REV_1_1			0x0111                  /* 5-port:0x111, 4-port 0x1111 */
+#define AR9331_REV_1_1			0x1111
+#define AR9330_REV_1_2			0x0112
+#define AR9331_REV_1_2			0x1112
+
+#define AR9344_REV_1_x		0x2120	/* Wasp 1.x, ignore minor id */
+#define AR9342_REV_1_x		0x1120
+#define AR9341_REV_1_x		0x0120
+
+#define AR9344_REV_1_0		0x2120	/* Wasp 1.0 */
+#define AR9342_REV_1_0		0x1120
+#define AR9341_REV_1_0		0x0120
+
+#define AR9344_REV_1_1		0x2121	/* Wasp 1.1 */
+#define AR9342_REV_1_1		0x1121
+#define AR9341_REV_1_1		0x0121
+
+#define is_ar7240()     (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_2) || \
+                         ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_1) || \
+                         ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_0))
+
+#define is_ar7241()     (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7241_REV_1_0) || \
+                         ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7241_REV_1_1))
+
+#define is_ar7242()     (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7242_REV_1_0) || \
+                         ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7242_REV_1_1))
+
+#define is_ar9330() (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9330_REV_1_0) || \
+                        ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9330_REV_1_1) || \
+                        ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9330_REV_1_2))
+
+#define is_ar9331() (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9331_REV_1_0) || \
+                        ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9331_REV_1_1) || \
+                        ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9331_REV_1_2))
+
+#define is_ar933x_10()  (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9330_REV_1_0) || \
+                            ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9331_REV_1_0))
+
+#define is_ar933x_11()  (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9330_REV_1_1) || \
+                            ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9331_REV_1_1))
+   
+#define is_ar933x_12()  (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9330_REV_1_2) || \
+                            ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9331_REV_1_2))
+
+
+#define is_ar933x() (is_ar9330() || is_ar9331())
+
+#define is_ar9344()	((ar7240_reg_rd(AR7240_REV_ID) & AR9344_REV_ID_MASK) == AR9344_REV_1_x)
+#define is_ar9342()	((ar7240_reg_rd(AR7240_REV_ID) & AR9344_REV_ID_MASK) == AR9342_REV_1_x)
+#define is_ar9341()	((ar7240_reg_rd(AR7240_REV_ID) & AR9344_REV_ID_MASK) == AR9341_REV_1_x)
+
+#ifdef CONFIG_WASP_SUPPORT
+#define is_wasp()	1
+#define is_ar934x()	1
+#else
+#define is_wasp()	0
+#define is_ar934x()	0
+#endif
+#ifdef CONFIG_AR7240_EMU
+#define is_emu()	1
+#else
+#define is_emu()	0
+#endif
+#ifdef CONFIG_F1E_PHY
+#define is_f1e()	1
+#else
+#define is_f1e()	0
+#endif
+#ifdef CONFIG_F2E_PHY
+#define is_f2e()	1
+#else
+#define is_f2e()	0
+#endif
+#ifdef CONFIG_ATHRS16_PHY
+#define is_s16()	1
+#else
+#define is_s16()	0
+#endif
+
+#define is_ar934x_12_or_later() (is_ar934x() && ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK_MINOR) >= 2))
+
+/*
+ * AR7240_RESET bit defines
+ */
+#define AR7240_RESET_EXTERNAL               (1 << 28)
+#define AR7240_RESET_WMAC                   (1 << 27)
+#define AR7240_RESET_FULL_CHIP              (1 << 24)
+#define AR7240_RESET_CPU_NMI                (1 << 21)
+#define AR7240_RESET_CPU_COLD_RESET_MASK    (1 << 20)
+#define AR7240_RESET_DDR                    (1 << 16)
+#define AR7240_RESET_GE1_MAC                (1 << 13)
+#define AR7240_RESET_GE1_MDIO               (1 << 23)
+#define AR7240_RESET_GE1_PHY                (1 << 12) /* Not valid */
+#define AR7240_RESET_PCIE_PHY_SERIAL        (1 << 10)
+#define AR7240_RESET_GE0_MAC                (1 << 9)
+#define AR7240_RESET_GE0_MDIO               (1 << 22)
+#define AR7240_RESET_GE0_PHY                (1 << 8) /* Switch reset */
+#define AR7240_RESET_PCIE_PHY               (1 << 7)
+#define AR7240_RESET_PCIE                   (1 << 6)
+#define AR7240_RESET_USB_HOST               (1 << 5)
+#define AR7240_RESET_USB_OHCI_DLL           (1 << 3)
+
+#define AR7240_MII0_CTRL                    0x18070000
+#define AR7240_MII1_CTRL                    0x18070004
+
+#define K1BASE KSEG1
+
+#ifndef __ASSEMBLY__
+typedef enum {
+    AR7240_DDR_16B_LOW,
+    AR7240_DDR_16B_HIGH,
+    AR7240_DDR_32B,
+}ar7240_ddr_width_t;
+
+#define ar7240_reg_rd(_phys)    (*(volatile unsigned int *)KSEG1ADDR(_phys))
+#define ar7240_reg_wr_nf(_phys, _val) \
+                    ((*(volatile unsigned int *)KSEG1ADDR(_phys)) = (_val))
+
+#define ar7240_reg_wr(_phys, _val) do {     \
+                    ar7240_reg_wr_nf(_phys, _val);  \
+                    ar7240_reg_rd(_phys);       \
+}while(0);
+
+#define ar7240_write_pci_window(_no)             \
+  ar7240_reg_wr(AR7240_PCI_WINDOW##_no##_OFFSET, AR7240_PCI_WINDOW##_no##_VAL);
+
+#define BIT(_x) (1 << (_x))
+
+#define ar7240_reg_rmw_set(_reg, _mask)  do {                        \
+    ar7240_reg_wr((_reg), (ar7240_reg_rd((_reg)) | (_mask)));      \
+    ar7240_reg_rd((_reg));                                           \
+}while(0);
+
+#define ar7240_reg_rmw_clear(_reg, _mask)  do {                        \
+    ar7240_reg_wr((_reg), (ar7240_reg_rd((_reg)) & ~(_mask)));      \
+    ar7240_reg_rd((_reg));                                           \
+}while(0);
+
+#define ar7240_get_bit(_reg, _bit)  (ar7240_reg_rd((_reg)) & (1 << (_bit)))
+
+#define ar7240_flush_ge(_unit) do {                             \
+    u32     reg = (_unit) ? AR7240_DDR_GE1_FLUSH : AR7240_DDR_GE0_FLUSH;   \
+    ar7240_reg_wr(reg, 1);                 \
+    while((ar7240_reg_rd(reg) & 0x1));   \
+    ar7240_reg_wr(reg, 1);                 \
+    while((ar7240_reg_rd(reg) & 0x1));   \
+}while(0);
+
+#define ar7240_flush_pci() do {                             \
+    ar7240_reg_wr(AR7240_DDR_PCI_FLUSH, 1);                 \
+    while((ar7240_reg_rd(AR7240_DDR_PCI_FLUSH) & 0x1));   \
+    ar7240_reg_wr(AR7240_DDR_PCI_FLUSH, 1);                 \
+    while((ar7240_reg_rd(AR7240_DDR_PCI_FLUSH) & 0x1));   \
+}while(0);
+
+#endif  /*__ASSEMBLY*/
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/ar934x_soc.h u-boot_1.1//include/ar934x_soc.h
--- u-boot//include/ar934x_soc.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/ar934x_soc.h	2014-02-18 01:46:27.615052895 -0800
@@ -0,0 +1,3148 @@
+/*
+ * Atheros AR924X series processor SOC registers
+ *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _AR934X_SOC_H
+#define _AR934X_SOC_H
+
+// 32'h0000 (CPU_PLL_CONFIG)
+#define CPU_PLL_CONFIG_UPDATING_MSB                                  31
+#define CPU_PLL_CONFIG_UPDATING_LSB                                  31
+#define CPU_PLL_CONFIG_UPDATING_MASK                                 0x80000000
+#define CPU_PLL_CONFIG_UPDATING_GET(x)                               (((x) & CPU_PLL_CONFIG_UPDATING_MASK) >> CPU_PLL_CONFIG_UPDATING_LSB)
+#define CPU_PLL_CONFIG_UPDATING_SET(x)                               (((x) << CPU_PLL_CONFIG_UPDATING_LSB) & CPU_PLL_CONFIG_UPDATING_MASK)
+#define CPU_PLL_CONFIG_UPDATING_RESET                                1
+#define CPU_PLL_CONFIG_PLLPWD_MSB                                    30
+#define CPU_PLL_CONFIG_PLLPWD_LSB                                    30
+#define CPU_PLL_CONFIG_PLLPWD_MASK                                   0x40000000
+#define CPU_PLL_CONFIG_PLLPWD_GET(x)                                 (((x) & CPU_PLL_CONFIG_PLLPWD_MASK) >> CPU_PLL_CONFIG_PLLPWD_LSB)
+#define CPU_PLL_CONFIG_PLLPWD_SET(x)                                 (((x) << CPU_PLL_CONFIG_PLLPWD_LSB) & CPU_PLL_CONFIG_PLLPWD_MASK)
+#define CPU_PLL_CONFIG_PLLPWD_RESET                                  1
+#define CPU_PLL_CONFIG_SPARE_MSB                                     29
+#define CPU_PLL_CONFIG_SPARE_LSB                                     22
+#define CPU_PLL_CONFIG_SPARE_MASK                                    0x3fc00000
+#define CPU_PLL_CONFIG_SPARE_GET(x)                                  (((x) & CPU_PLL_CONFIG_SPARE_MASK) >> CPU_PLL_CONFIG_SPARE_LSB)
+#define CPU_PLL_CONFIG_SPARE_SET(x)                                  (((x) << CPU_PLL_CONFIG_SPARE_LSB) & CPU_PLL_CONFIG_SPARE_MASK)
+#define CPU_PLL_CONFIG_SPARE_RESET                                   0
+#define CPU_PLL_CONFIG_OUTDIV_MSB                                    21
+#define CPU_PLL_CONFIG_OUTDIV_LSB                                    19
+#define CPU_PLL_CONFIG_OUTDIV_MASK                                   0x00380000
+#define CPU_PLL_CONFIG_OUTDIV_GET(x)                                 (((x) & CPU_PLL_CONFIG_OUTDIV_MASK) >> CPU_PLL_CONFIG_OUTDIV_LSB)
+#define CPU_PLL_CONFIG_OUTDIV_SET(x)                                 (((x) << CPU_PLL_CONFIG_OUTDIV_LSB) & CPU_PLL_CONFIG_OUTDIV_MASK)
+#define CPU_PLL_CONFIG_OUTDIV_RESET                                  0
+#define CPU_PLL_CONFIG_RANGE_MSB                                     18
+#define CPU_PLL_CONFIG_RANGE_LSB                                     17
+#define CPU_PLL_CONFIG_RANGE_MASK                                    0x00060000
+#define CPU_PLL_CONFIG_RANGE_GET(x)                                  (((x) & CPU_PLL_CONFIG_RANGE_MASK) >> CPU_PLL_CONFIG_RANGE_LSB)
+#define CPU_PLL_CONFIG_RANGE_SET(x)                                  (((x) << CPU_PLL_CONFIG_RANGE_LSB) & CPU_PLL_CONFIG_RANGE_MASK)
+#define CPU_PLL_CONFIG_RANGE_RESET                                   3
+#define CPU_PLL_CONFIG_REFDIV_MSB                                    16
+#define CPU_PLL_CONFIG_REFDIV_LSB                                    12
+#define CPU_PLL_CONFIG_REFDIV_MASK                                   0x0001f000
+#define CPU_PLL_CONFIG_REFDIV_GET(x)                                 (((x) & CPU_PLL_CONFIG_REFDIV_MASK) >> CPU_PLL_CONFIG_REFDIV_LSB)
+#define CPU_PLL_CONFIG_REFDIV_SET(x)                                 (((x) << CPU_PLL_CONFIG_REFDIV_LSB) & CPU_PLL_CONFIG_REFDIV_MASK)
+#define CPU_PLL_CONFIG_REFDIV_RESET                                  2
+#define CPU_PLL_CONFIG_NINT_MSB                                      11
+#define CPU_PLL_CONFIG_NINT_LSB                                      6
+#define CPU_PLL_CONFIG_NINT_MASK                                     0x00000fc0
+#define CPU_PLL_CONFIG_NINT_GET(x)                                   (((x) & CPU_PLL_CONFIG_NINT_MASK) >> CPU_PLL_CONFIG_NINT_LSB)
+#define CPU_PLL_CONFIG_NINT_SET(x)                                   (((x) << CPU_PLL_CONFIG_NINT_LSB) & CPU_PLL_CONFIG_NINT_MASK)
+#define CPU_PLL_CONFIG_NINT_RESET                                    20
+#define CPU_PLL_CONFIG_NFRAC_MSB                                     5
+#define CPU_PLL_CONFIG_NFRAC_LSB                                     0
+#define CPU_PLL_CONFIG_NFRAC_MASK                                    0x0000003f
+#define CPU_PLL_CONFIG_NFRAC_GET(x)                                  (((x) & CPU_PLL_CONFIG_NFRAC_MASK) >> CPU_PLL_CONFIG_NFRAC_LSB)
+#define CPU_PLL_CONFIG_NFRAC_SET(x)                                  (((x) << CPU_PLL_CONFIG_NFRAC_LSB) & CPU_PLL_CONFIG_NFRAC_MASK)
+#define CPU_PLL_CONFIG_NFRAC_RESET                                   16
+#define CPU_PLL_CONFIG_ADDRESS                                       0x0000
+#define CPU_PLL_CONFIG_OFFSET                                        0x0000
+// SW modifiable bits
+#define CPU_PLL_CONFIG_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define CPU_PLL_CONFIG_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define CPU_PLL_CONFIG_RESET                                         0xc0062510
+
+// 32'h0004 (DDR_PLL_CONFIG)
+#define DDR_PLL_CONFIG_UPDATING_MSB                                  31
+#define DDR_PLL_CONFIG_UPDATING_LSB                                  31
+#define DDR_PLL_CONFIG_UPDATING_MASK                                 0x80000000
+#define DDR_PLL_CONFIG_UPDATING_GET(x)                               (((x) & DDR_PLL_CONFIG_UPDATING_MASK) >> DDR_PLL_CONFIG_UPDATING_LSB)
+#define DDR_PLL_CONFIG_UPDATING_SET(x)                               (((x) << DDR_PLL_CONFIG_UPDATING_LSB) & DDR_PLL_CONFIG_UPDATING_MASK)
+#define DDR_PLL_CONFIG_UPDATING_RESET                                1
+#define DDR_PLL_CONFIG_PLLPWD_MSB                                    30
+#define DDR_PLL_CONFIG_PLLPWD_LSB                                    30
+#define DDR_PLL_CONFIG_PLLPWD_MASK                                   0x40000000
+#define DDR_PLL_CONFIG_PLLPWD_GET(x)                                 (((x) & DDR_PLL_CONFIG_PLLPWD_MASK) >> DDR_PLL_CONFIG_PLLPWD_LSB)
+#define DDR_PLL_CONFIG_PLLPWD_SET(x)                                 (((x) << DDR_PLL_CONFIG_PLLPWD_LSB) & DDR_PLL_CONFIG_PLLPWD_MASK)
+#define DDR_PLL_CONFIG_PLLPWD_RESET                                  1
+#define DDR_PLL_CONFIG_SPARE_MSB                                     29
+#define DDR_PLL_CONFIG_SPARE_LSB                                     26
+#define DDR_PLL_CONFIG_SPARE_MASK                                    0x3c000000
+#define DDR_PLL_CONFIG_SPARE_GET(x)                                  (((x) & DDR_PLL_CONFIG_SPARE_MASK) >> DDR_PLL_CONFIG_SPARE_LSB)
+#define DDR_PLL_CONFIG_SPARE_SET(x)                                  (((x) << DDR_PLL_CONFIG_SPARE_LSB) & DDR_PLL_CONFIG_SPARE_MASK)
+#define DDR_PLL_CONFIG_SPARE_RESET                                   0
+#define DDR_PLL_CONFIG_OUTDIV_MSB                                    25
+#define DDR_PLL_CONFIG_OUTDIV_LSB                                    23
+#define DDR_PLL_CONFIG_OUTDIV_MASK                                   0x03800000
+#define DDR_PLL_CONFIG_OUTDIV_GET(x)                                 (((x) & DDR_PLL_CONFIG_OUTDIV_MASK) >> DDR_PLL_CONFIG_OUTDIV_LSB)
+#define DDR_PLL_CONFIG_OUTDIV_SET(x)                                 (((x) << DDR_PLL_CONFIG_OUTDIV_LSB) & DDR_PLL_CONFIG_OUTDIV_MASK)
+#define DDR_PLL_CONFIG_OUTDIV_RESET                                  0
+#define DDR_PLL_CONFIG_RANGE_MSB                                     22
+#define DDR_PLL_CONFIG_RANGE_LSB                                     21
+#define DDR_PLL_CONFIG_RANGE_MASK                                    0x00600000
+#define DDR_PLL_CONFIG_RANGE_GET(x)                                  (((x) & DDR_PLL_CONFIG_RANGE_MASK) >> DDR_PLL_CONFIG_RANGE_LSB)
+#define DDR_PLL_CONFIG_RANGE_SET(x)                                  (((x) << DDR_PLL_CONFIG_RANGE_LSB) & DDR_PLL_CONFIG_RANGE_MASK)
+#define DDR_PLL_CONFIG_RANGE_RESET                                   3
+#define DDR_PLL_CONFIG_REFDIV_MSB                                    20
+#define DDR_PLL_CONFIG_REFDIV_LSB                                    16
+#define DDR_PLL_CONFIG_REFDIV_MASK                                   0x001f0000
+#define DDR_PLL_CONFIG_REFDIV_GET(x)                                 (((x) & DDR_PLL_CONFIG_REFDIV_MASK) >> DDR_PLL_CONFIG_REFDIV_LSB)
+#define DDR_PLL_CONFIG_REFDIV_SET(x)                                 (((x) << DDR_PLL_CONFIG_REFDIV_LSB) & DDR_PLL_CONFIG_REFDIV_MASK)
+#define DDR_PLL_CONFIG_REFDIV_RESET                                  2
+#define DDR_PLL_CONFIG_NINT_MSB                                      15
+#define DDR_PLL_CONFIG_NINT_LSB                                      10
+#define DDR_PLL_CONFIG_NINT_MASK                                     0x0000fc00
+#define DDR_PLL_CONFIG_NINT_GET(x)                                   (((x) & DDR_PLL_CONFIG_NINT_MASK) >> DDR_PLL_CONFIG_NINT_LSB)
+#define DDR_PLL_CONFIG_NINT_SET(x)                                   (((x) << DDR_PLL_CONFIG_NINT_LSB) & DDR_PLL_CONFIG_NINT_MASK)
+#define DDR_PLL_CONFIG_NINT_RESET                                    20
+#define DDR_PLL_CONFIG_NFRAC_MSB                                     9
+#define DDR_PLL_CONFIG_NFRAC_LSB                                     0
+#define DDR_PLL_CONFIG_NFRAC_MASK                                    0x000003ff
+#define DDR_PLL_CONFIG_NFRAC_GET(x)                                  (((x) & DDR_PLL_CONFIG_NFRAC_MASK) >> DDR_PLL_CONFIG_NFRAC_LSB)
+#define DDR_PLL_CONFIG_NFRAC_SET(x)                                  (((x) << DDR_PLL_CONFIG_NFRAC_LSB) & DDR_PLL_CONFIG_NFRAC_MASK)
+#define DDR_PLL_CONFIG_NFRAC_RESET                                   512
+#define DDR_PLL_CONFIG_ADDRESS                                       0x0004
+#define DDR_PLL_CONFIG_OFFSET                                        0x0004
+// SW modifiable bits
+#define DDR_PLL_CONFIG_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define DDR_PLL_CONFIG_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define DDR_PLL_CONFIG_RESET                                         0xc0625200
+
+// 32'h0008 (CPU_DDR_CLOCK_CONTROL)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_MSB                              31
+#define CPU_DDR_CLOCK_CONTROL_SPARE_LSB                              25
+#define CPU_DDR_CLOCK_CONTROL_SPARE_MASK                             0xfe000000
+#define CPU_DDR_CLOCK_CONTROL_SPARE_GET(x)                           (((x) & CPU_DDR_CLOCK_CONTROL_SPARE_MASK) >> CPU_DDR_CLOCK_CONTROL_SPARE_LSB)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_SET(x)                           (((x) << CPU_DDR_CLOCK_CONTROL_SPARE_LSB) & CPU_DDR_CLOCK_CONTROL_SPARE_MASK)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_RESET                            0
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MSB                 24
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB                 24
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK                0x01000000
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB) & CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_RESET               1
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MSB            23
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB            23
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK           0x00800000
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_GET(x)         (((x) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_SET(x)         (((x) << CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_RESET          0
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MSB               22
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB               22
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK              0x00400000
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_GET(x)            (((x) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_SET(x)            (((x) << CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_RESET             0
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MSB                 21
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_LSB                 21
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MASK                0x00200000
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_LSB) & CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_RESET               1
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MSB                 20
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_LSB                 20
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MASK                0x00100000
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_LSB) & CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_RESET               1
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MSB                       19
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB                       15
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK                      0x000f8000
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MSB                       14
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB                       10
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK                      0x00007c00
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MSB                       9
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB                       5
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK                      0x000003e0
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MSB                     4
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB                     4
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK                    0x00000010
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MSB                     3
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB                     3
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK                    0x00000008
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MSB                     2
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB                     2
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK                    0x00000004
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MSB                       1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB                       1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK                      0x00000002
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK) >> CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB)
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB) & CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK)
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MSB                       0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB                       0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK                      0x00000001
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK) >> CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB) & CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_ADDRESS                                0x0008
+#define CPU_DDR_CLOCK_CONTROL_OFFSET                                 0x0008
+// SW modifiable bits
+#define CPU_DDR_CLOCK_CONTROL_SW_MASK                                0xffffffff
+// bits defined at reset
+#define CPU_DDR_CLOCK_CONTROL_RSTMASK                                0xffffffff
+// reset value (ignore bits undefined at reset)
+#define CPU_DDR_CLOCK_CONTROL_RESET                                  0x0130001c
+
+// 32'h000c (CPU_SYNC)
+#define CPU_SYNC_LENGTH_MSB                                          19
+#define CPU_SYNC_LENGTH_LSB                                          16
+#define CPU_SYNC_LENGTH_MASK                                         0x000f0000
+#define CPU_SYNC_LENGTH_GET(x)                                       (((x) & CPU_SYNC_LENGTH_MASK) >> CPU_SYNC_LENGTH_LSB)
+#define CPU_SYNC_LENGTH_SET(x)                                       (((x) << CPU_SYNC_LENGTH_LSB) & CPU_SYNC_LENGTH_MASK)
+#define CPU_SYNC_LENGTH_RESET                                        0
+#define CPU_SYNC_PATTERN_MSB                                         15
+#define CPU_SYNC_PATTERN_LSB                                         0
+#define CPU_SYNC_PATTERN_MASK                                        0x0000ffff
+#define CPU_SYNC_PATTERN_GET(x)                                      (((x) & CPU_SYNC_PATTERN_MASK) >> CPU_SYNC_PATTERN_LSB)
+#define CPU_SYNC_PATTERN_SET(x)                                      (((x) << CPU_SYNC_PATTERN_LSB) & CPU_SYNC_PATTERN_MASK)
+#define CPU_SYNC_PATTERN_RESET                                       65535
+#define CPU_SYNC_ADDRESS                                             0x000c
+#define CPU_SYNC_OFFSET                                              0x000c
+// SW modifiable bits
+#define CPU_SYNC_SW_MASK                                             0x000fffff
+// bits defined at reset
+#define CPU_SYNC_RSTMASK                                             0xffffffff
+// reset value (ignore bits undefined at reset)
+#define CPU_SYNC_RESET                                               0x0000ffff
+
+// 32'h0010 (PCIE_PLL_CONFIG)
+#define PCIE_PLL_CONFIG_UPDATING_MSB                                 31
+#define PCIE_PLL_CONFIG_UPDATING_LSB                                 31
+#define PCIE_PLL_CONFIG_UPDATING_MASK                                0x80000000
+#define PCIE_PLL_CONFIG_UPDATING_GET(x)                              (((x) & PCIE_PLL_CONFIG_UPDATING_MASK) >> PCIE_PLL_CONFIG_UPDATING_LSB)
+#define PCIE_PLL_CONFIG_UPDATING_SET(x)                              (((x) << PCIE_PLL_CONFIG_UPDATING_LSB) & PCIE_PLL_CONFIG_UPDATING_MASK)
+#define PCIE_PLL_CONFIG_UPDATING_RESET                               0
+#define PCIE_PLL_CONFIG_PLLPWD_MSB                                   30
+#define PCIE_PLL_CONFIG_PLLPWD_LSB                                   30
+#define PCIE_PLL_CONFIG_PLLPWD_MASK                                  0x40000000
+#define PCIE_PLL_CONFIG_PLLPWD_GET(x)                                (((x) & PCIE_PLL_CONFIG_PLLPWD_MASK) >> PCIE_PLL_CONFIG_PLLPWD_LSB)
+#define PCIE_PLL_CONFIG_PLLPWD_SET(x)                                (((x) << PCIE_PLL_CONFIG_PLLPWD_LSB) & PCIE_PLL_CONFIG_PLLPWD_MASK)
+#define PCIE_PLL_CONFIG_PLLPWD_RESET                                 1
+#define PCIE_PLL_CONFIG_BYPASS_MSB                                   16
+#define PCIE_PLL_CONFIG_BYPASS_LSB                                   16
+#define PCIE_PLL_CONFIG_BYPASS_MASK                                  0x00010000
+#define PCIE_PLL_CONFIG_BYPASS_GET(x)                                (((x) & PCIE_PLL_CONFIG_BYPASS_MASK) >> PCIE_PLL_CONFIG_BYPASS_LSB)
+#define PCIE_PLL_CONFIG_BYPASS_SET(x)                                (((x) << PCIE_PLL_CONFIG_BYPASS_LSB) & PCIE_PLL_CONFIG_BYPASS_MASK)
+#define PCIE_PLL_CONFIG_BYPASS_RESET                                 1
+#define PCIE_PLL_CONFIG_REFDIV_MSB                                   14
+#define PCIE_PLL_CONFIG_REFDIV_LSB                                   10
+#define PCIE_PLL_CONFIG_REFDIV_MASK                                  0x00007c00
+#define PCIE_PLL_CONFIG_REFDIV_GET(x)                                (((x) & PCIE_PLL_CONFIG_REFDIV_MASK) >> PCIE_PLL_CONFIG_REFDIV_LSB)
+#define PCIE_PLL_CONFIG_REFDIV_SET(x)                                (((x) << PCIE_PLL_CONFIG_REFDIV_LSB) & PCIE_PLL_CONFIG_REFDIV_MASK)
+#define PCIE_PLL_CONFIG_REFDIV_RESET                                 1
+#define PCIE_PLL_CONFIG_ADDRESS                                      0x0010
+#define PCIE_PLL_CONFIG_OFFSET                                       0x0010
+// SW modifiable bits
+#define PCIE_PLL_CONFIG_SW_MASK                                      0xc0017c00
+// bits defined at reset
+#define PCIE_PLL_CONFIG_RSTMASK                                      0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PLL_CONFIG_RESET                                        0x40010400
+
+// 32'h0014 (PCIE_PLL_DITHER_DIV_MAX)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MSB                        31
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB                        31
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK                       0x80000000
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_GET(x)                     (((x) & PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK) >> PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_SET(x)                     (((x) << PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB) & PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_RESET                      1
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MSB                          30
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB                          30
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK                         0x40000000
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_GET(x)                       (((x) & PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK) >> PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(x)                       (((x) << PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB) & PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_RESET                        1
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MSB                      20
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB                      15
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK                     0x001f8000
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_GET(x)                   (((x) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK) >> PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(x)                   (((x) << PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_RESET                    19
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MSB                     14
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB                     1
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK                    0x00007ffe
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_GET(x)                  (((x) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK) >> PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(x)                  (((x) << PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_RESET                   16383
+#define PCIE_PLL_DITHER_DIV_MAX_ADDRESS                              0x0014
+#define PCIE_PLL_DITHER_DIV_MAX_OFFSET                               0x0014
+// SW modifiable bits
+#define PCIE_PLL_DITHER_DIV_MAX_SW_MASK                              0xc01ffffe
+// bits defined at reset
+#define PCIE_PLL_DITHER_DIV_MAX_RSTMASK                              0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PLL_DITHER_DIV_MAX_RESET                                0xc009fffe
+
+// 32'h0018 (PCIE_PLL_DITHER_DIV_MIN)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MSB                      20
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB                      15
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK                     0x001f8000
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_GET(x)                   (((x) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK) >> PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_SET(x)                   (((x) << PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_RESET                    19
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MSB                     14
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB                     1
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK                    0x00007ffe
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_GET(x)                  (((x) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK) >> PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_SET(x)                  (((x) << PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_RESET                   14749
+#define PCIE_PLL_DITHER_DIV_MIN_ADDRESS                              0x0018
+#define PCIE_PLL_DITHER_DIV_MIN_OFFSET                               0x0018
+// SW modifiable bits
+#define PCIE_PLL_DITHER_DIV_MIN_SW_MASK                              0x001ffffe
+// bits defined at reset
+#define PCIE_PLL_DITHER_DIV_MIN_RSTMASK                              0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PLL_DITHER_DIV_MIN_RESET                                0x0009f33a
+
+// 32'h001c (PCIE_PLL_DITHER_STEP)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_MSB                          31
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB                          28
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK                         0xf0000000
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_GET(x)                       (((x) & PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK) >> PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_SET(x)                       (((x) << PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB) & PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_RESET                        0
+#define PCIE_PLL_DITHER_STEP_STEP_INT_MSB                            24
+#define PCIE_PLL_DITHER_STEP_STEP_INT_LSB                            15
+#define PCIE_PLL_DITHER_STEP_STEP_INT_MASK                           0x01ff8000
+#define PCIE_PLL_DITHER_STEP_STEP_INT_GET(x)                         (((x) & PCIE_PLL_DITHER_STEP_STEP_INT_MASK) >> PCIE_PLL_DITHER_STEP_STEP_INT_LSB)
+#define PCIE_PLL_DITHER_STEP_STEP_INT_SET(x)                         (((x) << PCIE_PLL_DITHER_STEP_STEP_INT_LSB) & PCIE_PLL_DITHER_STEP_STEP_INT_MASK)
+#define PCIE_PLL_DITHER_STEP_STEP_INT_RESET                          0
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_MSB                           14
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB                           1
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK                          0x00007ffe
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_GET(x)                        (((x) & PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK) >> PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB)
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_SET(x)                        (((x) << PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB) & PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK)
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_RESET                         10
+#define PCIE_PLL_DITHER_STEP_ADDRESS                                 0x001c
+#define PCIE_PLL_DITHER_STEP_OFFSET                                  0x001c
+// SW modifiable bits
+#define PCIE_PLL_DITHER_STEP_SW_MASK                                 0xf1fffffe
+// bits defined at reset
+#define PCIE_PLL_DITHER_STEP_RSTMASK                                 0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PLL_DITHER_STEP_RESET                                   0x00000014
+
+// 32'h0020 (LDO_POWER_CONTROL)
+#define LDO_POWER_CONTROL_PKG_SEL_MSB                                5
+#define LDO_POWER_CONTROL_PKG_SEL_LSB                                5
+#define LDO_POWER_CONTROL_PKG_SEL_MASK                               0x00000020
+#define LDO_POWER_CONTROL_PKG_SEL_GET(x)                             (((x) & LDO_POWER_CONTROL_PKG_SEL_MASK) >> LDO_POWER_CONTROL_PKG_SEL_LSB)
+#define LDO_POWER_CONTROL_PKG_SEL_SET(x)                             (((x) << LDO_POWER_CONTROL_PKG_SEL_LSB) & LDO_POWER_CONTROL_PKG_SEL_MASK)
+#define LDO_POWER_CONTROL_PKG_SEL_RESET                              0
+#define LDO_POWER_CONTROL_PWDLDO_CPU_MSB                             4
+#define LDO_POWER_CONTROL_PWDLDO_CPU_LSB                             4
+#define LDO_POWER_CONTROL_PWDLDO_CPU_MASK                            0x00000010
+#define LDO_POWER_CONTROL_PWDLDO_CPU_GET(x)                          (((x) & LDO_POWER_CONTROL_PWDLDO_CPU_MASK) >> LDO_POWER_CONTROL_PWDLDO_CPU_LSB)
+#define LDO_POWER_CONTROL_PWDLDO_CPU_SET(x)                          (((x) << LDO_POWER_CONTROL_PWDLDO_CPU_LSB) & LDO_POWER_CONTROL_PWDLDO_CPU_MASK)
+#define LDO_POWER_CONTROL_PWDLDO_CPU_RESET                           0
+#define LDO_POWER_CONTROL_PWDLDO_DDR_MSB                             3
+#define LDO_POWER_CONTROL_PWDLDO_DDR_LSB                             3
+#define LDO_POWER_CONTROL_PWDLDO_DDR_MASK                            0x00000008
+#define LDO_POWER_CONTROL_PWDLDO_DDR_GET(x)                          (((x) & LDO_POWER_CONTROL_PWDLDO_DDR_MASK) >> LDO_POWER_CONTROL_PWDLDO_DDR_LSB)
+#define LDO_POWER_CONTROL_PWDLDO_DDR_SET(x)                          (((x) << LDO_POWER_CONTROL_PWDLDO_DDR_LSB) & LDO_POWER_CONTROL_PWDLDO_DDR_MASK)
+#define LDO_POWER_CONTROL_PWDLDO_DDR_RESET                           0
+#define LDO_POWER_CONTROL_CPU_REFSEL_MSB                             2
+#define LDO_POWER_CONTROL_CPU_REFSEL_LSB                             1
+#define LDO_POWER_CONTROL_CPU_REFSEL_MASK                            0x00000006
+#define LDO_POWER_CONTROL_CPU_REFSEL_GET(x)                          (((x) & LDO_POWER_CONTROL_CPU_REFSEL_MASK) >> LDO_POWER_CONTROL_CPU_REFSEL_LSB)
+#define LDO_POWER_CONTROL_CPU_REFSEL_SET(x)                          (((x) << LDO_POWER_CONTROL_CPU_REFSEL_LSB) & LDO_POWER_CONTROL_CPU_REFSEL_MASK)
+#define LDO_POWER_CONTROL_CPU_REFSEL_RESET                           3
+#define LDO_POWER_CONTROL_SELECT_DDR1_MSB                            0
+#define LDO_POWER_CONTROL_SELECT_DDR1_LSB                            0
+#define LDO_POWER_CONTROL_SELECT_DDR1_MASK                           0x00000001
+#define LDO_POWER_CONTROL_SELECT_DDR1_GET(x)                         (((x) & LDO_POWER_CONTROL_SELECT_DDR1_MASK) >> LDO_POWER_CONTROL_SELECT_DDR1_LSB)
+#define LDO_POWER_CONTROL_SELECT_DDR1_SET(x)                         (((x) << LDO_POWER_CONTROL_SELECT_DDR1_LSB) & LDO_POWER_CONTROL_SELECT_DDR1_MASK)
+#define LDO_POWER_CONTROL_SELECT_DDR1_RESET                          0
+#define LDO_POWER_CONTROL_ADDRESS                                    0x0020
+#define LDO_POWER_CONTROL_OFFSET                                     0x0020
+// SW modifiable bits
+#define LDO_POWER_CONTROL_SW_MASK                                    0x0000003f
+// bits defined at reset
+#define LDO_POWER_CONTROL_RSTMASK                                    0xffffffff
+// reset value (ignore bits undefined at reset)
+#define LDO_POWER_CONTROL_RESET                                      0x00000006
+
+// 32'h0024 (SWITCH_CLOCK_SPARE)
+#define SWITCH_CLOCK_SPARE_SPARE_MSB                                 31
+#define SWITCH_CLOCK_SPARE_SPARE_LSB                                 12
+#define SWITCH_CLOCK_SPARE_SPARE_MASK                                0xfffff000
+#define SWITCH_CLOCK_SPARE_SPARE_GET(x)                              (((x) & SWITCH_CLOCK_SPARE_SPARE_MASK) >> SWITCH_CLOCK_SPARE_SPARE_LSB)
+#define SWITCH_CLOCK_SPARE_SPARE_SET(x)                              (((x) << SWITCH_CLOCK_SPARE_SPARE_LSB) & SWITCH_CLOCK_SPARE_SPARE_MASK)
+#define SWITCH_CLOCK_SPARE_SPARE_RESET                               0
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MSB                   11
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB                   8
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK                  0x00000f00
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_GET(x)                (((x) & SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK) >> SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(x)                (((x) << SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB) & SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_RESET                 5
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MSB                         7
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB                         7
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK                        0x00000080
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_GET(x)                      (((x) & SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_SET(x)                      (((x) << SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_RESET                       0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MSB                          6
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_LSB                          6
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MASK                         0x00000040
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_GET(x)                       (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_SET(x)                       (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_RESET                        0
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MSB                       5
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB                       5
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK                      0x00000020
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK) >> SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB)
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB) & SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK)
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_RESET                     1
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_MSB                            4
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB                            4
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK                           0x00000010
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_GET(x)                         (((x) & SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK) >> SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB)
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_SET(x)                         (((x) << SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB) & SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK)
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_RESET                          1
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_MSB                            3
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB                            3
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK                           0x00000008
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_GET(x)                         (((x) & SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK) >> SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB)
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_SET(x)                         (((x) << SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB) & SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK)
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_RESET                          0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MSB             2
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_LSB             2
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MASK            0x00000004
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_GET(x)          (((x) & SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MASK) >> SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_LSB)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_SET(x)          (((x) << SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_LSB) & SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MASK)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_RESET           0
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MSB                  1
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB                  1
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK                 0x00000002
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_GET(x)               (((x) & SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK) >> SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB)
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_SET(x)               (((x) << SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB) & SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK)
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_RESET                0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MSB                         0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB                         0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK                        0x00000001
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_GET(x)                      (((x) & SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_SET(x)                      (((x) << SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB) & SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_RESET                       1
+#define SWITCH_CLOCK_SPARE_ADDRESS                                   0x0024
+#define SWITCH_CLOCK_SPARE_OFFSET                                    0x0024
+// SW modifiable bits
+#define SWITCH_CLOCK_SPARE_SW_MASK                                   0xffffffff
+// bits defined at reset
+#define SWITCH_CLOCK_SPARE_RSTMASK                                   0xffffffff
+// reset value (ignore bits undefined at reset)
+#define SWITCH_CLOCK_SPARE_RESET                                     0x00000531
+
+// 32'h0028 (CURRENT_PCIE_PLL_DITHER)
+#define CURRENT_PCIE_PLL_DITHER_INT_MSB                              20
+#define CURRENT_PCIE_PLL_DITHER_INT_LSB                              15
+#define CURRENT_PCIE_PLL_DITHER_INT_MASK                             0x001f8000
+#define CURRENT_PCIE_PLL_DITHER_INT_GET(x)                           (((x) & CURRENT_PCIE_PLL_DITHER_INT_MASK) >> CURRENT_PCIE_PLL_DITHER_INT_LSB)
+#define CURRENT_PCIE_PLL_DITHER_INT_SET(x)                           (((x) << CURRENT_PCIE_PLL_DITHER_INT_LSB) & CURRENT_PCIE_PLL_DITHER_INT_MASK)
+#define CURRENT_PCIE_PLL_DITHER_INT_RESET                            1
+#define CURRENT_PCIE_PLL_DITHER_FRAC_MSB                             13
+#define CURRENT_PCIE_PLL_DITHER_FRAC_LSB                             0
+#define CURRENT_PCIE_PLL_DITHER_FRAC_MASK                            0x00003fff
+#define CURRENT_PCIE_PLL_DITHER_FRAC_GET(x)                          (((x) & CURRENT_PCIE_PLL_DITHER_FRAC_MASK) >> CURRENT_PCIE_PLL_DITHER_FRAC_LSB)
+#define CURRENT_PCIE_PLL_DITHER_FRAC_SET(x)                          (((x) << CURRENT_PCIE_PLL_DITHER_FRAC_LSB) & CURRENT_PCIE_PLL_DITHER_FRAC_MASK)
+#define CURRENT_PCIE_PLL_DITHER_FRAC_RESET                           0
+#define CURRENT_PCIE_PLL_DITHER_ADDRESS                              0x0028
+#define CURRENT_PCIE_PLL_DITHER_OFFSET                               0x0028
+// SW modifiable bits
+#define CURRENT_PCIE_PLL_DITHER_SW_MASK                              0x001fbfff
+// bits defined at reset
+#define CURRENT_PCIE_PLL_DITHER_RSTMASK                              0xffffffff
+// reset value (ignore bits undefined at reset)
+#define CURRENT_PCIE_PLL_DITHER_RESET                                0x00008000
+
+// 32'h002c (ETH_XMII)
+#define ETH_XMII_TX_INVERT_MSB                                       31
+#define ETH_XMII_TX_INVERT_LSB                                       31
+#define ETH_XMII_TX_INVERT_MASK                                      0x80000000
+#define ETH_XMII_TX_INVERT_GET(x)                                    (((x) & ETH_XMII_TX_INVERT_MASK) >> ETH_XMII_TX_INVERT_LSB)
+#define ETH_XMII_TX_INVERT_SET(x)                                    (((x) << ETH_XMII_TX_INVERT_LSB) & ETH_XMII_TX_INVERT_MASK)
+#define ETH_XMII_TX_INVERT_RESET                                     0
+#define ETH_XMII_GIGE_QUAD_MSB                                       30
+#define ETH_XMII_GIGE_QUAD_LSB                                       30
+#define ETH_XMII_GIGE_QUAD_MASK                                      0x40000000
+#define ETH_XMII_GIGE_QUAD_GET(x)                                    (((x) & ETH_XMII_GIGE_QUAD_MASK) >> ETH_XMII_GIGE_QUAD_LSB)
+#define ETH_XMII_GIGE_QUAD_SET(x)                                    (((x) << ETH_XMII_GIGE_QUAD_LSB) & ETH_XMII_GIGE_QUAD_MASK)
+#define ETH_XMII_GIGE_QUAD_RESET                                     0
+#define ETH_XMII_RX_DELAY_MSB                                        29
+#define ETH_XMII_RX_DELAY_LSB                                        28
+#define ETH_XMII_RX_DELAY_MASK                                       0x30000000
+#define ETH_XMII_RX_DELAY_GET(x)                                     (((x) & ETH_XMII_RX_DELAY_MASK) >> ETH_XMII_RX_DELAY_LSB)
+#define ETH_XMII_RX_DELAY_SET(x)                                     (((x) << ETH_XMII_RX_DELAY_LSB) & ETH_XMII_RX_DELAY_MASK)
+#define ETH_XMII_RX_DELAY_RESET                                      0
+#define ETH_XMII_TX_DELAY_MSB                                        27
+#define ETH_XMII_TX_DELAY_LSB                                        26
+#define ETH_XMII_TX_DELAY_MASK                                       0x0c000000
+#define ETH_XMII_TX_DELAY_GET(x)                                     (((x) & ETH_XMII_TX_DELAY_MASK) >> ETH_XMII_TX_DELAY_LSB)
+#define ETH_XMII_TX_DELAY_SET(x)                                     (((x) << ETH_XMII_TX_DELAY_LSB) & ETH_XMII_TX_DELAY_MASK)
+#define ETH_XMII_TX_DELAY_RESET                                      0
+#define ETH_XMII_GIGE_MSB                                            25
+#define ETH_XMII_GIGE_LSB                                            25
+#define ETH_XMII_GIGE_MASK                                           0x02000000
+#define ETH_XMII_GIGE_GET(x)                                         (((x) & ETH_XMII_GIGE_MASK) >> ETH_XMII_GIGE_LSB)
+#define ETH_XMII_GIGE_SET(x)                                         (((x) << ETH_XMII_GIGE_LSB) & ETH_XMII_GIGE_MASK)
+#define ETH_XMII_GIGE_RESET                                          0
+#define ETH_XMII_OFFSET_PHASE_MSB                                    24
+#define ETH_XMII_OFFSET_PHASE_LSB                                    24
+#define ETH_XMII_OFFSET_PHASE_MASK                                   0x01000000
+#define ETH_XMII_OFFSET_PHASE_GET(x)                                 (((x) & ETH_XMII_OFFSET_PHASE_MASK) >> ETH_XMII_OFFSET_PHASE_LSB)
+#define ETH_XMII_OFFSET_PHASE_SET(x)                                 (((x) << ETH_XMII_OFFSET_PHASE_LSB) & ETH_XMII_OFFSET_PHASE_MASK)
+#define ETH_XMII_OFFSET_PHASE_RESET                                  0
+#define ETH_XMII_OFFSET_COUNT_MSB                                    23
+#define ETH_XMII_OFFSET_COUNT_LSB                                    16
+#define ETH_XMII_OFFSET_COUNT_MASK                                   0x00ff0000
+#define ETH_XMII_OFFSET_COUNT_GET(x)                                 (((x) & ETH_XMII_OFFSET_COUNT_MASK) >> ETH_XMII_OFFSET_COUNT_LSB)
+#define ETH_XMII_OFFSET_COUNT_SET(x)                                 (((x) << ETH_XMII_OFFSET_COUNT_LSB) & ETH_XMII_OFFSET_COUNT_MASK)
+#define ETH_XMII_OFFSET_COUNT_RESET                                  0
+#define ETH_XMII_PHASE1_COUNT_MSB                                    15
+#define ETH_XMII_PHASE1_COUNT_LSB                                    8
+#define ETH_XMII_PHASE1_COUNT_MASK                                   0x0000ff00
+#define ETH_XMII_PHASE1_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE1_COUNT_MASK) >> ETH_XMII_PHASE1_COUNT_LSB)
+#define ETH_XMII_PHASE1_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE1_COUNT_LSB) & ETH_XMII_PHASE1_COUNT_MASK)
+#define ETH_XMII_PHASE1_COUNT_RESET                                  1
+#define ETH_XMII_PHASE0_COUNT_MSB                                    7
+#define ETH_XMII_PHASE0_COUNT_LSB                                    0
+#define ETH_XMII_PHASE0_COUNT_MASK                                   0x000000ff
+#define ETH_XMII_PHASE0_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE0_COUNT_MASK) >> ETH_XMII_PHASE0_COUNT_LSB)
+#define ETH_XMII_PHASE0_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE0_COUNT_LSB) & ETH_XMII_PHASE0_COUNT_MASK)
+#define ETH_XMII_PHASE0_COUNT_RESET                                  1
+#define ETH_XMII_ADDRESS                                             0x002c
+#define ETH_XMII_OFFSET                                              0x002c
+// SW modifiable bits
+#define ETH_XMII_SW_MASK                                             0xffffffff
+// bits defined at reset
+#define ETH_XMII_RSTMASK                                             0xffffffff
+// reset value (ignore bits undefined at reset)
+#define ETH_XMII_RESET                                               0x00000101
+
+// 32'h0030 (AUDIO_PLL_CONFIG)
+#define AUDIO_PLL_CONFIG_UPDATING_MSB                                31
+#define AUDIO_PLL_CONFIG_UPDATING_LSB                                31
+#define AUDIO_PLL_CONFIG_UPDATING_MASK                               0x80000000
+#define AUDIO_PLL_CONFIG_UPDATING_GET(x)                             (((x) & AUDIO_PLL_CONFIG_UPDATING_MASK) >> AUDIO_PLL_CONFIG_UPDATING_LSB)
+#define AUDIO_PLL_CONFIG_UPDATING_SET(x)                             (((x) << AUDIO_PLL_CONFIG_UPDATING_LSB) & AUDIO_PLL_CONFIG_UPDATING_MASK)
+#define AUDIO_PLL_CONFIG_UPDATING_RESET                              1
+#define AUDIO_PLL_CONFIG_EXT_DIV_MSB                                 14
+#define AUDIO_PLL_CONFIG_EXT_DIV_LSB                                 12
+#define AUDIO_PLL_CONFIG_EXT_DIV_MASK                                0x00007000
+#define AUDIO_PLL_CONFIG_EXT_DIV_GET(x)                              (((x) & AUDIO_PLL_CONFIG_EXT_DIV_MASK) >> AUDIO_PLL_CONFIG_EXT_DIV_LSB)
+#define AUDIO_PLL_CONFIG_EXT_DIV_SET(x)                              (((x) << AUDIO_PLL_CONFIG_EXT_DIV_LSB) & AUDIO_PLL_CONFIG_EXT_DIV_MASK)
+#define AUDIO_PLL_CONFIG_EXT_DIV_RESET                               1
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_MSB                              9
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_LSB                              7
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_MASK                             0x00000380
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_GET(x)                           (((x) & AUDIO_PLL_CONFIG_POSTPLLDIV_MASK) >> AUDIO_PLL_CONFIG_POSTPLLDIV_LSB)
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_SET(x)                           (((x) << AUDIO_PLL_CONFIG_POSTPLLDIV_LSB) & AUDIO_PLL_CONFIG_POSTPLLDIV_MASK)
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_RESET                            1
+#define AUDIO_PLL_CONFIG_PLLPWD_MSB                                  5
+#define AUDIO_PLL_CONFIG_PLLPWD_LSB                                  5
+#define AUDIO_PLL_CONFIG_PLLPWD_MASK                                 0x00000020
+#define AUDIO_PLL_CONFIG_PLLPWD_GET(x)                               (((x) & AUDIO_PLL_CONFIG_PLLPWD_MASK) >> AUDIO_PLL_CONFIG_PLLPWD_LSB)
+#define AUDIO_PLL_CONFIG_PLLPWD_SET(x)                               (((x) << AUDIO_PLL_CONFIG_PLLPWD_LSB) & AUDIO_PLL_CONFIG_PLLPWD_MASK)
+#define AUDIO_PLL_CONFIG_PLLPWD_RESET                                1
+#define AUDIO_PLL_CONFIG_BYPASS_MSB                                  4
+#define AUDIO_PLL_CONFIG_BYPASS_LSB                                  4
+#define AUDIO_PLL_CONFIG_BYPASS_MASK                                 0x00000010
+#define AUDIO_PLL_CONFIG_BYPASS_GET(x)                               (((x) & AUDIO_PLL_CONFIG_BYPASS_MASK) >> AUDIO_PLL_CONFIG_BYPASS_LSB)
+#define AUDIO_PLL_CONFIG_BYPASS_SET(x)                               (((x) << AUDIO_PLL_CONFIG_BYPASS_LSB) & AUDIO_PLL_CONFIG_BYPASS_MASK)
+#define AUDIO_PLL_CONFIG_BYPASS_RESET                                1
+#define AUDIO_PLL_CONFIG_REFDIV_MSB                                  3
+#define AUDIO_PLL_CONFIG_REFDIV_LSB                                  0
+#define AUDIO_PLL_CONFIG_REFDIV_MASK                                 0x0000000f
+#define AUDIO_PLL_CONFIG_REFDIV_GET(x)                               (((x) & AUDIO_PLL_CONFIG_REFDIV_MASK) >> AUDIO_PLL_CONFIG_REFDIV_LSB)
+#define AUDIO_PLL_CONFIG_REFDIV_SET(x)                               (((x) << AUDIO_PLL_CONFIG_REFDIV_LSB) & AUDIO_PLL_CONFIG_REFDIV_MASK)
+#define AUDIO_PLL_CONFIG_REFDIV_RESET                                3
+#define AUDIO_PLL_CONFIG_ADDRESS                                     0x0030
+#define AUDIO_PLL_CONFIG_OFFSET                                      0x0030
+// SW modifiable bits
+#define AUDIO_PLL_CONFIG_SW_MASK                                     0x800073bf
+// bits defined at reset
+#define AUDIO_PLL_CONFIG_RSTMASK                                     0xffffffff
+// reset value (ignore bits undefined at reset)
+#define AUDIO_PLL_CONFIG_RESET                                       0x800010b3
+
+// 32'h0034 (AUDIO_PLL_MODULATION)
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MSB                        28
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_LSB                        11
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MASK                       0x1ffff800
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_GET(x)                     (((x) & AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MASK) >> AUDIO_PLL_MODULATION_TGT_DIV_FRAC_LSB)
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_SET(x)                     (((x) << AUDIO_PLL_MODULATION_TGT_DIV_FRAC_LSB) & AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MASK)
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_RESET                      84222
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_MSB                         6
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_LSB                         1
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_MASK                        0x0000007e
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_GET(x)                      (((x) & AUDIO_PLL_MODULATION_TGT_DIV_INT_MASK) >> AUDIO_PLL_MODULATION_TGT_DIV_INT_LSB)
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_SET(x)                      (((x) << AUDIO_PLL_MODULATION_TGT_DIV_INT_LSB) & AUDIO_PLL_MODULATION_TGT_DIV_INT_MASK)
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_RESET                       20
+#define AUDIO_PLL_MODULATION_START_MSB                               0
+#define AUDIO_PLL_MODULATION_START_LSB                               0
+#define AUDIO_PLL_MODULATION_START_MASK                              0x00000001
+#define AUDIO_PLL_MODULATION_START_GET(x)                            (((x) & AUDIO_PLL_MODULATION_START_MASK) >> AUDIO_PLL_MODULATION_START_LSB)
+#define AUDIO_PLL_MODULATION_START_SET(x)                            (((x) << AUDIO_PLL_MODULATION_START_LSB) & AUDIO_PLL_MODULATION_START_MASK)
+#define AUDIO_PLL_MODULATION_START_RESET                             0
+#define AUDIO_PLL_MODULATION_ADDRESS                                 0x0034
+#define AUDIO_PLL_MODULATION_OFFSET                                  0x0034
+// SW modifiable bits
+#define AUDIO_PLL_MODULATION_SW_MASK                                 0x1ffff87f
+// bits defined at reset
+#define AUDIO_PLL_MODULATION_RSTMASK                                 0xffffffff
+// reset value (ignore bits undefined at reset)
+#define AUDIO_PLL_MODULATION_RESET                                   0x0a47f028
+
+// 32'h0038 (AUDIO_PLL_MOD_STEP)
+#define AUDIO_PLL_MOD_STEP_FRAC_MSB                                  31
+#define AUDIO_PLL_MOD_STEP_FRAC_LSB                                  14
+#define AUDIO_PLL_MOD_STEP_FRAC_MASK                                 0xffffc000
+#define AUDIO_PLL_MOD_STEP_FRAC_GET(x)                               (((x) & AUDIO_PLL_MOD_STEP_FRAC_MASK) >> AUDIO_PLL_MOD_STEP_FRAC_LSB)
+#define AUDIO_PLL_MOD_STEP_FRAC_SET(x)                               (((x) << AUDIO_PLL_MOD_STEP_FRAC_LSB) & AUDIO_PLL_MOD_STEP_FRAC_MASK)
+#define AUDIO_PLL_MOD_STEP_FRAC_RESET                                1
+#define AUDIO_PLL_MOD_STEP_INT_MSB                                   13
+#define AUDIO_PLL_MOD_STEP_INT_LSB                                   4
+#define AUDIO_PLL_MOD_STEP_INT_MASK                                  0x00003ff0
+#define AUDIO_PLL_MOD_STEP_INT_GET(x)                                (((x) & AUDIO_PLL_MOD_STEP_INT_MASK) >> AUDIO_PLL_MOD_STEP_INT_LSB)
+#define AUDIO_PLL_MOD_STEP_INT_SET(x)                                (((x) << AUDIO_PLL_MOD_STEP_INT_LSB) & AUDIO_PLL_MOD_STEP_INT_MASK)
+#define AUDIO_PLL_MOD_STEP_INT_RESET                                 0
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_MSB                            3
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_LSB                            0
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_MASK                           0x0000000f
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_GET(x)                         (((x) & AUDIO_PLL_MOD_STEP_UPDATE_CNT_MASK) >> AUDIO_PLL_MOD_STEP_UPDATE_CNT_LSB)
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_SET(x)                         (((x) << AUDIO_PLL_MOD_STEP_UPDATE_CNT_LSB) & AUDIO_PLL_MOD_STEP_UPDATE_CNT_MASK)
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_RESET                          0
+#define AUDIO_PLL_MOD_STEP_ADDRESS                                   0x0038
+#define AUDIO_PLL_MOD_STEP_OFFSET                                    0x0038
+// SW modifiable bits
+#define AUDIO_PLL_MOD_STEP_SW_MASK                                   0xffffffff
+// bits defined at reset
+#define AUDIO_PLL_MOD_STEP_RSTMASK                                   0xffffffff
+// reset value (ignore bits undefined at reset)
+#define AUDIO_PLL_MOD_STEP_RESET                                     0x00004000
+
+// 32'h003c (CURRENT_AUDIO_PLL_MODULATION)
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_MSB                        27
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_LSB                        10
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_MASK                       0x0ffffc00
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_GET(x)                     (((x) & CURRENT_AUDIO_PLL_MODULATION_FRAC_MASK) >> CURRENT_AUDIO_PLL_MODULATION_FRAC_LSB)
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_SET(x)                     (((x) << CURRENT_AUDIO_PLL_MODULATION_FRAC_LSB) & CURRENT_AUDIO_PLL_MODULATION_FRAC_MASK)
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_RESET                      1
+#define CURRENT_AUDIO_PLL_MODULATION_INT_MSB                         6
+#define CURRENT_AUDIO_PLL_MODULATION_INT_LSB                         1
+#define CURRENT_AUDIO_PLL_MODULATION_INT_MASK                        0x0000007e
+#define CURRENT_AUDIO_PLL_MODULATION_INT_GET(x)                      (((x) & CURRENT_AUDIO_PLL_MODULATION_INT_MASK) >> CURRENT_AUDIO_PLL_MODULATION_INT_LSB)
+#define CURRENT_AUDIO_PLL_MODULATION_INT_SET(x)                      (((x) << CURRENT_AUDIO_PLL_MODULATION_INT_LSB) & CURRENT_AUDIO_PLL_MODULATION_INT_MASK)
+#define CURRENT_AUDIO_PLL_MODULATION_INT_RESET                       0
+#define CURRENT_AUDIO_PLL_MODULATION_ADDRESS                         0x003c
+#define CURRENT_AUDIO_PLL_MODULATION_OFFSET                          0x003c
+// SW modifiable bits
+#define CURRENT_AUDIO_PLL_MODULATION_SW_MASK                         0x0ffffc7e
+// bits defined at reset
+#define CURRENT_AUDIO_PLL_MODULATION_RSTMASK                         0xffffffff
+// reset value (ignore bits undefined at reset)
+#define CURRENT_AUDIO_PLL_MODULATION_RESET                           0x00000400
+
+#define RST_BOOTSTRAP_ADDRESS                                        0x180600b0
+
+// 32'h0040 (BB_PLL_CONFIG)
+#define BB_PLL_CONFIG_UPDATING_MSB                                   31
+#define BB_PLL_CONFIG_UPDATING_LSB                                   31
+#define BB_PLL_CONFIG_UPDATING_MASK                                  0x80000000
+#define BB_PLL_CONFIG_UPDATING_GET(x)                                (((x) & BB_PLL_CONFIG_UPDATING_MASK) >> BB_PLL_CONFIG_UPDATING_LSB)
+#define BB_PLL_CONFIG_UPDATING_SET(x)                                (((x) << BB_PLL_CONFIG_UPDATING_LSB) & BB_PLL_CONFIG_UPDATING_MASK)
+#define BB_PLL_CONFIG_UPDATING_RESET                                 1
+#define BB_PLL_CONFIG_PLLPWD_MSB                                     30
+#define BB_PLL_CONFIG_PLLPWD_LSB                                     30
+#define BB_PLL_CONFIG_PLLPWD_MASK                                    0x40000000
+#define BB_PLL_CONFIG_PLLPWD_GET(x)                                  (((x) & BB_PLL_CONFIG_PLLPWD_MASK) >> BB_PLL_CONFIG_PLLPWD_LSB)
+#define BB_PLL_CONFIG_PLLPWD_SET(x)                                  (((x) << BB_PLL_CONFIG_PLLPWD_LSB) & BB_PLL_CONFIG_PLLPWD_MASK)
+#define BB_PLL_CONFIG_PLLPWD_RESET                                   1
+#define BB_PLL_CONFIG_SPARE_MSB                                      29
+#define BB_PLL_CONFIG_SPARE_LSB                                      29
+#define BB_PLL_CONFIG_SPARE_MASK                                     0x20000000
+#define BB_PLL_CONFIG_SPARE_GET(x)                                   (((x) & BB_PLL_CONFIG_SPARE_MASK) >> BB_PLL_CONFIG_SPARE_LSB)
+#define BB_PLL_CONFIG_SPARE_SET(x)                                   (((x) << BB_PLL_CONFIG_SPARE_LSB) & BB_PLL_CONFIG_SPARE_MASK)
+#define BB_PLL_CONFIG_SPARE_RESET                                    0
+#define BB_PLL_CONFIG_REFDIV_MSB                                     28
+#define BB_PLL_CONFIG_REFDIV_LSB                                     24
+#define BB_PLL_CONFIG_REFDIV_MASK                                    0x1f000000
+#define BB_PLL_CONFIG_REFDIV_GET(x)                                  (((x) & BB_PLL_CONFIG_REFDIV_MASK) >> BB_PLL_CONFIG_REFDIV_LSB)
+#define BB_PLL_CONFIG_REFDIV_SET(x)                                  (((x) << BB_PLL_CONFIG_REFDIV_LSB) & BB_PLL_CONFIG_REFDIV_MASK)
+#define BB_PLL_CONFIG_REFDIV_RESET                                   1
+#define BB_PLL_CONFIG_NINT_MSB                                       21
+#define BB_PLL_CONFIG_NINT_LSB                                       16
+#define BB_PLL_CONFIG_NINT_MASK                                      0x003f0000
+#define BB_PLL_CONFIG_NINT_GET(x)                                    (((x) & BB_PLL_CONFIG_NINT_MASK) >> BB_PLL_CONFIG_NINT_LSB)
+#define BB_PLL_CONFIG_NINT_SET(x)                                    (((x) << BB_PLL_CONFIG_NINT_LSB) & BB_PLL_CONFIG_NINT_MASK)
+#define BB_PLL_CONFIG_NINT_RESET                                     2
+#define BB_PLL_CONFIG_NFRAC_MSB                                      13
+#define BB_PLL_CONFIG_NFRAC_LSB                                      0
+#define BB_PLL_CONFIG_NFRAC_MASK                                     0x00003fff
+#define BB_PLL_CONFIG_NFRAC_GET(x)                                   (((x) & BB_PLL_CONFIG_NFRAC_MASK) >> BB_PLL_CONFIG_NFRAC_LSB)
+#define BB_PLL_CONFIG_NFRAC_SET(x)                                   (((x) << BB_PLL_CONFIG_NFRAC_LSB) & BB_PLL_CONFIG_NFRAC_MASK)
+#define BB_PLL_CONFIG_NFRAC_RESET                                    3276
+#define BB_PLL_CONFIG_ADDRESS                                        0x0040
+#define BB_PLL_CONFIG_OFFSET                                         0x0040
+// SW modifiable bits
+#define BB_PLL_CONFIG_SW_MASK                                        0xff3f3fff
+// bits defined at reset
+#define BB_PLL_CONFIG_RSTMASK                                        0xffffffff
+// reset value (ignore bits undefined at reset)
+#define BB_PLL_CONFIG_RESET                                          0xc1020ccc
+
+// 32'h0044 (DDR_PLL_DITHER)
+#define DDR_PLL_DITHER_DITHER_EN_MSB                                 31
+#define DDR_PLL_DITHER_DITHER_EN_LSB                                 31
+#define DDR_PLL_DITHER_DITHER_EN_MASK                                0x80000000
+#define DDR_PLL_DITHER_DITHER_EN_GET(x)                              (((x) & DDR_PLL_DITHER_DITHER_EN_MASK) >> DDR_PLL_DITHER_DITHER_EN_LSB)
+#define DDR_PLL_DITHER_DITHER_EN_SET(x)                              (((x) << DDR_PLL_DITHER_DITHER_EN_LSB) & DDR_PLL_DITHER_DITHER_EN_MASK)
+#define DDR_PLL_DITHER_DITHER_EN_RESET                               0
+#define DDR_PLL_DITHER_UPDATE_COUNT_MSB                              30
+#define DDR_PLL_DITHER_UPDATE_COUNT_LSB                              27
+#define DDR_PLL_DITHER_UPDATE_COUNT_MASK                             0x78000000
+#define DDR_PLL_DITHER_UPDATE_COUNT_GET(x)                           (((x) & DDR_PLL_DITHER_UPDATE_COUNT_MASK) >> DDR_PLL_DITHER_UPDATE_COUNT_LSB)
+#define DDR_PLL_DITHER_UPDATE_COUNT_SET(x)                           (((x) << DDR_PLL_DITHER_UPDATE_COUNT_LSB) & DDR_PLL_DITHER_UPDATE_COUNT_MASK)
+#define DDR_PLL_DITHER_UPDATE_COUNT_RESET                            15
+#define DDR_PLL_DITHER_NFRAC_STEP_MSB                                26
+#define DDR_PLL_DITHER_NFRAC_STEP_LSB                                20
+#define DDR_PLL_DITHER_NFRAC_STEP_MASK                               0x07f00000
+#define DDR_PLL_DITHER_NFRAC_STEP_GET(x)                             (((x) & DDR_PLL_DITHER_NFRAC_STEP_MASK) >> DDR_PLL_DITHER_NFRAC_STEP_LSB)
+#define DDR_PLL_DITHER_NFRAC_STEP_SET(x)                             (((x) << DDR_PLL_DITHER_NFRAC_STEP_LSB) & DDR_PLL_DITHER_NFRAC_STEP_MASK)
+#define DDR_PLL_DITHER_NFRAC_STEP_RESET                              1
+#define DDR_PLL_DITHER_NFRAC_MIN_MSB                                 19
+#define DDR_PLL_DITHER_NFRAC_MIN_LSB                                 10
+#define DDR_PLL_DITHER_NFRAC_MIN_MASK                                0x000ffc00
+#define DDR_PLL_DITHER_NFRAC_MIN_GET(x)                              (((x) & DDR_PLL_DITHER_NFRAC_MIN_MASK) >> DDR_PLL_DITHER_NFRAC_MIN_LSB)
+#define DDR_PLL_DITHER_NFRAC_MIN_SET(x)                              (((x) << DDR_PLL_DITHER_NFRAC_MIN_LSB) & DDR_PLL_DITHER_NFRAC_MIN_MASK)
+#define DDR_PLL_DITHER_NFRAC_MIN_RESET                               25
+#define DDR_PLL_DITHER_NFRAC_MAX_MSB                                 9
+#define DDR_PLL_DITHER_NFRAC_MAX_LSB                                 0
+#define DDR_PLL_DITHER_NFRAC_MAX_MASK                                0x000003ff
+#define DDR_PLL_DITHER_NFRAC_MAX_GET(x)                              (((x) & DDR_PLL_DITHER_NFRAC_MAX_MASK) >> DDR_PLL_DITHER_NFRAC_MAX_LSB)
+#define DDR_PLL_DITHER_NFRAC_MAX_SET(x)                              (((x) << DDR_PLL_DITHER_NFRAC_MAX_LSB) & DDR_PLL_DITHER_NFRAC_MAX_MASK)
+#define DDR_PLL_DITHER_NFRAC_MAX_RESET                               1000
+#define DDR_PLL_DITHER_ADDRESS                                       0x0044
+#define DDR_PLL_DITHER_OFFSET                                        0x0044
+// SW modifiable bits
+#define DDR_PLL_DITHER_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define DDR_PLL_DITHER_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define DDR_PLL_DITHER_RESET                                         0x781067e8
+
+// 32'h0048 (CPU_PLL_DITHER)
+#define CPU_PLL_DITHER_DITHER_EN_MSB                                 31
+#define CPU_PLL_DITHER_DITHER_EN_LSB                                 31
+#define CPU_PLL_DITHER_DITHER_EN_MASK                                0x80000000
+#define CPU_PLL_DITHER_DITHER_EN_GET(x)                              (((x) & CPU_PLL_DITHER_DITHER_EN_MASK) >> CPU_PLL_DITHER_DITHER_EN_LSB)
+#define CPU_PLL_DITHER_DITHER_EN_SET(x)                              (((x) << CPU_PLL_DITHER_DITHER_EN_LSB) & CPU_PLL_DITHER_DITHER_EN_MASK)
+#define CPU_PLL_DITHER_DITHER_EN_RESET                               0
+#define CPU_PLL_DITHER_UPDATE_COUNT_MSB                              23
+#define CPU_PLL_DITHER_UPDATE_COUNT_LSB                              18
+#define CPU_PLL_DITHER_UPDATE_COUNT_MASK                             0x00fc0000
+#define CPU_PLL_DITHER_UPDATE_COUNT_GET(x)                           (((x) & CPU_PLL_DITHER_UPDATE_COUNT_MASK) >> CPU_PLL_DITHER_UPDATE_COUNT_LSB)
+#define CPU_PLL_DITHER_UPDATE_COUNT_SET(x)                           (((x) << CPU_PLL_DITHER_UPDATE_COUNT_LSB) & CPU_PLL_DITHER_UPDATE_COUNT_MASK)
+#define CPU_PLL_DITHER_UPDATE_COUNT_RESET                            20
+#define CPU_PLL_DITHER_NFRAC_STEP_MSB                                17
+#define CPU_PLL_DITHER_NFRAC_STEP_LSB                                12
+#define CPU_PLL_DITHER_NFRAC_STEP_MASK                               0x0003f000
+#define CPU_PLL_DITHER_NFRAC_STEP_GET(x)                             (((x) & CPU_PLL_DITHER_NFRAC_STEP_MASK) >> CPU_PLL_DITHER_NFRAC_STEP_LSB)
+#define CPU_PLL_DITHER_NFRAC_STEP_SET(x)                             (((x) << CPU_PLL_DITHER_NFRAC_STEP_LSB) & CPU_PLL_DITHER_NFRAC_STEP_MASK)
+#define CPU_PLL_DITHER_NFRAC_STEP_RESET                              1
+#define CPU_PLL_DITHER_NFRAC_MIN_MSB                                 11
+#define CPU_PLL_DITHER_NFRAC_MIN_LSB                                 6
+#define CPU_PLL_DITHER_NFRAC_MIN_MASK                                0x00000fc0
+#define CPU_PLL_DITHER_NFRAC_MIN_GET(x)                              (((x) & CPU_PLL_DITHER_NFRAC_MIN_MASK) >> CPU_PLL_DITHER_NFRAC_MIN_LSB)
+#define CPU_PLL_DITHER_NFRAC_MIN_SET(x)                              (((x) << CPU_PLL_DITHER_NFRAC_MIN_LSB) & CPU_PLL_DITHER_NFRAC_MIN_MASK)
+#define CPU_PLL_DITHER_NFRAC_MIN_RESET                               3
+#define CPU_PLL_DITHER_NFRAC_MAX_MSB                                 5
+#define CPU_PLL_DITHER_NFRAC_MAX_LSB                                 0
+#define CPU_PLL_DITHER_NFRAC_MAX_MASK                                0x0000003f
+#define CPU_PLL_DITHER_NFRAC_MAX_GET(x)                              (((x) & CPU_PLL_DITHER_NFRAC_MAX_MASK) >> CPU_PLL_DITHER_NFRAC_MAX_LSB)
+#define CPU_PLL_DITHER_NFRAC_MAX_SET(x)                              (((x) << CPU_PLL_DITHER_NFRAC_MAX_LSB) & CPU_PLL_DITHER_NFRAC_MAX_MASK)
+#define CPU_PLL_DITHER_NFRAC_MAX_RESET                               60
+#define CPU_PLL_DITHER_ADDRESS                                       0x0048
+#define CPU_PLL_DITHER_OFFSET                                        0x0048
+// SW modifiable bits
+#define CPU_PLL_DITHER_SW_MASK                                       0x80ffffff
+// bits defined at reset
+#define CPU_PLL_DITHER_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define CPU_PLL_DITHER_RESET                                         0x005010fc
+
+// 32'h1806001c (RST_RESET)
+#define RST_RESET_HOST_RESET_MSB                                     31
+#define RST_RESET_HOST_RESET_LSB                                     31
+#define RST_RESET_HOST_RESET_MASK                                    0x80000000
+#define RST_RESET_HOST_RESET_GET(x)                                  (((x) & RST_RESET_HOST_RESET_MASK) >> RST_RESET_HOST_RESET_LSB)
+#define RST_RESET_HOST_RESET_SET(x)                                  (((x) << RST_RESET_HOST_RESET_LSB) & RST_RESET_HOST_RESET_MASK)
+#define RST_RESET_HOST_RESET_RESET                                   0
+#define RST_RESET_SLIC_RESET_MSB                                     30
+#define RST_RESET_SLIC_RESET_LSB                                     30
+#define RST_RESET_SLIC_RESET_MASK                                    0x40000000
+#define RST_RESET_SLIC_RESET_GET(x)                                  (((x) & RST_RESET_SLIC_RESET_MASK) >> RST_RESET_SLIC_RESET_LSB)
+#define RST_RESET_SLIC_RESET_SET(x)                                  (((x) << RST_RESET_SLIC_RESET_LSB) & RST_RESET_SLIC_RESET_MASK)
+#define RST_RESET_SLIC_RESET_RESET                                   0
+#define RST_RESET_HDMA_RESET_MSB                                     29
+#define RST_RESET_HDMA_RESET_LSB                                     29
+#define RST_RESET_HDMA_RESET_MASK                                    0x20000000
+#define RST_RESET_HDMA_RESET_GET(x)                                  (((x) & RST_RESET_HDMA_RESET_MASK) >> RST_RESET_HDMA_RESET_LSB)
+#define RST_RESET_HDMA_RESET_SET(x)                                  (((x) << RST_RESET_HDMA_RESET_LSB) & RST_RESET_HDMA_RESET_MASK)
+#define RST_RESET_HDMA_RESET_RESET                                   1
+#define RST_RESET_EXTERNAL_RESET_MSB                                 28
+#define RST_RESET_EXTERNAL_RESET_LSB                                 28
+#define RST_RESET_EXTERNAL_RESET_MASK                                0x10000000
+#define RST_RESET_EXTERNAL_RESET_GET(x)                              (((x) & RST_RESET_EXTERNAL_RESET_MASK) >> RST_RESET_EXTERNAL_RESET_LSB)
+#define RST_RESET_EXTERNAL_RESET_SET(x)                              (((x) << RST_RESET_EXTERNAL_RESET_LSB) & RST_RESET_EXTERNAL_RESET_MASK)
+#define RST_RESET_EXTERNAL_RESET_RESET                               0
+#define RST_RESET_RTC_RESET_MSB                                      27
+#define RST_RESET_RTC_RESET_LSB                                      27
+#define RST_RESET_RTC_RESET_MASK                                     0x08000000
+#define RST_RESET_RTC_RESET_GET(x)                                   (((x) & RST_RESET_RTC_RESET_MASK) >> RST_RESET_RTC_RESET_LSB)
+#define RST_RESET_RTC_RESET_SET(x)                                   (((x) << RST_RESET_RTC_RESET_LSB) & RST_RESET_RTC_RESET_MASK)
+#define RST_RESET_RTC_RESET_RESET                                    1
+#define RST_RESET_PCIEEP_RST_INT_MSB                                 26
+#define RST_RESET_PCIEEP_RST_INT_LSB                                 26
+#define RST_RESET_PCIEEP_RST_INT_MASK                                0x04000000
+#define RST_RESET_PCIEEP_RST_INT_GET(x)                              (((x) & RST_RESET_PCIEEP_RST_INT_MASK) >> RST_RESET_PCIEEP_RST_INT_LSB)
+#define RST_RESET_PCIEEP_RST_INT_SET(x)                              (((x) << RST_RESET_PCIEEP_RST_INT_LSB) & RST_RESET_PCIEEP_RST_INT_MASK)
+#define RST_RESET_PCIEEP_RST_INT_RESET                               0
+#define RST_RESET_CHKSUM_ACC_RESET_MSB                               25
+#define RST_RESET_CHKSUM_ACC_RESET_LSB                               25
+#define RST_RESET_CHKSUM_ACC_RESET_MASK                              0x02000000
+#define RST_RESET_CHKSUM_ACC_RESET_GET(x)                            (((x) & RST_RESET_CHKSUM_ACC_RESET_MASK) >> RST_RESET_CHKSUM_ACC_RESET_LSB)
+#define RST_RESET_CHKSUM_ACC_RESET_SET(x)                            (((x) << RST_RESET_CHKSUM_ACC_RESET_LSB) & RST_RESET_CHKSUM_ACC_RESET_MASK)
+#define RST_RESET_CHKSUM_ACC_RESET_RESET                             0
+#define RST_RESET_FULL_CHIP_RESET_MSB                                24
+#define RST_RESET_FULL_CHIP_RESET_LSB                                24
+#define RST_RESET_FULL_CHIP_RESET_MASK                               0x01000000
+#define RST_RESET_FULL_CHIP_RESET_GET(x)                             (((x) & RST_RESET_FULL_CHIP_RESET_MASK) >> RST_RESET_FULL_CHIP_RESET_LSB)
+#define RST_RESET_FULL_CHIP_RESET_SET(x)                             (((x) << RST_RESET_FULL_CHIP_RESET_LSB) & RST_RESET_FULL_CHIP_RESET_MASK)
+#define RST_RESET_FULL_CHIP_RESET_RESET                              0
+#define RST_RESET_GE1_MDIO_RESET_MSB                                 23
+#define RST_RESET_GE1_MDIO_RESET_LSB                                 23
+#define RST_RESET_GE1_MDIO_RESET_MASK                                0x00800000
+#define RST_RESET_GE1_MDIO_RESET_GET(x)                              (((x) & RST_RESET_GE1_MDIO_RESET_MASK) >> RST_RESET_GE1_MDIO_RESET_LSB)
+#define RST_RESET_GE1_MDIO_RESET_SET(x)                              (((x) << RST_RESET_GE1_MDIO_RESET_LSB) & RST_RESET_GE1_MDIO_RESET_MASK)
+#define RST_RESET_GE1_MDIO_RESET_RESET                               1
+#define RST_RESET_GE0_MDIO_RESET_MSB                                 22
+#define RST_RESET_GE0_MDIO_RESET_LSB                                 22
+#define RST_RESET_GE0_MDIO_RESET_MASK                                0x00400000
+#define RST_RESET_GE0_MDIO_RESET_GET(x)                              (((x) & RST_RESET_GE0_MDIO_RESET_MASK) >> RST_RESET_GE0_MDIO_RESET_LSB)
+#define RST_RESET_GE0_MDIO_RESET_SET(x)                              (((x) << RST_RESET_GE0_MDIO_RESET_LSB) & RST_RESET_GE0_MDIO_RESET_MASK)
+#define RST_RESET_GE0_MDIO_RESET_RESET                               1
+#define RST_RESET_CPU_NMI_MSB                                        21
+#define RST_RESET_CPU_NMI_LSB                                        21
+#define RST_RESET_CPU_NMI_MASK                                       0x00200000
+#define RST_RESET_CPU_NMI_GET(x)                                     (((x) & RST_RESET_CPU_NMI_MASK) >> RST_RESET_CPU_NMI_LSB)
+#define RST_RESET_CPU_NMI_SET(x)                                     (((x) << RST_RESET_CPU_NMI_LSB) & RST_RESET_CPU_NMI_MASK)
+#define RST_RESET_CPU_NMI_RESET                                      0
+#define RST_RESET_CPU_COLD_RESET_MSB                                 20
+#define RST_RESET_CPU_COLD_RESET_LSB                                 20
+#define RST_RESET_CPU_COLD_RESET_MASK                                0x00100000
+#define RST_RESET_CPU_COLD_RESET_GET(x)                              (((x) & RST_RESET_CPU_COLD_RESET_MASK) >> RST_RESET_CPU_COLD_RESET_LSB)
+#define RST_RESET_CPU_COLD_RESET_SET(x)                              (((x) << RST_RESET_CPU_COLD_RESET_LSB) & RST_RESET_CPU_COLD_RESET_MASK)
+#define RST_RESET_CPU_COLD_RESET_RESET                               0
+#define RST_RESET_HOST_RESET_INT_MSB                                 19
+#define RST_RESET_HOST_RESET_INT_LSB                                 19
+#define RST_RESET_HOST_RESET_INT_MASK                                0x00080000
+#define RST_RESET_HOST_RESET_INT_GET(x)                              (((x) & RST_RESET_HOST_RESET_INT_MASK) >> RST_RESET_HOST_RESET_INT_LSB)
+#define RST_RESET_HOST_RESET_INT_SET(x)                              (((x) << RST_RESET_HOST_RESET_INT_LSB) & RST_RESET_HOST_RESET_INT_MASK)
+#define RST_RESET_HOST_RESET_INT_RESET                               0
+#define RST_RESET_PCIEEP_RESET_MSB                                   18
+#define RST_RESET_PCIEEP_RESET_LSB                                   18
+#define RST_RESET_PCIEEP_RESET_MASK                                  0x00040000
+#define RST_RESET_PCIEEP_RESET_GET(x)                                (((x) & RST_RESET_PCIEEP_RESET_MASK) >> RST_RESET_PCIEEP_RESET_LSB)
+#define RST_RESET_PCIEEP_RESET_SET(x)                                (((x) << RST_RESET_PCIEEP_RESET_LSB) & RST_RESET_PCIEEP_RESET_MASK)
+#define RST_RESET_PCIEEP_RESET_RESET                                 0
+#define RST_RESET_UART1_RESET_MSB                                    17
+#define RST_RESET_UART1_RESET_LSB                                    17
+#define RST_RESET_UART1_RESET_MASK                                   0x00020000
+#define RST_RESET_UART1_RESET_GET(x)                                 (((x) & RST_RESET_UART1_RESET_MASK) >> RST_RESET_UART1_RESET_LSB)
+#define RST_RESET_UART1_RESET_SET(x)                                 (((x) << RST_RESET_UART1_RESET_LSB) & RST_RESET_UART1_RESET_MASK)
+#define RST_RESET_UART1_RESET_RESET                                  0
+#define RST_RESET_DDR_RESET_MSB                                      16
+#define RST_RESET_DDR_RESET_LSB                                      16
+#define RST_RESET_DDR_RESET_MASK                                     0x00010000
+#define RST_RESET_DDR_RESET_GET(x)                                   (((x) & RST_RESET_DDR_RESET_MASK) >> RST_RESET_DDR_RESET_LSB)
+#define RST_RESET_DDR_RESET_SET(x)                                   (((x) << RST_RESET_DDR_RESET_LSB) & RST_RESET_DDR_RESET_MASK)
+#define RST_RESET_DDR_RESET_RESET                                    0
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_MSB                            15
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_LSB                            15
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_MASK                           0x00008000
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_GET(x)                         (((x) & RST_RESET_USB_PHY_PLL_PWD_EXT_MASK) >> RST_RESET_USB_PHY_PLL_PWD_EXT_LSB)
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_SET(x)                         (((x) << RST_RESET_USB_PHY_PLL_PWD_EXT_LSB) & RST_RESET_USB_PHY_PLL_PWD_EXT_MASK)
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_RESET                          0
+#define RST_RESET_NANDF_RESET_MSB                                    14
+#define RST_RESET_NANDF_RESET_LSB                                    14
+#define RST_RESET_NANDF_RESET_MASK                                   0x00004000
+#define RST_RESET_NANDF_RESET_GET(x)                                 (((x) & RST_RESET_NANDF_RESET_MASK) >> RST_RESET_NANDF_RESET_LSB)
+#define RST_RESET_NANDF_RESET_SET(x)                                 (((x) << RST_RESET_NANDF_RESET_LSB) & RST_RESET_NANDF_RESET_MASK)
+#define RST_RESET_NANDF_RESET_RESET                                  1
+#define RST_RESET_GE1_MAC_RESET_MSB                                  13
+#define RST_RESET_GE1_MAC_RESET_LSB                                  13
+#define RST_RESET_GE1_MAC_RESET_MASK                                 0x00002000
+#define RST_RESET_GE1_MAC_RESET_GET(x)                               (((x) & RST_RESET_GE1_MAC_RESET_MASK) >> RST_RESET_GE1_MAC_RESET_LSB)
+#define RST_RESET_GE1_MAC_RESET_SET(x)                               (((x) << RST_RESET_GE1_MAC_RESET_LSB) & RST_RESET_GE1_MAC_RESET_MASK)
+#define RST_RESET_GE1_MAC_RESET_RESET                                1
+#define RST_RESET_ETH_SWITCH_ARESET_MSB                              12
+#define RST_RESET_ETH_SWITCH_ARESET_LSB                              12
+#define RST_RESET_ETH_SWITCH_ARESET_MASK                             0x00001000
+#define RST_RESET_ETH_SWITCH_ARESET_GET(x)                           (((x) & RST_RESET_ETH_SWITCH_ARESET_MASK) >> RST_RESET_ETH_SWITCH_ARESET_LSB)
+#define RST_RESET_ETH_SWITCH_ARESET_SET(x)                           (((x) << RST_RESET_ETH_SWITCH_ARESET_LSB) & RST_RESET_ETH_SWITCH_ARESET_MASK)
+#define RST_RESET_ETH_SWITCH_ARESET_RESET                            1
+#define RST_RESET_USB_PHY_ARESET_MSB                                 11
+#define RST_RESET_USB_PHY_ARESET_LSB                                 11
+#define RST_RESET_USB_PHY_ARESET_MASK                                0x00000800
+#define RST_RESET_USB_PHY_ARESET_GET(x)                              (((x) & RST_RESET_USB_PHY_ARESET_MASK) >> RST_RESET_USB_PHY_ARESET_LSB)
+#define RST_RESET_USB_PHY_ARESET_SET(x)                              (((x) << RST_RESET_USB_PHY_ARESET_LSB) & RST_RESET_USB_PHY_ARESET_MASK)
+#define RST_RESET_USB_PHY_ARESET_RESET                               1
+#define RST_RESET_RESERVED_MSB                                       10
+#define RST_RESET_RESERVED_LSB                                       10
+#define RST_RESET_RESERVED_MASK                                      0x00000400
+#define RST_RESET_RESERVED_GET(x)                                    (((x) & RST_RESET_RESERVED_MASK) >> RST_RESET_RESERVED_LSB)
+#define RST_RESET_RESERVED_SET(x)                                    (((x) << RST_RESET_RESERVED_LSB) & RST_RESET_RESERVED_MASK)
+#define RST_RESET_RESERVED_RESET                                     1
+#define RST_RESET_GE0_MAC_RESET_MSB                                  9
+#define RST_RESET_GE0_MAC_RESET_LSB                                  9
+#define RST_RESET_GE0_MAC_RESET_MASK                                 0x00000200
+#define RST_RESET_GE0_MAC_RESET_GET(x)                               (((x) & RST_RESET_GE0_MAC_RESET_MASK) >> RST_RESET_GE0_MAC_RESET_LSB)
+#define RST_RESET_GE0_MAC_RESET_SET(x)                               (((x) << RST_RESET_GE0_MAC_RESET_LSB) & RST_RESET_GE0_MAC_RESET_MASK)
+#define RST_RESET_GE0_MAC_RESET_RESET                                1
+#define RST_RESET_ETH_SWITCH_RESET_MSB                               8
+#define RST_RESET_ETH_SWITCH_RESET_LSB                               8
+#define RST_RESET_ETH_SWITCH_RESET_MASK                              0x00000100
+#define RST_RESET_ETH_SWITCH_RESET_GET(x)                            (((x) & RST_RESET_ETH_SWITCH_RESET_MASK) >> RST_RESET_ETH_SWITCH_RESET_LSB)
+#define RST_RESET_ETH_SWITCH_RESET_SET(x)                            (((x) << RST_RESET_ETH_SWITCH_RESET_LSB) & RST_RESET_ETH_SWITCH_RESET_MASK)
+#define RST_RESET_ETH_SWITCH_RESET_RESET                             1
+#define RST_RESET_PCIE_PHY_RESET_MSB                                 7
+#define RST_RESET_PCIE_PHY_RESET_LSB                                 7
+#define RST_RESET_PCIE_PHY_RESET_MASK                                0x00000080
+#define RST_RESET_PCIE_PHY_RESET_GET(x)                              (((x) & RST_RESET_PCIE_PHY_RESET_MASK) >> RST_RESET_PCIE_PHY_RESET_LSB)
+#define RST_RESET_PCIE_PHY_RESET_SET(x)                              (((x) << RST_RESET_PCIE_PHY_RESET_LSB) & RST_RESET_PCIE_PHY_RESET_MASK)
+#define RST_RESET_PCIE_PHY_RESET_RESET                               1
+#define RST_RESET_PCIE_RESET_MSB                                     6
+#define RST_RESET_PCIE_RESET_LSB                                     6
+#define RST_RESET_PCIE_RESET_MASK                                    0x00000040
+#define RST_RESET_PCIE_RESET_GET(x)                                  (((x) & RST_RESET_PCIE_RESET_MASK) >> RST_RESET_PCIE_RESET_LSB)
+#define RST_RESET_PCIE_RESET_SET(x)                                  (((x) << RST_RESET_PCIE_RESET_LSB) & RST_RESET_PCIE_RESET_MASK)
+#define RST_RESET_PCIE_RESET_RESET                                   1
+#define RST_RESET_USB_HOST_RESET_MSB                                 5
+#define RST_RESET_USB_HOST_RESET_LSB                                 5
+#define RST_RESET_USB_HOST_RESET_MASK                                0x00000020
+#define RST_RESET_USB_HOST_RESET_GET(x)                              (((x) & RST_RESET_USB_HOST_RESET_MASK) >> RST_RESET_USB_HOST_RESET_LSB)
+#define RST_RESET_USB_HOST_RESET_SET(x)                              (((x) << RST_RESET_USB_HOST_RESET_LSB) & RST_RESET_USB_HOST_RESET_MASK)
+#define RST_RESET_USB_HOST_RESET_RESET                               1
+#define RST_RESET_USB_PHY_RESET_MSB                                  4
+#define RST_RESET_USB_PHY_RESET_LSB                                  4
+#define RST_RESET_USB_PHY_RESET_MASK                                 0x00000010
+#define RST_RESET_USB_PHY_RESET_GET(x)                               (((x) & RST_RESET_USB_PHY_RESET_MASK) >> RST_RESET_USB_PHY_RESET_LSB)
+#define RST_RESET_USB_PHY_RESET_SET(x)                               (((x) << RST_RESET_USB_PHY_RESET_LSB) & RST_RESET_USB_PHY_RESET_MASK)
+#define RST_RESET_USB_PHY_RESET_RESET                                1
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MSB                       3
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB                       3
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK                      0x00000008
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_GET(x)                    (((x) & RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK) >> RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB)
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(x)                    (((x) << RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB) & RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK)
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_RESET                     0
+#define RST_RESET_LUT_RESET_MSB                                      2
+#define RST_RESET_LUT_RESET_LSB                                      2
+#define RST_RESET_LUT_RESET_MASK                                     0x00000004
+#define RST_RESET_LUT_RESET_GET(x)                                   (((x) & RST_RESET_LUT_RESET_MASK) >> RST_RESET_LUT_RESET_LSB)
+#define RST_RESET_LUT_RESET_SET(x)                                   (((x) << RST_RESET_LUT_RESET_LSB) & RST_RESET_LUT_RESET_MASK)
+#define RST_RESET_LUT_RESET_RESET                                    0
+#define RST_RESET_MBOX_RESET_MSB                                     1
+#define RST_RESET_MBOX_RESET_LSB                                     1
+#define RST_RESET_MBOX_RESET_MASK                                    0x00000002
+#define RST_RESET_MBOX_RESET_GET(x)                                  (((x) & RST_RESET_MBOX_RESET_MASK) >> RST_RESET_MBOX_RESET_LSB)
+#define RST_RESET_MBOX_RESET_SET(x)                                  (((x) << RST_RESET_MBOX_RESET_LSB) & RST_RESET_MBOX_RESET_MASK)
+#define RST_RESET_MBOX_RESET_RESET                                   0
+#define RST_RESET_I2S_RESET_MSB                                      0
+#define RST_RESET_I2S_RESET_LSB                                      0
+#define RST_RESET_I2S_RESET_MASK                                     0x00000001
+#define RST_RESET_I2S_RESET_GET(x)                                   (((x) & RST_RESET_I2S_RESET_MASK) >> RST_RESET_I2S_RESET_LSB)
+#define RST_RESET_I2S_RESET_SET(x)                                   (((x) << RST_RESET_I2S_RESET_LSB) & RST_RESET_I2S_RESET_MASK)
+#define RST_RESET_I2S_RESET_RESET                                    0
+#define RST_RESET_ADDRESS                                            0x1806001c
+#define RST_RESET_OFFSET                                             0x001c
+// SW modifiable bits
+#define RST_RESET_SW_MASK                                            0xffffffff
+// bits defined at reset
+#define RST_RESET_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define RST_RESET_RESET                                              0x28c07ff0
+
+#define RST_MISC2_SPARE_MSB                                          31
+#define RST_MISC2_SPARE_LSB                                          26
+#define RST_MISC2_SPARE_MASK                                         0xfc000000
+#define RST_MISC2_SPARE_GET(x)                                       (((x) & RST_MISC2_SPARE_MASK) >> RST_MISC2_SPARE_LSB)
+#define RST_MISC2_SPARE_SET(x)                                       (((x) << RST_MISC2_SPARE_LSB) & RST_MISC2_SPARE_MASK)
+#define RST_MISC2_SPARE_RESET                                        0x0 // 0
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_MSB                             25
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_LSB                             25
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_MASK                            0x02000000
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L2_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L2_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L2_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L2_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_MSB                             24
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_LSB                             24
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_MASK                            0x01000000
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L2_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L2_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L2_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L2_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_MSB                             23
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_LSB                             23
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_MASK                            0x00800000
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L1_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L1_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L1_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L1_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_MSB                             22
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_LSB                             22
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_MASK                            0x00400000
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L1_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L1_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L1_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L1_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_MSB                            21
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB                            21
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK                           0x00200000
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_GET(x)                         (((x) & RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_SET(x)                         (((x) << RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_RESET                          0x0 // 0
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_MSB                            20
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB                            20
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK                           0x00100000
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_GET(x)                         (((x) & RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_SET(x)                         (((x) << RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_RESET                          0x0 // 0
+#define RST_MISC2_PCIEEP_REGWR_EN_MSB                                19
+#define RST_MISC2_PCIEEP_REGWR_EN_LSB                                19
+#define RST_MISC2_PCIEEP_REGWR_EN_MASK                               0x00080000
+#define RST_MISC2_PCIEEP_REGWR_EN_GET(x)                             (((x) & RST_MISC2_PCIEEP_REGWR_EN_MASK) >> RST_MISC2_PCIEEP_REGWR_EN_LSB)
+#define RST_MISC2_PCIEEP_REGWR_EN_SET(x)                             (((x) << RST_MISC2_PCIEEP_REGWR_EN_LSB) & RST_MISC2_PCIEEP_REGWR_EN_MASK)
+#define RST_MISC2_PCIEEP_REGWR_EN_RESET                              0x1 // 1
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_MSB                           18
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_LSB                           18
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_MASK                          0x00040000
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_GET(x)                        (((x) & RST_MISC2_EXT_HOST_WASP_RST_EN_MASK) >> RST_MISC2_EXT_HOST_WASP_RST_EN_LSB)
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_SET(x)                        (((x) << RST_MISC2_EXT_HOST_WASP_RST_EN_LSB) & RST_MISC2_EXT_HOST_WASP_RST_EN_MASK)
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_RESET                         0x0 // 0
+#define RST_MISC2_PCIEEP_RST_INT_MASK_MSB                            17
+#define RST_MISC2_PCIEEP_RST_INT_MASK_LSB                            17
+#define RST_MISC2_PCIEEP_RST_INT_MASK_MASK                           0x00020000
+#define RST_MISC2_PCIEEP_RST_INT_MASK_GET(x)                         (((x) & RST_MISC2_PCIEEP_RST_INT_MASK_MASK) >> RST_MISC2_PCIEEP_RST_INT_MASK_LSB)
+#define RST_MISC2_PCIEEP_RST_INT_MASK_SET(x)                         (((x) << RST_MISC2_PCIEEP_RST_INT_MASK_LSB) & RST_MISC2_PCIEEP_RST_INT_MASK_MASK)
+#define RST_MISC2_PCIEEP_RST_INT_MASK_RESET                          0x0 // 0
+#define RST_MISC2_HOST_RESET_INT_MASK_MSB                            16
+#define RST_MISC2_HOST_RESET_INT_MASK_LSB                            16
+#define RST_MISC2_HOST_RESET_INT_MASK_MASK                           0x00010000
+#define RST_MISC2_HOST_RESET_INT_MASK_GET(x)                         (((x) & RST_MISC2_HOST_RESET_INT_MASK_MASK) >> RST_MISC2_HOST_RESET_INT_MASK_LSB)
+#define RST_MISC2_HOST_RESET_INT_MASK_SET(x)                         (((x) << RST_MISC2_HOST_RESET_INT_MASK_LSB) & RST_MISC2_HOST_RESET_INT_MASK_MASK)
+#define RST_MISC2_HOST_RESET_INT_MASK_RESET                          0x0 // 0
+#define RST_MISC2_CPU_HOST_WA_MSB                                    15
+#define RST_MISC2_CPU_HOST_WA_LSB                                    15
+#define RST_MISC2_CPU_HOST_WA_MASK                                   0x00008000
+#define RST_MISC2_CPU_HOST_WA_GET(x)                                 (((x) & RST_MISC2_CPU_HOST_WA_MASK) >> RST_MISC2_CPU_HOST_WA_LSB)
+#define RST_MISC2_CPU_HOST_WA_SET(x)                                 (((x) << RST_MISC2_CPU_HOST_WA_LSB) & RST_MISC2_CPU_HOST_WA_MASK)
+#define RST_MISC2_CPU_HOST_WA_RESET                                  0x0 // 0
+#define RST_MISC2_PERSTN_EPPHY_MSB                                   14
+#define RST_MISC2_PERSTN_EPPHY_LSB                                   14
+#define RST_MISC2_PERSTN_EPPHY_MASK                                  0x00004000
+#define RST_MISC2_PERSTN_EPPHY_GET(x)                                (((x) & RST_MISC2_PERSTN_EPPHY_MASK) >> RST_MISC2_PERSTN_EPPHY_LSB)
+#define RST_MISC2_PERSTN_EPPHY_SET(x)                                (((x) << RST_MISC2_PERSTN_EPPHY_LSB) & RST_MISC2_PERSTN_EPPHY_MASK)
+#define RST_MISC2_PERSTN_EPPHY_RESET                                 0x1 // 1
+#define RST_MISC2_PERSTN_RCPHY_MSB                                   13
+#define RST_MISC2_PERSTN_RCPHY_LSB                                   13
+#define RST_MISC2_PERSTN_RCPHY_MASK                                  0x00002000
+#define RST_MISC2_PERSTN_RCPHY_GET(x)                                (((x) & RST_MISC2_PERSTN_RCPHY_MASK) >> RST_MISC2_PERSTN_RCPHY_LSB)
+#define RST_MISC2_PERSTN_RCPHY_SET(x)                                (((x) << RST_MISC2_PERSTN_RCPHY_LSB) & RST_MISC2_PERSTN_RCPHY_MASK)
+#define RST_MISC2_PERSTN_RCPHY_RESET                                 0x1 // 1
+#define RST_MISC2_PCIEEP_LTSSM_STATE_MSB                             12
+#define RST_MISC2_PCIEEP_LTSSM_STATE_LSB                             8
+#define RST_MISC2_PCIEEP_LTSSM_STATE_MASK                            0x00001f00
+#define RST_MISC2_PCIEEP_LTSSM_STATE_GET(x)                          (((x) & RST_MISC2_PCIEEP_LTSSM_STATE_MASK) >> RST_MISC2_PCIEEP_LTSSM_STATE_LSB)
+#define RST_MISC2_PCIEEP_LTSSM_STATE_SET(x)                          (((x) << RST_MISC2_PCIEEP_LTSSM_STATE_LSB) & RST_MISC2_PCIEEP_LTSSM_STATE_MASK)
+#define RST_MISC2_PCIEEP_LTSSM_STATE_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L2_INT_MASK_MSB                             7
+#define RST_MISC2_PCIEEP_L2_INT_MASK_LSB                             7
+#define RST_MISC2_PCIEEP_L2_INT_MASK_MASK                            0x00000080
+#define RST_MISC2_PCIEEP_L2_INT_MASK_GET(x)                          (((x) & RST_MISC2_PCIEEP_L2_INT_MASK_MASK) >> RST_MISC2_PCIEEP_L2_INT_MASK_LSB)
+#define RST_MISC2_PCIEEP_L2_INT_MASK_SET(x)                          (((x) << RST_MISC2_PCIEEP_L2_INT_MASK_LSB) & RST_MISC2_PCIEEP_L2_INT_MASK_MASK)
+#define RST_MISC2_PCIEEP_L2_INT_MASK_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L1_INT_MASK_MSB                             6
+#define RST_MISC2_PCIEEP_L1_INT_MASK_LSB                             6
+#define RST_MISC2_PCIEEP_L1_INT_MASK_MASK                            0x00000040
+#define RST_MISC2_PCIEEP_L1_INT_MASK_GET(x)                          (((x) & RST_MISC2_PCIEEP_L1_INT_MASK_MASK) >> RST_MISC2_PCIEEP_L1_INT_MASK_LSB)
+#define RST_MISC2_PCIEEP_L1_INT_MASK_SET(x)                          (((x) << RST_MISC2_PCIEEP_L1_INT_MASK_LSB) & RST_MISC2_PCIEEP_L1_INT_MASK_MASK)
+#define RST_MISC2_PCIEEP_L1_INT_MASK_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L0S_INT_MASK_MSB                            5
+#define RST_MISC2_PCIEEP_L0S_INT_MASK_LSB                            5
+#define RST_MISC2_PCIEEP_L0S_INT_MASK_MASK                           0x00000020
+#define RST_MISC2_PCIEEP_L0S_INT_MASK_GET(x)                         (((x) & RST_MISC2_PCIEEP_L0S_INT_MASK_MASK) >> RST_MISC2_PCIEEP_L0S_INT_MASK_LSB)
+#define RST_MISC2_PCIEEP_L0S_INT_MASK_SET(x)                         (((x) << RST_MISC2_PCIEEP_L0S_INT_MASK_LSB) & RST_MISC2_PCIEEP_L0S_INT_MASK_MASK)
+#define RST_MISC2_PCIEEP_L0S_INT_MASK_RESET                          0x0 // 0
+#define RST_MISC2_PCIEEP_LINK_STATUS_MSB                             4
+#define RST_MISC2_PCIEEP_LINK_STATUS_LSB                             4
+#define RST_MISC2_PCIEEP_LINK_STATUS_MASK                            0x00000010
+#define RST_MISC2_PCIEEP_LINK_STATUS_GET(x)                          (((x) & RST_MISC2_PCIEEP_LINK_STATUS_MASK) >> RST_MISC2_PCIEEP_LINK_STATUS_LSB)
+#define RST_MISC2_PCIEEP_LINK_STATUS_SET(x)                          (((x) << RST_MISC2_PCIEEP_LINK_STATUS_LSB) & RST_MISC2_PCIEEP_LINK_STATUS_MASK)
+#define RST_MISC2_PCIEEP_LINK_STATUS_RESET                           0x0 // 0
+#define RST_MISC2_RESERVED_MSB                                       3
+#define RST_MISC2_RESERVED_LSB                                       1
+#define RST_MISC2_RESERVED_MASK                                      0x0000000e
+#define RST_MISC2_RESERVED_GET(x)                                    (((x) & RST_MISC2_RESERVED_MASK) >> RST_MISC2_RESERVED_LSB)
+#define RST_MISC2_RESERVED_SET(x)                                    (((x) << RST_MISC2_RESERVED_LSB) & RST_MISC2_RESERVED_MASK)
+#define RST_MISC2_RESERVED_RESET                                     0x0 // 0
+#define RST_MISC2_PCIEEP_CFG_DONE_MSB                                0
+#define RST_MISC2_PCIEEP_CFG_DONE_LSB                                0
+#define RST_MISC2_PCIEEP_CFG_DONE_MASK                               0x00000001
+#define RST_MISC2_PCIEEP_CFG_DONE_GET(x)                             (((x) & RST_MISC2_PCIEEP_CFG_DONE_MASK) >> RST_MISC2_PCIEEP_CFG_DONE_LSB)
+#define RST_MISC2_PCIEEP_CFG_DONE_SET(x)                             (((x) << RST_MISC2_PCIEEP_CFG_DONE_LSB) & RST_MISC2_PCIEEP_CFG_DONE_MASK)
+#define RST_MISC2_PCIEEP_CFG_DONE_RESET                              0x0 // 0
+#define RST_MISC2_ADDRESS                                            0x180600bc
+
+#define DDR_CONFIG_CAS_LATENCY_MSB_MSB                               31
+#define DDR_CONFIG_CAS_LATENCY_MSB_LSB                               31
+#define DDR_CONFIG_CAS_LATENCY_MSB_MASK                              0x80000000
+#define DDR_CONFIG_CAS_LATENCY_MSB_GET(x)                            (((x) & DDR_CONFIG_CAS_LATENCY_MSB_MASK) >> DDR_CONFIG_CAS_LATENCY_MSB_LSB)
+#define DDR_CONFIG_CAS_LATENCY_MSB_SET(x)                            (((x) << DDR_CONFIG_CAS_LATENCY_MSB_LSB) & DDR_CONFIG_CAS_LATENCY_MSB_MASK)
+//#define DDR_CONFIG_CAS_LATENCY_MSB_RESET                             1'd0
+#define DDR_CONFIG_OPEN_PAGE_MSB                                     30
+#define DDR_CONFIG_OPEN_PAGE_LSB                                     30
+#define DDR_CONFIG_OPEN_PAGE_MASK                                    0x40000000
+#define DDR_CONFIG_OPEN_PAGE_GET(x)                                  (((x) & DDR_CONFIG_OPEN_PAGE_MASK) >> DDR_CONFIG_OPEN_PAGE_LSB)
+#define DDR_CONFIG_OPEN_PAGE_SET(x)                                  (((x) << DDR_CONFIG_OPEN_PAGE_LSB) & DDR_CONFIG_OPEN_PAGE_MASK)
+//#define DDR_CONFIG_OPEN_PAGE_RESET                                   1'd1
+#define DDR_CONFIG_CAS_LATENCY_MSB                                   29
+#define DDR_CONFIG_CAS_LATENCY_LSB                                   27
+#define DDR_CONFIG_CAS_LATENCY_MASK                                  0x38000000
+#define DDR_CONFIG_CAS_LATENCY_GET(x)                                (((x) & DDR_CONFIG_CAS_LATENCY_MASK) >> DDR_CONFIG_CAS_LATENCY_LSB)
+#define DDR_CONFIG_CAS_LATENCY_SET(x)                                (((x) << DDR_CONFIG_CAS_LATENCY_LSB) & DDR_CONFIG_CAS_LATENCY_MASK)
+//#define DDR_CONFIG_CAS_LATENCY_RESET                                 3'd6
+#define DDR_CONFIG_TMRD_MSB                                          26
+#define DDR_CONFIG_TMRD_LSB                                          23
+#define DDR_CONFIG_TMRD_MASK                                         0x07800000
+#define DDR_CONFIG_TMRD_GET(x)                                       (((x) & DDR_CONFIG_TMRD_MASK) >> DDR_CONFIG_TMRD_LSB)
+#define DDR_CONFIG_TMRD_SET(x)                                       (((x) << DDR_CONFIG_TMRD_LSB) & DDR_CONFIG_TMRD_MASK)
+//#define DDR_CONFIG_TMRD_RESET                                        4'd15
+#define DDR_CONFIG_TRFC_MSB                                          22
+#define DDR_CONFIG_TRFC_LSB                                          17
+#define DDR_CONFIG_TRFC_MASK                                         0x007e0000
+#define DDR_CONFIG_TRFC_GET(x)                                       (((x) & DDR_CONFIG_TRFC_MASK) >> DDR_CONFIG_TRFC_LSB)
+#define DDR_CONFIG_TRFC_SET(x)                                       (((x) << DDR_CONFIG_TRFC_LSB) & DDR_CONFIG_TRFC_MASK)
+//#define DDR_CONFIG_TRFC_RESET                                        6'd31
+#define DDR_CONFIG_TRRD_MSB                                          16
+#define DDR_CONFIG_TRRD_LSB                                          13
+#define DDR_CONFIG_TRRD_MASK                                         0x0001e000
+#define DDR_CONFIG_TRRD_GET(x)                                       (((x) & DDR_CONFIG_TRRD_MASK) >> DDR_CONFIG_TRRD_LSB)
+#define DDR_CONFIG_TRRD_SET(x)                                       (((x) << DDR_CONFIG_TRRD_LSB) & DDR_CONFIG_TRRD_MASK)
+//#define DDR_CONFIG_TRRD_RESET                                        4'd4
+#define DDR_CONFIG_TRP_MSB                                           12
+#define DDR_CONFIG_TRP_LSB                                           9
+#define DDR_CONFIG_TRP_MASK                                          0x00001e00
+#define DDR_CONFIG_TRP_GET(x)                                        (((x) & DDR_CONFIG_TRP_MASK) >> DDR_CONFIG_TRP_LSB)
+#define DDR_CONFIG_TRP_SET(x)                                        (((x) << DDR_CONFIG_TRP_LSB) & DDR_CONFIG_TRP_MASK)
+//#define DDR_CONFIG_TRP_RESET                                         4'd6
+#define DDR_CONFIG_TRCD_MSB                                          8
+#define DDR_CONFIG_TRCD_LSB                                          5
+#define DDR_CONFIG_TRCD_MASK                                         0x000001e0
+#define DDR_CONFIG_TRCD_GET(x)                                       (((x) & DDR_CONFIG_TRCD_MASK) >> DDR_CONFIG_TRCD_LSB)
+#define DDR_CONFIG_TRCD_SET(x)                                       (((x) << DDR_CONFIG_TRCD_LSB) & DDR_CONFIG_TRCD_MASK)
+//#define DDR_CONFIG_TRCD_RESET                                        4'd6
+#define DDR_CONFIG_TRAS_MSB                                          4
+#define DDR_CONFIG_TRAS_LSB                                          0
+#define DDR_CONFIG_TRAS_MASK                                         0x0000001f
+#define DDR_CONFIG_TRAS_GET(x)                                       (((x) & DDR_CONFIG_TRAS_MASK) >> DDR_CONFIG_TRAS_LSB)
+#define DDR_CONFIG_TRAS_SET(x)                                       (((x) << DDR_CONFIG_TRAS_LSB) & DDR_CONFIG_TRAS_MASK)
+//#define DDR_CONFIG_TRAS_RESET                                        5'd16
+#define DDR_CONFIG_ADDRESS                                           0x18000000
+
+// 32'h18000004 (DDR_CONFIG2)
+#define DDR_CONFIG2_HALF_WIDTH_LOW_MSB                               31
+#define DDR_CONFIG2_HALF_WIDTH_LOW_LSB                               31
+#define DDR_CONFIG2_HALF_WIDTH_LOW_MASK                              0x80000000
+#define DDR_CONFIG2_HALF_WIDTH_LOW_GET(x)                            (((x) & DDR_CONFIG2_HALF_WIDTH_LOW_MASK) >> DDR_CONFIG2_HALF_WIDTH_LOW_LSB)
+#define DDR_CONFIG2_HALF_WIDTH_LOW_SET(x)                            (((x) << DDR_CONFIG2_HALF_WIDTH_LOW_LSB) & DDR_CONFIG2_HALF_WIDTH_LOW_MASK)
+//#define DDR_CONFIG2_HALF_WIDTH_LOW_RESET                             1'd1
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_MSB                            29
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_LSB                            26
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_MASK                           0x3c000000
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_GET(x)                         (((x) & DDR_CONFIG2_GATE_OPEN_LATENCY_MASK) >> DDR_CONFIG2_GATE_OPEN_LATENCY_LSB)
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_SET(x)                         (((x) << DDR_CONFIG2_GATE_OPEN_LATENCY_LSB) & DDR_CONFIG2_GATE_OPEN_LATENCY_MASK)
+//#define DDR_CONFIG2_GATE_OPEN_LATENCY_RESET                          4'd6
+#define DDR_CONFIG2_TWTR_MSB                                         25
+#define DDR_CONFIG2_TWTR_LSB                                         21
+#define DDR_CONFIG2_TWTR_MASK                                        0x03e00000
+#define DDR_CONFIG2_TWTR_GET(x)                                      (((x) & DDR_CONFIG2_TWTR_MASK) >> DDR_CONFIG2_TWTR_LSB)
+#define DDR_CONFIG2_TWTR_SET(x)                                      (((x) << DDR_CONFIG2_TWTR_LSB) & DDR_CONFIG2_TWTR_MASK)
+//#define DDR_CONFIG2_TWTR_RESET                                       5'd14
+#define DDR_CONFIG2_TRTP_MSB                                         20
+#define DDR_CONFIG2_TRTP_LSB                                         17
+#define DDR_CONFIG2_TRTP_MASK                                        0x001e0000
+#define DDR_CONFIG2_TRTP_GET(x)                                      (((x) & DDR_CONFIG2_TRTP_MASK) >> DDR_CONFIG2_TRTP_LSB)
+#define DDR_CONFIG2_TRTP_SET(x)                                      (((x) << DDR_CONFIG2_TRTP_LSB) & DDR_CONFIG2_TRTP_MASK)
+//#define DDR_CONFIG2_TRTP_RESET                                       4'd8
+#define DDR_CONFIG2_TRTW_MSB                                         16
+#define DDR_CONFIG2_TRTW_LSB                                         12
+#define DDR_CONFIG2_TRTW_MASK                                        0x0001f000
+#define DDR_CONFIG2_TRTW_GET(x)                                      (((x) & DDR_CONFIG2_TRTW_MASK) >> DDR_CONFIG2_TRTW_LSB)
+#define DDR_CONFIG2_TRTW_SET(x)                                      (((x) << DDR_CONFIG2_TRTW_LSB) & DDR_CONFIG2_TRTW_MASK)
+//#define DDR_CONFIG2_TRTW_RESET                                       5'd16
+#define DDR_CONFIG2_TWR_MSB                                          11
+#define DDR_CONFIG2_TWR_LSB                                          8
+#define DDR_CONFIG2_TWR_MASK                                         0x00000f00
+#define DDR_CONFIG2_TWR_GET(x)                                       (((x) & DDR_CONFIG2_TWR_MASK) >> DDR_CONFIG2_TWR_LSB)
+#define DDR_CONFIG2_TWR_SET(x)                                       (((x) << DDR_CONFIG2_TWR_LSB) & DDR_CONFIG2_TWR_MASK)
+//#define DDR_CONFIG2_TWR_RESET                                        4'd6
+#define DDR_CONFIG2_CKE_MSB                                          7
+#define DDR_CONFIG2_CKE_LSB                                          7
+#define DDR_CONFIG2_CKE_MASK                                         0x00000080
+#define DDR_CONFIG2_CKE_GET(x)                                       (((x) & DDR_CONFIG2_CKE_MASK) >> DDR_CONFIG2_CKE_LSB)
+#define DDR_CONFIG2_CKE_SET(x)                                       (((x) << DDR_CONFIG2_CKE_LSB) & DDR_CONFIG2_CKE_MASK)
+//#define DDR_CONFIG2_CKE_RESET                                        1'd0
+#define DDR_CONFIG2_PHASE_SELECT_MSB                                 6
+#define DDR_CONFIG2_PHASE_SELECT_LSB                                 6
+#define DDR_CONFIG2_PHASE_SELECT_MASK                                0x00000040
+#define DDR_CONFIG2_PHASE_SELECT_GET(x)                              (((x) & DDR_CONFIG2_PHASE_SELECT_MASK) >> DDR_CONFIG2_PHASE_SELECT_LSB)
+#define DDR_CONFIG2_PHASE_SELECT_SET(x)                              (((x) << DDR_CONFIG2_PHASE_SELECT_LSB) & DDR_CONFIG2_PHASE_SELECT_MASK)
+//#define DDR_CONFIG2_PHASE_SELECT_RESET                               1'd0
+#define DDR_CONFIG2_CNTL_OE_EN_MSB                                   5
+#define DDR_CONFIG2_CNTL_OE_EN_LSB                                   5
+#define DDR_CONFIG2_CNTL_OE_EN_MASK                                  0x00000020
+#define DDR_CONFIG2_CNTL_OE_EN_GET(x)                                (((x) & DDR_CONFIG2_CNTL_OE_EN_MASK) >> DDR_CONFIG2_CNTL_OE_EN_LSB)
+#define DDR_CONFIG2_CNTL_OE_EN_SET(x)                                (((x) << DDR_CONFIG2_CNTL_OE_EN_LSB) & DDR_CONFIG2_CNTL_OE_EN_MASK)
+//#define DDR_CONFIG2_CNTL_OE_EN_RESET                                 1'd1
+#define DDR_CONFIG2_BURST_TYPE_MSB                                   4
+#define DDR_CONFIG2_BURST_TYPE_LSB                                   4
+#define DDR_CONFIG2_BURST_TYPE_MASK                                  0x00000010
+#define DDR_CONFIG2_BURST_TYPE_GET(x)                                (((x) & DDR_CONFIG2_BURST_TYPE_MASK) >> DDR_CONFIG2_BURST_TYPE_LSB)
+#define DDR_CONFIG2_BURST_TYPE_SET(x)                                (((x) << DDR_CONFIG2_BURST_TYPE_LSB) & DDR_CONFIG2_BURST_TYPE_MASK)
+//#define DDR_CONFIG2_BURST_TYPE_RESET                                 1'd0
+#define DDR_CONFIG2_BURST_LENGTH_MSB                                 3
+#define DDR_CONFIG2_BURST_LENGTH_LSB                                 0
+#define DDR_CONFIG2_BURST_LENGTH_MASK                                0x0000000f
+#define DDR_CONFIG2_BURST_LENGTH_GET(x)                              (((x) & DDR_CONFIG2_BURST_LENGTH_MASK) >> DDR_CONFIG2_BURST_LENGTH_LSB)
+#define DDR_CONFIG2_BURST_LENGTH_SET(x)                              (((x) << DDR_CONFIG2_BURST_LENGTH_LSB) & DDR_CONFIG2_BURST_LENGTH_MASK)
+//#define DDR_CONFIG2_BURST_LENGTH_RESET                               4'd8
+#define DDR_CONFIG2_ADDRESS                                          0x18000004
+
+
+#define DDR2_CONFIG_DDR2_TWL_MSB                                     13
+#define DDR2_CONFIG_DDR2_TWL_LSB                                     10
+#define DDR2_CONFIG_DDR2_TWL_MASK                                    0x00003c00
+#define DDR2_CONFIG_DDR2_TWL_GET(x)                                  (((x) & DDR2_CONFIG_DDR2_TWL_MASK) >> DDR2_CONFIG_DDR2_TWL_LSB)
+#define DDR2_CONFIG_DDR2_TWL_SET(x)                                  (((x) << DDR2_CONFIG_DDR2_TWL_LSB) & DDR2_CONFIG_DDR2_TWL_MASK)
+//#define DDR2_CONFIG_DDR2_TWL_RESET                                   4'd1
+#define DDR2_CONFIG_DDR2_ODT_MSB                                     9
+#define DDR2_CONFIG_DDR2_ODT_LSB                                     9
+#define DDR2_CONFIG_DDR2_ODT_MASK                                    0x00000200
+#define DDR2_CONFIG_DDR2_ODT_GET(x)                                  (((x) & DDR2_CONFIG_DDR2_ODT_MASK) >> DDR2_CONFIG_DDR2_ODT_LSB)
+#define DDR2_CONFIG_DDR2_ODT_SET(x)                                  (((x) << DDR2_CONFIG_DDR2_ODT_LSB) & DDR2_CONFIG_DDR2_ODT_MASK)
+//#define DDR2_CONFIG_DDR2_ODT_RESET                                   1'd1
+#define DDR2_CONFIG_TFAW_MSB                                         7
+#define DDR2_CONFIG_TFAW_LSB                                         2
+#define DDR2_CONFIG_TFAW_MASK                                        0x000000fc
+#define DDR2_CONFIG_TFAW_GET(x)                                      (((x) & DDR2_CONFIG_TFAW_MASK) >> DDR2_CONFIG_TFAW_LSB)
+#define DDR2_CONFIG_TFAW_SET(x)                                      (((x) << DDR2_CONFIG_TFAW_LSB) & DDR2_CONFIG_TFAW_MASK)
+//#define DDR2_CONFIG_TFAW_RESET                                       6'd22
+#define DDR2_CONFIG_ENABLE_DDR2_MSB                                  0
+#define DDR2_CONFIG_ENABLE_DDR2_LSB                                  0
+#define DDR2_CONFIG_ENABLE_DDR2_MASK                                 0x00000001
+#define DDR2_CONFIG_ENABLE_DDR2_GET(x)                               (((x) & DDR2_CONFIG_ENABLE_DDR2_MASK) >> DDR2_CONFIG_ENABLE_DDR2_LSB)
+#define DDR2_CONFIG_ENABLE_DDR2_SET(x)                               (((x) << DDR2_CONFIG_ENABLE_DDR2_LSB) & DDR2_CONFIG_ENABLE_DDR2_MASK)
+//#define DDR2_CONFIG_ENABLE_DDR2_RESET                                1'd0
+#define DDR2_CONFIG_ADDRESS                                          0x180000b8
+
+#define DDR_CTL_CONFIG_SRAM_TSEL_MSB                                 31
+#define DDR_CTL_CONFIG_SRAM_TSEL_LSB                                 30
+#define DDR_CTL_CONFIG_SRAM_TSEL_MASK                                0xc0000000
+#define DDR_CTL_CONFIG_SRAM_TSEL_GET(x)                              (((x) & DDR_CTL_CONFIG_SRAM_TSEL_MASK) >> DDR_CTL_CONFIG_SRAM_TSEL_LSB)
+#define DDR_CTL_CONFIG_SRAM_TSEL_SET(x)                              (((x) << DDR_CTL_CONFIG_SRAM_TSEL_LSB) & DDR_CTL_CONFIG_SRAM_TSEL_MASK)
+#define DDR_CTL_CONFIG_SRAM_TSEL_RESET                               0x1 // 1
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MSB                           29
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB                           21
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK                          0x3fe00000
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_GET(x)                        (((x) & DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK) >> DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB)
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_SET(x)                        (((x) << DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB) & DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK)
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_RESET                         0x0 // 0
+#define DDR_CTL_CONFIG_SPARE_MSB                                     20
+#define DDR_CTL_CONFIG_SPARE_LSB                                     6
+#define DDR_CTL_CONFIG_SPARE_MASK                                    0x001fffc0
+#define DDR_CTL_CONFIG_SPARE_GET(x)                                  (((x) & DDR_CTL_CONFIG_SPARE_MASK) >> DDR_CTL_CONFIG_SPARE_LSB)
+#define DDR_CTL_CONFIG_SPARE_SET(x)                                  (((x) << DDR_CTL_CONFIG_SPARE_LSB) & DDR_CTL_CONFIG_SPARE_MASK)
+#define DDR_CTL_CONFIG_SPARE_RESET                                   0x4 // 4
+#define DDR_CTL_CONFIG_PREFETCH_CNT_MSB                              5
+#define DDR_CTL_CONFIG_PREFETCH_CNT_LSB                              2
+#define DDR_CTL_CONFIG_PREFETCH_CNT_MASK                             0x0000003c
+#define DDR_CTL_CONFIG_PREFETCH_CNT_GET(x)                           (((x) & DDR_CTL_CONFIG_PREFETCH_CNT_MASK) >> DDR_CTL_CONFIG_PREFETCH_CNT_LSB)
+#define DDR_CTL_CONFIG_PREFETCH_CNT_SET(x)                           (((x) << DDR_CTL_CONFIG_PREFETCH_CNT_LSB) & DDR_CTL_CONFIG_PREFETCH_CNT_MASK)
+#define DDR_CTL_CONFIG_PREFETCH_CNT_RESET                            0x3 // 3
+#define DDR_CTL_CONFIG_HALF_WIDTH_MSB                                1
+#define DDR_CTL_CONFIG_HALF_WIDTH_LSB                                1
+#define DDR_CTL_CONFIG_HALF_WIDTH_MASK                               0x00000002
+#define DDR_CTL_CONFIG_HALF_WIDTH_GET(x)                             (((x) & DDR_CTL_CONFIG_HALF_WIDTH_MASK) >> DDR_CTL_CONFIG_HALF_WIDTH_LSB)
+#define DDR_CTL_CONFIG_HALF_WIDTH_SET(x)                             (((x) << DDR_CTL_CONFIG_HALF_WIDTH_LSB) & DDR_CTL_CONFIG_HALF_WIDTH_MASK)
+#define DDR_CTL_CONFIG_HALF_WIDTH_RESET                              0x1 // 1
+#define DDR_CTL_CONFIG_SRAM_MODE_EN_MSB                              0
+#define DDR_CTL_CONFIG_SRAM_MODE_EN_LSB                              0
+#define DDR_CTL_CONFIG_SRAM_MODE_EN_MASK                             0x00000001
+#define DDR_CTL_CONFIG_SRAM_MODE_EN_GET(x)                           (((x) & DDR_CTL_CONFIG_SRAM_MODE_EN_MASK) >> DDR_CTL_CONFIG_SRAM_MODE_EN_LSB)
+#define DDR_CTL_CONFIG_SRAM_MODE_EN_SET(x)                           (((x) << DDR_CTL_CONFIG_SRAM_MODE_EN_LSB) & DDR_CTL_CONFIG_SRAM_MODE_EN_MASK)
+#define DDR_CTL_CONFIG_SRAM_MODE_EN_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_ADDRESS                                       0x18000108
+
+
+#define CPU_DPLL3_MEAS_AT_TXON_MSB		31
+#define CPU_DPLL3_MEAS_AT_TXON_LSB		31
+#define CPU_DPLL3_MEAS_AT_TXON_MASK		0x80000000
+#define CPU_DPLL3_MEAS_AT_TXON_GET(x)		(((x) & CPU_DPLL3_MEAS_AT_TXON_MASK) >> CPU_DPLL3_MEAS_AT_TXON_LSB)
+#define CPU_DPLL3_MEAS_AT_TXON_SET(x)		(((x) << CPU_DPLL3_MEAS_AT_TXON_LSB) & CPU_DPLL3_MEAS_AT_TXON_MASK)
+#define CPU_DPLL3_MEAS_AT_TXON_RESET		0x0 // 0
+#define CPU_DPLL3_DO_MEAS_MSB			30
+#define CPU_DPLL3_DO_MEAS_LSB			30
+#define CPU_DPLL3_DO_MEAS_MASK			0x40000000
+#define CPU_DPLL3_DO_MEAS_GET(x)		(((x) & CPU_DPLL3_DO_MEAS_MASK) >> CPU_DPLL3_DO_MEAS_LSB)
+#define CPU_DPLL3_DO_MEAS_SET(x)		(((x) << CPU_DPLL3_DO_MEAS_LSB) & CPU_DPLL3_DO_MEAS_MASK)
+#define CPU_DPLL3_DO_MEAS_RESET			0x0 // 0
+#define CPU_DPLL3_PHASE_SHIFT_MSB		29
+#define CPU_DPLL3_PHASE_SHIFT_LSB		23
+#define CPU_DPLL3_PHASE_SHIFT_MASK		0x3f800000
+#define CPU_DPLL3_PHASE_SHIFT_GET(x)		(((x) & CPU_DPLL3_PHASE_SHIFT_MASK) >> CPU_DPLL3_PHASE_SHIFT_LSB)
+#define CPU_DPLL3_PHASE_SHIFT_SET(x)		(((x) << CPU_DPLL3_PHASE_SHIFT_LSB) & CPU_DPLL3_PHASE_SHIFT_MASK)
+#define CPU_DPLL3_PHASE_SHIFT_RESET		0x0 // 0
+#define CPU_DPLL3_SQSUM_DVC_MSB			22
+#define CPU_DPLL3_SQSUM_DVC_LSB			3
+#define CPU_DPLL3_SQSUM_DVC_MASK		0x007ffff8
+#define CPU_DPLL3_SQSUM_DVC_GET(x)		(((x) & CPU_DPLL3_SQSUM_DVC_MASK) >> CPU_DPLL3_SQSUM_DVC_LSB)
+#define CPU_DPLL3_SQSUM_DVC_SET(x)		(((x) << CPU_DPLL3_SQSUM_DVC_LSB) & CPU_DPLL3_SQSUM_DVC_MASK)
+#define CPU_DPLL3_SQSUM_DVC_RESET		0x0 // 0
+#define CPU_DPLL3_SPARE_MSB			2
+#define CPU_DPLL3_SPARE_LSB			0
+#define CPU_DPLL3_SPARE_MASK			0x00000007
+#define CPU_DPLL3_SPARE_GET(x)			(((x) & CPU_DPLL3_SPARE_MASK) >> CPU_DPLL3_SPARE_LSB)
+#define CPU_DPLL3_SPARE_SET(x)			(((x) << CPU_DPLL3_SPARE_LSB) & CPU_DPLL3_SPARE_MASK)
+#define CPU_DPLL3_SPARE_RESET			0x0 // 0
+#define CPU_DPLL3_ADDRESS			0x181161c8
+#define CPU_DPLL4_MEAN_DVC_MSB			31
+#define CPU_DPLL4_MEAN_DVC_LSB			21
+#define CPU_DPLL4_MEAN_DVC_MASK			0xffe00000
+#define CPU_DPLL4_MEAN_DVC_GET(x)		(((x) & CPU_DPLL4_MEAN_DVC_MASK) >> CPU_DPLL4_MEAN_DVC_LSB)
+#define CPU_DPLL4_MEAN_DVC_SET(x)		(((x) << CPU_DPLL4_MEAN_DVC_LSB) & CPU_DPLL4_MEAN_DVC_MASK)
+#define CPU_DPLL4_MEAN_DVC_RESET		0x0 // 0
+#define CPU_DPLL4_VC_MEAS0_MSB			20
+#define CPU_DPLL4_VC_MEAS0_LSB			4
+#define CPU_DPLL4_VC_MEAS0_MASK			0x001ffff0
+#define CPU_DPLL4_VC_MEAS0_GET(x)		(((x) & CPU_DPLL4_VC_MEAS0_MASK) >> CPU_DPLL4_VC_MEAS0_LSB)
+#define CPU_DPLL4_VC_MEAS0_SET(x)		(((x) << CPU_DPLL4_VC_MEAS0_LSB) & CPU_DPLL4_VC_MEAS0_MASK)
+#define CPU_DPLL4_VC_MEAS0_RESET		0x0 // 0
+#define CPU_DPLL4_MEAS_DONE_MSB			3
+#define CPU_DPLL4_MEAS_DONE_LSB			3
+#define CPU_DPLL4_MEAS_DONE_MASK		0x00000008
+#define CPU_DPLL4_MEAS_DONE_GET(x)		(((x) & CPU_DPLL4_MEAS_DONE_MASK) >> CPU_DPLL4_MEAS_DONE_LSB)
+#define CPU_DPLL4_MEAS_DONE_SET(x)		(((x) << CPU_DPLL4_MEAS_DONE_LSB) & CPU_DPLL4_MEAS_DONE_MASK)
+#define CPU_DPLL4_MEAS_DONE_RESET		0x0 // 0
+#define CPU_DPLL4_SPARE_MSB			2
+#define CPU_DPLL4_SPARE_LSB			0
+#define CPU_DPLL4_SPARE_MASK			0x00000007
+#define CPU_DPLL4_SPARE_GET(x)			(((x) & CPU_DPLL4_SPARE_MASK) >> CPU_DPLL4_SPARE_LSB)
+#define CPU_DPLL4_SPARE_SET(x)			(((x) << CPU_DPLL4_SPARE_LSB) & CPU_DPLL4_SPARE_MASK)
+#define CPU_DPLL4_SPARE_RESET			0x0 // 0
+#define CPU_DPLL4_ADDRESS			0x181161cc
+
+#define DDR_DPLL3_MEAS_AT_TXON_MSB		31
+#define DDR_DPLL3_MEAS_AT_TXON_LSB		31
+#define DDR_DPLL3_MEAS_AT_TXON_MASK		0x80000000
+#define DDR_DPLL3_MEAS_AT_TXON_GET(x)		(((x) & DDR_DPLL3_MEAS_AT_TXON_MASK) >> DDR_DPLL3_MEAS_AT_TXON_LSB)
+#define DDR_DPLL3_MEAS_AT_TXON_SET(x)		(((x) << DDR_DPLL3_MEAS_AT_TXON_LSB) & DDR_DPLL3_MEAS_AT_TXON_MASK)
+#define DDR_DPLL3_MEAS_AT_TXON_RESET		0x0 // 0
+#define DDR_DPLL3_DO_MEAS_MSB			30
+#define DDR_DPLL3_DO_MEAS_LSB			30
+#define DDR_DPLL3_DO_MEAS_MASK			0x40000000
+#define DDR_DPLL3_DO_MEAS_GET(x)		(((x) & DDR_DPLL3_DO_MEAS_MASK) >> DDR_DPLL3_DO_MEAS_LSB)
+#define DDR_DPLL3_DO_MEAS_SET(x)		(((x) << DDR_DPLL3_DO_MEAS_LSB) & DDR_DPLL3_DO_MEAS_MASK)
+#define DDR_DPLL3_DO_MEAS_RESET			0x0 // 0
+#define DDR_DPLL3_PHASE_SHIFT_MSB		29
+#define DDR_DPLL3_PHASE_SHIFT_LSB		23
+#define DDR_DPLL3_PHASE_SHIFT_MASK		0x3f800000
+#define DDR_DPLL3_PHASE_SHIFT_GET(x)		(((x) & DDR_DPLL3_PHASE_SHIFT_MASK) >> DDR_DPLL3_PHASE_SHIFT_LSB)
+#define DDR_DPLL3_PHASE_SHIFT_SET(x)		(((x) << DDR_DPLL3_PHASE_SHIFT_LSB) & DDR_DPLL3_PHASE_SHIFT_MASK)
+#define DDR_DPLL3_PHASE_SHIFT_RESET		0x0 // 0
+#define DDR_DPLL3_SQSUM_DVC_MSB			22
+#define DDR_DPLL3_SQSUM_DVC_LSB			3
+#define DDR_DPLL3_SQSUM_DVC_MASK		0x007ffff8
+#define DDR_DPLL3_SQSUM_DVC_GET(x)		(((x) & DDR_DPLL3_SQSUM_DVC_MASK) >> DDR_DPLL3_SQSUM_DVC_LSB)
+#define DDR_DPLL3_SQSUM_DVC_SET(x)		(((x) << DDR_DPLL3_SQSUM_DVC_LSB) & DDR_DPLL3_SQSUM_DVC_MASK)
+#define DDR_DPLL3_SQSUM_DVC_RESET		0x0 // 0
+#define DDR_DPLL3_SPARE_MSB			2
+#define DDR_DPLL3_SPARE_LSB			0
+#define DDR_DPLL3_SPARE_MASK			0x00000007
+#define DDR_DPLL3_SPARE_GET(x)			(((x) & DDR_DPLL3_SPARE_MASK) >> DDR_DPLL3_SPARE_LSB)
+#define DDR_DPLL3_SPARE_SET(x)			(((x) << DDR_DPLL3_SPARE_LSB) & DDR_DPLL3_SPARE_MASK)
+#define DDR_DPLL3_SPARE_RESET			0x0 // 0
+#define DDR_DPLL3_ADDRESS			0x18116248
+
+// 32'h1811624c (DDR_DPLL4)
+#define DDR_DPLL4_MEAN_DVC_MSB			31
+#define DDR_DPLL4_MEAN_DVC_LSB			21
+#define DDR_DPLL4_MEAN_DVC_MASK			0xffe00000
+#define DDR_DPLL4_MEAN_DVC_GET(x)		(((x) & DDR_DPLL4_MEAN_DVC_MASK) >> DDR_DPLL4_MEAN_DVC_LSB)
+#define DDR_DPLL4_MEAN_DVC_SET(x)		(((x) << DDR_DPLL4_MEAN_DVC_LSB) & DDR_DPLL4_MEAN_DVC_MASK)
+#define DDR_DPLL4_MEAN_DVC_RESET		0x0 // 0
+#define DDR_DPLL4_VC_MEAS0_MSB			20
+#define DDR_DPLL4_VC_MEAS0_LSB			4
+#define DDR_DPLL4_VC_MEAS0_MASK			0x001ffff0
+#define DDR_DPLL4_VC_MEAS0_GET(x)		(((x) & DDR_DPLL4_VC_MEAS0_MASK) >> DDR_DPLL4_VC_MEAS0_LSB)
+#define DDR_DPLL4_VC_MEAS0_SET(x)		(((x) << DDR_DPLL4_VC_MEAS0_LSB) & DDR_DPLL4_VC_MEAS0_MASK)
+#define DDR_DPLL4_VC_MEAS0_RESET		0x0 // 0
+#define DDR_DPLL4_MEAS_DONE_MSB			3
+#define DDR_DPLL4_MEAS_DONE_LSB			3
+#define DDR_DPLL4_MEAS_DONE_MASK		0x00000008
+#define DDR_DPLL4_MEAS_DONE_GET(x)		(((x) & DDR_DPLL4_MEAS_DONE_MASK) >> DDR_DPLL4_MEAS_DONE_LSB)
+#define DDR_DPLL4_MEAS_DONE_SET(x)		(((x) << DDR_DPLL4_MEAS_DONE_LSB) & DDR_DPLL4_MEAS_DONE_MASK)
+#define DDR_DPLL4_MEAS_DONE_RESET		0x0 // 0
+#define DDR_DPLL4_SPARE_MSB			2
+#define DDR_DPLL4_SPARE_LSB			0
+#define DDR_DPLL4_SPARE_MASK			0x00000007
+#define DDR_DPLL4_SPARE_GET(x)			(((x) & DDR_DPLL4_SPARE_MASK) >> DDR_DPLL4_SPARE_LSB)
+#define DDR_DPLL4_SPARE_SET(x)			(((x) << DDR_DPLL4_SPARE_LSB) & DDR_DPLL4_SPARE_MASK)
+#define DDR_DPLL4_SPARE_RESET			0x0 // 0
+#define DDR_DPLL4_ADDRESS			0x1811624c
+
+#define DPLL2_ADDRESS_c4			0x181161c4
+#define DPLL3_ADDRESS_c8			CPU_DPLL3_ADDRESS
+#define DPLL2_ADDRESS_44			0x18116244
+#define DPLL3_ADDRESS_48			DDR_DPLL3_ADDRESS
+#define DPLL3_ADDRESS_88			0x18116188
+
+#define PCIe_DPLL_REFDIV_MSB			31
+#define PCIe_DPLL_REFDIV_LSB			27
+#define PCIe_DPLL_REFDIV_MASK			0xf8000000
+#define PCIe_DPLL_REFDIV_GET(x)			(((x) & PCIe_DPLL_REFDIV_MASK) >> PCIe_DPLL_REFDIV_LSB)
+#define PCIe_DPLL_REFDIV_SET(x)			(((x) << PCIe_DPLL_REFDIV_LSB) & PCIe_DPLL_REFDIV_MASK)
+#define PCIe_DPLL_REFDIV_RESET			0x1 // 1
+#define PCIe_DPLL_NINT_MSB			26
+#define PCIe_DPLL_NINT_LSB			18
+#define PCIe_DPLL_NINT_MASK			0x07fc0000
+#define PCIe_DPLL_NINT_GET(x)			(((x) & PCIe_DPLL_NINT_MASK) >> PCIe_DPLL_NINT_LSB)
+#define PCIe_DPLL_NINT_SET(x)			(((x) << PCIe_DPLL_NINT_LSB) & PCIe_DPLL_NINT_MASK)
+#define PCIe_DPLL_NINT_RESET			0x10 // 16
+#define PCIe_DPLL_NFRAC_MSB			17
+#define PCIe_DPLL_NFRAC_LSB			0
+#define PCIe_DPLL_NFRAC_MASK			0x0003ffff
+#define PCIe_DPLL_NFRAC_GET(x)			(((x) & PCIe_DPLL_NFRAC_MASK) >> PCIe_DPLL_NFRAC_LSB)
+#define PCIe_DPLL_NFRAC_SET(x)			(((x) << PCIe_DPLL_NFRAC_LSB) & PCIe_DPLL_NFRAC_MASK)
+#define PCIe_DPLL_NFRAC_RESET			0x0 // 0
+#define PCIe_DPLL_ADDRESS			0x18116c00
+
+// 32'h18116c04 (PCIe_DPLL2)
+#define PCIe_DPLL2_RANGE_MSB			31
+#define PCIe_DPLL2_RANGE_LSB			31
+#define PCIe_DPLL2_RANGE_MASK			0x80000000
+#define PCIe_DPLL2_RANGE_GET(x)			(((x) & PCIe_DPLL2_RANGE_MASK) >> PCIe_DPLL2_RANGE_LSB)
+#define PCIe_DPLL2_RANGE_SET(x)			(((x) << PCIe_DPLL2_RANGE_LSB) & PCIe_DPLL2_RANGE_MASK)
+#define PCIe_DPLL2_RANGE_RESET			0x0 // 0
+#define PCIe_DPLL2_LOCAL_PLL_MSB		30
+#define PCIe_DPLL2_LOCAL_PLL_LSB		30
+#define PCIe_DPLL2_LOCAL_PLL_MASK		0x40000000
+#define PCIe_DPLL2_LOCAL_PLL_GET(x)		(((x) & PCIe_DPLL2_LOCAL_PLL_MASK) >> PCIe_DPLL2_LOCAL_PLL_LSB)
+#define PCIe_DPLL2_LOCAL_PLL_SET(x)		(((x) << PCIe_DPLL2_LOCAL_PLL_LSB) & PCIe_DPLL2_LOCAL_PLL_MASK)
+#define PCIe_DPLL2_LOCAL_PLL_RESET		0x0 // 0
+#define PCIe_DPLL2_KI_MSB			29
+#define PCIe_DPLL2_KI_LSB			26
+#define PCIe_DPLL2_KI_MASK			0x3c000000
+#define PCIe_DPLL2_KI_GET(x)			(((x) & PCIe_DPLL2_KI_MASK) >> PCIe_DPLL2_KI_LSB)
+#define PCIe_DPLL2_KI_SET(x)			(((x) << PCIe_DPLL2_KI_LSB) & PCIe_DPLL2_KI_MASK)
+#define PCIe_DPLL2_KI_RESET			0x6 // 6
+#define PCIe_DPLL2_KD_MSB			25
+#define PCIe_DPLL2_KD_LSB			19
+#define PCIe_DPLL2_KD_MASK			0x03f80000
+#define PCIe_DPLL2_KD_GET(x)			(((x) & PCIe_DPLL2_KD_MASK) >> PCIe_DPLL2_KD_LSB)
+#define PCIe_DPLL2_KD_SET(x)			(((x) << PCIe_DPLL2_KD_LSB) & PCIe_DPLL2_KD_MASK)
+#define PCIe_DPLL2_KD_RESET			0x7f // 127
+#define PCIe_DPLL2_EN_NEGTRIG_MSB		18
+#define PCIe_DPLL2_EN_NEGTRIG_LSB		18
+#define PCIe_DPLL2_EN_NEGTRIG_MASK		0x00040000
+#define PCIe_DPLL2_EN_NEGTRIG_GET(x)		(((x) & PCIe_DPLL2_EN_NEGTRIG_MASK) >> PCIe_DPLL2_EN_NEGTRIG_LSB)
+#define PCIe_DPLL2_EN_NEGTRIG_SET(x)		(((x) << PCIe_DPLL2_EN_NEGTRIG_LSB) & PCIe_DPLL2_EN_NEGTRIG_MASK)
+#define PCIe_DPLL2_EN_NEGTRIG_RESET		0x0 // 0
+#define PCIe_DPLL2_SEL_1SDM_MSB			17
+#define PCIe_DPLL2_SEL_1SDM_LSB			17
+#define PCIe_DPLL2_SEL_1SDM_MASK		0x00020000
+#define PCIe_DPLL2_SEL_1SDM_GET(x)		(((x) & PCIe_DPLL2_SEL_1SDM_MASK) >> PCIe_DPLL2_SEL_1SDM_LSB)
+#define PCIe_DPLL2_SEL_1SDM_SET(x)		(((x) << PCIe_DPLL2_SEL_1SDM_LSB) & PCIe_DPLL2_SEL_1SDM_MASK)
+#define PCIe_DPLL2_SEL_1SDM_RESET		0x0 // 0
+#define PCIe_DPLL2_PLL_PWD_MSB			16
+#define PCIe_DPLL2_PLL_PWD_LSB			16
+#define PCIe_DPLL2_PLL_PWD_MASK			0x00010000
+#define PCIe_DPLL2_PLL_PWD_GET(x)		(((x) & PCIe_DPLL2_PLL_PWD_MASK) >> PCIe_DPLL2_PLL_PWD_LSB)
+#define PCIe_DPLL2_PLL_PWD_SET(x)		(((x) << PCIe_DPLL2_PLL_PWD_LSB) & PCIe_DPLL2_PLL_PWD_MASK)
+#define PCIe_DPLL2_PLL_PWD_RESET		0x1 // 1
+#define PCIe_DPLL2_OUTDIV_MSB			15
+#define PCIe_DPLL2_OUTDIV_LSB			13
+#define PCIe_DPLL2_OUTDIV_MASK			0x0000e000
+#define PCIe_DPLL2_OUTDIV_GET(x)		(((x) & PCIe_DPLL2_OUTDIV_MASK) >> PCIe_DPLL2_OUTDIV_LSB)
+#define PCIe_DPLL2_OUTDIV_SET(x)		(((x) << PCIe_DPLL2_OUTDIV_LSB) & PCIe_DPLL2_OUTDIV_MASK)
+#define PCIe_DPLL2_OUTDIV_RESET			0x0 // 0
+#define PCIe_DPLL2_DELTA_MSB			12
+#define PCIe_DPLL2_DELTA_LSB			7
+#define PCIe_DPLL2_DELTA_MASK			0x00001f80
+#define PCIe_DPLL2_DELTA_GET(x)			(((x) & PCIe_DPLL2_DELTA_MASK) >> PCIe_DPLL2_DELTA_LSB)
+#define PCIe_DPLL2_DELTA_SET(x)			(((x) << PCIe_DPLL2_DELTA_LSB) & PCIe_DPLL2_DELTA_MASK)
+#define PCIe_DPLL2_DELTA_RESET			0x1e // 30
+#define PCIe_DPLL2_SPARE_MSB			6
+#define PCIe_DPLL2_SPARE_LSB			0
+#define PCIe_DPLL2_SPARE_MASK			0x0000007f
+#define PCIe_DPLL2_SPARE_GET(x)			(((x) & PCIe_DPLL2_SPARE_MASK) >> PCIe_DPLL2_SPARE_LSB)
+#define PCIe_DPLL2_SPARE_SET(x)			(((x) << PCIe_DPLL2_SPARE_LSB) & PCIe_DPLL2_SPARE_MASK)
+#define PCIe_DPLL2_SPARE_RESET			0x0 // 0
+#define PCIe_DPLL2_ADDRESS			0x18116c04
+
+#define PCIe_DPLL3_MEAS_AT_TXON_MSB		31
+#define PCIe_DPLL3_MEAS_AT_TXON_LSB		31
+#define PCIe_DPLL3_MEAS_AT_TXON_MASK		0x80000000
+#define PCIe_DPLL3_MEAS_AT_TXON_GET(x)		(((x) & PCIe_DPLL3_MEAS_AT_TXON_MASK) >> PCIe_DPLL3_MEAS_AT_TXON_LSB)
+#define PCIe_DPLL3_MEAS_AT_TXON_SET(x)		(((x) << PCIe_DPLL3_MEAS_AT_TXON_LSB) & PCIe_DPLL3_MEAS_AT_TXON_MASK)
+#define PCIe_DPLL3_MEAS_AT_TXON_RESET		0x0 // 0
+#define PCIe_DPLL3_DO_MEAS_MSB			30
+#define PCIe_DPLL3_DO_MEAS_LSB			30
+#define PCIe_DPLL3_DO_MEAS_MASK			0x40000000
+#define PCIe_DPLL3_DO_MEAS_GET(x)		(((x) & PCIe_DPLL3_DO_MEAS_MASK) >> PCIe_DPLL3_DO_MEAS_LSB)
+#define PCIe_DPLL3_DO_MEAS_SET(x)		(((x) << PCIe_DPLL3_DO_MEAS_LSB) & PCIe_DPLL3_DO_MEAS_MASK)
+#define PCIe_DPLL3_DO_MEAS_RESET		0x0 // 0
+#define PCIe_DPLL3_PHASE_SHIFT_MSB		29
+#define PCIe_DPLL3_PHASE_SHIFT_LSB		23
+#define PCIe_DPLL3_PHASE_SHIFT_MASK		0x3f800000
+#define PCIe_DPLL3_PHASE_SHIFT_GET(x)		(((x) & PCIe_DPLL3_PHASE_SHIFT_MASK) >> PCIe_DPLL3_PHASE_SHIFT_LSB)
+#define PCIe_DPLL3_PHASE_SHIFT_SET(x)		(((x) << PCIe_DPLL3_PHASE_SHIFT_LSB) & PCIe_DPLL3_PHASE_SHIFT_MASK)
+#define PCIe_DPLL3_PHASE_SHIFT_RESET		0x0 // 0
+#define PCIe_DPLL3_SQSUM_DVC_MSB		22
+#define PCIe_DPLL3_SQSUM_DVC_LSB		3
+#define PCIe_DPLL3_SQSUM_DVC_MASK		0x007ffff8
+#define PCIe_DPLL3_SQSUM_DVC_GET(x)		(((x) & PCIe_DPLL3_SQSUM_DVC_MASK) >> PCIe_DPLL3_SQSUM_DVC_LSB)
+#define PCIe_DPLL3_SQSUM_DVC_SET(x)		(((x) << PCIe_DPLL3_SQSUM_DVC_LSB) & PCIe_DPLL3_SQSUM_DVC_MASK)
+#define PCIe_DPLL3_SQSUM_DVC_RESET		0x0 // 0
+#define PCIe_DPLL3_SPARE_MSB			2
+#define PCIe_DPLL3_SPARE_LSB			0
+#define PCIe_DPLL3_SPARE_MASK			0x00000007
+#define PCIe_DPLL3_SPARE_GET(x)			(((x) & PCIe_DPLL3_SPARE_MASK) >> PCIe_DPLL3_SPARE_LSB)
+#define PCIe_DPLL3_SPARE_SET(x)			(((x) << PCIe_DPLL3_SPARE_LSB) & PCIe_DPLL3_SPARE_MASK)
+#define PCIe_DPLL3_SPARE_RESET			0x0 // 0
+#define PCIe_DPLL3_ADDRESS			0x18116c08
+
+#define PCIe_DPLL4_MEAN_DVC_MSB			31
+#define PCIe_DPLL4_MEAN_DVC_LSB			21
+#define PCIe_DPLL4_MEAN_DVC_MASK		0xffe00000
+#define PCIe_DPLL4_MEAN_DVC_GET(x)		(((x) & PCIe_DPLL4_MEAN_DVC_MASK) >> PCIe_DPLL4_MEAN_DVC_LSB)
+#define PCIe_DPLL4_MEAN_DVC_SET(x)		(((x) << PCIe_DPLL4_MEAN_DVC_LSB) & PCIe_DPLL4_MEAN_DVC_MASK)
+#define PCIe_DPLL4_MEAN_DVC_RESET		0x0 // 0
+#define PCIe_DPLL4_VC_MEAS0_MSB			20
+#define PCIe_DPLL4_VC_MEAS0_LSB			4
+#define PCIe_DPLL4_VC_MEAS0_MASK		0x001ffff0
+#define PCIe_DPLL4_VC_MEAS0_GET(x)		(((x) & PCIe_DPLL4_VC_MEAS0_MASK) >> PCIe_DPLL4_VC_MEAS0_LSB)
+#define PCIe_DPLL4_VC_MEAS0_SET(x)		(((x) << PCIe_DPLL4_VC_MEAS0_LSB) & PCIe_DPLL4_VC_MEAS0_MASK)
+#define PCIe_DPLL4_VC_MEAS0_RESET		0x0 // 0
+#define PCIe_DPLL4_MEAS_DONE_MSB		3
+#define PCIe_DPLL4_MEAS_DONE_LSB		3
+#define PCIe_DPLL4_MEAS_DONE_MASK		0x00000008
+#define PCIe_DPLL4_MEAS_DONE_GET(x)		(((x) & PCIe_DPLL4_MEAS_DONE_MASK) >> PCIe_DPLL4_MEAS_DONE_LSB)
+#define PCIe_DPLL4_MEAS_DONE_SET(x)		(((x) << PCIe_DPLL4_MEAS_DONE_LSB) & PCIe_DPLL4_MEAS_DONE_MASK)
+#define PCIe_DPLL4_MEAS_DONE_RESET		0x0 // 0
+#define PCIe_DPLL4_SPARE_MSB			2
+#define PCIe_DPLL4_SPARE_LSB			0
+#define PCIe_DPLL4_SPARE_MASK			0x00000007
+#define PCIe_DPLL4_SPARE_GET(x)			(((x) & PCIe_DPLL4_SPARE_MASK) >> PCIe_DPLL4_SPARE_LSB)
+#define PCIe_DPLL4_SPARE_SET(x)			(((x) << PCIe_DPLL4_SPARE_LSB) & PCIe_DPLL4_SPARE_MASK)
+#define PCIe_DPLL4_SPARE_RESET			0x0 // 0
+#define PCIe_DPLL4_ADDRESS			0x18116c0c
+
+#define	ATH_DDR_COUNT_LOC	0xbd000000
+#define	ATH_CPU_COUNT_LOC	0xbd000004
+
+#define XTAL_ADDRESS                                                 0x18116290
+
+#define GPIO_OE_ADDRESS                                              0x18040000
+
+
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MSB                          31
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB                          31
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK                         0x80000000
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_GET(x)                       (((x) & PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK) >> PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB)
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_SET(x)                       (((x) << PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB) & PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK)
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MSB                          30
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB                          29
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK                         0x60000000
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_GET(x)                       (((x) & PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK) >> PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB)
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_SET(x)                       (((x) << PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB) & PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK)
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_PERSTDELAY_MSB                                28
+#define PCIE_PHY_REG_1_PERSTDELAY_LSB                                27
+#define PCIE_PHY_REG_1_PERSTDELAY_MASK                               0x18000000
+#define PCIE_PHY_REG_1_PERSTDELAY_GET(x)                             (((x) & PCIE_PHY_REG_1_PERSTDELAY_MASK) >> PCIE_PHY_REG_1_PERSTDELAY_LSB)
+#define PCIE_PHY_REG_1_PERSTDELAY_SET(x)                             (((x) << PCIE_PHY_REG_1_PERSTDELAY_LSB) & PCIE_PHY_REG_1_PERSTDELAY_MASK)
+#define PCIE_PHY_REG_1_PERSTDELAY_RESET                              0x2 // 2
+#define PCIE_PHY_REG_1_CLKOBSSEL_MSB                                 26
+#define PCIE_PHY_REG_1_CLKOBSSEL_LSB                                 25
+#define PCIE_PHY_REG_1_CLKOBSSEL_MASK                                0x06000000
+#define PCIE_PHY_REG_1_CLKOBSSEL_GET(x)                              (((x) & PCIE_PHY_REG_1_CLKOBSSEL_MASK) >> PCIE_PHY_REG_1_CLKOBSSEL_LSB)
+#define PCIE_PHY_REG_1_CLKOBSSEL_SET(x)                              (((x) << PCIE_PHY_REG_1_CLKOBSSEL_LSB) & PCIE_PHY_REG_1_CLKOBSSEL_MASK)
+#define PCIE_PHY_REG_1_CLKOBSSEL_RESET                               0x0 // 0
+#define PCIE_PHY_REG_1_DATAOBSEN_MSB                                 24
+#define PCIE_PHY_REG_1_DATAOBSEN_LSB                                 24
+#define PCIE_PHY_REG_1_DATAOBSEN_MASK                                0x01000000
+#define PCIE_PHY_REG_1_DATAOBSEN_GET(x)                              (((x) & PCIE_PHY_REG_1_DATAOBSEN_MASK) >> PCIE_PHY_REG_1_DATAOBSEN_LSB)
+#define PCIE_PHY_REG_1_DATAOBSEN_SET(x)                              (((x) << PCIE_PHY_REG_1_DATAOBSEN_LSB) & PCIE_PHY_REG_1_DATAOBSEN_MASK)
+#define PCIE_PHY_REG_1_DATAOBSEN_RESET                               0x0 // 0
+#define PCIE_PHY_REG_1_FUNCTESTEN_MSB                                23
+#define PCIE_PHY_REG_1_FUNCTESTEN_LSB                                23
+#define PCIE_PHY_REG_1_FUNCTESTEN_MASK                               0x00800000
+#define PCIE_PHY_REG_1_FUNCTESTEN_GET(x)                             (((x) & PCIE_PHY_REG_1_FUNCTESTEN_MASK) >> PCIE_PHY_REG_1_FUNCTESTEN_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTEN_SET(x)                             (((x) << PCIE_PHY_REG_1_FUNCTESTEN_LSB) & PCIE_PHY_REG_1_FUNCTESTEN_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTEN_RESET                              0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_DISABLE_MSB                            22
+#define PCIE_PHY_REG_1_SERDES_DISABLE_LSB                            22
+#define PCIE_PHY_REG_1_SERDES_DISABLE_MASK                           0x00400000
+#define PCIE_PHY_REG_1_SERDES_DISABLE_GET(x)                         (((x) & PCIE_PHY_REG_1_SERDES_DISABLE_MASK) >> PCIE_PHY_REG_1_SERDES_DISABLE_LSB)
+#define PCIE_PHY_REG_1_SERDES_DISABLE_SET(x)                         (((x) << PCIE_PHY_REG_1_SERDES_DISABLE_LSB) & PCIE_PHY_REG_1_SERDES_DISABLE_MASK)
+#define PCIE_PHY_REG_1_SERDES_DISABLE_RESET                          0x0 // 0
+#define PCIE_PHY_REG_1_RXCLKINV_MSB                                  21
+#define PCIE_PHY_REG_1_RXCLKINV_LSB                                  21
+#define PCIE_PHY_REG_1_RXCLKINV_MASK                                 0x00200000
+#define PCIE_PHY_REG_1_RXCLKINV_GET(x)                               (((x) & PCIE_PHY_REG_1_RXCLKINV_MASK) >> PCIE_PHY_REG_1_RXCLKINV_LSB)
+#define PCIE_PHY_REG_1_RXCLKINV_SET(x)                               (((x) << PCIE_PHY_REG_1_RXCLKINV_LSB) & PCIE_PHY_REG_1_RXCLKINV_MASK)
+#define PCIE_PHY_REG_1_RXCLKINV_RESET                                0x1 // 1
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MSB                          20
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB                          20
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK                         0x00100000
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_GET(x)                       (((x) & PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK) >> PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_SET(x)                       (((x) << PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB) & PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MSB                          19
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB                          19
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK                         0x00080000
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_GET(x)                       (((x) & PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK) >> PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_SET(x)                       (((x) << PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB) & PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_ENABLECLKREQ_MSB                              18
+#define PCIE_PHY_REG_1_ENABLECLKREQ_LSB                              18
+#define PCIE_PHY_REG_1_ENABLECLKREQ_MASK                             0x00040000
+#define PCIE_PHY_REG_1_ENABLECLKREQ_GET(x)                           (((x) & PCIE_PHY_REG_1_ENABLECLKREQ_MASK) >> PCIE_PHY_REG_1_ENABLECLKREQ_LSB)
+#define PCIE_PHY_REG_1_ENABLECLKREQ_SET(x)                           (((x) << PCIE_PHY_REG_1_ENABLECLKREQ_LSB) & PCIE_PHY_REG_1_ENABLECLKREQ_MASK)
+#define PCIE_PHY_REG_1_ENABLECLKREQ_RESET                            0x0 // 0
+#define PCIE_PHY_REG_1_FORCELOOPBACK_MSB                             17
+#define PCIE_PHY_REG_1_FORCELOOPBACK_LSB                             17
+#define PCIE_PHY_REG_1_FORCELOOPBACK_MASK                            0x00020000
+#define PCIE_PHY_REG_1_FORCELOOPBACK_GET(x)                          (((x) & PCIE_PHY_REG_1_FORCELOOPBACK_MASK) >> PCIE_PHY_REG_1_FORCELOOPBACK_LSB)
+#define PCIE_PHY_REG_1_FORCELOOPBACK_SET(x)                          (((x) << PCIE_PHY_REG_1_FORCELOOPBACK_LSB) & PCIE_PHY_REG_1_FORCELOOPBACK_MASK)
+#define PCIE_PHY_REG_1_FORCELOOPBACK_RESET                           0x0 // 0
+#define PCIE_PHY_REG_1_SEL_CLK_MSB                                   16
+#define PCIE_PHY_REG_1_SEL_CLK_LSB                                   15
+#define PCIE_PHY_REG_1_SEL_CLK_MASK                                  0x00018000
+#define PCIE_PHY_REG_1_SEL_CLK_GET(x)                                (((x) & PCIE_PHY_REG_1_SEL_CLK_MASK) >> PCIE_PHY_REG_1_SEL_CLK_LSB)
+#define PCIE_PHY_REG_1_SEL_CLK_SET(x)                                (((x) << PCIE_PHY_REG_1_SEL_CLK_LSB) & PCIE_PHY_REG_1_SEL_CLK_MASK)
+#define PCIE_PHY_REG_1_SEL_CLK_RESET                                 0x2 // 2
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_MSB                              14
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_LSB                              14
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_MASK                             0x00004000
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_GET(x)                           (((x) & PCIE_PHY_REG_1_SERDES_RX_EQ_MASK) >> PCIE_PHY_REG_1_SERDES_RX_EQ_LSB)
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_SET(x)                           (((x) << PCIE_PHY_REG_1_SERDES_RX_EQ_LSB) & PCIE_PHY_REG_1_SERDES_RX_EQ_MASK)
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_RESET                            0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_MSB                           13
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB                           13
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK                          0x00002000
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK) >> PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB)
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB) & PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK)
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_RESET                         0x1 // 1
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MSB                     12
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB                     12
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK                    0x00001000
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_GET(x)                  (((x) & PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK) >> PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB)
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_SET(x)                  (((x) << PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB) & PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK)
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_RESET                   0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_MSB                         11
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB                         11
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK                        0x00000800
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_GET(x)                      (((x) & PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK) >> PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB)
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_SET(x)                      (((x) << PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB) & PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK)
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_RESET                       0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_MSB                             10
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_LSB                             9
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_MASK                            0x00000600
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_GET(x)                          (((x) & PCIE_PHY_REG_1_SERDES_CDR_BW_MASK) >> PCIE_PHY_REG_1_SERDES_CDR_BW_LSB)
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_SET(x)                          (((x) << PCIE_PHY_REG_1_SERDES_CDR_BW_LSB) & PCIE_PHY_REG_1_SERDES_CDR_BW_MASK)
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_RESET                           0x3 // 3
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_MSB                             8
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_LSB                             7
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_MASK                            0x00000180
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_GET(x)                          (((x) & PCIE_PHY_REG_1_SERDES_TH_LOS_MASK) >> PCIE_PHY_REG_1_SERDES_TH_LOS_LSB)
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_SET(x)                          (((x) << PCIE_PHY_REG_1_SERDES_TH_LOS_LSB) & PCIE_PHY_REG_1_SERDES_TH_LOS_MASK)
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_RESET                           0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_MSB                           6
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB                           6
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK                          0x00000040
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK) >> PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB)
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB) & PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK)
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_RESET                         0x1 // 1
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_MSB                           5
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB                           5
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK                          0x00000020
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK) >> PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB)
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB) & PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK)
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_RESET                         0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_MSB                            4
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB                            4
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK                           0x00000010
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_GET(x)                         (((x) & PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK) >> PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB)
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_SET(x)                         (((x) << PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB) & PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK)
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_RESET                          0x1 // 1
+#define PCIE_PHY_REG_1_S_MSB                                         3
+#define PCIE_PHY_REG_1_S_LSB                                         0
+#define PCIE_PHY_REG_1_S_MASK                                        0x0000000f
+#define PCIE_PHY_REG_1_S_GET(x)                                      (((x) & PCIE_PHY_REG_1_S_MASK) >> PCIE_PHY_REG_1_S_LSB)
+#define PCIE_PHY_REG_1_S_SET(x)                                      (((x) << PCIE_PHY_REG_1_S_LSB) & PCIE_PHY_REG_1_S_MASK)
+#define PCIE_PHY_REG_1_S_RESET                                       0xe // 14
+#define PCIE_PHY_REG_1_ADDRESS                                       0x18116cc0
+
+
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MSB                         31
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB                         24
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK                        0xff000000
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_RESET                       0xb // 11
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MSB                         23
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB                         16
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK                        0x00ff0000
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_RESET                       0xa // 10
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MSB                         15
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB                         8
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_RESET                       0x9 // 9
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MSB                         7
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB                         0
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_RESET                       0x14 // 20
+#define GPIO_OUT_FUNCTION1_ADDRESS                                   0x18040030
+
+
+#if (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(32)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(1)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(32)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(1)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(2)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(2)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(1)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(24)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(48)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(1)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(48)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(1)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(40)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(44)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_332_166)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(26)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_332_200)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(26)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_266_133)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(21)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_266_200)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(21)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_566_550_275)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(22)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(13)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(40) | CPU_PLL_DITHER_NFRAC_MAX_SET(40)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(9) | CPU_PLL_DITHER_NFRAC_MAX_SET(9)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(768) | DDR_PLL_DITHER_NFRAC_MAX_SET(768)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_566_525_262)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(21)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(13)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(40) | CPU_PLL_DITHER_NFRAC_MAX_SET(40)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(9) | CPU_PLL_DITHER_NFRAC_MAX_SET(9)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(128) | DDR_PLL_DITHER_NFRAC_MAX_SET(128)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(12)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(40) | CPU_PLL_DITHER_NFRAC_MAX_SET(40)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(9) | CPU_PLL_DITHER_NFRAC_MAX_SET(9)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(512) | DDR_PLL_DITHER_NFRAC_MAX_SET(512)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(19)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(11)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(41) | CPU_PLL_DITHER_NFRAC_MAX_SET(41)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(9) | CPU_PLL_DITHER_NFRAC_MAX_SET(9)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(1023)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(895) | DDR_PLL_DITHER_NFRAC_MAX_SET(1023)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_566_450_225)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(36)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(22)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(40) | CPU_PLL_DITHER_NFRAC_MAX_SET(40)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(9) | CPU_PLL_DITHER_NFRAC_MAX_SET(9)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(512) | DDR_PLL_DITHER_NFRAC_MAX_SET(512)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_566_400_200)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(10)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(40) | CPU_PLL_DITHER_NFRAC_MAX_SET(40)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(9) | CPU_PLL_DITHER_NFRAC_MAX_SET(9)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(19)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(12)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(25) | CPU_PLL_DITHER_NFRAC_MAX_SET(25)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(204) | DDR_PLL_DITHER_NFRAC_MAX_SET(204)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_480_240)
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(32)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(1)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(19)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(12)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(204) | DDR_PLL_DITHER_NFRAC_MAX_SET(204)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+
+
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(26)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(24)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_600_300)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(24)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_275)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(22)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_650_325)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(26)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_525_262)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(21)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_575_287)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(23)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(14)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_450_200)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(18)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(21)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(13)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(21)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(13)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(12)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(28)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(24)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_300)
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(20)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(12)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(32) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(28)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(17)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(3)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(12)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_500_500_250)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#else
+/*
+ * This is for old lowlevel init file that was used for wasp 1.0 to compile.
+ */
+
+#ifdef CONFIG_AP123			// CFG_PLL_535_400_200
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(21)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(13)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif defined(CONFIG_ATH_NAND_SUPPORT)	// NAND on DB120 CFG_PLL_560_400_200
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(10)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(25) | CPU_PLL_DITHER_NFRAC_MAX_SET(25)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#else					// CFG_PLL_560_450_225
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(36)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(22)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(25) | CPU_PLL_DITHER_NFRAC_MAX_SET(25)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(512) | DDR_PLL_DITHER_NFRAC_MAX_SET(512)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#endif
+
+#endif
+
+#define DDR_DPLL_REFDIV_MSB                                              31
+#define DDR_DPLL_REFDIV_LSB                                              27
+#define DDR_DPLL_REFDIV_MASK                                             0xf8000000
+#define DDR_DPLL_REFDIV_GET(x)                                           (((x) & DDR_DPLL_REFDIV_MASK) >> DDR_DPLL_REFDIV_LSB)
+#define DDR_DPLL_REFDIV_SET(x)                                           (((x) << DDR_DPLL_REFDIV_LSB) & DDR_DPLL_REFDIV_MASK)
+#define DDR_DPLL_REFDIV_RESET                                            0x1 // 1
+#define DDR_DPLL_NINT_MSB                                                26
+#define DDR_DPLL_NINT_LSB                                                18
+#define DDR_DPLL_NINT_MASK                                               0x07fc0000
+#define DDR_DPLL_NINT_GET(x)                                             (((x) & DDR_DPLL_NINT_MASK) >> DDR_DPLL_NINT_LSB)
+#define DDR_DPLL_NINT_SET(x)                                             (((x) << DDR_DPLL_NINT_LSB) & DDR_DPLL_NINT_MASK)
+#define DDR_DPLL_NINT_RESET                                              0x10 // 16
+#define DDR_DPLL_NFRAC_MSB                                               17
+#define DDR_DPLL_NFRAC_LSB                                               0
+#define DDR_DPLL_NFRAC_MASK                                              0x0003ffff
+#define DDR_DPLL_NFRAC_GET(x)                                            (((x) & DDR_DPLL_NFRAC_MASK) >> DDR_DPLL_NFRAC_LSB)
+#define DDR_DPLL_NFRAC_SET(x)                                            (((x) << DDR_DPLL_NFRAC_LSB) & DDR_DPLL_NFRAC_MASK)
+#define DDR_DPLL_NFRAC_RESET                                             0x0 // 0
+#define DDR_DPLL_ADDRESS                                                 0x18116240
+
+#define DDR_DPLL2_RANGE_MSB                                              31
+#define DDR_DPLL2_RANGE_LSB                                              31
+#define DDR_DPLL2_RANGE_MASK                                             0x80000000
+#define DDR_DPLL2_RANGE_GET(x)                                           (((x) & DDR_DPLL2_RANGE_MASK) >> DDR_DPLL2_RANGE_LSB)
+#define DDR_DPLL2_RANGE_SET(x)                                           (((x) << DDR_DPLL2_RANGE_LSB) & DDR_DPLL2_RANGE_MASK)
+#define DDR_DPLL2_RANGE_RESET                                            0x0 // 0
+#define DDR_DPLL2_LOCAL_PLL_MSB                                          30
+#define DDR_DPLL2_LOCAL_PLL_LSB                                          30
+#define DDR_DPLL2_LOCAL_PLL_MASK                                         0x40000000
+#define DDR_DPLL2_LOCAL_PLL_GET(x)                                       (((x) & DDR_DPLL2_LOCAL_PLL_MASK) >> DDR_DPLL2_LOCAL_PLL_LSB)
+#define DDR_DPLL2_LOCAL_PLL_SET(x)                                       (((x) << DDR_DPLL2_LOCAL_PLL_LSB) & DDR_DPLL2_LOCAL_PLL_MASK)
+#define DDR_DPLL2_LOCAL_PLL_RESET                                        0x0 // 0
+#define DDR_DPLL2_KI_MSB                                                 29
+#define DDR_DPLL2_KI_LSB                                                 26
+#define DDR_DPLL2_KI_MASK                                                0x3c000000
+#define DDR_DPLL2_KI_GET(x)                                              (((x) & DDR_DPLL2_KI_MASK) >> DDR_DPLL2_KI_LSB)
+#define DDR_DPLL2_KI_SET(x)                                              (((x) << DDR_DPLL2_KI_LSB) & DDR_DPLL2_KI_MASK)
+#define DDR_DPLL2_KI_RESET                                               0x6 // 6
+#define DDR_DPLL2_KD_MSB                                                 25
+#define DDR_DPLL2_KD_LSB                                                 19
+#define DDR_DPLL2_KD_MASK                                                0x03f80000
+#define DDR_DPLL2_KD_GET(x)                                              (((x) & DDR_DPLL2_KD_MASK) >> DDR_DPLL2_KD_LSB)
+#define DDR_DPLL2_KD_SET(x)                                              (((x) << DDR_DPLL2_KD_LSB) & DDR_DPLL2_KD_MASK)
+#define DDR_DPLL2_KD_RESET                                               0x7f // 127
+#define DDR_DPLL2_EN_NEGTRIG_MSB                                         18
+#define DDR_DPLL2_EN_NEGTRIG_LSB                                         18
+#define DDR_DPLL2_EN_NEGTRIG_MASK                                        0x00040000
+#define DDR_DPLL2_EN_NEGTRIG_GET(x)                                      (((x) & DDR_DPLL2_EN_NEGTRIG_MASK) >> DDR_DPLL2_EN_NEGTRIG_LSB)
+#define DDR_DPLL2_EN_NEGTRIG_SET(x)                                      (((x) << DDR_DPLL2_EN_NEGTRIG_LSB) & DDR_DPLL2_EN_NEGTRIG_MASK)
+#define DDR_DPLL2_EN_NEGTRIG_RESET                                       0x0 // 0
+#define DDR_DPLL2_SEL_1SDM_MSB                                           17
+#define DDR_DPLL2_SEL_1SDM_LSB                                           17
+#define DDR_DPLL2_SEL_1SDM_MASK                                          0x00020000
+#define DDR_DPLL2_SEL_1SDM_GET(x)                                        (((x) & DDR_DPLL2_SEL_1SDM_MASK) >> DDR_DPLL2_SEL_1SDM_LSB)
+#define DDR_DPLL2_SEL_1SDM_SET(x)                                        (((x) << DDR_DPLL2_SEL_1SDM_LSB) & DDR_DPLL2_SEL_1SDM_MASK)
+#define DDR_DPLL2_SEL_1SDM_RESET                                         0x0 // 0
+#define DDR_DPLL2_PLL_PWD_MSB                                            16
+#define DDR_DPLL2_PLL_PWD_LSB                                            16
+#define DDR_DPLL2_PLL_PWD_MASK                                           0x00010000
+#define DDR_DPLL2_PLL_PWD_GET(x)                                         (((x) & DDR_DPLL2_PLL_PWD_MASK) >> DDR_DPLL2_PLL_PWD_LSB)
+#define DDR_DPLL2_PLL_PWD_SET(x)                                         (((x) << DDR_DPLL2_PLL_PWD_LSB) & DDR_DPLL2_PLL_PWD_MASK)
+#define DDR_DPLL2_PLL_PWD_RESET                                          0x1 // 1
+#define DDR_DPLL2_OUTDIV_MSB                                             15
+#define DDR_DPLL2_OUTDIV_LSB                                             13
+#define DDR_DPLL2_OUTDIV_MASK                                            0x0000e000
+#define DDR_DPLL2_OUTDIV_GET(x)                                          (((x) & DDR_DPLL2_OUTDIV_MASK) >> DDR_DPLL2_OUTDIV_LSB)
+#define DDR_DPLL2_OUTDIV_SET(x)                                          (((x) << DDR_DPLL2_OUTDIV_LSB) & DDR_DPLL2_OUTDIV_MASK)
+#define DDR_DPLL2_OUTDIV_RESET                                           0x0 // 0
+#define DDR_DPLL2_DELTA_MSB                                              12
+#define DDR_DPLL2_DELTA_LSB                                              7
+#define DDR_DPLL2_DELTA_MASK                                             0x00001f80
+#define DDR_DPLL2_DELTA_GET(x)                                           (((x) & DDR_DPLL2_DELTA_MASK) >> DDR_DPLL2_DELTA_LSB)
+#define DDR_DPLL2_DELTA_SET(x)                                           (((x) << DDR_DPLL2_DELTA_LSB) & DDR_DPLL2_DELTA_MASK)
+#define DDR_DPLL2_DELTA_RESET                                            0x1e // 30
+#define DDR_DPLL2_SPARE_MSB                                              6
+#define DDR_DPLL2_SPARE_LSB                                              0
+#define DDR_DPLL2_SPARE_MASK                                             0x0000007f
+#define DDR_DPLL2_SPARE_GET(x)                                           (((x) & DDR_DPLL2_SPARE_MASK) >> DDR_DPLL2_SPARE_LSB)
+#define DDR_DPLL2_SPARE_SET(x)                                           (((x) << DDR_DPLL2_SPARE_LSB) & DDR_DPLL2_SPARE_MASK)
+#define DDR_DPLL2_SPARE_RESET                                            0x0 // 0
+#define DDR_DPLL2_ADDRESS                                                0x18116244
+
+#define DDR_DPLL3_MEAS_AT_TXON_MSB                                       31
+#define DDR_DPLL3_MEAS_AT_TXON_LSB                                       31
+#define DDR_DPLL3_MEAS_AT_TXON_MASK                                      0x80000000
+#define DDR_DPLL3_MEAS_AT_TXON_GET(x)                                    (((x) & DDR_DPLL3_MEAS_AT_TXON_MASK) >> DDR_DPLL3_MEAS_AT_TXON_LSB)
+#define DDR_DPLL3_MEAS_AT_TXON_SET(x)                                    (((x) << DDR_DPLL3_MEAS_AT_TXON_LSB) & DDR_DPLL3_MEAS_AT_TXON_MASK)
+#define DDR_DPLL3_MEAS_AT_TXON_RESET                                     0x0 // 0
+#define DDR_DPLL3_DO_MEAS_MSB                                            30
+#define DDR_DPLL3_DO_MEAS_LSB                                            30
+#define DDR_DPLL3_DO_MEAS_MASK                                           0x40000000
+#define DDR_DPLL3_DO_MEAS_GET(x)                                         (((x) & DDR_DPLL3_DO_MEAS_MASK) >> DDR_DPLL3_DO_MEAS_LSB)
+#define DDR_DPLL3_DO_MEAS_SET(x)                                         (((x) << DDR_DPLL3_DO_MEAS_LSB) & DDR_DPLL3_DO_MEAS_MASK)
+#define DDR_DPLL3_DO_MEAS_RESET                                          0x0 // 0
+#define DDR_DPLL3_PHASE_SHIFT_MSB                                        29
+#define DDR_DPLL3_PHASE_SHIFT_LSB                                        23
+#define DDR_DPLL3_PHASE_SHIFT_MASK                                       0x3f800000
+#define DDR_DPLL3_PHASE_SHIFT_GET(x)                                     (((x) & DDR_DPLL3_PHASE_SHIFT_MASK) >> DDR_DPLL3_PHASE_SHIFT_LSB)
+#define DDR_DPLL3_PHASE_SHIFT_SET(x)                                     (((x) << DDR_DPLL3_PHASE_SHIFT_LSB) & DDR_DPLL3_PHASE_SHIFT_MASK)
+#define DDR_DPLL3_PHASE_SHIFT_RESET                                      0x0 // 0
+#define DDR_DPLL3_SQSUM_DVC_MSB                                          22
+#define DDR_DPLL3_SQSUM_DVC_LSB                                          3
+#define DDR_DPLL3_SQSUM_DVC_MASK                                         0x007ffff8
+#define DDR_DPLL3_SQSUM_DVC_GET(x)                                       (((x) & DDR_DPLL3_SQSUM_DVC_MASK) >> DDR_DPLL3_SQSUM_DVC_LSB)
+#define DDR_DPLL3_SQSUM_DVC_SET(x)                                       (((x) << DDR_DPLL3_SQSUM_DVC_LSB) & DDR_DPLL3_SQSUM_DVC_MASK)
+#define DDR_DPLL3_SQSUM_DVC_RESET                                        0x0 // 0
+#define DDR_DPLL3_SPARE_MSB                                              2
+#define DDR_DPLL3_SPARE_LSB                                              0
+#define DDR_DPLL3_SPARE_MASK                                             0x00000007
+#define DDR_DPLL3_SPARE_GET(x)                                           (((x) & DDR_DPLL3_SPARE_MASK) >> DDR_DPLL3_SPARE_LSB)
+#define DDR_DPLL3_SPARE_SET(x)                                           (((x) << DDR_DPLL3_SPARE_LSB) & DDR_DPLL3_SPARE_MASK)
+#define DDR_DPLL3_SPARE_RESET                                            0x0 // 0
+#define DDR_DPLL3_ADDRESS                                                0x18116248
+
+#define CPU_DPLL_REFDIV_MSB                                              31
+#define CPU_DPLL_REFDIV_LSB                                              27
+#define CPU_DPLL_REFDIV_MASK                                             0xf8000000
+#define CPU_DPLL_REFDIV_GET(x)                                           (((x) & CPU_DPLL_REFDIV_MASK) >> CPU_DPLL_REFDIV_LSB)
+#define CPU_DPLL_REFDIV_SET(x)                                           (((x) << CPU_DPLL_REFDIV_LSB) & CPU_DPLL_REFDIV_MASK)
+#define CPU_DPLL_REFDIV_RESET                                            0x1 // 1
+#define CPU_DPLL_NINT_MSB                                                26
+#define CPU_DPLL_NINT_LSB                                                18
+#define CPU_DPLL_NINT_MASK                                               0x07fc0000
+#define CPU_DPLL_NINT_GET(x)                                             (((x) & CPU_DPLL_NINT_MASK) >> CPU_DPLL_NINT_LSB)
+#define CPU_DPLL_NINT_SET(x)                                             (((x) << CPU_DPLL_NINT_LSB) & CPU_DPLL_NINT_MASK)
+#define CPU_DPLL_NINT_RESET                                              0x10 // 16
+#define CPU_DPLL_NFRAC_MSB                                               17
+#define CPU_DPLL_NFRAC_LSB                                               0
+#define CPU_DPLL_NFRAC_MASK                                              0x0003ffff
+#define CPU_DPLL_NFRAC_GET(x)                                            (((x) & CPU_DPLL_NFRAC_MASK) >> CPU_DPLL_NFRAC_LSB)
+#define CPU_DPLL_NFRAC_SET(x)                                            (((x) << CPU_DPLL_NFRAC_LSB) & CPU_DPLL_NFRAC_MASK)
+#define CPU_DPLL_NFRAC_RESET                                             0x0 // 0
+#define CPU_DPLL_ADDRESS                                                 0x181161c0
+
+#define CPU_DPLL2_RANGE_MSB                                              31
+#define CPU_DPLL2_RANGE_LSB                                              31
+#define CPU_DPLL2_RANGE_MASK                                             0x80000000
+#define CPU_DPLL2_RANGE_GET(x)                                           (((x) & CPU_DPLL2_RANGE_MASK) >> CPU_DPLL2_RANGE_LSB)
+#define CPU_DPLL2_RANGE_SET(x)                                           (((x) << CPU_DPLL2_RANGE_LSB) & CPU_DPLL2_RANGE_MASK)
+#define CPU_DPLL2_RANGE_RESET                                            0x0 // 0
+#define CPU_DPLL2_LOCAL_PLL_MSB                                          30
+#define CPU_DPLL2_LOCAL_PLL_LSB                                          30
+#define CPU_DPLL2_LOCAL_PLL_MASK                                         0x40000000
+#define CPU_DPLL2_LOCAL_PLL_GET(x)                                       (((x) & CPU_DPLL2_LOCAL_PLL_MASK) >> CPU_DPLL2_LOCAL_PLL_LSB)
+#define CPU_DPLL2_LOCAL_PLL_SET(x)                                       (((x) << CPU_DPLL2_LOCAL_PLL_LSB) & CPU_DPLL2_LOCAL_PLL_MASK)
+#define CPU_DPLL2_LOCAL_PLL_RESET                                        0x0 // 0
+#define CPU_DPLL2_KI_MSB                                                 29
+#define CPU_DPLL2_KI_LSB                                                 26
+#define CPU_DPLL2_KI_MASK                                                0x3c000000
+#define CPU_DPLL2_KI_GET(x)                                              (((x) & CPU_DPLL2_KI_MASK) >> CPU_DPLL2_KI_LSB)
+#define CPU_DPLL2_KI_SET(x)                                              (((x) << CPU_DPLL2_KI_LSB) & CPU_DPLL2_KI_MASK)
+#define CPU_DPLL2_KI_RESET                                               0x6 // 6
+#define CPU_DPLL2_KD_MSB                                                 25
+#define CPU_DPLL2_KD_LSB                                                 19
+#define CPU_DPLL2_KD_MASK                                                0x03f80000
+#define CPU_DPLL2_KD_GET(x)                                              (((x) & CPU_DPLL2_KD_MASK) >> CPU_DPLL2_KD_LSB)
+#define CPU_DPLL2_KD_SET(x)                                              (((x) << CPU_DPLL2_KD_LSB) & CPU_DPLL2_KD_MASK)
+#define CPU_DPLL2_KD_RESET                                               0x7f // 127
+#define CPU_DPLL2_EN_NEGTRIG_MSB                                         18
+#define CPU_DPLL2_EN_NEGTRIG_LSB                                         18
+#define CPU_DPLL2_EN_NEGTRIG_MASK                                        0x00040000
+#define CPU_DPLL2_EN_NEGTRIG_GET(x)                                      (((x) & CPU_DPLL2_EN_NEGTRIG_MASK) >> CPU_DPLL2_EN_NEGTRIG_LSB)
+#define CPU_DPLL2_EN_NEGTRIG_SET(x)                                      (((x) << CPU_DPLL2_EN_NEGTRIG_LSB) & CPU_DPLL2_EN_NEGTRIG_MASK)
+#define CPU_DPLL2_EN_NEGTRIG_RESET                                       0x0 // 0
+#define CPU_DPLL2_SEL_1SDM_MSB                                           17
+#define CPU_DPLL2_SEL_1SDM_LSB                                           17
+#define CPU_DPLL2_SEL_1SDM_MASK                                          0x00020000
+#define CPU_DPLL2_SEL_1SDM_GET(x)                                        (((x) & CPU_DPLL2_SEL_1SDM_MASK) >> CPU_DPLL2_SEL_1SDM_LSB)
+#define CPU_DPLL2_SEL_1SDM_SET(x)                                        (((x) << CPU_DPLL2_SEL_1SDM_LSB) & CPU_DPLL2_SEL_1SDM_MASK)
+#define CPU_DPLL2_SEL_1SDM_RESET                                         0x0 // 0
+#define CPU_DPLL2_PLL_PWD_MSB                                            16
+#define CPU_DPLL2_PLL_PWD_LSB                                            16
+#define CPU_DPLL2_PLL_PWD_MASK                                           0x00010000
+#define CPU_DPLL2_PLL_PWD_GET(x)                                         (((x) & CPU_DPLL2_PLL_PWD_MASK) >> CPU_DPLL2_PLL_PWD_LSB)
+#define CPU_DPLL2_PLL_PWD_SET(x)                                         (((x) << CPU_DPLL2_PLL_PWD_LSB) & CPU_DPLL2_PLL_PWD_MASK)
+#define CPU_DPLL2_PLL_PWD_RESET                                          0x1 // 1
+#define CPU_DPLL2_OUTDIV_MSB                                             15
+#define CPU_DPLL2_OUTDIV_LSB                                             13
+#define CPU_DPLL2_OUTDIV_MASK                                            0x0000e000
+#define CPU_DPLL2_OUTDIV_GET(x)                                          (((x) & CPU_DPLL2_OUTDIV_MASK) >> CPU_DPLL2_OUTDIV_LSB)
+#define CPU_DPLL2_OUTDIV_SET(x)                                          (((x) << CPU_DPLL2_OUTDIV_LSB) & CPU_DPLL2_OUTDIV_MASK)
+#define CPU_DPLL2_OUTDIV_RESET                                           0x0 // 0
+#define CPU_DPLL2_DELTA_MSB                                              12
+#define CPU_DPLL2_DELTA_LSB                                              7
+#define CPU_DPLL2_DELTA_MASK                                             0x00001f80
+#define CPU_DPLL2_DELTA_GET(x)                                           (((x) & CPU_DPLL2_DELTA_MASK) >> CPU_DPLL2_DELTA_LSB)
+#define CPU_DPLL2_DELTA_SET(x)                                           (((x) << CPU_DPLL2_DELTA_LSB) & CPU_DPLL2_DELTA_MASK)
+#define CPU_DPLL2_DELTA_RESET                                            0x1e // 30
+#define CPU_DPLL2_SPARE_MSB                                              6
+#define CPU_DPLL2_SPARE_LSB                                              0
+#define CPU_DPLL2_SPARE_MASK                                             0x0000007f
+#define CPU_DPLL2_SPARE_GET(x)                                           (((x) & CPU_DPLL2_SPARE_MASK) >> CPU_DPLL2_SPARE_LSB)
+#define CPU_DPLL2_SPARE_SET(x)                                           (((x) << CPU_DPLL2_SPARE_LSB) & CPU_DPLL2_SPARE_MASK)
+#define CPU_DPLL2_SPARE_RESET                                            0x0 // 0
+#define CPU_DPLL2_ADDRESS                                                0x181161c4
+
+// 32'h181161c8 (CPU_DPLL3)
+#define CPU_DPLL3_MEAS_AT_TXON_MSB                                       31
+#define CPU_DPLL3_MEAS_AT_TXON_LSB                                       31
+#define CPU_DPLL3_MEAS_AT_TXON_MASK                                      0x80000000
+#define CPU_DPLL3_MEAS_AT_TXON_GET(x)                                    (((x) & CPU_DPLL3_MEAS_AT_TXON_MASK) >> CPU_DPLL3_MEAS_AT_TXON_LSB)
+#define CPU_DPLL3_MEAS_AT_TXON_SET(x)                                    (((x) << CPU_DPLL3_MEAS_AT_TXON_LSB) & CPU_DPLL3_MEAS_AT_TXON_MASK)
+#define CPU_DPLL3_MEAS_AT_TXON_RESET                                     0x0 // 0
+#define CPU_DPLL3_DO_MEAS_MSB                                            30
+#define CPU_DPLL3_DO_MEAS_LSB                                            30
+#define CPU_DPLL3_DO_MEAS_MASK                                           0x40000000
+#define CPU_DPLL3_DO_MEAS_GET(x)                                         (((x) & CPU_DPLL3_DO_MEAS_MASK) >> CPU_DPLL3_DO_MEAS_LSB)
+#define CPU_DPLL3_DO_MEAS_SET(x)                                         (((x) << CPU_DPLL3_DO_MEAS_LSB) & CPU_DPLL3_DO_MEAS_MASK)
+#define CPU_DPLL3_DO_MEAS_RESET                                          0x0 // 0
+#define CPU_DPLL3_PHASE_SHIFT_MSB                                        29
+#define CPU_DPLL3_PHASE_SHIFT_LSB                                        23
+#define CPU_DPLL3_PHASE_SHIFT_MASK                                       0x3f800000
+#define CPU_DPLL3_PHASE_SHIFT_GET(x)                                     (((x) & CPU_DPLL3_PHASE_SHIFT_MASK) >> CPU_DPLL3_PHASE_SHIFT_LSB)
+#define CPU_DPLL3_PHASE_SHIFT_SET(x)                                     (((x) << CPU_DPLL3_PHASE_SHIFT_LSB) & CPU_DPLL3_PHASE_SHIFT_MASK)
+#define CPU_DPLL3_PHASE_SHIFT_RESET                                      0x0 // 0
+#define CPU_DPLL3_SQSUM_DVC_MSB                                          22
+#define CPU_DPLL3_SQSUM_DVC_LSB                                          3
+#define CPU_DPLL3_SQSUM_DVC_MASK                                         0x007ffff8
+#define CPU_DPLL3_SQSUM_DVC_GET(x)                                       (((x) & CPU_DPLL3_SQSUM_DVC_MASK) >> CPU_DPLL3_SQSUM_DVC_LSB)
+#define CPU_DPLL3_SQSUM_DVC_SET(x)                                       (((x) << CPU_DPLL3_SQSUM_DVC_LSB) & CPU_DPLL3_SQSUM_DVC_MASK)
+#define CPU_DPLL3_SQSUM_DVC_RESET                                        0x0 // 0
+#define CPU_DPLL3_SPARE_MSB                                              2
+#define CPU_DPLL3_SPARE_LSB                                              0
+#define CPU_DPLL3_SPARE_MASK                                             0x00000007
+#define CPU_DPLL3_SPARE_GET(x)                                           (((x) & CPU_DPLL3_SPARE_MASK) >> CPU_DPLL3_SPARE_LSB)
+#define CPU_DPLL3_SPARE_SET(x)                                           (((x) << CPU_DPLL3_SPARE_LSB) & CPU_DPLL3_SPARE_MASK)
+#define CPU_DPLL3_SPARE_RESET                                            0x0 // 0
+#define CPU_DPLL3_ADDRESS                                                0x181161c8
+
+/*
+ * Range:
+ *	0: frequency range of (530 ~ 830 MHz)/2^outdiv
+ *	1: frequency range of (350 ~ 750 MHz)/2^outdiv
+ */
+
+#if (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+#	define CPU_DPLL_40		CPU_DPLL_REFDIV_SET(0x8) | CPU_DPLL_NINT_SET(160)
+#	define CPU_DPLL_25		CPU_DPLL_REFDIV_SET(0x5) | CPU_DPLL_NINT_SET(160)
+#	define __CPU_DPLL2_VAL		CPU_DPLL2_RANGE_SET(0) | \
+					CPU_DPLL2_KI_SET(0x4) | \
+					CPU_DPLL2_KD_SET(0x10) | \
+					CPU_DPLL2_OUTDIV_SET(1) | \
+					CPU_DPLL2_DELTA_SET(0x1e)
+
+#	define DDR_DPLL_40		DDR_DPLL_REFDIV_SET(0x8) | DDR_DPLL_NINT_SET(160)
+#	define DDR_DPLL_25		DDR_DPLL_REFDIV_SET(0x5) | DDR_DPLL_NINT_SET(160)
+#	define __DDR_DPLL2_VAL		DDR_DPLL2_RANGE_SET(0) | \
+					DDR_DPLL2_KI_SET(0x4) | \
+					DDR_DPLL2_KD_SET(0x10) | \
+					DDR_DPLL2_OUTDIV_SET(1) | \
+					DDR_DPLL2_DELTA_SET(0x1e)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_535_400_200)
+#	define CPU_DPLL_40		CPU_DPLL_REFDIV_SET(0x8) | CPU_DPLL_NINT_SET(107)
+#	define CPU_DPLL_25		CPU_DPLL_REFDIV_SET(0x5) | CPU_DPLL_NINT_SET(107)
+#	define __CPU_DPLL2_VAL		CPU_DPLL2_RANGE_SET(1) | \
+					CPU_DPLL2_KI_SET(0x4) | \
+					CPU_DPLL2_KD_SET(0x10) | \
+					CPU_DPLL2_OUTDIV_SET(0) | \
+					CPU_DPLL2_DELTA_SET(0x1e)
+
+#	define DDR_DPLL_40		DDR_DPLL_REFDIV_SET(0x8) | DDR_DPLL_NINT_SET(160)
+#	define DDR_DPLL_25		DDR_DPLL_REFDIV_SET(0x5) | DDR_DPLL_NINT_SET(160)
+#	define __DDR_DPLL2_VAL		DDR_DPLL2_RANGE_SET(0) | \
+					DDR_DPLL2_KI_SET(0x4) | \
+					DDR_DPLL2_KD_SET(0x10) | \
+					DDR_DPLL2_OUTDIV_SET(1) | \
+					DDR_DPLL2_DELTA_SET(0x1e)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#	define CPU_DPLL_40		CPU_DPLL_REFDIV_SET(0x8) | CPU_DPLL_NINT_SET(112)
+#	define CPU_DPLL_25		CPU_DPLL_REFDIV_SET(0x5) | CPU_DPLL_NINT_SET(112)
+
+#	define __CPU_DPLL2_VAL		CPU_DPLL2_RANGE_SET(1) | \
+					CPU_DPLL2_KI_SET(0x4) | \
+					CPU_DPLL2_KD_SET(0x10) | \
+					CPU_DPLL2_OUTDIV_SET(0) | \
+					CPU_DPLL2_DELTA_SET(0x1e)
+
+#	define DDR_DPLL_40		DDR_DPLL_REFDIV_SET(0x8) | DDR_DPLL_NINT_SET(96)
+#	define DDR_DPLL_25		DDR_DPLL_REFDIV_SET(0x5) | DDR_DPLL_NINT_SET(96)
+#	define __DDR_DPLL2_VAL		DDR_DPLL2_RANGE_SET(1) | \
+					DDR_DPLL2_KI_SET(0x4) | \
+					DDR_DPLL2_KD_SET(0x10) | \
+					DDR_DPLL2_OUTDIV_SET(0) | \
+					DDR_DPLL2_DELTA_SET(0x1e)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_480_240)
+#	define CPU_DPLL_40		CPU_DPLL_REFDIV_SET(0x8) | CPU_DPLL_NINT_SET(160)
+#	define CPU_DPLL_25		CPU_DPLL_REFDIV_SET(0x5) | CPU_DPLL_NINT_SET(160)
+
+#	define __CPU_DPLL2_VAL		CPU_DPLL2_RANGE_SET(0) | \
+					CPU_DPLL2_KI_SET(0x4) | \
+					CPU_DPLL2_KD_SET(0x10) | \
+					CPU_DPLL2_OUTDIV_SET(1) | \
+					CPU_DPLL2_DELTA_SET(0x1e)
+
+#	define DDR_DPLL_40		DDR_DPLL_REFDIV_SET(0x8) | DDR_DPLL_NINT_SET(96)
+#	define DDR_DPLL_25		DDR_DPLL_REFDIV_SET(0x5) | DDR_DPLL_NINT_SET(96)
+#	define __DDR_DPLL2_VAL		DDR_DPLL2_RANGE_SET(1) | \
+					DDR_DPLL2_KI_SET(0x4) | \
+					DDR_DPLL2_KD_SET(0x10) | \
+					DDR_DPLL2_OUTDIV_SET(0) | \
+					DDR_DPLL2_DELTA_SET(0x1e)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_450_240)
+#	define CPU_DPLL_40		CPU_DPLL_REFDIV_SET(0x8) | CPU_DPLL_NINT_SET(160)
+#	define CPU_DPLL_25		CPU_DPLL_REFDIV_SET(0x5) | CPU_DPLL_NINT_SET(160)
+
+#	define __CPU_DPLL2_VAL		CPU_DPLL2_RANGE_SET(0) | \
+					CPU_DPLL2_KI_SET(0x4) | \
+					CPU_DPLL2_KD_SET(0x10) | \
+					CPU_DPLL2_OUTDIV_SET(1) | \
+					CPU_DPLL2_DELTA_SET(0x1e)
+
+#	define DDR_DPLL_40		DDR_DPLL_REFDIV_SET(0x8) | DDR_DPLL_NINT_SET(90)
+#	define DDR_DPLL_25		DDR_DPLL_REFDIV_SET(0x5) | DDR_DPLL_NINT_SET(90)
+#	define __DDR_DPLL2_VAL		DDR_DPLL2_RANGE_SET(1) | \
+					DDR_DPLL2_KI_SET(0x4) | \
+					DDR_DPLL2_KD_SET(0x10) | \
+					DDR_DPLL2_OUTDIV_SET(0) | \
+					DDR_DPLL2_DELTA_SET(0x1e)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_560_450_225)
+#	define CPU_DPLL_40		CPU_DPLL_REFDIV_SET(0x8) | CPU_DPLL_NINT_SET(112)
+#	define CPU_DPLL_25		CPU_DPLL_REFDIV_SET(0x5) | CPU_DPLL_NINT_SET(112)
+#	define __CPU_DPLL2_VAL		CPU_DPLL2_RANGE_SET(1) | \
+					CPU_DPLL2_KI_SET(0x4) | \
+					CPU_DPLL2_KD_SET(0x10) | \
+					CPU_DPLL2_OUTDIV_SET(0) | \
+					CPU_DPLL2_DELTA_SET(0x1e)
+
+#	define DDR_DPLL_40		DDR_DPLL_REFDIV_SET(0x8) | DDR_DPLL_NINT_SET(90)
+#	define DDR_DPLL_25		DDR_DPLL_REFDIV_SET(0x5) | DDR_DPLL_NINT_SET(90)
+#	define __DDR_DPLL2_VAL		DDR_DPLL2_RANGE_SET(1) | \
+					DDR_DPLL2_KI_SET(0x4) | \
+					DDR_DPLL2_KD_SET(0x10) | \
+					DDR_DPLL2_OUTDIV_SET(0) | \
+					DDR_DPLL2_DELTA_SET(0x1e)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_560_400_200)
+#	define CPU_DPLL_40		CPU_DPLL_REFDIV_SET(0x8) | CPU_DPLL_NINT_SET(112)
+#	define CPU_DPLL_25		CPU_DPLL_REFDIV_SET(0x5) | CPU_DPLL_NINT_SET(112)
+#	define __CPU_DPLL2_VAL		CPU_DPLL2_RANGE_SET(1) | \
+					CPU_DPLL2_KI_SET(0x4) | \
+					CPU_DPLL2_KD_SET(0x10) | \
+					CPU_DPLL2_OUTDIV_SET(0) | \
+					CPU_DPLL2_DELTA_SET(0x1e)
+
+#	define DDR_DPLL_40		DDR_DPLL_REFDIV_SET(0x8) | DDR_DPLL_NINT_SET(160)
+#	define DDR_DPLL_25		DDR_DPLL_REFDIV_SET(0x5) | DDR_DPLL_NINT_SET(160)
+#	define __DDR_DPLL2_VAL		DDR_DPLL2_RANGE_SET(0) | \
+					DDR_DPLL2_KI_SET(0x4) | \
+					DDR_DPLL2_KD_SET(0x10) | \
+					DDR_DPLL2_OUTDIV_SET(1) | \
+					DDR_DPLL2_DELTA_SET(0x1e)
+#endif
+
+#define CPU_DPLL2_INIT			__CPU_DPLL2_VAL | CPU_DPLL2_PLL_PWD_SET(1)
+#define CPU_DPLL2_VAL			__CPU_DPLL2_VAL | CPU_DPLL2_LOCAL_PLL_SET(1)
+#define CPU_DPLL2_VAL_PWD		CPU_DPLL2_VAL | CPU_DPLL2_PLL_PWD_SET(1)
+
+#define DDR_DPLL2_INIT			__DDR_DPLL2_VAL | DDR_DPLL2_PLL_PWD_SET(1)
+#define DDR_DPLL2_VAL			__DDR_DPLL2_VAL | DDR_DPLL2_LOCAL_PLL_SET(1)
+#define DDR_DPLL2_VAL_PWD		DDR_DPLL2_VAL | DDR_DPLL2_PLL_PWD_SET(1)
+
+#endif /* _AR934X_SOC_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/asm-mips/addrspace.h u-boot_1.1//include/asm-mips/addrspace.h
--- u-boot//include/asm-mips/addrspace.h	2014-02-18 01:46:23.179049784 -0800
+++ u-boot_1.1//include/asm-mips/addrspace.h	2014-02-18 01:46:27.971053129 -0800
@@ -5,6 +5,7 @@
  *
  * Copyright (C) 1996 by Ralf Baechle
  * Copyright (C) 2000 by Maciej W. Rozycki
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
  *
  * Defitions for the address spaces of the MIPS CPUs.
  */
@@ -48,7 +49,9 @@
 /* We use a 36 bit physical address map here and
    cannot access physical memory directly from core */
 #define UNCACHED_SDRAM(a) (((unsigned long)(a)) | 0x20000000)
-#else	/* !CONFIG_AU1X00 */
+#elif defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+#define UNCACHED_SDRAM(a)   KSEG1ADDR((a))
+#else	/* !CONFIG_AR7100 */
 #define UNCACHED_SDRAM(a) PHYSADDR(a)
 #endif	/* CONFIG_AU1X00 */
 #endif	/* __ASSEMBLY__ */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/asm-mips/bitops.h u-boot_1.1//include/asm-mips/bitops.h
--- u-boot//include/asm-mips/bitops.h	2014-02-18 01:46:23.183049787 -0800
+++ u-boot_1.1//include/asm-mips/bitops.h	2014-02-18 01:46:27.991053140 -0800
@@ -5,6 +5,7 @@
  *
  * Copyright (c) 1994 - 1997, 1999, 2000  Ralf Baechle (ralf@gnu.org)
  * Copyright (c) 2000  Silicon Graphics, Inc.
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
  */
 #ifndef _ASM_BITOPS_H
 #define _ASM_BITOPS_H
@@ -794,7 +795,7 @@
 #endif /* (__MIPSEB__) */
 
 /* Now for the ext2 filesystem bit operations and helper routines. */
-
+#if (CONFIG_COMMANDS & CFG_CMD_EXT2)
 #ifdef __MIPSEB__
 extern __inline__ int ext2_set_bit(int nr, void * addr)
 {
@@ -908,5 +909,6 @@
 #define minix_test_and_clear_bit(nr,addr) test_and_clear_bit(nr,addr)
 #define minix_test_bit(nr,addr) test_bit(nr,addr)
 #define minix_find_first_zero_bit(addr,size) find_first_zero_bit(addr,size)
+#endif /* (CONFIG_COMMANDS & CFG_CMD_EXT2) */
 
 #endif /* _ASM_BITOPS_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/atheros.h u-boot_1.1//include/atheros.h
--- u-boot//include/atheros.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/atheros.h	2014-02-18 01:46:28.127053237 -0800
@@ -0,0 +1,364 @@
+/*
+ * vim: tabstop=8 : noexpandtab
+ */
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _ATHEROS_H
+#define _ATHEROS_H
+
+/*
+ * Set everything to zero. The corresponding header will
+ * undef and re-define the appropriate ones
+ */
+#define is_ar7100()	(0)
+
+#define is_ar7240()	(0)
+#define is_ar7241()	(0)
+#define is_ar7242()	(0)
+
+#define is_ar9330()	(0)
+#define is_ar933x()	(0)
+#define is_hornet()	(0)
+
+#define is_ar934x()	(0)
+#define is_wasp()	(0)
+
+#define is_qca955x()	(0)
+#define is_sco()	(0)
+
+#define is_qca953x()	(0)
+#define is_hb()		(0)
+
+#define is_qca956x()	(0)
+
+#define ATH_CONSOLE_BAUD	115200
+
+#define AR7240_REV_1_2		0xc2
+
+#ifdef CONFIG_ATH_EMULATION
+#define is_emu()	(1)
+#else
+#define is_emu()	(0)
+#endif
+
+#ifdef CONFIG_F1E_PHY
+#define is_f1e()	1
+#else
+#define is_f1e()	0
+#endif
+#ifdef CONFIG_F2E_PHY
+#define is_f2e()	1
+#else
+#define is_f2e()	0
+#endif
+#ifdef CONFIG_ATHRS16_PHY
+#define is_s16()	1
+#else
+#define is_s16()	0
+#endif
+
+#ifdef CONFIG_ATHRS17_PHY
+#define is_s17()        1
+#else
+#define is_s17()        0
+#endif
+
+#ifdef CONFIG_ATHR_8033_PHY
+#define is_ar8033() 1
+#else
+#define is_ar8033() 0
+#endif
+
+#ifdef CONFIG_VIR_PHY
+#define is_vir_phy()	1
+#else
+#define is_vir_phy() 	0
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+#define is_s27()        1
+#else
+#define is_s27()        0
+#endif
+
+#define ath_arch_init_irq() /* nothing */
+
+#ifndef __ASSEMBLY__
+
+int ath_uart_freq(void);
+
+typedef unsigned int ath_reg_t;
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+#endif /* __ASSEMBLY__ */
+
+#define ath_reg_rd(_phys)	(*(volatile ath_reg_t *)KSEG1ADDR(_phys))
+
+#define ath_reg_wr_nf(_phys, _val) \
+	((*(volatile ath_reg_t *)KSEG1ADDR(_phys)) = (_val))
+
+#define ath_reg_wr(_phys, _val) do {	\
+	ath_reg_wr_nf(_phys, _val);	\
+	ath_reg_rd(_phys);		\
+} while(0)
+
+#define ath_reg_rmw_set(_reg, _mask)	do {			\
+	ath_reg_wr((_reg), (ath_reg_rd((_reg)) | (_mask)));	\
+	ath_reg_rd((_reg));					\
+} while(0)
+
+#define ath_reg_rmw_clear(_reg, _mask) do {			\
+	ath_reg_wr((_reg), (ath_reg_rd((_reg)) & ~(_mask)));	\
+	ath_reg_rd((_reg));					\
+} while(0)
+
+#define ath_uart_rd(y)		ath_reg_rd((ATH_UART_BASE+y))
+#define ath_uart_wr(x, z)	ath_reg_wr((ATH_UART_BASE+x), z)
+
+#define REG_OFFSET		4
+
+#define OFS_RCV_BUFFER		(0 * REG_OFFSET)
+#define OFS_TRANS_HOLD		(0 * REG_OFFSET)
+#define OFS_SEND_BUFFER		(0 * REG_OFFSET)
+#define OFS_INTR_ENABLE		(1 * REG_OFFSET)
+#define OFS_INTR_ID		(2 * REG_OFFSET)
+#define OFS_DATA_FORMAT		(3 * REG_OFFSET)
+#define OFS_LINE_CONTROL	(3 * REG_OFFSET)
+#define OFS_MODEM_CONTROL	(4 * REG_OFFSET)
+#define OFS_RS232_OUTPUT	(4 * REG_OFFSET)
+#define OFS_LINE_STATUS		(5 * REG_OFFSET)
+#define OFS_MODEM_STATUS	(6 * REG_OFFSET)
+#define OFS_RS232_INPUT		(6 * REG_OFFSET)
+#define OFS_SCRATCH_PAD		(7 * REG_OFFSET)
+
+#define OFS_DIVISOR_LSB		(0 * REG_OFFSET)
+#define OFS_DIVISOR_MSB		(1 * REG_OFFSET)
+
+/*
+ * PLL Config for different CPU/DDR/AHB frequencies
+ */
+#define CFG_PLL_720_600_200	0x01
+#define CFG_PLL_720_680_240	0x02
+#define CFG_PLL_720_600_240	0x03
+#define CFG_PLL_680_680_226	0x04
+#define CFG_PLL_720_600_300	0x05
+#define CFG_PLL_400_400_200	0x06
+#define CFG_PLL_560_450_220	0x07
+#define CFG_PLL_550_400_200	0x08
+#define CFG_PLL_550_600_200	0x09
+#define CFG_PLL_600_600_200	0x0a
+#define CFG_PLL_750_400_250	0x0b
+#define CFG_PLL_800_400_266	0x0c
+#define CFG_PLL_750_667_250	0x0d
+#define CFG_PLL_800_600_266	0x0e
+#define CFG_PLL_800_667_266	0x0f
+#define CFG_PLL_810_700_270	0x10
+#define CFG_PLL_810_666_270	0x11
+#define CFG_PLL_775_650_258	0x12
+
+#define UBOOT_SIZE                      (256 * 1024)
+#define PLL_FLASH_ADDR                  (CFG_FLASH_BASE + UBOOT_SIZE)
+#define PLL_CONFIG_VAL_F                (PLL_FLASH_ADDR + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define PLL_MAGIC                        0xaabbccdd
+#define SRIF_PLL_CONFIG_VAL_F           (PLL_CONFIG_VAL_F - 12)
+#define SRIF_PLL_MAGIC                  0x73726966 /* srif */
+
+#include <config.h>
+
+#if defined(CONFIG_MACH_AR724x)
+#	include <724x.h>
+#elif defined(CONFIG_MACH_AR933x)
+#	include <933x.h>
+#elif defined(CONFIG_MACH_AR934x)
+#	include <934x.h>
+#elif defined(CONFIG_MACH_QCA955x)
+#	include <955x.h>
+#elif defined(CONFIG_MACH_QCA953x)
+#	include <953x.h>
+#elif defined(CONFIG_MACH_QCA956x)
+#	include <956x.h>
+#else
+#	error "Building U-Boot for unknown device"
+#endif
+
+#ifndef __ASSEMBLY__
+
+#define ATH_MEM_SDRAM		1
+#define ATH_MEM_DDR1		2
+#define ATH_MEM_DDR2		3
+/*
+ * GPIO Access & Control
+ */
+void ath_gpio_init(void);
+void ath_gpio_down(void);
+void ath_gpio_up(void);
+
+void ath_gpio_irq_init(int);
+/*
+ * GPIO Helper Functions
+ */
+void ath_gpio_enable_slic(void);
+
+/* enable UART block, takes away GPIO 10 and 9 */
+void ath_gpio_enable_uart(void);
+
+/* enable STEREO block, takes away GPIO 11,8,7, and 6 */
+void ath_gpio_enable_stereo(void);
+
+/* allow CS0/CS1 to be controlled via SPI register, takes away GPIO0/GPIO1 */
+void ath_gpio_enable_spi_cs1_cs0(void);
+
+/* allow GPIO0/GPIO1 to be used as SCL/SDA for software based i2c */
+void ath_gpio_enable_i2c_on_gpio_0_1(void);
+
+/*
+ * GPIO General Functions
+ */
+void ath_gpio_drive_low(unsigned int mask);
+void ath_gpio_drive_high(unsigned int mask);
+
+unsigned int ath_gpio_float_high_test(unsigned int mask);
+
+/* Functions to access SPI through software. Example:
+ *
+ * ath_spi_down(); ---------------------- disable others from accessing SPI bus taking semaphore
+ * ath_spi_enable_soft_access(); -------- disable HW control of SPI
+ *
+ * <board specific chip select routine>
+ *
+ * <read/write SPI using using custom routine or general purposeflash routines
+ * Custom routine may use:
+ *
+ *	ath_spi_raw_output_u8(unsigned char)
+ *	ath_spi_raw_output_u32(unsigned int)
+ *	ath_spi_raw_input_u32()
+ *
+ * General purpose flash routines:
+ *	ath_spi_flash_read_page(unsigned int addr, unsigned char *data, int len);
+ *	ath_spi_flash_write_page(unsigned int addr, unsigned char *data, int len);
+ *	ath_spi_flash_sector_erase(unsigned int addr);
+ * >
+ *
+ * <board specific chip deselect routine>
+ *
+ * ath_spi_disable_soft_acess(); ------- enable HW control of SPI bus
+ * ath_spi_up(); ----------------------- enable others to access SPI bus releasing semaphore
+ */
+void ath_spi_init(void);
+void ath_spi_down(void);
+void ath_spi_up(void);
+
+static inline void
+ath_spi_enable_soft_access(void)
+{
+	ath_reg_wr_nf(ATH_SPI_FS, 1);
+}
+
+static inline void
+ath_spi_disable_soft_access(void)
+{
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_DIS);
+	ath_reg_wr_nf(ATH_SPI_FS, 0);
+}
+
+void ath_spi_raw_output_u8(unsigned char val);
+void ath_spi_raw_output_u32(unsigned int val);
+unsigned int ath_spi_raw_input_u8(void);
+unsigned int ath_spi_raw_input_u32(void);
+
+void ath_spi_flash_read_page(unsigned int addr, unsigned char *data, int len);
+void ath_spi_flash_write_page(unsigned int addr, unsigned char *data, int len);
+void ath_spi_flash_sector_erase(unsigned int addr);
+
+/*
+ * Allow access to cs0-2 when GPIO Function enables cs0-2 through SPI register.
+ */
+static inline void
+ath_spi_enable_cs0(void)
+{
+	unsigned int cs;
+	ath_spi_down();
+	ath_spi_enable_soft_access();
+	cs = ath_reg_rd(ATH_SPI_WRITE) & ~ATH_SPI_CS_DIS;
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_ENABLE_0 | cs);
+}
+
+static inline void
+ath_spi_enable_cs1(void)
+{
+	unsigned int cs;
+#if defined(CONFIG_MACH_AR934x)	|| \
+    defined(CONFIG_MACH_QCA955x)
+	ath_spi_down();
+	ath_spi_init();
+	ath_spi_enable_soft_access();
+	cs = ath_reg_rd(ATH_SPI_WRITE) & ATH_SPI_CS_DIS;
+	ath_reg_wr_nf(ATH_SPI_WRITE, cs | ATH_SPI_CLK_HIGH);
+	cs = ath_reg_rd(ATH_SPI_WRITE) & ~ATH_SPI_CS_DIS;
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_ENABLE_1 | cs | ATH_SPI_CLK_HIGH);
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_ENABLE_1 | cs);
+#else
+	ath_spi_down();
+	ath_spi_enable_soft_access();
+	cs = ath_reg_rd(ATH_SPI_WRITE) & ~ATH_SPI_CS_DIS;
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_ENABLE_1 | cs);
+#endif
+}
+
+static inline void
+ath_spi_disable_cs(void)
+{
+	unsigned int cs = ath_reg_rd(ATH_SPI_WRITE) | ATH_SPI_CS_DIS;
+	ath_reg_wr_nf(ATH_SPI_WRITE, cs);
+	ath_spi_disable_soft_access();
+	ath_spi_up();
+}
+
+/*
+ * Example usage to access BOOT flash
+ */
+static inline void
+ath_spi_flash_cs0_sector_erase(unsigned int addr)
+{
+	ath_spi_enable_cs0();
+	ath_spi_flash_sector_erase(addr);
+	ath_spi_disable_cs();
+}
+
+static inline void
+ath_spi_flash_cs0_write_page(unsigned int addr, unsigned char *data, int len)
+{
+	ath_spi_enable_cs0();
+	ath_spi_flash_write_page(addr, data, len);
+	ath_spi_disable_cs();
+}
+
+#endif /* __ASSEMBLY__ */
+
+
+#endif /* _ATHEROS_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/athversion.h u-boot_1.1//include/athversion.h
--- u-boot//include/athversion.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/athversion.h	2014-02-18 01:46:28.127053237 -0800
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ATHVERSION_H_
+#define __ATHVERSION_H_
+
+#define ATH_AP83_UBOOT_VERSION "0.0.12"
+#define ATH_PB45_UBOOT_VERSION "0.0.1"
+#define ATH_AP96_UBOOT_VERSION "0.0.1"
+
+#endif /* __ATHVERSION_H_ */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/bmp_logo.h u-boot_1.1//include/bmp_logo.h
--- u-boot//include/bmp_logo.h	2014-02-18 01:46:23.231049820 -0800
+++ u-boot_1.1//include/bmp_logo.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,1948 +0,0 @@
-/*
- * Automatically generated by "tools/bmp_logo"
- *
- * DO NOT EDIT
- *
- */
-
-
-#ifndef __BMP_LOGO_H__
-#define __BMP_LOGO_H__
-
-#define BMP_LOGO_WIDTH		160
-#define BMP_LOGO_HEIGHT		96
-#define BMP_LOGO_COLORS		31
-#define BMP_LOGO_OFFSET		16
-
-unsigned short bmp_logo_palette[] = {
-	0x0343,  0x0454,  0x0565,  0x0565,  0x0676,  0x0787,  0x0898,  0x0999,
-	0x0AAA,  0x0ABA,  0x0BCB,  0x0CCC,  0x0DDD,  0x0EEE,  0x0FFF,  0x0FB3,
-	0x0FB4,  0x0FC4,  0x0FC5,  0x0FC6,  0x0FD7,  0x0FD8,  0x0FD9,  0x0FDA,
-	0x0FEA,  0x0FEB,  0x0FEC,  0x0FFD,  0x0FFE,  0x0FFF,  0x0FFF,
-};
-
-unsigned char bmp_logo_bitmap[] = {
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1B,
-	0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x1B, 0x11, 0x10, 0x10, 0x10, 0x10,
-	0x14, 0x1E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x1B, 0x14, 0x10, 0x10, 0x10, 0x10, 0x10, 0x17,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x1B, 0x14, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x14, 0x1C, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x22, 0x2A, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x29, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x14,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x18, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x18, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x12, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x19,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x18, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x2D, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x28, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x1C, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x19, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x12, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x1B, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x18,
-	0x2E, 0x2E, 0x2E, 0x16, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x18, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x16, 0x2E, 0x17, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x19, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x2B, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2D, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x16, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x28, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x20, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x22, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x22, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x14, 0x17, 0x15, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x17, 0x1B, 0x2E, 0x1A, 0x14, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x17, 0x1B, 0x2E, 0x1B,
-	0x14, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1B, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2D, 0x29,
-	0x23, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x23, 0x2A,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x14, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x14, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x1B, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x15, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x17, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x12, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x19, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2B, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x24, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x12, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x14, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x1B, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x1E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x1A, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1C, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x16, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x11, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x11, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1E, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x1E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x1A, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2B, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x28, 0x2E, 0x2A, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x29, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x1E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x19, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x1E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x21, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x12, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x17,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x1D, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x17,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x14, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x1B, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x2A, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x14, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x17,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x1B, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x1B, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x23, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x17, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x17,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x20, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x22, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x18, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x17,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x23, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x17, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x17,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x23, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x17,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x2A, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x17,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x1E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x21, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x2D, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x1E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x12, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x1D, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x18, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x1D, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x22, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x20, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x16, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2D, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x1D, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x1C, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x1C, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x1E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x16, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x1E, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x17, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x16, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2D, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x21, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x24, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x1D, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x14, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x18,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x15, 0x2E, 0x2E, 0x2E, 0x19,
-	0x12, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x1E, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x1B, 0x2E, 0x2E, 0x1B, 0x16, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x19, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2D, 0x26,
-	0x22, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x22, 0x27,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x13, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x16, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x19, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x2D, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2D, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x12, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x1C, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x2A, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x20, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x13, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x2C, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2D, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x1C, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1C,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x11, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x12, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x1F, 0x2A, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2B, 0x1F, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x13, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1B,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x1D, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x12, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x20,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1A, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x11, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x15, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x1F,
-	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x2D, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x29, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x17, 0x14, 0x10, 0x11, 0x14,
-	0x1A, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x1B, 0x17, 0x17, 0x1A, 0x1B, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2B, 0x26,
-	0x2A, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2A, 0x26,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x17, 0x1B, 0x1B, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x16, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x17, 0x10,
-	0x1E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x12, 0x10, 0x10, 0x14, 0x14, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x16,
-	0x10, 0x10, 0x14, 0x14, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x12, 0x10, 0x1B, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x17, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x13, 0x14, 0x13, 0x10, 0x10, 0x1C, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1B, 0x10, 0x2E,
-	0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x18, 0x10, 0x10, 0x17, 0x14, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x16, 0x10,
-	0x16, 0x2E, 0x2E, 0x2E, 0x2E, 0x16, 0x10, 0x11,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x19, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1B, 0x10, 0x10,
-	0x1D, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x12,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x10, 0x10, 0x19, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x15,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x1B, 0x10, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1B, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x15, 0x10, 0x10, 0x10,
-	0x1D, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x1B,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x14, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x10,
-	0x19, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x10,
-	0x1B, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1E,
-	0x10, 0x10, 0x10, 0x17, 0x17, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1B, 0x10, 0x1B,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x16, 0x10, 0x1E, 0x12, 0x10,
-	0x2E, 0x2E, 0x2E, 0x18, 0x10, 0x2E, 0x17, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x16, 0x10,
-	0x1C, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1B, 0x10, 0x1B,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x15, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x17,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x14, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1B, 0x10, 0x1B,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x14,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10, 0x11, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x17, 0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x13, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x17, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x17,
-	0x10, 0x10, 0x10, 0x18, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1B, 0x10, 0x1B,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x17, 0x10, 0x10, 0x10, 0x10, 0x10, 0x19,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x17, 0x17, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x17, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x13, 0x10, 0x1A, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x1E, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x19, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x19, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1C, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x16, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x15, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x17, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x17, 0x10, 0x2E, 0x17,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x1E, 0x10, 0x12, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x12,
-	0x11, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x1C, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1A, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x17, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x17, 0x10, 0x10, 0x1C,
-	0x2E, 0x2E, 0x2E, 0x1B, 0x10, 0x16, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x16, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x17, 0x10, 0x1A, 0x2E,
-	0x2E, 0x1D, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x14, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x1E, 0x10, 0x19, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x1A, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x13,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x17, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x17, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x17, 0x10, 0x13, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x17, 0x10, 0x1C, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x14, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x11, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x14,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x17, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x17, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x17, 0x10, 0x18,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x1D, 0x10, 0x15, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x14, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x19, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x17, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x17, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x17, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x14, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x19, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x14, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10,
-	0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1A, 0x10,
-	0x14, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x17, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x17, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x1B, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x1C, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x14, 0x10, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x1A, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x1C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x13, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x13, 0x10, 0x10, 0x10, 0x10, 0x10, 0x16, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x17, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x17, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x13, 0x10,
-	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x1E, 0x10, 0x16, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x1A, 0x10, 0x19, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x11, 0x10, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x10, 0x10, 0x10, 0x11, 0x14,
-	0x10, 0x10, 0x10, 0x17, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
-	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x16, 0x10, 0x10,
-	0x10, 0x14, 0x13, 0x10, 0x10, 0x10, 0x2E, 0x2E,
-
-};
-
-#endif /* __BMP_LOGO_H__ */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/cmd_confdefs.h u-boot_1.1//include/cmd_confdefs.h
--- u-boot//include/cmd_confdefs.h	2014-02-18 01:46:23.231049820 -0800
+++ u-boot_1.1//include/cmd_confdefs.h	2014-02-18 01:46:28.151053255 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2000-2002
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -76,7 +78,8 @@
 #define CFG_CMD_HWFLOW	0x0000020000000000ULL	/* RTS/CTS hw flow control	*/
 #define CFG_CMD_SAVES	0x0000040000000000ULL	/* save S record dump		*/
 #define CFG_CMD_SPI	0x0000100000000000ULL	/* SPI utility			*/
-#define CFG_CMD_FDOS	0x0000200000000000ULL	/* Floppy DOS support		*/
+//#define CFG_CMD_FDOS	0x0000200000000000ULL	/* Floppy DOS support		*/
+#define CFG_CMD_PLL     0x0000200000000000ULL   /* Change CPU clock speeds      */
 #define CFG_CMD_VFD	0x0000400000000000ULL	/* VFD support (TRAB)		*/
 #define CFG_CMD_NAND	0x0000800000000000ULL	/* NAND support			*/
 #define CFG_CMD_BMP	0x0001000000000000ULL	/* BMP support			*/
@@ -94,12 +97,16 @@
 #define CFG_CMD_EXT2	0x1000000000000000ULL	/* EXT2 Support			*/
 #define CFG_CMD_SNTP	0x2000000000000000ULL	/* SNTP support			*/
 #define CFG_CMD_DISPLAY	0x4000000000000000ULL	/* Display support		*/
+#define CFG_CMD_ETHREG	0x8000000000000000ULL	/* S26 Reg RD/WR utility	*/
+
 
 #define CFG_CMD_ALL	0xFFFFFFFFFFFFFFFFULL	/* ALL commands			*/
 
-/* Commands that are considered "non-standard" for some reason
+/* 
+ *  Commands that are considered "non-standard" for some reason
  * (memory hogs, requires special hardware, not fully tested, etc.)
  */
+#ifndef COMPRESSED_UBOOT
 #define CFG_CMD_NONSTD (CFG_CMD_ASKENV	| \
 			CFG_CMD_BEDBUG	| \
 			CFG_CMD_BMP	| \
@@ -117,7 +124,6 @@
 			CFG_CMD_EXT2	| \
 			CFG_CMD_FDC	| \
 			CFG_CMD_FAT	| \
-			CFG_CMD_FDOS	| \
 			CFG_CMD_HWFLOW	| \
 			CFG_CMD_I2C	| \
 			CFG_CMD_IDE	| \
@@ -141,8 +147,70 @@
 			CFG_CMD_SPI	| \
 			CFG_CMD_UNIVERSE | \
 			CFG_CMD_USB	| \
+			CFG_CMD_ETHREG  | \
+			CFG_CMD_PLL     | \
+			CFG_CMD_LOADB	| \
+			CFG_CMD_LOADS	| \
+			CFG_CMD_VFD	)
+#else
+#define CFG_CMD_NONSTD (CFG_CMD_ASKENV	| \
+			CFG_CMD_BEDBUG	| \
+			CFG_CMD_BDI	| \
+			CFG_CMD_BMP	| \
+			CFG_CMD_BSP	| \
+			CFG_CMD_CACHE	| \
+			CFG_CMD_CDP	| \
+			CFG_CMD_CONSOLE	| \
+			CFG_CMD_DATE	| \
+			CFG_CMD_DHCP	| \
+			CFG_CMD_DIAG	| \
+			CFG_CMD_DISPLAY	| \
+			CFG_CMD_DOC	| \
+			CFG_CMD_DTT	| \
+			CFG_CMD_ECHO	| \
+			CFG_CMD_EEPROM	| \
+			CFG_CMD_ELF	| \
+			CFG_CMD_ENV	| \
+			CFG_CMD_EXT2	| \
+			CFG_CMD_FDC	| \
+			CFG_CMD_FAT	| \
+			CFG_CMD_FPGA	| \
+			CFG_CMD_HWFLOW	| \
+			CFG_CMD_I2C	| \
+			CFG_CMD_IDE	| \
+			CFG_CMD_IMI	| \
+			CFG_CMD_IMLS	| \
+			CFG_CMD_IMMAP	| \
+			CFG_CMD_IRQ	| \
+			CFG_CMD_ITEST	| \
+			CFG_CMD_JFFS2	| \
+			CFG_CMD_KGDB	| \
+			CFG_CMD_LOADB	| \
+			CFG_CMD_LOADS	| \
+			CFG_CMD_MISC	| \
+			CFG_CMD_MMC	| \
+			CFG_CMD_NAND	| \
+			CFG_CMD_NFS	| \
+			CFG_CMD_PCI	| \
+			CFG_CMD_PCMCIA	| \
+			CFG_CMD_PING	| \
+			CFG_CMD_PORTIO	| \
+			CFG_CMD_REGINFO	| \
+			CFG_CMD_REISER	| \
+			CFG_CMD_SAVES	| \
+			CFG_CMD_SCSI	| \
+			CFG_CMD_SETGETDCR	|\
+			CFG_CMD_SDRAM	| \
+			CFG_CMD_SNTP	| \
+			CFG_CMD_SPI	| \
+			CFG_CMD_UNIVERSE	 | \
+			CFG_CMD_USB	| \
+			CFG_CMD_XIMG	| \
+			CFG_CMD_ETHREG	| \
+			CFG_CMD_PLL     | \
 			CFG_CMD_VFD	)
 
+#endif
 /* Default configuration
  */
 #define CONFIG_CMD_DFL	(CFG_CMD_ALL & ~CFG_CMD_NONSTD)
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/common.h u-boot_1.1//include/common.h
--- u-boot//include/common.h	2014-02-18 01:46:23.231049820 -0800
+++ u-boot_1.1//include/common.h	2014-02-18 01:46:28.151053255 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2000-2004
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -187,7 +189,11 @@
 /* lib_$(ARCH)/board.c */
 void	board_init_f  (ulong);
 void	board_init_r  (gd_t *, ulong);
+#ifdef COMPRESSED_UBOOT
+int	checkboard    (char *);
+#else
 int	checkboard    (void);
+#endif
 int	checkflash    (void);
 int	checkdram     (void);
 char *	strmhz(char *buf, long hz);
@@ -230,7 +236,11 @@
 #endif
 
 void	pci_init      (void);
+#ifdef  COMPRESSED_UBOOT
+int	pci_init_board(void);
+#else
 void	pci_init_board(void);
+#endif /* #ifdef COMPRESSED_UBOOT */
 void	pciinfo	      (int, int);
 
 #if defined(CONFIG_PCI) && defined(CONFIG_440)
@@ -356,6 +366,7 @@
 void	dcache_enable (void);
 void	dcache_disable(void);
 void	relocate_code (ulong, gd_t *, ulong);
+void 	ar7240_ddr_tap_init(void);
 ulong	get_endaddr   (void);
 void	trap_init     (ulong);
 #if defined (CONFIG_4xx)	|| \
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/ap120.h u-boot_1.1//include/configs/ap120.h
--- u-boot//include/configs/ap120.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/ap120.h	2014-02-18 01:46:28.595053563 -0800
@@ -0,0 +1,498 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE		16
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if CONFIG_MI124
+#define BC "bc=mi124_f1e\0"
+#endif
+#if CONFIG_AP123
+#define BC "bc=ap123\0"
+#endif
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else	//dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, u-boot.bin)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		db12x${bc}-nand-jffs2
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#elif defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#	ifdef COMPRESSED_UBOOT
+#		define ATH_U_FILE	tuboot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f010000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+		/*
+		 * For compressed uboot, environment sector is not used.
+		 * Hence the mtd partition indices get reduced by 1.
+		 * This conflicts with
+		 *	- minor no. for /dev/caldata in
+		 *		build/scripts/{board}/dev.txt
+		 *	- root=<rooot dev> kernel cmdline parameter
+		 * Hence, doing a dummy split of the u-boot partition
+		 * to maintain the same minor no. as in the normal u-boot.
+		 */
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	else /* COMPRESSED_UBOOT */
+#		define ATH_U_FILE	u-boot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f050000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	endif /* COMPRESSED_UBOOT */
+#elif defined(CONFIG_DB12X_P2P)
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x-p2p${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		ap120-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#if (FLASH_SIZE == 16) 
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k@0xff0000(ART)"
+#else/* 8M */
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif /*CONFIG_MI124*/
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef CONFIG_ATH_NAND_SUPPORT
+#	define CFG_ENV_ADDR		0x9f040000
+#	if (FLASH_SIZE == 16)
+#		define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#	else  /* FLASH_SIZE == 16 */
+#		ifdef COMPRESSED_UBOOT
+#			if (FLASH_SIZE == 4)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else  /* FLASH_SIZE == 4 */
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#			endif  /* FLASH_SIZE == 4 */
+#		else /* COMPRESSED_UBOOT */
+#			if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#			endif
+#		endif  /* COMPRESSED_UBOOT */
+#	endif  /* FLASH_SIZE == 16 */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#define ATH_CFG_COMMANDS	(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define BOARDCAL                         (CFG_FLASH_BASE + CFG_FLASH_SIZE -0x10000)
+#define WLANCAL                         (BOARDCAL +0x1000)
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/ap121.h u-boot_1.1//include/configs/ap121.h
--- u-boot//include/configs/ap121.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/ap121.h	2014-02-18 01:46:28.595053563 -0800
@@ -0,0 +1,351 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+#include <config.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ *-----------------------------------------------------------------------
+ */
+ 
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+
+#define ENABLE_DYNAMIC_CONF 1
+
+#elif (FLASH_SIZE == 4)
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+
+#define ENABLE_DYNAMIC_CONF 1
+
+#else
+/* For 2 MB flash */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      32     /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00200000 /* Total flash size */
+#endif
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+
+#if (FLASH_SIZE == 16)
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),14528k(rootfs),1408k(uImage),64k(NVRAM),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),14528k(rootfs),1408k(uImage),64k(NVRAM),64k(ART)"
+#elif (FLASH_SIZE == 4)
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),1216k(rootfs),640k(uImage),64k(NVRAM),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),1152k(rootfs),704k(uImage),64k(NVRAM),64k(ART)"
+#endif
+
+#if (BOARD_STRING == 1)
+#undef CONFIG_BOOTARGS
+#undef MTDPARTS_DEFAULT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),3008k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#endif
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_HORNET_EMU
+    #ifdef CONFIG_HORNET_EMU_HARDI_WLAN
+    #define CFG_PLL_FREQ	CFG_PLL_48_48_24
+    #else
+    #define CFG_PLL_FREQ	CFG_PLL_80_80_40
+    #endif
+#else
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+#endif
+
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#define CPU_PLL_DITHER_FRAC_VAL 0x001003e8
+#define CPU_CLK_CONTROL_VAL2 0x00008000
+
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (300000000/2)
+    #if CONFIG_40MHZ_XTAL_SUPPORT
+        #define CPU_PLL_CONFIG_VAL1 0x40813C00
+        #define CPU_PLL_CONFIG_VAL2 0x00813C00    
+    #else
+        #define CPU_PLL_CONFIG_VAL1 0x40816000
+        #define CPU_PLL_CONFIG_VAL2 0x00816000
+    #endif
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#	define CFG_HZ          (350000000/2)
+    #if CONFIG_40MHZ_XTAL_SUPPORT
+        #undef CPU_PLL_DITHER_FRAC_VAL
+        #define CPU_PLL_DITHER_FRAC_VAL 0x001803E8
+        #define CPU_PLL_CONFIG_VAL1 0x40814600
+        #define CPU_PLL_CONFIG_VAL2 0x00814600    
+    #else
+        #define CPU_PLL_CONFIG_VAL1 0x40817000
+        #define CPU_PLL_CONFIG_VAL2 0x00817000
+    #endif
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+    #if CONFIG_40MHZ_XTAL_SUPPORT
+        #define CPU_PLL_CONFIG_VAL1 0x40815000
+        #define CPU_PLL_CONFIG_VAL2 0x00815000    
+    #else
+        #define CPU_PLL_CONFIG_VAL1 0x40818000
+        #define CPU_PLL_CONFIG_VAL2 0x00818000
+    #endif
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#	define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#	define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#	define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_362_362_181)
+#	define CFG_HZ          (326500000/2)
+    #define CPU_PLL_CONFIG_VAL1 0x40817400
+    #define CPU_PLL_CONFIG_VAL2 0x00817400
+#elif (CFG_PLL_FREQ == CFG_PLL_80_80_40)
+#	define CFG_HZ          (80000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_64_64_32)
+#	define CFG_HZ          (64000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_48_48_24)
+#	define CFG_HZ          (48000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_32_32_16)
+#	define CFG_HZ          (32000000/2)
+#endif
+
+#if CONFIG_40MHZ_XTAL_SUPPORT
+    #define CPU_PLL_SETTLE_TIME_VAL    0x00000550
+#else
+    #define CPU_PLL_SETTLE_TIME_VAL    0x00000352
+#endif
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		0x10000
+
+#if (FLASH_SIZE == 16)
+    #define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#elif (FLASH_SIZE == 4)
+    #define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else
+    #ifdef VXWORKS_UBOOT
+       #define CONFIG_BOOTCOMMAND "bootm 0x9f050000"
+    #else
+       #define CONFIG_BOOTCOMMAND "bootm 0x9f140000"
+    #endif
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#if CONFIG_40MHZ_XTAL_SUPPORT
+#define CFG_DDR_REFRESH_VAL     0x4270
+#else
+#define CFG_DDR_REFRESH_VAL     0x4186
+#endif
+#define CFG_DDR_CONFIG_VAL      0x7fbc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#	define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#	define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+//#define CFG_DDR_CONFIG2_VAL	 0x99d0e6a8     // HORNET 1.0
+#define CFG_DDR_CONFIG2_VAL	 0x9dd0e6a8         // HORNET 1.1
+
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+#ifndef CONFIG_HORNET_EMU
+#define CFG_DDR_TAP0_VAL        0x8
+#define CFG_DDR_TAP1_VAL        0x9
+#else
+#define CFG_DDR_TAP0_VAL        0x8
+#define CFG_DDR_TAP1_VAL        0x9
+#endif
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+/* DDR value from Flash */
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#ifndef COMPRESSED_UBOOT
+#	ifndef CONFIG_MACH_HORNET
+#		define CONFIG_PCI 1
+#	endif
+#else
+#	define ATH_NO_PCI_INIT
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV |	\
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_ETHREG ))
+#elif defined(VXWORKS_UBOOT)
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_MII | CFG_CMD_ELF))
+#else
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_MII))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CFG_ATHRS26_PHY  1
+
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+
+#ifdef CONFIG_HORNET_EMU
+#define CFG_AG7240_NMACS 1
+#else
+#define CFG_AG7240_NMACS 2
+#endif
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#if (FLASH_SIZE == 16)
+#define WLANCAL                        0xbfff1000
+#define BOARDCAL                       0xbfff0000
+#elif (FLASH_SIZE == 4)
+#define WLANCAL                        0xbf3f1000
+#define BOARDCAL                       0xbf3f0000
+#else
+#define WLANCAL                        0xbf1f1000
+#define BOARDCAL                       0xbf1f0000
+#endif
+
+#define ATHEROS_PRODUCT_ID             138
+#define CAL_SECTOR                     (CFG_MAX_FLASH_SECT - 1)
+
+/* For Kite, only PCI-e interface is valid */
+#define AR7240_ART_PCICFG_OFFSET        3
+
+
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/ap123.h u-boot_1.1//include/configs/ap123.h
--- u-boot//include/configs/ap123.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/ap123.h	2014-02-18 01:46:28.595053563 -0800
@@ -0,0 +1,496 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE		8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if CONFIG_MI124
+#define BC "bc=mi124_f1e\0"
+#endif
+#if CONFIG_AP123
+#define BC "bc=ap123\0"
+#endif
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else	//dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, u-boot.bin)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		db12x${bc}-nand-jffs2
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#elif defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#	ifdef COMPRESSED_UBOOT
+#		define ATH_U_FILE	tuboot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f010000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+		/*
+		 * For compressed uboot, environment sector is not used.
+		 * Hence the mtd partition indices get reduced by 1.
+		 * This conflicts with
+		 *	- minor no. for /dev/caldata in
+		 *		build/scripts/{board}/dev.txt
+		 *	- root=<rooot dev> kernel cmdline parameter
+		 * Hence, doing a dummy split of the u-boot partition
+		 * to maintain the same minor no. as in the normal u-boot.
+		 */
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	else /* COMPRESSED_UBOOT */
+#		define ATH_U_FILE	u-boot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f050000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	endif /* COMPRESSED_UBOOT */
+#elif defined(CONFIG_DB12X_P2P)
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x-p2p${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=squashfs init=/sbin/init " MTDPARTS_DEFAULT
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef CONFIG_ATH_NAND_SUPPORT
+#	define CFG_ENV_ADDR		0x9f040000
+#	if (FLASH_SIZE == 16)
+#		define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#	else  /* FLASH_SIZE == 16 */
+#		ifdef COMPRESSED_UBOOT
+#			if (FLASH_SIZE == 4)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else  /* FLASH_SIZE == 4 */
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#			endif  /* FLASH_SIZE == 4 */
+#		else /* COMPRESSED_UBOOT */
+#			if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#			endif
+#		endif  /* COMPRESSED_UBOOT */
+#	endif  /* FLASH_SIZE == 16 */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#define ATH_CFG_COMMANDS	(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/aph126.h u-boot_1.1//include/configs/aph126.h
--- u-boot//include/configs/aph126.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/aph126.h	2014-02-18 01:46:28.595053563 -0800
@@ -0,0 +1,443 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the db120 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if !defined(CONFIG_ATH_NAND_BR)
+#define FLASH_SIZE 16
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* Assuming nand flash wouldn't use compressed u-boot */
+#ifdef CONFIG_ATH_NAND_BR
+#	define CFG_FLASH_BASE			0
+#else
+	/*
+	 * We boot from this flash
+	 */
+#	define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        (CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#define CFG_ENV_SIZE        CFG_FLASH_SECTOR_SIZE
+
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),8192k(reserve),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=8M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#if (FLASH_SIZE == 16)
+#define CFG_KERNEL_ADDR 0x9f680000
+#else
+#define CFG_KERNEL_ADDR 0x9f680000
+#endif
+#define CFG_MIB0_ADDR		0x9ffe0000
+
+#define CONFIG_BOOTCOMMAND "bootm ${KERNELADDR}"
+
+#ifndef CFG_LOAD_ADDR
+#define CFG_LOAD_ADDR		0x80060000
+#endif
+#ifndef COMPRESSED_UBOOT
+#define CFG_FS_ADDR			0x9f050000//(CFG_ENV_ADDR+CFG_ENV_SIZE)
+#else
+#define CFG_FS_ADDR			0x9f010000//(CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#endif /* COMPRESSED_UBOOT */
+#define ENV_FS_ADDR			"FSADDR=" MK_STR(CFG_FS_ADDR) "\0"
+
+#define ENV_UBOOT_ADDR		"UBOOTADDR=" MK_STR(CFG_FLASH_BASE) "\0"
+#define ENV_KERNEL_ADDR		"KERNELADDR=" MK_STR(CFG_KERNEL_ADDR) "\0"
+#define ENV_MIB0_ADDR		"MIB0ADDR=" MK_STR(CFG_MIB0_ADDR) "\0"
+
+#define ENV_UPDATE \
+    "update=tftpboot " MK_STR(CFG_LOAD_ADDR) " ${filename} && "	\
+            "erase ${loadaddr} +${filesize} && "				\
+            "cp.b ${fileaddr} ${loadaddr} ${filesize}\0"
+
+#define ENV_UPDATE_KERNEL \
+    "updk=loadaddr=${KERNELADDR} && filename=zImage.uImage && " \
+    "run update\0"
+
+#define ENV_UPDATE_FS \
+    "updfs=loadaddr=${FSADDR} && filename=rootfs-jffs2 && " \
+    "run update\0"
+
+#ifdef COMPRESSED_UBOOT
+#define UBOOT_FILENAME "tuboot.bin"
+#else
+#define UBOOT_FILENAME "u-boot.bin"
+#endif
+
+#define ENV_UPDATE_UBOOT \
+    "updub=loadaddr=${UBOOTADDR} && filename=" UBOOT_FILENAME " && " \
+    "run update\0"
+
+#define ENV_UPDATE_ALL \
+	"updall=run updub && run updfs && run updk\0"
+
+#define ENV_ERASE_MIB0 \
+	"erasemib0=erase ${MIB0ADDR} +0x10000"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		ENV_UBOOT_ADDR \
+		ENV_FS_ADDR \
+		ENV_KERNEL_ADDR \
+		ENV_MIB0_ADDR \
+		ENV_UPDATE \
+		ENV_UPDATE_KERNEL \
+		ENV_UPDATE_FS \
+		ENV_UPDATE_UBOOT \
+		ENV_UPDATE_ALL \
+		ENV_ERASE_MIB0 \
+		""
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET 0xbd007000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+#if 0
+#ifdef CONFIG_ATH_NAND_BR
+#define CONFIG_BOOTCOMMAND "bootm 0x80000"
+#define CFG_ENV_ADDR		0x00040000
+#else  /* CONFIG_ATH_NAND_BR */
+#define CFG_ENV_ADDR		0x9f040000
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else  /* FLASH_SIZE == 16 */
+#ifdef COMPRESSED_UBOOT
+#if (FLASH_SIZE == 4)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else  /* FLASH_SIZE == 4 */
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#endif  /* FLASH_SIZE == 4 */
+#else /* COMPRESSED_UBOOT */
+#if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#endif
+#endif  /* COMPRESSED_UBOOT */
+#endif  /* FLASH_SIZE == 16 */
+#endif  /* CONFIG_ATH_NAND_BR */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/aph128.h u-boot_1.1//include/configs/aph128.h
--- u-boot//include/configs/aph128.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/aph128.h	2014-02-18 01:46:28.651053603 -0800
@@ -0,0 +1,443 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the db120 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if !defined(CONFIG_ATH_NAND_BR)
+#define FLASH_SIZE 16
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* Assuming nand flash wouldn't use compressed u-boot */
+#ifdef CONFIG_ATH_NAND_BR
+#	define CFG_FLASH_BASE			0
+#else
+	/*
+	 * We boot from this flash
+	 */
+#	define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        (CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#define CFG_ENV_SIZE        CFG_FLASH_SECTOR_SIZE
+
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),8192k(reserve),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=8M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#if (FLASH_SIZE == 16)
+#define CFG_KERNEL_ADDR 0x9f680000
+#else
+#define CFG_KERNEL_ADDR 0x9f680000
+#endif
+#define CFG_MIB0_ADDR		0x9ffe0000
+
+#define CONFIG_BOOTCOMMAND "bootm ${KERNELADDR}"
+
+#ifndef CFG_LOAD_ADDR
+#define CFG_LOAD_ADDR		0x80060000
+#endif
+#ifndef COMPRESSED_UBOOT
+#define CFG_FS_ADDR			0x9f050000//(CFG_ENV_ADDR+CFG_ENV_SIZE)
+#else
+#define CFG_FS_ADDR			0x9f010000//(CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#endif /* COMPRESSED_UBOOT */
+#define ENV_FS_ADDR			"FSADDR=" MK_STR(CFG_FS_ADDR) "\0"
+
+#define ENV_UBOOT_ADDR		"UBOOTADDR=" MK_STR(CFG_FLASH_BASE) "\0"
+#define ENV_KERNEL_ADDR		"KERNELADDR=" MK_STR(CFG_KERNEL_ADDR) "\0"
+#define ENV_MIB0_ADDR		"MIB0ADDR=" MK_STR(CFG_MIB0_ADDR) "\0"
+
+#define ENV_UPDATE \
+    "update=tftpboot " MK_STR(CFG_LOAD_ADDR) " ${filename} && "	\
+            "erase ${loadaddr} +${filesize} && "				\
+            "cp.b ${fileaddr} ${loadaddr} ${filesize}\0"
+
+#define ENV_UPDATE_KERNEL \
+    "updk=loadaddr=${KERNELADDR} && filename=zImage.uImage && " \
+    "run update\0"
+
+#define ENV_UPDATE_FS \
+    "updfs=loadaddr=${FSADDR} && filename=rootfs-jffs2 && " \
+    "run update\0"
+
+#ifdef COMPRESSED_UBOOT
+#define UBOOT_FILENAME "tuboot.bin"
+#else
+#define UBOOT_FILENAME "u-boot.bin"
+#endif
+
+#define ENV_UPDATE_UBOOT \
+    "updub=loadaddr=${UBOOTADDR} && filename=" UBOOT_FILENAME " && " \
+    "run update\0"
+
+#define ENV_UPDATE_ALL \
+	"updall=run updub && run updfs && run updk\0"
+
+#define ENV_ERASE_MIB0 \
+	"erasemib0=erase ${MIB0ADDR} +0x10000"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		ENV_UBOOT_ADDR \
+		ENV_FS_ADDR \
+		ENV_KERNEL_ADDR \
+		ENV_MIB0_ADDR \
+		ENV_UPDATE \
+		ENV_UPDATE_KERNEL \
+		ENV_UPDATE_FS \
+		ENV_UPDATE_UBOOT \
+		ENV_UPDATE_ALL \
+		ENV_ERASE_MIB0 \
+		""
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET 0xbd007000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+#if 0
+#ifdef CONFIG_ATH_NAND_BR
+#define CONFIG_BOOTCOMMAND "bootm 0x80000"
+#define CFG_ENV_ADDR		0x00040000
+#else  /* CONFIG_ATH_NAND_BR */
+#define CFG_ENV_ADDR		0x9f040000
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else  /* FLASH_SIZE == 16 */
+#ifdef COMPRESSED_UBOOT
+#if (FLASH_SIZE == 4)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else  /* FLASH_SIZE == 4 */
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#endif  /* FLASH_SIZE == 4 */
+#else /* COMPRESSED_UBOOT */
+#if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#endif
+#endif  /* COMPRESSED_UBOOT */
+#endif  /* FLASH_SIZE == 16 */
+#endif  /* CONFIG_ATH_NAND_BR */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/ar7240_emu.h u-boot_1.1//include/configs/ar7240_emu.h
--- u-boot//include/configs/ar7240_emu.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/ar7240_emu.h	2014-02-18 01:46:28.651053603 -0800
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#define CONFIG_AR7240_EMU 1
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0xbf000000
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS     "console=ttyS0,9600 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_400_400_100
+
+/* Atheros Header configuration */
+
+#define CFG_ATHRS26_PHY  1
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0xbf040000
+#define CFG_ENV_SIZE		0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0xbf550000"
+//#define CONFIG_FLASH_16BIT
+
+#define CONFIG_NR_DRAM_BANKS	2
+#if 0
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#define CFG_DDR_REFRESH_VAL     0x4c00
+#define CFG_DDR_CONFIG_VAL      0x67bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x161
+#define CFG_DDR_EXT_MODE_VAL    0x2
+#define CFG_DDR_MODE_VAL        0x61
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#define CFG_DDR_REFRESH_VAL     0x5f00
+#define CFG_DDR_CONFIG_VAL      0x77bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x131
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x31
+#endif
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL			    0x83d1f6a2
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0xffff
+
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0x6fbc8890
+#define CFG_DDR_MODE_VAL_INIT   0x123
+#define CFG_DDR_EXT_MODE_VAL    0x1
+#define CFG_DDR_MODE_VAL        0x23
+
+#define CFG_DDR_CONFIG2_VAL     0x91d0e6a8	
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | \
+            CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET |\
+   CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB \
+   | CFG_CMD_ELF ))
+
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.27
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              136
+#define CAL_SECTOR                      63
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/ar7240.h u-boot_1.1//include/configs/ar7240.h
--- u-boot//include/configs/ar7240.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/ar7240.h	2014-02-18 01:46:28.651053603 -0800
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __AR7240_H
+#define __AR7240_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core	*/
+
+#define CONFIG_BOOTDELAY	4	/* autoboot after 4 seconds	*/
+
+#define CONFIG_BAUDRATE		115200 
+#define CFG_BAUDRATE_TABLE  { 	115200}
+
+#define	CONFIG_TIMESTAMP		/* Print image info with timestamp */
+
+#define CONFIG_ROOTFS_RD
+
+#define	CONFIG_BOOTARGS_RD     "console=ttyS0,115200 root=01:00 rd_start=0x80600000 rd_size=5242880 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),4096k(rootfs),2048k(uImage)"
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),2048k(uImage)"
+
+#ifdef CONFIG_ROOTFS_FLASH
+#define CONFIG_BOOTARGS CONFIG_BOOTARGS_FL
+#else
+#define CONFIG_BOOTARGS ""
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"ar7240> "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		512		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+//#define CFG_SDRAM_BASE		0xa0000000     /* Cached addr */
+
+#define	CFG_LOAD_ADDR		0x81000000     /* default load address	*/
+//#define	CFG_LOAD_ADDR		0xa1000000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#undef CFG_MEMTEST_START
+#define CFG_MEMTEST_START       0x80200000
+#define CFG_MEMTEST_END		0x83800000
+
+/*------------------------------------------------------------------------
+ * *  * JFFS2
+ */
+#define CFG_JFFS_CUSTOM_PART            /* board defined part   */
+#define CONFIG_JFFS2_CMDLINE
+#define MTDIDS_DEFAULT      "nor0=ar7240-nor0"
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#ifdef CONFIG_HORNET_EMU_HARDI_WLAN
+#define CFG_HZ          24000000
+#else
+#define CFG_HZ          40000000
+#endif
+
+#define CFG_RX_ETH_BUFFER   16
+
+/*
+** PLL Config for different CPU/DDR/AHB frequencies
+*/
+
+#define CFG_PLL_200_200_100		0x00
+#define CFG_PLL_300_300_150		0x01
+#define CFG_PLL_320_320_160		0x02
+#define CFG_PLL_340_340_170		0x03
+#define CFG_PLL_350_350_175		0x04
+#define CFG_PLL_360_360_180		0x05
+#define CFG_PLL_400_400_200		0x06
+#define CFG_PLL_300_300_75		0x07
+#define CFG_PLL_400_400_100		0x08
+#define CFG_PLL_320_320_80		0x09
+#define CFG_PLL_410_400_200		0x0a
+#define CFG_PLL_420_400_200		0x0b
+#define CFG_PLL_80_80_40		0x0c
+#define CFG_PLL_64_64_32		0x0d
+#define CFG_PLL_48_48_24		0x0e
+#define CFG_PLL_32_32_16		0x0f
+#define CFG_PLL_333_333_166		0x10
+#define CFG_PLL_266_266_133		0x11
+#define CFG_PLL_266_266_66		0x12
+#define CFG_PLL_240_240_120		0x13
+#define CFG_PLL_160_160_80		0x14
+#define CFG_PLL_400_200_200		0x15
+#define CFG_PLL_500_400_200		0x16
+#define CFG_PLL_600_400_200		0x17
+#define CFG_PLL_600_500_250		0x18
+#define CFG_PLL_600_400_300		0x19
+#define CFG_PLL_500_500_250		0x1a
+#define CFG_PLL_600_350_175		0x1b
+#define CFG_PLL_600_300_150		0x1c
+#define CFG_PLL_600_550_1_1G_275	0x1d
+#define CFG_PLL_600_500_1G_250		0x1e
+#define CFG_PLL_533_400_200		0x1f
+#define CFG_PLL_600_450_200		0x20
+#define CFG_PLL_533_500_250		0x21
+#define CFG_PLL_700_400_200		0x22
+#define CFG_PLL_650_600_300		0x23
+#define CFG_PLL_600_600_300		0x24
+#define CFG_PLL_600_550_275		0x25
+#define CFG_PLL_566_475_237		0x26
+#define CFG_PLL_566_450_225		0x27
+#define CFG_PLL_600_332_166		0x28
+#define CFG_PLL_600_575_287		0x29
+#define CFG_PLL_600_525_262		0x2a
+#define CFG_PLL_566_550_275		0x2b
+#define CFG_PLL_566_525_262		0x2c
+#define CFG_PLL_600_332_200		0x2d
+#define CFG_PLL_600_266_133		0x2e
+#define CFG_PLL_600_266_200		0x2f
+#define CFG_PLL_600_650_325		0x30
+#define CFG_PLL_566_400_200		0x31
+#define CFG_PLL_566_500_250		0x32
+#define CFG_PLL_600_1_2G_400_200	0x33
+#define CFG_PLL_560_480_240		0x34
+#define CFG_PLL_333_166_166		0x35
+#define CFG_PLL_350_175_175		0x36
+#define CFG_PLL_360_180_180		0x37
+#define CFG_PLL_380_190_190		0x38
+#define CFG_PLL_262_262_131		0x39
+#define CFG_PLL_275_275_137		0x3a
+#define CFG_PLL_200_200_200		0x3b
+#define CFG_PLL_250_250_125		0x3c
+#define CFG_PLL_225_225_112		0x3d
+#define CFG_PLL_212_212_106		0x3e
+#define CFG_PLL_187_187_93		0x3f
+#define CFG_PLL_535_400_200		0x40
+#define CFG_PLL_560_400_200		0x41
+#define CFG_PLL_560_450_225		0x42
+#define CFG_PLL_400_480_240		0x43
+
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		32768
+#define CFG_ICACHE_SIZE		65536
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/board953x.h u-boot_1.1//include/configs/board953x.h
--- u-boot//include/configs/board953x.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/board953x.h	2014-02-18 01:46:28.691053630 -0800
@@ -0,0 +1,356 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __BOARD_955X_H
+#define __BOARD_955X_H
+
+#include <config.h>
+
+#undef MTDPARTS_DEFAULT
+
+#undef CFG_HZ
+
+#include <atheros.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE 8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT	256	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"8256k(mib0)"
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT	128	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"64k(mib0)"
+#else
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"64k(mib0)"
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE	(64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE		0x01000000	/* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE		0x00800000	/* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE		0x00400000	/* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF	1
+#endif
+
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE	unsigned short
+
+#if defined(CONFIG_ATH_NAND_BR) && defined(COMPRESSED_UBOOT)
+#define CFG_FLASH_BASE			0xa0100000
+#else
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE		CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE	BOOTSTRAP_TEXT_BASE
+#endif
+
+#define CONFIG_PCI_CONFIG_DATA_IN_OTP
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE		(256 * 1024)
+#define UBOOT_ENV_SEC_START		(CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC			0xaabacada
+#define CFG_FLASH_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F		(CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F		CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F		CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+#define CFG_DDR_REFRESH_VAL		0x4138
+
+/*
+ * The following #defines are needed to get flash environment right
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#define __fs_name(x, y)		x ## y
+#define _fs_name(x, y)		__fs_name(x, y)
+#define fs_name(y)		_fs_name(__CONFIG_BOARD_NAME, y)
+
+#ifdef COMPRESSED_UBOOT
+#	define ATH_U_FILE	tuboot.bin
+#else
+#	define ATH_U_FILE	u-boot.bin
+#endif
+
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		if defined(COMPRESSED_UBOOT)
+#			define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x20000)
+#			define MTDPARTS_DEFAULT	"mtdparts=ath-nand:128k(u-boot),384k(free),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		else
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		endif
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else //dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		fs_name(${bc}-nand-jffs2)
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#else
+#	if defined(COMPRESSED_UBOOT)
+#		define ATH_U_FILE	tuboot.bin
+#		define ATH_F_FILE	fs_name(${bc}-jffs2)
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f010000
+#		define ATH_K_FILE	vmlinux${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+		/*
+		 * For compressed uboot, environment sector is not used.
+		 * Hence the mtd partition indices get reduced by 1.
+		 * This conflicts with
+		 *	- minor no. for /dev/caldata in
+		 *		build/scripts/{board}/dev.txt
+		 *	- root=<rooot dev> kernel cmdline parameter
+		 * Hence, doing a dummy split of the u-boot partition
+		 * to maintain the same minor no. as in the normal u-boot.
+		 */
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	else
+#		define ATH_F_FILE		fs_name(${bc}-jffs2)
+#		define ATH_F_LEN		0x630000
+#		define ATH_F_ADDR		0x9f050000
+#		define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#		define ATH_K_ADDR		0x9f680000
+#		define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage)," ATH_MTDPARTS_MIB0 ",64k(ART)"
+#	endif
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+//#define CFG_PLL_FREQ    CFG_PLL_720_600_200
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET	0xbd001800
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#else
+#	define CFG_ENV_ADDR		0x9f040000
+#	ifdef COMPRESSED_UBOOT
+#		define CONFIG_BOOTCOMMAND	"bootm 0x9f300000"
+#	else
+#		define CONFIG_BOOTCOMMAND	"bootm 0x9f680000"
+#	endif
+#endif
+
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC		0xaabacada
+#define CFG_DDR_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#	ifdef CONFIG_ATH_NAND_BR
+#		define ATH_CFG_COMMANDS		((			\
+						CONFIG_CMD_DFL	|	\
+						CFG_CMD_PING	|	\
+						CFG_CMD_NET) & ~(	\
+						CFG_CMD_FLASH		\
+						))
+#	else
+#		define ATH_CFG_COMMANDS		(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#	endif
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL				0x9fff1000
+#define BOARDCAL			0x9fff0000
+#define ATHEROS_PRODUCT_ID		137
+#define CAL_SECTOR			(CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define ATH_ART_PCICFG_OFFSET		12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __BOARD_955X_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/board955x.h u-boot_1.1//include/configs/board955x.h
--- u-boot//include/configs/board955x.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/board955x.h	2014-02-18 01:46:28.691053630 -0800
@@ -0,0 +1,332 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __BOARD_955X_H
+#define __BOARD_955X_H
+
+#include <config.h>
+
+#undef MTDPARTS_DEFAULT
+
+#undef CFG_HZ
+
+#include <atheros.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE 8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT	256	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"8256k(mib0)"
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT	128	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"64k(mib0)"
+#else
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"64k(mib0)"
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE	(64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE		0x01000000	/* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE		0x00800000	/* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE		0x00400000	/* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF	1
+#endif
+
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE	unsigned short
+
+#if defined(CONFIG_ATH_NAND_BR) && defined(COMPRESSED_UBOOT)
+#define CFG_FLASH_BASE			0xa0100000
+#else
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE		CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE	BOOTSTRAP_TEXT_BASE
+#endif
+
+#define CONFIG_PCI_CONFIG_DATA_IN_OTP
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE		(256 * 1024)
+#define UBOOT_ENV_SEC_START		(CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC			0xaabacada
+#define CFG_FLASH_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F		(CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F		CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F		CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+#define CFG_DDR_REFRESH_VAL		0x4138
+
+/*
+ * The following #defines are needed to get flash environment right
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#define __fs_name(x, y)		x ## y
+#define _fs_name(x, y)		__fs_name(x, y)
+#define fs_name(y)		_fs_name(__CONFIG_BOARD_NAME, y)
+
+#ifdef COMPRESSED_UBOOT
+#	define ATH_U_FILE	tuboot.bin
+#else
+#	define ATH_U_FILE	u-boot.bin
+#endif
+
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		if defined(COMPRESSED_UBOOT)
+#			define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x20000)
+#			define MTDPARTS_DEFAULT	"mtdparts=ath-nand:128k(u-boot),384k(free),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		else
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		endif
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else //dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nor0:320k(u-boot-and-env);ath-nand:512k(pad),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		fs_name(${bc}-nand-jffs2)
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#else
+#	define ATH_F_FILE		fs_name(${bc}-jffs2)
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage)," ATH_MTDPARTS_MIB0 ",64k(ART)"
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+//#define CFG_PLL_FREQ    CFG_PLL_720_600_200
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET	0xbd007000
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#else
+#	define CFG_ENV_ADDR		0x9f040000
+#	define CONFIG_BOOTCOMMAND	"bootm 0x9f680000"
+#endif
+
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC		0xaabacada
+#define CFG_DDR_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#	ifdef CONFIG_ATH_NAND_BR
+#		define ATH_CFG_COMMANDS		((			\
+						CONFIG_CMD_DFL	|	\
+						CFG_CMD_PING	|	\
+						CFG_CMD_NET) & ~(	\
+						CFG_CMD_FLASH		\
+						))
+#	else
+#		define ATH_CFG_COMMANDS		(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#	endif
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL				0x9fff1000
+#define BOARDCAL			0x9fff0000
+#define ATHEROS_PRODUCT_ID		137
+#define CAL_SECTOR			(CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define ATH_ART_PCICFG_OFFSET		12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __BOARD_955X_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/board956x.h u-boot_1.1//include/configs/board956x.h
--- u-boot//include/configs/board956x.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/board956x.h	2014-02-18 01:46:28.691053630 -0800
@@ -0,0 +1,377 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __BOARD_956X_H
+#define __BOARD_956X_H
+
+#include <config.h>
+
+#undef MTDPARTS_DEFAULT
+
+#undef CFG_HZ
+
+#include <atheros.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE 8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT	256	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"8256k(mib0)"
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT	128	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"64k(mib0)"
+#else
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"64k(mib0)"
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE	(64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE		0x01000000	/* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE		0x00800000	/* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE		0x00400000	/* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF	1
+#endif
+
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE	unsigned short
+
+#if defined(CONFIG_ATH_NAND_BR) && defined(COMPRESSED_UBOOT)
+#define CFG_FLASH_BASE			0xa0100000
+#else
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE		CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE	BOOTSTRAP_TEXT_BASE
+#endif
+
+#define CONFIG_PCI_CONFIG_DATA_IN_OTP
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE		(256 * 1024)
+#define UBOOT_ENV_SEC_START		(CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC			0xaabacada
+#define CFG_FLASH_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F		(CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F		CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F		CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+
+// DDR2
+// 0x40c3   25MHz
+// 0x4138   40MHz 
+// DDR1
+// 0x4186   25Mhz
+// 0x4270   40Mhz
+
+#define CFG_DDR_REFRESH_VAL		0x4186
+#define CFG_DDR2_REFRESH_VAL    0x40c3
+/*
+ * The following #defines are needed to get flash environment right
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#define __fs_name(x, y)		x ## y
+#define _fs_name(x, y)		__fs_name(x, y)
+#define fs_name(y)		_fs_name(__CONFIG_BOARD_NAME, y)
+
+#ifdef COMPRESSED_UBOOT
+#	define ATH_U_FILE	tuboot.bin
+#else
+#	define ATH_U_FILE	u-boot.bin
+#endif
+
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		if defined(COMPRESSED_UBOOT)
+#			define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x20000)
+#			define MTDPARTS_DEFAULT	"mtdparts=ath-nand:128k(u-boot),384k(free),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		else
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		endif
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else //dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nor0:320k(u-boot-and-env);ath-nand:512k(pad),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		fs_name(${bc}-nand-jffs2)
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#else
+#	if defined(COMPRESSED_UBOOT)
+#		define ATH_U_FILE	tuboot.bin
+#		define ATH_F_FILE	fs_name(${bc}-jffs2)
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f010000
+#		define ATH_K_FILE	vmlinux${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+		/*
+		 * For compressed uboot, environment sector is not used.
+		 * Hence the mtd partition indices get reduced by 1.
+		 * This conflicts with
+		 *	- minor no. for /dev/caldata in
+		 *		build/scripts/{board}/dev.txt
+		 *	- root=<rooot dev> kernel cmdline parameter
+		 * Hence, doing a dummy split of the u-boot partition
+		 * to maintain the same minor no. as in the normal u-boot.
+		 */
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	else
+#if (FLASH_SIZE == 8) /*FLASH SIZE */
+#	define ATH_F_FILE		fs_name(${bc}-jffs2)
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage)," ATH_MTDPARTS_MIB0 ",64k(ART)"
+#elif (FLASH_SIZE == 4) 
+#	define ATH_F_FILE		fs_name(${bc}-jffs2)
+#	define ATH_F_LEN		0x2b0000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f300000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage)," ATH_MTDPARTS_MIB0 ",64k(ART)"
+#endif /*FlASH SIZE */
+#endif /* COMPRESSED_UBOOT */
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET	0xbd001800
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#else
+#	define CFG_ENV_ADDR		0x9f040000
+#if (FLASH_SIZE == 8) /*FLASH_SIZE */
+#	define CONFIG_BOOTCOMMAND	"bootm 0x9f680000"
+#elif  (FLASH_SIZE == 4)
+#	define CONFIG_BOOTCOMMAND	"bootm 0x9f300000"
+#endif /*FLASH_SIZE */
+#endif
+
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC		0xaabacada
+#define CFG_DDR_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#if defined(CONFIG_CUS249) || defined(CONFIG_TB753)
+#else
+#define CONFIG_PCI 1
+#define CONFIG_USB 1
+#endif
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#	ifdef CONFIG_ATH_NAND_BR
+#		define ATH_CFG_COMMANDS		((			\
+						CONFIG_CMD_DFL	|	\
+						CFG_CMD_PING	|	\
+						CFG_CMD_NET) & ~(	\
+						CFG_CMD_FLASH		\
+						))
+#	else
+#		define ATH_CFG_COMMANDS		(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#	endif
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL				0x9fff1000
+#define BOARDCAL			0x9fff0000
+#define ATHEROS_PRODUCT_ID		137
+#define CAL_SECTOR			(CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define ATH_ART_PCICFG_OFFSET		12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __BOARD_956X_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/db12x-extender.h u-boot_1.1//include/configs/db12x-extender.h
--- u-boot//include/configs/db12x-extender.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/db12x-extender.h	2014-02-18 01:46:28.807053712 -0800
@@ -0,0 +1,441 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the db120 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if !defined(CONFIG_ATH_NAND_BR)
+#define FLASH_SIZE 8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* Assuming nand flash wouldn't use compressed u-boot */
+#ifdef CONFIG_ATH_NAND_BR
+#	define CFG_FLASH_BASE			0
+#else
+	/*
+	 * We boot from this flash
+	 */
+#	define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        CFG_FLASH_BASE+UBOOT_FLASH_SIZE
+#define CFG_ENV_SIZE        CFG_FLASH_SECTOR_SIZE
+
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),3072k(rootfs),1024k(uImage),3072k(spare-rootfs),1024k(spare-uImage),64k(mib0),64k(mib1),4096k(ct),3392k(var),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=8M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#if (FLASH_SIZE == 16)
+#define CFG_KERNEL_ADDR 0x9f550000
+#else
+#define CFG_KERNEL_ADDR 0x9f680000
+#endif
+#define CFG_MIB0_ADDR		0x9f7e0000
+
+#define CONFIG_BOOTCOMMAND "bootm ${KERNELADDR}"
+
+#ifndef CFG_LOAD_ADDR
+#define CFG_LOAD_ADDR		0x80060000
+#endif
+#ifndef COMPRESSED_UBOOT
+#define CFG_FS_ADDR			0x9f050000//(CFG_ENV_ADDR+CFG_ENV_SIZE)
+#else
+#define CFG_FS_ADDR			0x9f010000//(CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#endif /* COMPRESSED_UBOOT */
+#define ENV_FS_ADDR			"FSADDR=" MK_STR(CFG_FS_ADDR) "\0"
+
+#define ENV_UBOOT_ADDR		"UBOOTADDR=" MK_STR(CFG_FLASH_BASE) "\0"
+#define ENV_KERNEL_ADDR		"KERNELADDR=" MK_STR(CFG_KERNEL_ADDR) "\0"
+#define ENV_MIB0_ADDR		"MIB0ADDR=" MK_STR(CFG_MIB0_ADDR) "\0"
+
+#define ENV_UPDATE \
+    "update=tftpboot " MK_STR(CFG_LOAD_ADDR) " ${filename} && "	\
+            "erase ${loadaddr} +${filesize} && "				\
+            "cp.b ${fileaddr} ${loadaddr} ${filesize}\0"
+
+#define ENV_UPDATE_KERNEL \
+    "updk=loadaddr=${KERNELADDR} && filename=zImage.uImage && " \
+    "run update\0"
+
+#define ENV_UPDATE_FS \
+    "updfs=loadaddr=${FSADDR} && filename=rootfs-squashfs && " \
+    "run update\0"
+
+#ifdef COMPRESSED_UBOOT
+#define UBOOT_FILENAME "tuboot.bin"
+#else
+#define UBOOT_FILENAME "u-boot.bin"
+#endif
+
+#define ENV_UPDATE_UBOOT \
+    "updub=loadaddr=${UBOOTADDR} && filename=" UBOOT_FILENAME " && " \
+    "run update\0"
+
+#define ENV_UPDATE_ALL \
+	"updall=run updub && run updfs && run updk\0"
+
+#define ENV_ERASE_MIB0 \
+	"erasemib0=erase ${MIB0ADDR} +0x10000"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		ENV_UBOOT_ADDR \
+		ENV_FS_ADDR \
+		ENV_KERNEL_ADDR \
+		ENV_MIB0_ADDR \
+		ENV_UPDATE \
+		ENV_UPDATE_KERNEL \
+		ENV_UPDATE_FS \
+		ENV_UPDATE_UBOOT \
+		ENV_UPDATE_ALL \
+		ENV_ERASE_MIB0 \
+		""
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET 0xbd007000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+#if 0
+#ifdef CONFIG_ATH_NAND_BR
+#define CONFIG_BOOTCOMMAND "bootm 0x80000"
+#define CFG_ENV_ADDR		0x00040000
+#else  /* CONFIG_ATH_NAND_BR */
+#define CFG_ENV_ADDR		0x9f040000
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else  /* FLASH_SIZE == 16 */
+#ifdef COMPRESSED_UBOOT
+#if (FLASH_SIZE == 4)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else  /* FLASH_SIZE == 4 */
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#endif  /* FLASH_SIZE == 4 */
+#else /* COMPRESSED_UBOOT */
+#if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#endif
+#endif  /* COMPRESSED_UBOOT */
+#endif  /* FLASH_SIZE == 16 */
+#endif  /* CONFIG_ATH_NAND_BR */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_JFFS2 | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/db12x.h u-boot_1.1//include/configs/db12x.h
--- u-boot//include/configs/db12x.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/db12x.h	2014-02-18 01:46:28.807053712 -0800
@@ -0,0 +1,506 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE		8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+#if defined(CONFIG_ATH_NAND_SUPPORT) && defined(COMPRESSED_UBOOT)
+#define CFG_FLASH_BASE			0xa0100000
+#else
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/*
+ * The following #defines are needed to get flash environment right
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if CONFIG_MI124
+#define BC "bc=mi124_f1e\0"
+#endif
+#if CONFIG_AP123
+#define BC "bc=ap123\0"
+#endif
+
+#ifndef BC
+#define BC
+#endif
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		if defined(COMPRESSED_UBOOT)
+#			define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x20000)
+#			define MTDPARTS_DEFAULT	"mtdparts=ath-nand:128k(u-boot),384k(free),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		else
+#			define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#			define MTDPARTS_DEFAULT	"mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		endif
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else	//dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, u-boot.bin)
+#       define MTDPARTS_DEFAULT "mtdparts=ath-nor0:320k(u-boot-and-env);ath-nand:512k(pad),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		db12x${bc}-nand-jffs2${ns}
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#elif defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#	ifdef COMPRESSED_UBOOT
+#		define ATH_U_FILE	tuboot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f010000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+		/*
+		 * For compressed uboot, environment sector is not used.
+		 * Hence the mtd partition indices get reduced by 1.
+		 * This conflicts with
+		 *	- minor no. for /dev/caldata in
+		 *		build/scripts/{board}/dev.txt
+		 *	- root=<rooot dev> kernel cmdline parameter
+		 * Hence, doing a dummy split of the u-boot partition
+		 * to maintain the same minor no. as in the normal u-boot.
+		 */
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	else /* COMPRESSED_UBOOT */
+#		define ATH_U_FILE	u-boot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f050000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	endif /* COMPRESSED_UBOOT */
+#elif defined(CONFIG_DB12X_P2P)
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x-p2p${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_AP123
+#define CFG_PLL_FREQ	CFG_PLL_535_400_200
+#elif defined(CONFIG_ATH_NAND_SUPPORT)	// NAND on DB120
+#define CFG_PLL_FREQ	CFG_PLL_560_400_200
+#else					// DB120 and MI124
+#define CFG_PLL_FREQ	CFG_PLL_560_450_225
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200) || (CFG_PLL_FREQ == CFG_PLL_400_480_240)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_535_400_200)
+#   define CFG_HZ          (535000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240) || (CFG_PLL_FREQ == CFG_PLL_560_400_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_560_450_225)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET	0xbd007000
+
+#ifndef CONFIG_ATH_NAND_SUPPORT
+#	define CFG_ENV_ADDR		0x9f040000
+#	if (FLASH_SIZE == 16)
+#		define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#	else  /* FLASH_SIZE == 16 */
+#		ifdef COMPRESSED_UBOOT
+#			if (FLASH_SIZE == 4)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else  /* FLASH_SIZE == 4 */
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#			endif  /* FLASH_SIZE == 4 */
+#		else /* COMPRESSED_UBOOT */
+#			if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#			endif
+#		endif  /* COMPRESSED_UBOOT */
+#	endif  /* FLASH_SIZE == 16 */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#	ifdef CONFIG_ATH_NAND_BR
+#		define ATH_CFG_COMMANDS		((			\
+						CONFIG_CMD_DFL	|	\
+						CFG_CMD_PING	|	\
+						CFG_CMD_NET) & ~(	\
+						CFG_CMD_FLASH		\
+						))
+#	else
+#		define ATH_CFG_COMMANDS		(CONFIG_CMD_DFL	|	\
+						CFG_CMD_PING	|	\
+						CFG_CMD_NET)
+#	endif
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/db12x-hybrid.h u-boot_1.1//include/configs/db12x-hybrid.h
--- u-boot//include/configs/db12x-hybrid.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/db12x-hybrid.h	2014-02-18 01:46:28.807053712 -0800
@@ -0,0 +1,517 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE		8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if CONFIG_MI124
+#define BC "bc=mi124_f1e\0"
+#endif
+#if CONFIG_AP123
+#define BC "bc=ap123\0"
+#endif
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#               ifdef CONFIG_DB12X_HGW
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:512k(u-boot),128k(u-boot-env),3m(uImage),15m(rootfs),128k(mib0),128k(caldata)"
+#		define CFG_ENV_ADDR	0x00080000
+#               endif
+#	else	//dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, u-boot.bin)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#       ifdef CONFIG_DB12X_HGW
+#	        define ATH_F_FILE		db12x-hgw-nand-jffs2
+#	        define ATH_F_LEN		0xf00000
+#	        define ATH_F_ADDR		0x3a0000
+#	        define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	        define ATH_K_ADDR		0xa0000
+#	        define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	        define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	        define ATH_EXTRA_ENV		"bootdevice=0\0"
+#	        define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0xa0000"
+#       else
+#	        define ATH_F_FILE		db12x${bc}-nand-jffs2
+#	        define ATH_F_LEN		0x700000
+#	        define ATH_F_ADDR		0x1c0000
+#	        define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	        define ATH_K_ADDR		0x80000
+#	        define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	        define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	        define ATH_EXTRA_ENV		"bootdevice=0\0"
+#	        define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#       endif
+#elif defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#	ifdef COMPRESSED_UBOOT
+#		define ATH_U_FILE	tuboot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f010000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+		/*
+		 * For compressed uboot, environment sector is not used.
+		 * Hence the mtd partition indices get reduced by 1.
+		 * This conflicts with
+		 *	- minor no. for /dev/caldata in
+		 *		build/scripts/{board}/dev.txt
+		 *	- root=<rooot dev> kernel cmdline parameter
+		 * Hence, doing a dummy split of the u-boot partition
+		 * to maintain the same minor no. as in the normal u-boot.
+		 */
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	else /* COMPRESSED_UBOOT */
+#		define ATH_U_FILE	u-boot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f050000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	endif /* COMPRESSED_UBOOT */
+#elif defined(CONFIG_DB12X_P2P)
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x-p2p${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET 0xbd007000
+
+#ifndef CONFIG_ATH_NAND_SUPPORT
+#	define CFG_ENV_ADDR		0x9f040000
+#	if (FLASH_SIZE == 16)
+#		define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#	else  /* FLASH_SIZE == 16 */
+#		ifdef COMPRESSED_UBOOT
+#			if (FLASH_SIZE == 4)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else  /* FLASH_SIZE == 4 */
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#			endif  /* FLASH_SIZE == 4 */
+#		else /* COMPRESSED_UBOOT */
+#			if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#			endif
+#		endif  /* COMPRESSED_UBOOT */
+#	endif  /* FLASH_SIZE == 16 */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#define ATH_CFG_COMMANDS	(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#               ifdef CONFIG_DB12X_HGW
+#		        define CFG_ENV_OFFSET		0x80000u
+#		        define CFG_ENV_SIZE		0x20000u
+#               endif          
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/dhp1565.h u-boot_1.1//include/configs/dhp1565.h
--- u-boot//include/configs/dhp1565.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/dhp1565.h	2014-02-18 01:46:28.819053722 -0800
@@ -0,0 +1,442 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the db120 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if !defined(CONFIG_ATH_NAND_BR)
+#define FLASH_SIZE 8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* Assuming nand flash wouldn't use compressed u-boot */
+#ifdef CONFIG_ATH_NAND_BR
+#	define CFG_FLASH_BASE			0
+#else
+	/*
+	 * We boot from this flash
+	 */
+#	define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        (CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#define CFG_ENV_SIZE        CFG_FLASH_SECTOR_SIZE
+
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),3072k(rootfs),1024k(uImage),3072k(spare-rootfs),1024k(spare-uImage),64k(mib0),64k(mib1),4096k(ct),3392k(var),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=8M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#if (FLASH_SIZE == 16)
+#define CFG_KERNEL_ADDR 0x9f550000
+#else
+#define CFG_KERNEL_ADDR 0x9f680000
+#endif
+#define CFG_MIB0_ADDR		0x9f7e0000
+
+#define CONFIG_BOOTCOMMAND "bootm ${KERNELADDR}"
+
+#ifndef CFG_LOAD_ADDR
+#define CFG_LOAD_ADDR		0x80060000
+#endif
+#ifndef COMPRESSED_UBOOT
+#define CFG_FS_ADDR			0x9f050000//(CFG_ENV_ADDR+CFG_ENV_SIZE)
+#else
+#define CFG_FS_ADDR			0x9f010000//(CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#endif /* COMPRESSED_UBOOT */
+#define ENV_FS_ADDR			"FSADDR=" MK_STR(CFG_FS_ADDR) "\0"
+
+#define ENV_UBOOT_ADDR		"UBOOTADDR=" MK_STR(CFG_FLASH_BASE) "\0"
+#define ENV_KERNEL_ADDR		"KERNELADDR=" MK_STR(CFG_KERNEL_ADDR) "\0"
+#define ENV_MIB0_ADDR		"MIB0ADDR=" MK_STR(CFG_MIB0_ADDR) "\0"
+
+#define ENV_UPDATE \
+    "update=tftpboot " MK_STR(CFG_LOAD_ADDR) " ${filename} && "	\
+            "erase ${loadaddr} +${filesize} && "				\
+            "cp.b ${fileaddr} ${loadaddr} ${filesize}\0"
+
+#define ENV_UPDATE_KERNEL \
+    "updk=loadaddr=${KERNELADDR} && filename=zImage.uImage && " \
+    "run update\0"
+
+#define ENV_UPDATE_FS \
+    "updfs=loadaddr=${FSADDR} && filename=rootfs-squashfs && " \
+    "run update\0"
+
+#ifdef COMPRESSED_UBOOT
+#define UBOOT_FILENAME "tuboot.bin"
+#else
+#define UBOOT_FILENAME "u-boot.bin"
+#endif
+
+#define ENV_UPDATE_UBOOT \
+    "updub=loadaddr=${UBOOTADDR} && filename=" UBOOT_FILENAME " && " \
+    "run update\0"
+
+#define ENV_UPDATE_ALL \
+	"updall=run updub && run updfs && run updk\0"
+
+#define ENV_ERASE_MIB0 \
+	"erasemib0=erase ${MIB0ADDR} +0x10000"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		ENV_UBOOT_ADDR \
+		ENV_FS_ADDR \
+		ENV_KERNEL_ADDR \
+		ENV_MIB0_ADDR \
+		ENV_UPDATE \
+		ENV_UPDATE_KERNEL \
+		ENV_UPDATE_FS \
+		ENV_UPDATE_UBOOT \
+		ENV_UPDATE_ALL \
+		ENV_ERASE_MIB0 \
+		""
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+#if 0
+#ifdef CONFIG_ATH_NAND_BR
+#define CONFIG_BOOTCOMMAND "bootm 0x80000"
+#define CFG_ENV_ADDR		0x00040000
+#else  /* CONFIG_ATH_NAND_BR */
+#define CFG_ENV_ADDR		0x9f040000
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else  /* FLASH_SIZE == 16 */
+#ifdef COMPRESSED_UBOOT
+#if (FLASH_SIZE == 4)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else  /* FLASH_SIZE == 4 */
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#endif  /* FLASH_SIZE == 4 */
+#else /* COMPRESSED_UBOOT */
+#if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#endif
+#endif  /* COMPRESSED_UBOOT */
+#endif  /* FLASH_SIZE == 16 */
+#endif  /* CONFIG_ATH_NAND_BR */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/reh132.h u-boot_1.1//include/configs/reh132.h
--- u-boot//include/configs/reh132.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/reh132.h	2014-02-18 01:46:28.927053797 -0800
@@ -0,0 +1,445 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the db120 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if !defined(CONFIG_ATH_NAND_FL)
+#define FLASH_SIZE 16
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* Assuming nand flash wouldn't use compressed u-boot */
+#ifdef CONFIG_ATH_NAND_FL
+#	define CFG_FLASH_BASE			0
+#else
+	/*
+	 * We boot from this flash
+	 */
+#	define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        (CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#define CFG_ENV_SIZE        CFG_FLASH_SECTOR_SIZE
+
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),8192k(reserve),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=8M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#if (FLASH_SIZE == 16)
+#define CFG_KERNEL_ADDR 0x9f680000
+#else
+#define CFG_KERNEL_ADDR 0x9f680000
+#endif
+#define CFG_MIB0_ADDR		0x9ffe0000
+
+#define CONFIG_BOOTCOMMAND "bootm ${KERNELADDR}"
+
+#ifndef CFG_LOAD_ADDR
+#define CFG_LOAD_ADDR		0x80060000
+#endif
+#ifndef COMPRESSED_UBOOT
+#define CFG_FS_ADDR			0x9f050000//(CFG_ENV_ADDR+CFG_ENV_SIZE)
+#else
+#define CFG_FS_ADDR			0x9f010000//(CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#endif /* COMPRESSED_UBOOT */
+#define ENV_FS_ADDR			"FSADDR=" MK_STR(CFG_FS_ADDR) "\0"
+
+#define ENV_UBOOT_ADDR		"UBOOTADDR=" MK_STR(CFG_FLASH_BASE) "\0"
+#define ENV_KERNEL_ADDR		"KERNELADDR=" MK_STR(CFG_KERNEL_ADDR) "\0"
+#define ENV_MIB0_ADDR		"MIB0ADDR=" MK_STR(CFG_MIB0_ADDR) "\0"
+
+#define ENV_UPDATE \
+    "update=tftpboot " MK_STR(CFG_LOAD_ADDR) " ${filename} && "	\
+            "erase ${loadaddr} +${filesize} && "				\
+            "cp.b ${fileaddr} ${loadaddr} ${filesize}\0"
+
+#define ENV_UPDATE_KERNEL \
+    "updk=loadaddr=${KERNELADDR} && filename=zImage.uImage && " \
+    "run update\0"
+
+#define ENV_UPDATE_FS \
+    "updfs=loadaddr=${FSADDR} && filename=rootfs-jffs2 && " \
+    "run update\0"
+
+#ifdef COMPRESSED_UBOOT
+#define UBOOT_FILENAME "tuboot.bin"
+#else
+#define UBOOT_FILENAME "u-boot.bin"
+#endif
+
+#define ENV_UPDATE_UBOOT \
+    "updub=loadaddr=${UBOOTADDR} && filename=" UBOOT_FILENAME " && " \
+    "run update\0"
+
+#define ENV_UPDATE_ALL \
+	"updall=run updub && run updfs && run updk\0"
+
+#define ENV_ERASE_MIB0 \
+	"erasemib0=erase ${MIB0ADDR} +0x10000"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		ENV_UBOOT_ADDR \
+		ENV_FS_ADDR \
+		ENV_KERNEL_ADDR \
+		ENV_MIB0_ADDR \
+		ENV_UPDATE \
+		ENV_UPDATE_KERNEL \
+		ENV_UPDATE_FS \
+		ENV_UPDATE_UBOOT \
+		ENV_UPDATE_ALL \
+		ENV_ERASE_MIB0 \
+		""
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET 0xbd007000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+#if 0
+#ifdef CONFIG_ATH_NAND_FL
+#define CONFIG_BOOTCOMMAND "bootm 0x80000"
+#define CFG_ENV_ADDR		0x00040000
+#else  /* CONFIG_ATH_NAND_FL */
+#define CFG_ENV_ADDR		0x9f040000
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else  /* FLASH_SIZE == 16 */
+#ifdef COMPRESSED_UBOOT
+#if (FLASH_SIZE == 4)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else  /* FLASH_SIZE == 4 */
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#endif  /* FLASH_SIZE == 4 */
+#else /* COMPRESSED_UBOOT */
+#if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#endif
+#endif  /* COMPRESSED_UBOOT */
+#endif  /* FLASH_SIZE == 16 */
+#endif  /* CONFIG_ATH_NAND_FL */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_WAH132 1 
+
+#define CFG_PHY_ADDR 0 
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/scoemu.h u-boot_1.1//include/configs/scoemu.h
--- u-boot//include/configs/scoemu.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/scoemu.h	2014-02-18 01:46:28.935053803 -0800
@@ -0,0 +1,461 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SCOEMU_H
+#define __SCOEMU_H
+
+#include <config.h>
+
+#undef MTDPARTS_DEFAULT
+
+#undef CFG_HZ
+
+#include <atheros.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE 8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT	256	/* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT	128	/* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE	(64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE		0x01000000	/* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE		0x00800000	/* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE		0x00400000	/* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF	1
+#endif
+
+//#define CONFIG_WASP_SUPPORT	1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE	unsigned short
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 		1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED	1
+
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE		CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE	BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE		(256 * 1024)
+#define UBOOT_ENV_SEC_START		(CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC			0xaabacada
+#define CFG_FLASH_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F		(CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F		CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F		CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/*
+ * The following #defines are needed to get flash environment right
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if CONFIG_MI124
+#define BC "bc=mi124_f1e\0"
+#endif
+#if CONFIG_AP123
+#define BC "bc=ap123\0"
+#endif
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else	//dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, u-boot.bin)
+#	define MTDPARTS_DEFAULT 	"mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		db12x${bc}-nand-jffs2
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#elif defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#		ifdef COMPRESSED_UBOOT
+#		define ATH_U_FILE	tuboot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f010000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+			/*
+			 * For compressed uboot, environment sector is not used.
+			 * Hence the mtd partition indices get reduced by 1.
+			 * This conflicts with
+			 *	- minor no. for /dev/caldata in
+			 *		build/scripts/{board}/dev.txt
+			 *	- root=<rooot dev> kernel cmdline parameter
+			 * Hence, doing a dummy split of the u-boot partition
+			 * to maintain the same minor no. as in the normal u-boot.
+			 */
+#			define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#		else /* COMPRESSED_UBOOT */
+#		define ATH_U_FILE	u-boot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f050000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+#			define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#		endif /* COMPRESSED_UBOOT */
+#elif defined(CONFIG_DB12X_P2P)
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x-p2p${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline. The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#ifdef CONFIG_ATH_EMULATION
+#	define CFG_HZ	(80000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ	(200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ	(300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#	define CFG_HZ	(350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ	(333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ	(266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ	(400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#	define CFG_HZ	(320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#	define CFG_HZ	(410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#	define CFG_HZ	(420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#	define CFG_HZ	(240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#	define CFG_HZ	(160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#	define CFG_HZ	(500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#	define CFG_HZ	(600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#	define CFG_HZ	(533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#	define CFG_HZ	(700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#	define CFG_HZ	(650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#	define CFG_HZ	(560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+	(CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+	(CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#	define CFG_HZ	(566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef CONFIG_ATH_NAND_SUPPORT
+#	define CFG_ENV_ADDR		0x9f040000
+#	if (FLASH_SIZE == 16)
+#		define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#	else	/* FLASH_SIZE == 16 */
+#		ifdef COMPRESSED_UBOOT
+#			if (FLASH_SIZE == 4)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else	/* FLASH_SIZE == 4 */
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#			endif	/* FLASH_SIZE == 4 */
+#		else /* COMPRESSED_UBOOT */
+#			if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#			endif
+#		endif	/* COMPRESSED_UBOOT */
+#	endif	/* FLASH_SIZE == 16 */
+#endif
+
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC		0xaabacada
+#define CFG_DDR_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#define ATH_CFG_COMMANDS	(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL				0x9fff1000
+#define BOARDCAL			0x9fff0000
+#define ATHEROS_PRODUCT_ID		137
+#define CAL_SECTOR			(CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define ATH_ART_PCICFG_OFFSET		12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __SCOEMU_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/tb6xx.h u-boot_1.1//include/configs/tb6xx.h
--- u-boot//include/configs/tb6xx.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/tb6xx.h	2014-02-18 01:46:28.947053812 -0800
@@ -0,0 +1,364 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __TB6XX_H
+#define __TB6XX_H
+
+#include <config.h>
+
+#undef MTDPARTS_DEFAULT
+
+#undef CFG_HZ
+
+#include <atheros.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE 8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT	256	/* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT	128	/* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE	(64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE		0x01000000	/* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE		0x00800000	/* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE		0x00400000	/* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF	1
+#endif
+
+//#define CONFIG_WASP_SUPPORT	1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE	unsigned short
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 		1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED	1
+
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE		CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE	BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE		(256 * 1024)
+#define UBOOT_ENV_SEC_START		(CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC			0xaabacada
+#define CFG_FLASH_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F		(CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F		CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F		CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+#define CFG_DDR_REFRESH_VAL			0x412c
+
+/*
+ * The following #defines are needed to get flash environment right
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if CONFIG_MI124
+#define BC "bc=mi124_f1e\0"
+#endif
+#if CONFIG_AP123
+#define BC "bc=ap123\0"
+#endif
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else	//dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, u-boot.bin)
+#	define MTDPARTS_DEFAULT 	"mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		tb6xx${bc}-nand-jffs2
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#elif defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#		ifdef COMPRESSED_UBOOT
+#		define ATH_U_FILE	tuboot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f010000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+			/*
+			 * For compressed uboot, environment sector is not used.
+			 * Hence the mtd partition indices get reduced by 1.
+			 * This conflicts with
+			 *	- minor no. for /dev/caldata in
+			 *		build/scripts/{board}/dev.txt
+			 *	- root=<rooot dev> kernel cmdline parameter
+			 * Hence, doing a dummy split of the u-boot partition
+			 * to maintain the same minor no. as in the normal u-boot.
+			 */
+#			define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#		else /* COMPRESSED_UBOOT */
+#		define ATH_U_FILE	u-boot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f050000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+#			define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#		endif /* COMPRESSED_UBOOT */
+#elif defined(CONFIG_TB6XX_P2P)
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		tb6xx-p2p${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		tb6xx${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+//#define CFG_PLL_FREQ    CFG_PLL_720_600_200
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef CONFIG_ATH_NAND_SUPPORT
+#	define CFG_ENV_ADDR		0x9f040000
+#	if (FLASH_SIZE == 16)
+#		define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#	else	/* FLASH_SIZE == 16 */
+#		ifdef COMPRESSED_UBOOT
+#			if (FLASH_SIZE == 4)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else	/* FLASH_SIZE == 4 */
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#			endif	/* FLASH_SIZE == 4 */
+#		else /* COMPRESSED_UBOOT */
+#			if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#			endif
+#		endif	/* COMPRESSED_UBOOT */
+#	endif	/* FLASH_SIZE == 16 */
+#endif
+
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC		0xaabacada
+#define CFG_DDR_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#define ATH_CFG_COMMANDS	(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL				0x9fff1000
+#define BOARDCAL			0x9fff0000
+#define ATHEROS_PRODUCT_ID		137
+#define CAL_SECTOR			(CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define ATH_ART_PCICFG_OFFSET		12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __TB6XX_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/wah132.h u-boot_1.1//include/configs/wah132.h
--- u-boot//include/configs/wah132.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/wah132.h	2014-02-18 01:46:28.963053822 -0800
@@ -0,0 +1,444 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the db120 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if !defined(CONFIG_ATH_NAND_FL)
+#define FLASH_SIZE 16
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* Assuming nand flash wouldn't use compressed u-boot */
+#ifdef CONFIG_ATH_NAND_FL
+#	define CFG_FLASH_BASE			0
+#else
+	/*
+	 * We boot from this flash
+	 */
+#	define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        (CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#define CFG_ENV_SIZE        CFG_FLASH_SECTOR_SIZE
+
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),8192k(reserve),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=8M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#if (FLASH_SIZE == 16)
+#define CFG_KERNEL_ADDR 0x9f680000
+#else
+#define CFG_KERNEL_ADDR 0x9f680000
+#endif
+#define CFG_MIB0_ADDR		0x9ffe0000
+
+#define CONFIG_BOOTCOMMAND "bootm ${KERNELADDR}"
+
+#ifndef CFG_LOAD_ADDR
+#define CFG_LOAD_ADDR		0x80060000
+#endif
+#ifndef COMPRESSED_UBOOT
+#define CFG_FS_ADDR			0x9f050000//(CFG_ENV_ADDR+CFG_ENV_SIZE)
+#else
+#define CFG_FS_ADDR			0x9f010000//(CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#endif /* COMPRESSED_UBOOT */
+#define ENV_FS_ADDR			"FSADDR=" MK_STR(CFG_FS_ADDR) "\0"
+
+#define ENV_UBOOT_ADDR		"UBOOTADDR=" MK_STR(CFG_FLASH_BASE) "\0"
+#define ENV_KERNEL_ADDR		"KERNELADDR=" MK_STR(CFG_KERNEL_ADDR) "\0"
+#define ENV_MIB0_ADDR		"MIB0ADDR=" MK_STR(CFG_MIB0_ADDR) "\0"
+
+#define ENV_UPDATE \
+    "update=tftpboot " MK_STR(CFG_LOAD_ADDR) " ${filename} && "	\
+            "erase ${loadaddr} +${filesize} && "				\
+            "cp.b ${fileaddr} ${loadaddr} ${filesize}\0"
+
+#define ENV_UPDATE_KERNEL \
+    "updk=loadaddr=${KERNELADDR} && filename=zImage.uImage && " \
+    "run update\0"
+
+#define ENV_UPDATE_FS \
+    "updfs=loadaddr=${FSADDR} && filename=rootfs-jffs2 && " \
+    "run update\0"
+
+#ifdef COMPRESSED_UBOOT
+#define UBOOT_FILENAME "tuboot.bin"
+#else
+#define UBOOT_FILENAME "u-boot.bin"
+#endif
+
+#define ENV_UPDATE_UBOOT \
+    "updub=loadaddr=${UBOOTADDR} && filename=" UBOOT_FILENAME " && " \
+    "run update\0"
+
+#define ENV_UPDATE_ALL \
+	"updall=run updub && run updfs && run updk\0"
+
+#define ENV_ERASE_MIB0 \
+	"erasemib0=erase ${MIB0ADDR} +0x10000"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		ENV_UBOOT_ADDR \
+		ENV_FS_ADDR \
+		ENV_KERNEL_ADDR \
+		ENV_MIB0_ADDR \
+		ENV_UPDATE \
+		ENV_UPDATE_KERNEL \
+		ENV_UPDATE_FS \
+		ENV_UPDATE_UBOOT \
+		ENV_UPDATE_ALL \
+		ENV_ERASE_MIB0 \
+		""
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+#if 0
+#ifdef CONFIG_ATH_NAND_FL
+#define CONFIG_BOOTCOMMAND "bootm 0x80000"
+#define CFG_ENV_ADDR		0x00040000
+#else  /* CONFIG_ATH_NAND_FL */
+#define CFG_ENV_ADDR		0x9f040000
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else  /* FLASH_SIZE == 16 */
+#ifdef COMPRESSED_UBOOT
+#if (FLASH_SIZE == 4)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else  /* FLASH_SIZE == 4 */
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#endif  /* FLASH_SIZE == 4 */
+#else /* COMPRESSED_UBOOT */
+#if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#endif
+#endif  /* COMPRESSED_UBOOT */
+#endif  /* FLASH_SIZE == 16 */
+#endif  /* CONFIG_ATH_NAND_FL */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_WAH132 1 
+
+#define CFG_PHY_ADDR 0 
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/configs/wasp_emu.h u-boot_1.1//include/configs/wasp_emu.h
--- u-boot//include/configs/wasp_emu.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/configs/wasp_emu.h	2014-02-18 01:46:28.963053822 -0800
@@ -0,0 +1,201 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#define CONFIG_AR7240_EMU 1
+#define CONFIG_WASP_EMU 1
+#define CONFIG_WASP_SUPPORT 1
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0xbf000000
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS     "console=ttyS0,9600 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_400_400_100
+
+/* Atheros Header configuration */
+
+#define CFG_ATHRS27_PHY  1
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0xbf040000
+#define CFG_ENV_SIZE		0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0xbf550000"
+//#define CONFIG_FLASH_16BIT
+
+#define CONFIG_NR_DRAM_BANKS	2
+#if 0
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#define CFG_DDR_REFRESH_VAL     0x4c00
+#define CFG_DDR_CONFIG_VAL      0x67bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x161
+#define CFG_DDR_EXT_MODE_VAL    0x2
+#define CFG_DDR_MODE_VAL        0x61
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#define CFG_DDR_REFRESH_VAL     0x5f00
+#define CFG_DDR_CONFIG_VAL      0x77bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x131
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x31
+#endif
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL			    0x83d1f6a2
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0xffff
+
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0x6fbc8890
+#define CFG_DDR_MODE_VAL_INIT   0x123
+#define CFG_DDR_EXT_MODE_VAL    0x1
+#define CFG_DDR_MODE_VAL        0x23
+
+#define CFG_DDR_CONFIG2_VAL     0x91d0e6a8	
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | \
+            CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET |\
+   CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB \
+   | CFG_CMD_ELF ))
+
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.27
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              136
+#define CAL_SECTOR                      63
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/defines.h u-boot_1.1//include/defines.h
--- u-boot//include/defines.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/defines.h	2014-02-18 01:46:28.995053843 -0800
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Memory segments (32bit kernel mode addresses)
+ */
+#define KUSEG			0x00000000
+#define KSEG0			0x80000000
+#define KSEG1			0xa0000000
+#define KSEG2			0xc0000000
+#define KSEG3			0xe0000000
+
+#define SRAMADDR        0x1d000000
+
+/*
+ * SRAM size
+ */
+#define SRAM_SIZE       0x2000
+
+/*
+ * Reserved Space for code and stack
+ */
+#define RESERVED_SEGMENT_SIZE   0x2000
+#define STACK_POINTER_INIT_ADDR (KSEG0 + SRAMADDR + RESERVED_SEGMENT_SIZE - 4)
+
+/*
+ * Test Options
+ */
+/*UART : because Wasp and Hornet use different UART controllers, it is better to disable UART function */
+#define DISABLE_UART        0
+#define DISCARD_ERROR       0
+#define DATA_PATTERN_NUM    3
+
+/*
+ * Information
+ */
+#define INFO_BASE_ADDR          0xbd000000
+
+#define INFO_GEN_ADDR           (INFO_BASE_ADDR + 0x00)     /* Current Round Number : 1, 2, ... */
+#define INFO_SIZE_ADDR          (INFO_GEN_ADDR  + 0x4)
+#define INFO_MEM_START_ADDR     (INFO_GEN_ADDR  + 0x8)
+#define INFO_MEM_END_ADDR       (INFO_GEN_ADDR  + 0xc)
+#define INFO_CACHE_START_ADDR   (INFO_GEN_ADDR  + 0x10)
+#define INFO_CACHE_END_ADDR     (INFO_GEN_ADDR  + 0x14)
+
+#define INFO_MT_ADDR            (INFO_BASE_ADDR  + 0x20)    /* 0 : not started in current round, 1 : started in current round */
+#define INFO_MT_PAT_ADDR        (INFO_MT_ADDR    + 0x4)     /* Pattern : 1 for Random, 2 for Address, 3 for 0xffffffff */
+
+#define INFO_CT_ADDR            (INFO_BASE_ADDR  + 0x30)    /* 0 : not started in current round, 1 : started in current round */
+#define INFO_CT_PAT_ADDR        (INFO_CT_ADDR    + 0x4)     /* Pattern : 1 for Random, 2 for Address, 3 for 0xffffffff */
+
+#define INFO_ERROR_T_ADDR           (INFO_BASE_ADDR    + 0x40)  /* 0 : error not found in current round, 1 : error found in current round */
+#define INFO_ERROR_T_INVERSE_ADDR   (INFO_ERROR_T_ADDR + 0x4)   /* 0 : pattern, 1 : inverse pattern */
+#define INFO_ERROR_T_STRIDE_ADDR    (INFO_ERROR_T_ADDR + 0x8)   /* Stride */
+#define INFO_ERROR_T_OFFSET_ADDR    (INFO_ERROR_T_ADDR + 0xc)   /* Offset */
+#define INFO_ERROR_T_ADR_ADDR       (INFO_ERROR_T_ADDR + 0x10)  /* Address */
+#define INFO_ERROR_T_DATA_ADDR      (INFO_ERROR_T_ADDR + 0x14)  /* Actual Data */
+#define INFO_ERROR_T_EDATA_ADDR     (INFO_ERROR_T_ADDR + 0x18)  /* Expected Data */
+
+#define INFO_FAIL_ADDR          (INFO_BASE_ADDR + 0x60)     /* How many rounds at least one of all tests failed if errors were discarded */
+#define INFO_FAIL_MT_ADDR       (INFO_FAIL_ADDR + 0x4)      /* How many rounds MT test                   failed if errors were discarded */
+#define INFO_FAIL_CT_ADDR       (INFO_FAIL_ADDR + 0x8)      /* How many rounds CT test                   failed if errors were discarded */
+
+/*
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		32768
+#define CFG_ICACHE_SIZE		65536
+#define CFG_CACHELINE_SIZE	32
+
+/*
+ * Cache Operations
+ */
+#define Index_Invalidate_I      0x00
+#define Index_Writeback_Inv_D   0x01
+#define Index_Invalidate_SI     0x02
+#define Index_Writeback_Inv_SD  0x03
+#define Index_Load_Tag_I	0x04
+#define Index_Load_Tag_D	0x05
+#define Index_Load_Tag_SI	0x06
+#define Index_Load_Tag_SD	0x07
+#define Index_Store_Tag_I	0x08
+#define Index_Store_Tag_D	0x09
+#define Index_Store_Tag_SI	0x0A
+#define Index_Store_Tag_SD	0x0B
+#define Create_Dirty_Excl_D	0x0d
+#define Create_Dirty_Excl_SD	0x0f
+#define Hit_Invalidate_I	0x10
+#define Hit_Invalidate_D	0x11
+#define Hit_Invalidate_SI	0x12
+#define Hit_Invalidate_SD	0x13
+#define Fill			0x14
+#define Hit_Writeback_Inv_D	0x15
+					/* 0x16 is unused */
+#define Hit_Writeback_Inv_SD	0x17
+#define Hit_Writeback_I		0x18
+#define Hit_Writeback_D		0x19
+					/* 0x1a is unused */
+#define Hit_Writeback_SD	0x1b
+					/* 0x1c is unused */
+					/* 0x1e is unused */
+#define Hit_Set_Virtual_SI	0x1e
+#define Hit_Set_Virtual_SD	0x1f
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/flash.h u-boot_1.1//include/flash.h
--- u-boot//include/flash.h	2014-02-18 01:46:23.519050021 -0800
+++ u-boot_1.1//include/flash.h	2014-02-18 01:46:29.051053884 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2000-2005
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -416,6 +418,8 @@
 #define FLASH_MT28S4M16LC 0x00E1	/* Micron MT28S4M16LC			*/
 #define FLASH_S29GL064M 0x00F0		/* Spansion S29GL064M-R6		*/
 
+#define FLASH_M25P64    0x00F2      
+
 #define FLASH_UNKNOWN	0xFFFF		/* unknown flash type			*/
 
 
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/hornet_soc.h u-boot_1.1//include/hornet_soc.h
--- u-boot//include/hornet_soc.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//include/hornet_soc.h	2014-02-18 01:46:29.059053888 -0800
@@ -0,0 +1,293 @@
+/*
+ * Atheror Hornet series processor SOC registers
+ *
+ * (C) Copyright 2010 Atheros Communications, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _HORNET_SOC_H
+#define _HORNET_SOC_H
+#include <ar7240_soc.h>
+#include <config.h>
+
+/*
+ * UART block
+ */
+// 0x0000 (UARTDATA)
+#define UARTDATA_UARTTXCSR_MSB                                       9
+#define UARTDATA_UARTTXCSR_LSB                                       9
+#define UARTDATA_UARTTXCSR_MASK                                      0x00000200
+#define UARTDATA_UARTTXCSR_GET(x)                                    (((x) & UARTDATA_UARTTXCSR_MASK) >> UARTDATA_UARTTXCSR_LSB)
+#define UARTDATA_UARTTXCSR_SET(x)                                    (((0 | (x)) << UARTDATA_UARTTXCSR_LSB) & UARTDATA_UARTTXCSR_MASK)
+#define UARTDATA_UARTTXCSR_RESET                                     0
+#define UARTDATA_UARTRXCSR_MSB                                       8
+#define UARTDATA_UARTRXCSR_LSB                                       8
+#define UARTDATA_UARTRXCSR_MASK                                      0x00000100
+#define UARTDATA_UARTRXCSR_GET(x)                                    (((x) & UARTDATA_UARTRXCSR_MASK) >> UARTDATA_UARTRXCSR_LSB)
+#define UARTDATA_UARTRXCSR_SET(x)                                    (((0 | (x)) << UARTDATA_UARTRXCSR_LSB) & UARTDATA_UARTRXCSR_MASK)
+#define UARTDATA_UARTRXCSR_RESET                                     0
+#define UARTDATA_UARTTXRXDATA_MSB                                    7
+#define UARTDATA_UARTTXRXDATA_LSB                                    0
+#define UARTDATA_UARTTXRXDATA_MASK                                   0x000000ff
+#define UARTDATA_UARTTXRXDATA_GET(x)                                 (((x) & UARTDATA_UARTTXRXDATA_MASK) >> UARTDATA_UARTTXRXDATA_LSB)
+#define UARTDATA_UARTTXRXDATA_SET(x)                                 (((0 | (x)) << UARTDATA_UARTTXRXDATA_LSB) & UARTDATA_UARTTXRXDATA_MASK)
+#define UARTDATA_UARTTXRXDATA_RESET                                  0
+#define UARTDATA_ADDRESS                                             0x0000
+#define UARTDATA_HW_MASK                                             0x000003ff
+#define UARTDATA_SW_MASK                                             0x000003ff
+#define UARTDATA_RSTMASK                                             0x000003ff
+#define UARTDATA_RESET                                               0x00000000
+
+// 0x0004 (UARTCS)
+#define UARTCS_UARTRXBUSY_MSB                                        15
+#define UARTCS_UARTRXBUSY_LSB                                        15
+#define UARTCS_UARTRXBUSY_MASK                                       0x00008000
+#define UARTCS_UARTRXBUSY_GET(x)                                     (((x) & UARTCS_UARTRXBUSY_MASK) >> UARTCS_UARTRXBUSY_LSB)
+#define UARTCS_UARTRXBUSY_SET(x)                                     (((0 | (x)) << UARTCS_UARTRXBUSY_LSB) & UARTCS_UARTRXBUSY_MASK)
+#define UARTCS_UARTRXBUSY_RESET                                      0
+#define UARTCS_UARTTXBUSY_MSB                                        14
+#define UARTCS_UARTTXBUSY_LSB                                        14
+#define UARTCS_UARTTXBUSY_MASK                                       0x00004000
+#define UARTCS_UARTTXBUSY_GET(x)                                     (((x) & UARTCS_UARTTXBUSY_MASK) >> UARTCS_UARTTXBUSY_LSB)
+#define UARTCS_UARTTXBUSY_SET(x)                                     (((0 | (x)) << UARTCS_UARTTXBUSY_LSB) & UARTCS_UARTTXBUSY_MASK)
+#define UARTCS_UARTTXBUSY_RESET                                      0
+#define UARTCS_UARTHOSTINTEN_MSB                                     13
+#define UARTCS_UARTHOSTINTEN_LSB                                     13
+#define UARTCS_UARTHOSTINTEN_MASK                                    0x00002000
+#define UARTCS_UARTHOSTINTEN_GET(x)                                  (((x) & UARTCS_UARTHOSTINTEN_MASK) >> UARTCS_UARTHOSTINTEN_LSB)
+#define UARTCS_UARTHOSTINTEN_SET(x)                                  (((0 | (x)) << UARTCS_UARTHOSTINTEN_LSB) & UARTCS_UARTHOSTINTEN_MASK)
+#define UARTCS_UARTHOSTINTEN_RESET                                   0
+#define UARTCS_UARTHOSTINT_MSB                                       12
+#define UARTCS_UARTHOSTINT_LSB                                       12
+#define UARTCS_UARTHOSTINT_MASK                                      0x00001000
+#define UARTCS_UARTHOSTINT_GET(x)                                    (((x) & UARTCS_UARTHOSTINT_MASK) >> UARTCS_UARTHOSTINT_LSB)
+#define UARTCS_UARTHOSTINT_SET(x)                                    (((0 | (x)) << UARTCS_UARTHOSTINT_LSB) & UARTCS_UARTHOSTINT_MASK)
+#define UARTCS_UARTHOSTINT_RESET                                     0
+#define UARTCS_UARTTXBREAK_MSB                                       11
+#define UARTCS_UARTTXBREAK_LSB                                       11
+#define UARTCS_UARTTXBREAK_MASK                                      0x00000800
+#define UARTCS_UARTTXBREAK_GET(x)                                    (((x) & UARTCS_UARTTXBREAK_MASK) >> UARTCS_UARTTXBREAK_LSB)
+#define UARTCS_UARTTXBREAK_SET(x)                                    (((0 | (x)) << UARTCS_UARTTXBREAK_LSB) & UARTCS_UARTTXBREAK_MASK)
+#define UARTCS_UARTTXBREAK_RESET                                     0
+#define UARTCS_UARTRXBREAK_MSB                                       10
+#define UARTCS_UARTRXBREAK_LSB                                       10
+#define UARTCS_UARTRXBREAK_MASK                                      0x00000400
+#define UARTCS_UARTRXBREAK_GET(x)                                    (((x) & UARTCS_UARTRXBREAK_MASK) >> UARTCS_UARTRXBREAK_LSB)
+#define UARTCS_UARTRXBREAK_SET(x)                                    (((0 | (x)) << UARTCS_UARTRXBREAK_LSB) & UARTCS_UARTRXBREAK_MASK)
+#define UARTCS_UARTRXBREAK_RESET                                     0
+#define UARTCS_UARTSERIATXREADY_MSB                                  9
+#define UARTCS_UARTSERIATXREADY_LSB                                  9
+#define UARTCS_UARTSERIATXREADY_MASK                                 0x00000200
+#define UARTCS_UARTSERIATXREADY_GET(x)                               (((x) & UARTCS_UARTSERIATXREADY_MASK) >> UARTCS_UARTSERIATXREADY_LSB)
+#define UARTCS_UARTSERIATXREADY_SET(x)                               (((0 | (x)) << UARTCS_UARTSERIATXREADY_LSB) & UARTCS_UARTSERIATXREADY_MASK)
+#define UARTCS_UARTSERIATXREADY_RESET                                0
+#define UARTCS_UARTTXREADYORIDE_MSB                                  8
+#define UARTCS_UARTTXREADYORIDE_LSB                                  8
+#define UARTCS_UARTTXREADYORIDE_MASK                                 0x00000100
+#define UARTCS_UARTTXREADYORIDE_GET(x)                               (((x) & UARTCS_UARTTXREADYORIDE_MASK) >> UARTCS_UARTTXREADYORIDE_LSB)
+#define UARTCS_UARTTXREADYORIDE_SET(x)                               (((0 | (x)) << UARTCS_UARTTXREADYORIDE_LSB) & UARTCS_UARTTXREADYORIDE_MASK)
+#define UARTCS_UARTTXREADYORIDE_RESET                                0
+#define UARTCS_UARTRXREADYORIDE_MSB                                  7
+#define UARTCS_UARTRXREADYORIDE_LSB                                  7
+#define UARTCS_UARTRXREADYORIDE_MASK                                 0x00000080
+#define UARTCS_UARTRXREADYORIDE_GET(x)                               (((x) & UARTCS_UARTRXREADYORIDE_MASK) >> UARTCS_UARTRXREADYORIDE_LSB)
+#define UARTCS_UARTRXREADYORIDE_SET(x)                               (((0 | (x)) << UARTCS_UARTRXREADYORIDE_LSB) & UARTCS_UARTRXREADYORIDE_MASK)
+#define UARTCS_UARTRXREADYORIDE_RESET                                0
+#define UARTCS_UARTDMAEN_MSB                                         6
+#define UARTCS_UARTDMAEN_LSB                                         6
+#define UARTCS_UARTDMAEN_MASK                                        0x00000040
+#define UARTCS_UARTDMAEN_GET(x)                                      (((x) & UARTCS_UARTDMAEN_MASK) >> UARTCS_UARTDMAEN_LSB)
+#define UARTCS_UARTDMAEN_SET(x)                                      (((0 | (x)) << UARTCS_UARTDMAEN_LSB) & UARTCS_UARTDMAEN_MASK)
+#define UARTCS_UARTDMAEN_RESET                                       0
+#define UARTCS_UARTFLOWCONTROLMODE_MSB                               5
+#define UARTCS_UARTFLOWCONTROLMODE_LSB                               4
+#define UARTCS_UARTFLOWCONTROLMODE_MASK                              0x00000030
+#define UARTCS_UARTFLOWCONTROLMODE_GET(x)                            (((x) & UARTCS_UARTFLOWCONTROLMODE_MASK) >> UARTCS_UARTFLOWCONTROLMODE_LSB)
+#define UARTCS_UARTFLOWCONTROLMODE_SET(x)                            (((0 | (x)) << UARTCS_UARTFLOWCONTROLMODE_LSB) & UARTCS_UARTFLOWCONTROLMODE_MASK)
+#define UARTCS_UARTFLOWCONTROLMODE_RESET                             0
+#define UARTCS_UARTINTERFACEMODE_MSB                                 3
+#define UARTCS_UARTINTERFACEMODE_LSB                                 2
+#define UARTCS_UARTINTERFACEMODE_MASK                                0x0000000c
+#define UARTCS_UARTINTERFACEMODE_GET(x)                              (((x) & UARTCS_UARTINTERFACEMODE_MASK) >> UARTCS_UARTINTERFACEMODE_LSB)
+#define UARTCS_UARTINTERFACEMODE_SET(x)                              (((0 | (x)) << UARTCS_UARTINTERFACEMODE_LSB) & UARTCS_UARTINTERFACEMODE_MASK)
+#define UARTCS_UARTINTERFACEMODE_RESET                               0
+#define UARTCS_UARTPARITYMODE_MSB                                    1
+#define UARTCS_UARTPARITYMODE_LSB                                    0
+#define UARTCS_UARTPARITYMODE_MASK                                   0x00000003
+#define UARTCS_UARTPARITYMODE_GET(x)                                 (((x) & UARTCS_UARTPARITYMODE_MASK) >> UARTCS_UARTPARITYMODE_LSB)
+#define UARTCS_UARTPARITYMODE_SET(x)                                 (((0 | (x)) << UARTCS_UARTPARITYMODE_LSB) & UARTCS_UARTPARITYMODE_MASK)
+#define UARTCS_UARTPARITYMODE_RESET                                  0
+#define UARTCS_ADDRESS                                               0x0004
+#define UARTCS_HW_MASK                                               0x0000ffff
+#define UARTCS_SW_MASK                                               0x0000ffff
+#define UARTCS_RSTMASK                                               0x000029ff
+#define UARTCS_RESET                                                 0x00000000
+
+// 0x0008 (UARTCLOCK)
+#define UARTCLOCK_UARTCLOCKSCALE_MSB                                 23
+#define UARTCLOCK_UARTCLOCKSCALE_LSB                                 16
+#define UARTCLOCK_UARTCLOCKSCALE_MASK                                0x00ff0000
+#define UARTCLOCK_UARTCLOCKSCALE_GET(x)                              (((x) & UARTCLOCK_UARTCLOCKSCALE_MASK) >> UARTCLOCK_UARTCLOCKSCALE_LSB)
+#define UARTCLOCK_UARTCLOCKSCALE_SET(x)                              (((0 | (x)) << UARTCLOCK_UARTCLOCKSCALE_LSB) & UARTCLOCK_UARTCLOCKSCALE_MASK)
+#define UARTCLOCK_UARTCLOCKSCALE_RESET                               0
+#define UARTCLOCK_UARTCLOCKSTEP_MSB                                  15
+#define UARTCLOCK_UARTCLOCKSTEP_LSB                                  0
+#define UARTCLOCK_UARTCLOCKSTEP_MASK                                 0x0000ffff
+#define UARTCLOCK_UARTCLOCKSTEP_GET(x)                               (((x) & UARTCLOCK_UARTCLOCKSTEP_MASK) >> UARTCLOCK_UARTCLOCKSTEP_LSB)
+#define UARTCLOCK_UARTCLOCKSTEP_SET(x)                               (((0 | (x)) << UARTCLOCK_UARTCLOCKSTEP_LSB) & UARTCLOCK_UARTCLOCKSTEP_MASK)
+#define UARTCLOCK_UARTCLOCKSTEP_RESET                                0
+#define UARTCLOCK_ADDRESS                                            0x0008
+#define UARTCLOCK_HW_MASK                                            0x00ffffff
+#define UARTCLOCK_SW_MASK                                            0x00ffffff
+#define UARTCLOCK_RSTMASK                                            0x00ffffff
+#define UARTCLOCK_RESET                                              0x00000000
+
+// 0x000c (UARTINT)
+#define UARTINT_UARTTXEMPTYINT_MSB                                   9
+#define UARTINT_UARTTXEMPTYINT_LSB                                   9
+#define UARTINT_UARTTXEMPTYINT_MASK                                  0x00000200
+#define UARTINT_UARTTXEMPTYINT_GET(x)                                (((x) & UARTINT_UARTTXEMPTYINT_MASK) >> UARTINT_UARTTXEMPTYINT_LSB)
+#define UARTINT_UARTTXEMPTYINT_SET(x)                                (((0 | (x)) << UARTINT_UARTTXEMPTYINT_LSB) & UARTINT_UARTTXEMPTYINT_MASK)
+#define UARTINT_UARTTXEMPTYINT_RESET                                 0
+#define UARTINT_UARTRXFULLINT_MSB                                    8
+#define UARTINT_UARTRXFULLINT_LSB                                    8
+#define UARTINT_UARTRXFULLINT_MASK                                   0x00000100
+#define UARTINT_UARTRXFULLINT_GET(x)                                 (((x) & UARTINT_UARTRXFULLINT_MASK) >> UARTINT_UARTRXFULLINT_LSB)
+#define UARTINT_UARTRXFULLINT_SET(x)                                 (((0 | (x)) << UARTINT_UARTRXFULLINT_LSB) & UARTINT_UARTRXFULLINT_MASK)
+#define UARTINT_UARTRXFULLINT_RESET                                  0
+#define UARTINT_UARTRXBREAKOFFINT_MSB                                7
+#define UARTINT_UARTRXBREAKOFFINT_LSB                                7
+#define UARTINT_UARTRXBREAKOFFINT_MASK                               0x00000080
+#define UARTINT_UARTRXBREAKOFFINT_GET(x)                             (((x) & UARTINT_UARTRXBREAKOFFINT_MASK) >> UARTINT_UARTRXBREAKOFFINT_LSB)
+#define UARTINT_UARTRXBREAKOFFINT_SET(x)                             (((0 | (x)) << UARTINT_UARTRXBREAKOFFINT_LSB) & UARTINT_UARTRXBREAKOFFINT_MASK)
+#define UARTINT_UARTRXBREAKOFFINT_RESET                              0
+#define UARTINT_UARTRXBREAKONINT_MSB                                 6
+#define UARTINT_UARTRXBREAKONINT_LSB                                 6
+#define UARTINT_UARTRXBREAKONINT_MASK                                0x00000040
+#define UARTINT_UARTRXBREAKONINT_GET(x)                              (((x) & UARTINT_UARTRXBREAKONINT_MASK) >> UARTINT_UARTRXBREAKONINT_LSB)
+#define UARTINT_UARTRXBREAKONINT_SET(x)                              (((0 | (x)) << UARTINT_UARTRXBREAKONINT_LSB) & UARTINT_UARTRXBREAKONINT_MASK)
+#define UARTINT_UARTRXBREAKONINT_RESET                               0
+#define UARTINT_UARTRXPARITYERRINT_MSB                               5
+#define UARTINT_UARTRXPARITYERRINT_LSB                               5
+#define UARTINT_UARTRXPARITYERRINT_MASK                              0x00000020
+#define UARTINT_UARTRXPARITYERRINT_GET(x)                            (((x) & UARTINT_UARTRXPARITYERRINT_MASK) >> UARTINT_UARTRXPARITYERRINT_LSB)
+#define UARTINT_UARTRXPARITYERRINT_SET(x)                            (((0 | (x)) << UARTINT_UARTRXPARITYERRINT_LSB) & UARTINT_UARTRXPARITYERRINT_MASK)
+#define UARTINT_UARTRXPARITYERRINT_RESET                             0
+#define UARTINT_UARTTXOFLOWERRINT_MSB                                4
+#define UARTINT_UARTTXOFLOWERRINT_LSB                                4
+#define UARTINT_UARTTXOFLOWERRINT_MASK                               0x00000010
+#define UARTINT_UARTTXOFLOWERRINT_GET(x)                             (((x) & UARTINT_UARTTXOFLOWERRINT_MASK) >> UARTINT_UARTTXOFLOWERRINT_LSB)
+#define UARTINT_UARTTXOFLOWERRINT_SET(x)                             (((0 | (x)) << UARTINT_UARTTXOFLOWERRINT_LSB) & UARTINT_UARTTXOFLOWERRINT_MASK)
+#define UARTINT_UARTTXOFLOWERRINT_RESET                              0
+#define UARTINT_UARTRXOFLOWERRINT_MSB                                3
+#define UARTINT_UARTRXOFLOWERRINT_LSB                                3
+#define UARTINT_UARTRXOFLOWERRINT_MASK                               0x00000008
+#define UARTINT_UARTRXOFLOWERRINT_GET(x)                             (((x) & UARTINT_UARTRXOFLOWERRINT_MASK) >> UARTINT_UARTRXOFLOWERRINT_LSB)
+#define UARTINT_UARTRXOFLOWERRINT_SET(x)                             (((0 | (x)) << UARTINT_UARTRXOFLOWERRINT_LSB) & UARTINT_UARTRXOFLOWERRINT_MASK)
+#define UARTINT_UARTRXOFLOWERRINT_RESET                              0
+#define UARTINT_UARTRXFRAMINGERRINT_MSB                              2
+#define UARTINT_UARTRXFRAMINGERRINT_LSB                              2
+#define UARTINT_UARTRXFRAMINGERRINT_MASK                             0x00000004
+#define UARTINT_UARTRXFRAMINGERRINT_GET(x)                           (((x) & UARTINT_UARTRXFRAMINGERRINT_MASK) >> UARTINT_UARTRXFRAMINGERRINT_LSB)
+#define UARTINT_UARTRXFRAMINGERRINT_SET(x)                           (((0 | (x)) << UARTINT_UARTRXFRAMINGERRINT_LSB) & UARTINT_UARTRXFRAMINGERRINT_MASK)
+#define UARTINT_UARTRXFRAMINGERRINT_RESET                            0
+#define UARTINT_UARTTXREADYINT_MSB                                   1
+#define UARTINT_UARTTXREADYINT_LSB                                   1
+#define UARTINT_UARTTXREADYINT_MASK                                  0x00000002
+#define UARTINT_UARTTXREADYINT_GET(x)                                (((x) & UARTINT_UARTTXREADYINT_MASK) >> UARTINT_UARTTXREADYINT_LSB)
+#define UARTINT_UARTTXREADYINT_SET(x)                                (((0 | (x)) << UARTINT_UARTTXREADYINT_LSB) & UARTINT_UARTTXREADYINT_MASK)
+#define UARTINT_UARTTXREADYINT_RESET                                 0
+#define UARTINT_UARTRXVALIDINT_MSB                                   0
+#define UARTINT_UARTRXVALIDINT_LSB                                   0
+#define UARTINT_UARTRXVALIDINT_MASK                                  0x00000001
+#define UARTINT_UARTRXVALIDINT_GET(x)                                (((x) & UARTINT_UARTRXVALIDINT_MASK) >> UARTINT_UARTRXVALIDINT_LSB)
+#define UARTINT_UARTRXVALIDINT_SET(x)                                (((0 | (x)) << UARTINT_UARTRXVALIDINT_LSB) & UARTINT_UARTRXVALIDINT_MASK)
+#define UARTINT_UARTRXVALIDINT_RESET                                 0
+#define UARTINT_ADDRESS                                              0x000c
+#define UARTINT_HW_MASK                                              0x000003ff
+#define UARTINT_SW_MASK                                              0x000003ff
+#define UARTINT_RSTMASK                                              0x000003ff
+#define UARTINT_RESET                                                0x00000000
+
+// 0x0010 (UARTINTEN)
+#define UARTINTEN_UARTTXEMPTYINTEN_MSB                               9
+#define UARTINTEN_UARTTXEMPTYINTEN_LSB                               9
+#define UARTINTEN_UARTTXEMPTYINTEN_MASK                              0x00000200
+#define UARTINTEN_UARTTXEMPTYINTEN_GET(x)                            (((x) & UARTINTEN_UARTTXEMPTYINTEN_MASK) >> UARTINTEN_UARTTXEMPTYINTEN_LSB)
+#define UARTINTEN_UARTTXEMPTYINTEN_SET(x)                            (((0 | (x)) << UARTINTEN_UARTTXEMPTYINTEN_LSB) & UARTINTEN_UARTTXEMPTYINTEN_MASK)
+#define UARTINTEN_UARTTXEMPTYINTEN_RESET                             0
+#define UARTINTEN_UARTRXFULLINTEN_MSB                                8
+#define UARTINTEN_UARTRXFULLINTEN_LSB                                8
+#define UARTINTEN_UARTRXFULLINTEN_MASK                               0x00000100
+#define UARTINTEN_UARTRXFULLINTEN_GET(x)                             (((x) & UARTINTEN_UARTRXFULLINTEN_MASK) >> UARTINTEN_UARTRXFULLINTEN_LSB)
+#define UARTINTEN_UARTRXFULLINTEN_SET(x)                             (((0 | (x)) << UARTINTEN_UARTRXFULLINTEN_LSB) & UARTINTEN_UARTRXFULLINTEN_MASK)
+#define UARTINTEN_UARTRXFULLINTEN_RESET                              0
+#define UARTINTEN_UARTRXBREAKOFFINTEN_MSB                            7
+#define UARTINTEN_UARTRXBREAKOFFINTEN_LSB                            7
+#define UARTINTEN_UARTRXBREAKOFFINTEN_MASK                           0x00000080
+#define UARTINTEN_UARTRXBREAKOFFINTEN_GET(x)                         (((x) & UARTINTEN_UARTRXBREAKOFFINTEN_MASK) >> UARTINTEN_UARTRXBREAKOFFINTEN_LSB)
+#define UARTINTEN_UARTRXBREAKOFFINTEN_SET(x)                         (((0 | (x)) << UARTINTEN_UARTRXBREAKOFFINTEN_LSB) & UARTINTEN_UARTRXBREAKOFFINTEN_MASK)
+#define UARTINTEN_UARTRXBREAKOFFINTEN_RESET                          0
+#define UARTINTEN_UARTRXBREAKONINTEN_MSB                             6
+#define UARTINTEN_UARTRXBREAKONINTEN_LSB                             6
+#define UARTINTEN_UARTRXBREAKONINTEN_MASK                            0x00000040
+#define UARTINTEN_UARTRXBREAKONINTEN_GET(x)                          (((x) & UARTINTEN_UARTRXBREAKONINTEN_MASK) >> UARTINTEN_UARTRXBREAKONINTEN_LSB)
+#define UARTINTEN_UARTRXBREAKONINTEN_SET(x)                          (((0 | (x)) << UARTINTEN_UARTRXBREAKONINTEN_LSB) & UARTINTEN_UARTRXBREAKONINTEN_MASK)
+#define UARTINTEN_UARTRXBREAKONINTEN_RESET                           0
+#define UARTINTEN_UARTRXPARITYERRINTEN_MSB                           5
+#define UARTINTEN_UARTRXPARITYERRINTEN_LSB                           5
+#define UARTINTEN_UARTRXPARITYERRINTEN_MASK                          0x00000020
+#define UARTINTEN_UARTRXPARITYERRINTEN_GET(x)                        (((x) & UARTINTEN_UARTRXPARITYERRINTEN_MASK) >> UARTINTEN_UARTRXPARITYERRINTEN_LSB)
+#define UARTINTEN_UARTRXPARITYERRINTEN_SET(x)                        (((0 | (x)) << UARTINTEN_UARTRXPARITYERRINTEN_LSB) & UARTINTEN_UARTRXPARITYERRINTEN_MASK)
+#define UARTINTEN_UARTRXPARITYERRINTEN_RESET                         0
+#define UARTINTEN_UARTTXOFLOWERRINTEN_MSB                            4
+#define UARTINTEN_UARTTXOFLOWERRINTEN_LSB                            4
+#define UARTINTEN_UARTTXOFLOWERRINTEN_MASK                           0x00000010
+#define UARTINTEN_UARTTXOFLOWERRINTEN_GET(x)                         (((x) & UARTINTEN_UARTTXOFLOWERRINTEN_MASK) >> UARTINTEN_UARTTXOFLOWERRINTEN_LSB)
+#define UARTINTEN_UARTTXOFLOWERRINTEN_SET(x)                         (((0 | (x)) << UARTINTEN_UARTTXOFLOWERRINTEN_LSB) & UARTINTEN_UARTTXOFLOWERRINTEN_MASK)
+#define UARTINTEN_UARTTXOFLOWERRINTEN_RESET                          0
+#define UARTINTEN_UARTRXOFLOWERRINTEN_MSB                            3
+#define UARTINTEN_UARTRXOFLOWERRINTEN_LSB                            3
+#define UARTINTEN_UARTRXOFLOWERRINTEN_MASK                           0x00000008
+#define UARTINTEN_UARTRXOFLOWERRINTEN_GET(x)                         (((x) & UARTINTEN_UARTRXOFLOWERRINTEN_MASK) >> UARTINTEN_UARTRXOFLOWERRINTEN_LSB)
+#define UARTINTEN_UARTRXOFLOWERRINTEN_SET(x)                         (((0 | (x)) << UARTINTEN_UARTRXOFLOWERRINTEN_LSB) & UARTINTEN_UARTRXOFLOWERRINTEN_MASK)
+#define UARTINTEN_UARTRXOFLOWERRINTEN_RESET                          0
+#define UARTINTEN_UARTRXFRAMINGERRINTEN_MSB                          2
+#define UARTINTEN_UARTRXFRAMINGERRINTEN_LSB                          2
+#define UARTINTEN_UARTRXFRAMINGERRINTEN_MASK                         0x00000004
+#define UARTINTEN_UARTRXFRAMINGERRINTEN_GET(x)                       (((x) & UARTINTEN_UARTRXFRAMINGERRINTEN_MASK) >> UARTINTEN_UARTRXFRAMINGERRINTEN_LSB)
+#define UARTINTEN_UARTRXFRAMINGERRINTEN_SET(x)                       (((0 | (x)) << UARTINTEN_UARTRXFRAMINGERRINTEN_LSB) & UARTINTEN_UARTRXFRAMINGERRINTEN_MASK)
+#define UARTINTEN_UARTRXFRAMINGERRINTEN_RESET                        0
+#define UARTINTEN_UARTTXREADYINTEN_MSB                               1
+#define UARTINTEN_UARTTXREADYINTEN_LSB                               1
+#define UARTINTEN_UARTTXREADYINTEN_MASK                              0x00000002
+#define UARTINTEN_UARTTXREADYINTEN_GET(x)                            (((x) & UARTINTEN_UARTTXREADYINTEN_MASK) >> UARTINTEN_UARTTXREADYINTEN_LSB)
+#define UARTINTEN_UARTTXREADYINTEN_SET(x)                            (((0 | (x)) << UARTINTEN_UARTTXREADYINTEN_LSB) & UARTINTEN_UARTTXREADYINTEN_MASK)
+#define UARTINTEN_UARTTXREADYINTEN_RESET                             0
+#define UARTINTEN_UARTRXVALIDINTEN_MSB                               0
+#define UARTINTEN_UARTRXVALIDINTEN_LSB                               0
+#define UARTINTEN_UARTRXVALIDINTEN_MASK                              0x00000001
+#define UARTINTEN_UARTRXVALIDINTEN_GET(x)                            (((x) & UARTINTEN_UARTRXVALIDINTEN_MASK) >> UARTINTEN_UARTRXVALIDINTEN_LSB)
+#define UARTINTEN_UARTRXVALIDINTEN_SET(x)                            (((0 | (x)) << UARTINTEN_UARTRXVALIDINTEN_LSB) & UARTINTEN_UARTRXVALIDINTEN_MASK)
+#define UARTINTEN_UARTRXVALIDINTEN_RESET                             0
+#define UARTINTEN_ADDRESS                                            0x0010
+#define UARTINTEN_HW_MASK                                            0x000003ff
+#define UARTINTEN_SW_MASK                                            0x000003ff
+#define UARTINTEN_RSTMASK                                            0x000003ff
+#define UARTINTEN_RESET                                              0x00000000
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/image.h u-boot_1.1//include/image.h
--- u-boot//include/image.h	2014-02-18 01:46:23.519050021 -0800
+++ u-boot_1.1//include/image.h	2014-02-18 01:46:29.063053891 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2000-2005
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -131,7 +133,7 @@
 #define IH_COMP_NONE		0	/*  No	 Compression Used	*/
 #define IH_COMP_GZIP		1	/* gzip	 Compression Used	*/
 #define IH_COMP_BZIP2		2	/* bzip2 Compression Used	*/
-#define IH_COMP_LZMA		3	/* lzma  Compression used	*/
+#define IH_COMP_LZMA		3	/* lzma  Compression Used	*/
 
 #define IH_MAGIC	0x27051956	/* Image Magic Number		*/
 #define IH_NMLEN		32	/* Image Name Length		*/
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/linux/mtd/mtd.h u-boot_1.1//include/linux/mtd/mtd.h
--- u-boot//include/linux/mtd/mtd.h	2014-02-18 01:46:23.527050026 -0800
+++ u-boot_1.1//include/linux/mtd/mtd.h	2014-02-18 01:46:29.075053900 -0800
@@ -1,7 +1,8 @@
 /*
- * $Id: mtd.h,v 1.56 2004/08/09 18:46:04 dmarlin Exp $
+ * $Id: //depot/sw/qca_main/components/bootloaders/u-boot-1.1.4/1.1/include/linux/mtd/mtd.h#3 $
  *
  * Copyright (C) 1999-2003 David Woodhouse <dwmw2@infradead.org> et al.
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
  *
  * Released under GPL
  */
@@ -60,6 +61,10 @@
 	u_int32_t ecctype;
 	u_int32_t eccsize;
 
+	u_int32_t erasesize_shift;
+	u_int32_t erasesize_mask;
+	u_int32_t writesize_shift;
+	u_int32_t writesize_mask;
 
 	/* Kernel-only stuff starts here. */
 	char *name;
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/linux/mtd/nand.h u-boot_1.1//include/linux/mtd/nand.h
--- u-boot//include/linux/mtd/nand.h	2014-02-18 01:46:23.527050026 -0800
+++ u-boot_1.1//include/linux/mtd/nand.h	2014-02-18 01:46:29.075053900 -0800
@@ -5,7 +5,9 @@
  *                     Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *
- * $Id: nand.h,v 1.68 2004/11/12 10:40:37 gleixner Exp $
+ *  Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * $Id: //depot/sw/qca_main/components/bootloaders/u-boot-1.1.4/1.1/include/linux/mtd/nand.h#3 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -348,6 +350,10 @@
 #define NAND_MFR_NATIONAL	0x8f
 #define NAND_MFR_RENESAS	0x07
 #define NAND_MFR_STMICRO	0x20
+#define NAND_MFR_HYNIX		0xad
+#define NAND_MFR_MICRON		0x2c
+#define NAND_MFR_AMD		0x01
+
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/nand.h u-boot_1.1//include/nand.h
--- u-boot//include/nand.h	2014-02-18 01:46:23.543050038 -0800
+++ u-boot_1.1//include/nand.h	2014-02-18 01:46:29.139053946 -0800
@@ -3,6 +3,8 @@
  * 2N Telekomunikace, a.s. <www.2n.cz>
  * Ladislav Michl <michl@2n.cz>
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -33,17 +35,17 @@
 extern int nand_curr_device;
 extern nand_info_t nand_info[];
 
-static inline int nand_read(nand_info_t *info, ulong ofs, ulong *len, u_char *buf)
+static inline int nand_read(nand_info_t *info, loff_t ofs, ulong *len, u_char *buf)
 {
 	return info->read(info, ofs, *len, (size_t *)len, buf);
 }
 
-static inline int nand_write(nand_info_t *info, ulong ofs, ulong *len, u_char *buf)
+static inline int nand_write(nand_info_t *info, loff_t ofs, ulong *len, u_char *buf)
 {
 	return info->write(info, ofs, *len, (size_t *)len, buf);
 }
 
-static inline int nand_block_isbad(nand_info_t *info, ulong ofs)
+static inline int nand_block_isbad(nand_info_t *info, loff_t ofs)
 {
 	return info->block_isbad(info, ofs);
 }
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/net.h u-boot_1.1//include/net.h
--- u-boot//include/net.h	2014-02-18 01:46:23.543050038 -0800
+++ u-boot_1.1//include/net.h	2014-02-18 01:46:29.139053946 -0800
@@ -4,6 +4,7 @@
  *	Copyright 1994 - 2000 Neil Russell.
  *	(See License)
  *
+ *	Copyright (c) 2013 Qualcomm Atheros, Inc.
  *
  * History
  *	9/16/00	  bor  adapted to TQM823L/STK8xxL board, RARP/TFTP boot added
@@ -268,7 +269,11 @@
  * maximum packet size =  1518
  * maximum packet size and multiple of 32 bytes =  1536
  */
+#ifdef CFG_ATHRHDR_EN
+#define PKTSIZE			1520
+#else
 #define PKTSIZE			1518
+#endif
 #define PKTSIZE_ALIGN		1536
 /*#define PKTSIZE		608*/
 
@@ -336,7 +341,11 @@
 extern int		NetRestartWrap;		/* Tried all network devices	*/
 #endif
 
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+typedef enum { BOOTP, RARP, ARP, TFTP, DHCP, PING, DNS, NFS, CDP, NETCONS, SNTP, ATHRHDR } proto_t;
+#else
 typedef enum { BOOTP, RARP, ARP, TFTP, DHCP, PING, DNS, NFS, CDP, NETCONS, SNTP } proto_t;
+#endif
 
 /* from net/net.c */
 extern char	BootFile[128];			/* Boot File name		*/
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//include/version.h u-boot_1.1//include/version.h
--- u-boot//include/version.h	2014-02-18 01:46:23.583050066 -0800
+++ u-boot_1.1//include/version.h	2014-02-18 01:46:29.255054027 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2000-2006
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -25,5 +27,6 @@
 #define	__VERSION_H__
 
 #include "version_autogenerated.h"
+#include "athversion.h"
 
 #endif	/* __VERSION_H__ */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//lib_bootstrap/bootstrap_board.c u-boot_1.1//lib_bootstrap/bootstrap_board.c
--- u-boot//lib_bootstrap/bootstrap_board.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//lib_bootstrap/bootstrap_board.c	2014-02-18 01:46:29.271054037 -0800
@@ -0,0 +1,479 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <devices.h>
+#include <version.h>
+#include <net.h>
+#include <environment.h>
+#ifdef CONFIG_DANUBE
+#include <asm-mips/danube.h>
+#include <configs/danube.h>
+#endif
+#include "LzmaWrapper.h"
+
+//#define DEBUG_ENABLE_BOOTSTRAP_PRINTF
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if ( ((CFG_ENV_ADDR+CFG_ENV_SIZE) < BOOTSTRAP_CFG_MONITOR_BASE) || \
+      (CFG_ENV_ADDR >= (BOOTSTRAP_CFG_MONITOR_BASE + CFG_MONITOR_LEN)) ) || \
+    defined(CFG_ENV_IS_IN_NVRAM)
+#define	TOTAL_MALLOC_LEN	(CFG_MALLOC_LEN + CFG_ENV_SIZE)
+#else
+#define	TOTAL_MALLOC_LEN	CFG_MALLOC_LEN
+#endif
+
+#undef DEBUG
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+extern unsigned long nand_init(void);
+#endif
+
+#ifdef CONFIG_SERIAL_FLASH
+extern int serial_flash_init (void);
+#endif
+
+extern int timer_init(void);
+
+extern int incaip_set_cpuclk(void);
+
+extern ulong uboot_end_data_bootstrap;
+extern ulong uboot_end_bootstrap;
+
+ulong monitor_flash_len;
+
+const char version_string[] =
+	U_BOOT_VERSION" (" __DATE__ " - " __TIME__ ")";
+
+static char *failed = "*** failed ***\n";
+
+/*
+ * Begin and End of memory area for malloc(), and current "brk"
+ */
+static ulong mem_malloc_start;
+static ulong mem_malloc_end;
+static ulong mem_malloc_brk;
+
+
+/*
+ * The Malloc area is immediately below the monitor copy in DRAM
+ */
+static void mem_malloc_init (ulong dest_addr)
+{
+//	ulong dest_addr = BOOTSTRAP_CFG_MONITOR_BASE + gd->reloc_off;
+
+	mem_malloc_end = dest_addr;
+	mem_malloc_start = dest_addr - TOTAL_MALLOC_LEN;
+	mem_malloc_brk = mem_malloc_start;
+
+	memset ((void *) mem_malloc_start,
+		0,
+		mem_malloc_end - mem_malloc_start);
+}
+
+void *malloc(unsigned int size)
+{
+	if(size < (mem_malloc_end - mem_malloc_start))
+	{
+		mem_malloc_start += size;
+		return (void *)(mem_malloc_start - size);
+	}
+	return NULL;
+}
+
+void *realloc(void *src,unsigned int size)
+{
+	return NULL;
+}
+
+void free(void *src)
+{
+	return;
+}
+
+
+void *sbrk (ptrdiff_t increment)
+{
+	ulong old = mem_malloc_brk;
+	ulong new = old + increment;
+
+	if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
+		return (NULL);
+	}
+	mem_malloc_brk = new;
+	return ((void *) old);
+}
+
+
+static int init_func_ram (void)
+{
+#ifdef	CONFIG_BOARD_TYPES
+	int board_type = gd->board_type;
+#else
+	int board_type = 0;	/* use dummy arg */
+#endif
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	puts ("DRAM:  ");
+#endif
+
+	if ((gd->ram_size = initdram (board_type)) > 0) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		print_size (gd->ram_size, "\n");
+#endif
+		return (0);
+	}
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	puts (failed);
+#endif
+	return (1);
+}
+
+static int display_banner(void)
+{
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf ("\n\n%s\n\n", version_string);
+#endif
+	return (0);
+}
+
+static int init_baudrate (void)
+{
+#if 0
+	char tmp[64];	/* long enough for environment variables */
+	int i = getenv_r ("baudrate", tmp, sizeof (tmp));
+
+	gd->baudrate = (i > 0)
+			? (int) simple_strtoul (tmp, NULL, 10)
+			: CONFIG_BAUDRATE;
+#endif
+
+	gd->baudrate = CONFIG_BAUDRATE;
+
+	return (0);
+}
+#ifdef CONFIG_DANUBE
+static void init_led(void)
+{
+
+  *(unsigned long *)0xBE100B18 |=  0x70;
+  *(unsigned long *)0xBE100B1C |=  0x70;
+  *(unsigned long *)0xBE100B20 &= ~0x70;
+  *(unsigned long *)0xBE100B24 |=  0x70;
+#ifdef USE_REFERENCE_BOARD
+
+  *DANUBE_LED_CON1 = 0x00000003;
+  *DANUBE_LED_CPU0 = 0x0000010;
+  *DANUBE_LED_CPU1 = 0x00000000;
+  *DANUBE_LED_AR   = 0x00000000;
+  *DANUBE_LED_CON0 = 0x84000000;
+
+#else
+
+  *DANUBE_LED_CON1 = 0x00000007;
+  *DANUBE_LED_CPU0 = 0x00001000;
+  *DANUBE_LED_CPU1 = 0x00000000;
+  *DANUBE_LED_AR   = 0x00000000;
+  *DANUBE_LED_CON0 = 0x84000000;
+
+#endif
+
+}
+#endif
+/*
+ * Breath some life into the board...
+ *
+ * The first part of initialization is running from Flash memory;
+ * its main purpose is to initialize the RAM so that we
+ * can relocate the monitor code to RAM.
+ */
+
+/*
+ * All attempts to come up with a "common" initialization sequence
+ * that works for all boards and architectures failed: some of the
+ * requirements are just _too_ different. To get rid of the resulting
+ * mess of board dependend #ifdef'ed code we now make the whole
+ * initialization sequence configurable to the user.
+ *
+ * The requirements for any new initalization function is simple: it
+ * receives a pointer to the "global data" structure as it's only
+ * argument, and returns an integer return code, where 0 means
+ * "continue" and != 0 means "fatal error, hang the system".
+ */
+typedef int (init_fnc_t) (void);
+
+init_fnc_t *init_sequence[] = {
+	timer_init,
+	//env_init,		/* initialize environment */
+#ifdef CONFIG_INCA_IP
+	incaip_set_cpuclk,	/* set cpu clock according to environment variable */
+#endif
+	serial_init,		/* serial communications setup */
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	init_baudrate,		/* initialze baudrate settings */
+	console_init_f,
+	display_banner,		/* say that we are here */
+#endif
+	init_func_ram,
+#if !defined(ATH_NO_PCI_INIT) && !defined(CONFIG_WASP_SUPPORT)
+	pci_init_board,
+#endif
+	NULL,
+};
+
+
+void bootstrap_board_init_f(ulong bootflag)
+{
+	gd_t gd_data, *id;
+	bd_t *bd;
+	init_fnc_t **init_fnc_ptr;
+	ulong addr, addr_sp, len = (ulong)&uboot_end_bootstrap - BOOTSTRAP_CFG_MONITOR_BASE;
+	ulong *s;
+	ulong lzmaImageaddr  = 0;
+#ifdef CONFIG_PURPLE
+	void copy_code (ulong);
+#endif
+
+	/* Pointer is writable since we allocated a register for it.
+	 */
+	gd = &gd_data;
+	/* compiler optimization barrier needed for GCC >= 3.4 */
+	__asm__ __volatile__("": : :"memory");
+
+	memset ((void *)gd, 0, sizeof (gd_t));
+
+	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
+		if ((*init_fnc_ptr)() != 0) {
+			hang ();
+		}
+	}
+
+	/*
+	 * Now that we have DRAM mapped and working, we can
+	 * relocate the code and continue running from DRAM.
+	 */
+	addr = CFG_SDRAM_BASE + gd->ram_size;
+
+	/* We can reserve some RAM "on top" here.
+	 */
+
+	/* round down to next 4 kB limit.
+	 */
+	addr &= ~(4096 - 1);
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Top of RAM usable for U-Boot at: %08lx\n", addr);
+#endif
+	/* Reserve memory for U-Boot code, data & bss
+	 * round down to next 16 kB limit
+	 */
+	addr -= len;
+	addr &= ~(16 * 1024 - 1);
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Reserving %ldk for U-Boot at: %08lx\n", len >> 10, addr);
+#endif
+
+	 /* Reserve memory for malloc() arena.
+	 */
+	addr_sp = addr - TOTAL_MALLOC_LEN;
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Reserving %dk for malloc() at: %08lx\n",
+			TOTAL_MALLOC_LEN >> 10, addr_sp);
+#endif
+
+	/*
+	 * (permanently) allocate a Board Info struct
+	 * and a permanent copy of the "global" data
+	 */
+	addr_sp -= sizeof(bd_t);
+	bd = (bd_t *)addr_sp;
+	gd->bd = bd;
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Reserving %d Bytes for Board Info at: %08lx\n",
+			sizeof(bd_t), addr_sp);
+#endif
+
+	addr_sp -= sizeof(gd_t);
+	id = (gd_t *)addr_sp;
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Reserving %d Bytes for Global Data at: %08lx\n",
+			sizeof (gd_t), addr_sp);
+#endif
+ 	/* Reserve memory for boot params.
+	 */
+	addr_sp -= CFG_BOOTPARAMS_LEN;
+	bd->bi_boot_params = addr_sp;
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Reserving %dk for boot params() at: %08lx\n",
+			CFG_BOOTPARAMS_LEN >> 10, addr_sp);
+#endif
+	/*
+	 * Finally, we set up a new (bigger) stack.
+	 *
+	 * Leave some safety gap for SP, force alignment on 16 byte boundary
+	 * Clear initial stack frame
+	 */
+	addr_sp -= 16;
+	addr_sp &= ~0xF;
+	s = (ulong *)addr_sp;
+	*s-- = 0;
+	*s-- = 0;
+	addr_sp = (ulong)s;
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Stack Pointer at: %08lx\n", addr_sp);
+#endif
+	/*
+	 * Save local variables to board info struct
+	 */
+	bd->bi_memstart	= CFG_SDRAM_BASE;	/* start of  DRAM memory */
+	bd->bi_memsize	= gd->ram_size;		/* size  of  DRAM memory in bytes */
+	bd->bi_baudrate	= gd->baudrate;		/* Console Baudrate */
+
+	memcpy (id, (void *)gd, sizeof (gd_t));
+
+	/* On the purple board we copy the code in a special way
+	 * in order to solve flash problems
+	 */
+#ifdef CONFIG_PURPLE
+	copy_code(addr);
+#endif
+
+	lzmaImageaddr = (ulong)&uboot_end_data_bootstrap;
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf ("\n relocating to address %08x ", addr);
+#endif
+
+	bootstrap_relocate_code (addr_sp, id, addr);
+
+	/* NOTREACHED - relocate_code() does not return */
+}
+/************************************************************************
+ *
+ * This is the next part if the initialization sequence: we are now
+ * running from RAM and have a "normal" C environment, i. e. global
+ * data can be written, BSS has been cleared, the stack size in not
+ * that critical any more, etc.
+ *
+ ************************************************************************
+ */
+
+void bootstrap_board_init_r (gd_t *id, ulong dest_addr)
+{
+	int i;
+
+	ulong	addr;
+	ulong	data, len, checksum;
+	ulong  *len_ptr;
+	image_header_t header;
+	image_header_t *hdr = &header;
+	unsigned int destLen;
+	int (*fn)(int);
+
+	/* initialize malloc() area */
+	mem_malloc_init(dest_addr);
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf("\n Compressed Image at %08x \n ", (BOOTSTRAP_CFG_MONITOR_BASE + ((ulong)&uboot_end_data_bootstrap - dest_addr)));
+#endif
+
+	addr = (char *)(BOOTSTRAP_CFG_MONITOR_BASE + ((ulong)&uboot_end_data_bootstrap - dest_addr));
+	memmove (&header, (char *)addr, sizeof(image_header_t));
+
+	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		printf ("Bad Magic Number at address 0x%08lx\n",addr);
+#endif
+		return;
+	}
+
+	data = (ulong)&header;
+	len  = sizeof(image_header_t);
+
+	checksum = ntohl(hdr->ih_hcrc);
+	hdr->ih_hcrc = 0;
+	if (crc32 (0, (char *)data, len) != checksum) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		printf ("Bad Header Checksum\n");
+#endif
+		return;
+	}
+
+	data = addr + sizeof(image_header_t);
+	len  = ntohl(hdr->ih_size);
+
+	len_ptr = (ulong *)data;
+
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf ("Disabling all the interrupts\n");
+#endif
+	disable_interrupts();
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf ("   Uncompressing UBoot Image ... \n" );
+#endif
+
+	/*
+	 * If we've got less than 4 MB of malloc() space,
+	 * use slower decompression algorithm which requires
+	 * at most 2300 KB of memory.
+	 */
+	destLen = 0x0;
+
+#ifdef CONFIG_LZMA 
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf ("U-Boot uncompress address %08x\n ",hdr->ih_load);
+#endif
+	i = lzma_inflate ((unsigned char *)data, len, (unsigned char*)ntohl(hdr->ih_load), &destLen);
+	if (i != LZMA_RESULT_OK) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		printf ("LZMA ERROR %d - must RESET board to recover\n", i);
+#endif
+		//do_reset (cmdtp, flag, argc, argv);
+		return;
+	}
+#endif
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf ("Uncompression completed successfully with destLen %d\n ",destLen );
+	printf ("U-Boot Load address %08x\n ",hdr->ih_load);
+#endif
+
+        fn = ntohl(hdr->ih_load);
+
+	(*fn)(gd->ram_size);
+
+	hang ();
+}
+
+void hang (void)
+{
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	puts ("### ERROR ### Please RESET the board ###\n");
+#endif
+	for (;;);
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//lib_bootstrap/Makefile u-boot_1.1//lib_bootstrap/Makefile
--- u-boot//lib_bootstrap/Makefile	2014-02-18 01:46:23.599050077 -0800
+++ u-boot_1.1//lib_bootstrap/Makefile	2014-02-18 01:46:29.271054037 -0800
@@ -1,6 +1,7 @@
 #
 # (C) Copyright 2003
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
 #
 # See file CREDITS for list of people who contributed to this
 # project.
@@ -25,17 +26,19 @@
 
 LIB	= libbootstrap.a
 
-#OBJS_PRINTF_ENABLED	= bootstrap_board.o time.o console.o LzmaWrapper.o LzmaDecode.o crc32.o ctype.o display_options.o string.o vsprintf.o lists.o devices.o
-#OBJS_PRINTF_DISBALED	= bootstrap_board.o LzmaDecode.o string.o crc32.o LzmaWrapper.o 
+OBJS	= bootstrap_board.o LzmaDecode.o string.o crc32.o LzmaWrapper.o time.o
+#OBJS	= bootstrap_board.o LzmaDecode.o string.o crc32.o LzmaWrapper.o ctype.o display_options.o string.o vsprintf.o lists.o devices.o console.o time.o
 
-OBJS	= bootstrap_board_$(BOARDDIR).o LzmaDecode.o string.o crc32.o LzmaWrapper.o 
+#BOOTSTRAP_PRINTF_STATUS = BOOTSTRAP_PRINTF_ENABLED
 
 ifeq ($(BOOTSTRAP_PRINTF_STATUS), BOOTSTRAP_PRINTF_ENABLED)
 #overwrite objs
-OBJS	= bootstrap_board_$(BOARDDIR).o time.o console.o LzmaWrapper.o LzmaDecode.o crc32.o ctype.o display_options.o string.o vsprintf.o lists.o devices.o
+OBJS	= bootstrap_board.o time.o console.o LzmaWrapper.o LzmaDecode.o crc32.o ctype.o display_options.o string.o vsprintf.o lists.o devices.o
 CFLAGS += -DDEBUG_ENABLE_BOOTSTRAP_PRINTF
 endif
 
+CFLAGS += -DCONFIG_LZMA=1
+
 all:	.depend $(LIB)
 
 $(LIB):	$(OBJS)
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//lib_generic/LzmaDecode.c u-boot_1.1//lib_generic/LzmaDecode.c
--- u-boot//lib_generic/LzmaDecode.c	2014-02-18 01:46:23.603050079 -0800
+++ u-boot_1.1//lib_generic/LzmaDecode.c	2014-02-18 01:46:29.275054040 -0800
@@ -19,8 +19,6 @@
   to this file, however, are subject to the LGPL or CPL terms.
 */
 
-#include <config.h>
-
 #ifdef CONFIG_LZMA
 
 #include "LzmaDecode.h"
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//lib_generic/Makefile u-boot_1.1//lib_generic/Makefile
--- u-boot//lib_generic/Makefile	2014-02-18 01:46:23.603050079 -0800
+++ u-boot_1.1//lib_generic/Makefile	2014-02-18 01:46:29.275054040 -0800
@@ -2,6 +2,8 @@
 # (C) Copyright 2000-2002
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
 # See file CREDITS for list of people who contributed to this
 # project.
 #
@@ -25,10 +27,18 @@
 
 LIB	= libgeneric.a
 
+ifeq ($(COMPRESSED_UBOOT),1)
+OBJS    = crc32.o ctype.o display_options.o ldiv.o \
+			string.o vsprintf.o LzmaWrapper.o LzmaDecode.o
+else
 OBJS	= bzlib.o bzlib_crctable.o bzlib_decompress.o \
 	  bzlib_randtable.o bzlib_huffman.o \
 	  crc32.o ctype.o display_options.o ldiv.o \
-	  string.o vsprintf.o zlib.o
+	  string.o vsprintf.o zlib.o LzmaDecode.o LzmaWrapper.o
+endif
+
+CFLAGS += -DCONFIG_LZMA=1
+
 
 $(LIB):	.depend $(OBJS)
 	$(AR) crv $@ $(OBJS)
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//lib_generic/zlib.c u-boot_1.1//lib_generic/zlib.c
--- u-boot//lib_generic/zlib.c	2014-02-18 01:46:23.615050088 -0800
+++ u-boot_1.1//lib_generic/zlib.c	2014-02-18 01:46:29.331054076 -0800
@@ -16,6 +16,8 @@
 /* zutil.h -- internal interface and configuration of the compression library
  * Copyright (C) 1995 Jean-loup Gailly.
  * For conditions of distribution and use, see copyright notice in zlib.h
+ *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
  */
 
 /* WARNING: this file should *not* be used by applications. It is
@@ -2101,7 +2103,9 @@
 
 /* From: zutil.c,v 1.8 1995/05/03 17:27:12 jloup Exp */
 
+#ifndef COMPRESSED_UBOOT
 char *zlib_version = ZLIB_VERSION;
+#endif
 
 char *z_errmsg[] = {
 "stream end",          /* Z_STREAM_END    1 */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//lib_mips/board.c u-boot_1.1//lib_mips/board.c
--- u-boot//lib_mips/board.c	2014-02-18 01:46:23.623050094 -0800
+++ u-boot_1.1//lib_mips/board.c	2014-02-18 01:46:29.411054132 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2003
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -45,6 +47,13 @@
 
 extern int incaip_set_cpuclk(void);
 
+#if defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x) || defined(CONFIG_MACH_QCA956x)
+void ath_set_tuning_caps(void);
+#else
+#define ath_set_tuning_caps()	/* nothing */
+#endif
+
+
 extern ulong uboot_end_data;
 extern ulong uboot_end;
 
@@ -113,6 +122,7 @@
 {
 
 	printf ("\n\n%s\n\n", version_string);
+
 	return (0);
 }
 
@@ -159,17 +169,23 @@
 typedef int (init_fnc_t) (void);
 
 init_fnc_t *init_sequence[] = {
+#ifndef COMPRESSED_UBOOT
 	timer_init,
+#endif
 	env_init,		/* initialize environment */
 #ifdef CONFIG_INCA_IP
 	incaip_set_cpuclk,	/* set cpu clock according to environment variable */
 #endif
 	init_baudrate,		/* initialze baudrate settings */
+#ifndef COMPRESSED_UBOOT
 	serial_init,		/* serial communications setup */
+#endif
 	console_init_f,
 	display_banner,		/* say that we are here */
+#ifndef COMPRESSED_UBOOT
 	checkboard,
-	init_func_ram,
+        init_func_ram,
+#endif
 	NULL,
 };
 
@@ -181,10 +197,14 @@
 	init_fnc_t **init_fnc_ptr;
 	ulong addr, addr_sp, len = (ulong)&uboot_end - CFG_MONITOR_BASE;
 	ulong *s;
+#ifdef COMPRESSED_UBOOT
+        char board_string[50];
+#endif
 #ifdef CONFIG_PURPLE
 	void copy_code (ulong);
 #endif
 
+
 	/* Pointer is writable since we allocated a register for it.
 	 */
 	gd = &gd_data;
@@ -199,6 +219,14 @@
 		}
 	}
 
+#ifdef COMPRESSED_UBOOT
+        checkboard(board_string);
+        printf("%s\n\n",board_string);
+        gd->ram_size = bootflag;
+	puts ("DRAM:  ");
+	print_size (gd->ram_size, "\n");
+#endif
+
 	/*
 	 * Now that we have DRAM mapped and working, we can
 	 * relocate the code and continue running from DRAM.
@@ -301,6 +329,9 @@
 #ifndef CFG_ENV_IS_NOWHERE
 	extern char * env_name_spec;
 #endif
+#ifdef CONFIG_ATH_NAND_SUPPORT
+	extern ulong ath_nand_init(void);
+#endif
 	char *s, *e;
 	bd_t *bd;
 	int i;
@@ -347,9 +378,11 @@
 	env_name_spec += gd->reloc_off;
 #endif
 
+#ifndef CONFIG_ATH_NAND_BR
 	/* configure available FLASH banks */
 	size = flash_init();
 	display_flash_config (size);
+#endif
 
 	bd = gd->bd;
 	bd->bi_flashstart = CFG_FLASH_BASE;
@@ -364,6 +397,10 @@
 	mem_malloc_init();
 	malloc_bin_reloc();
 
+#ifdef CONFIG_ATH_NAND_BR
+	ath_nand_init();
+#endif
+
 	/* relocate environment function pointers etc. */
 	env_relocate();
 
@@ -417,6 +454,12 @@
 	eth_initialize(gd->bd);
 #endif
 
+#if defined(CONFIG_ATH_NAND_SUPPORT) && !defined(CONFIG_ATH_NAND_BR)
+	ath_nand_init();
+#endif
+
+        ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */
+
 	/* main_loop() can return to retry autoboot, if so just run it again. */
 	for (;;) {
 		main_loop ();
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//lib_mips/mips_linux.c u-boot_1.1//lib_mips/mips_linux.c
--- u-boot//lib_mips/mips_linux.c	2014-02-18 01:46:23.623050094 -0800
+++ u-boot_1.1//lib_mips/mips_linux.c	2014-02-18 01:46:29.411054132 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2003
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -28,6 +30,9 @@
 #include <asm/byteorder.h>
 #include <asm/addrspace.h>
 
+#ifdef CONFIG_AR7240
+#include <ar7240_soc.h>
+#endif
 DECLARE_GLOBAL_DATA_PTR;
 
 #define	LINUX_MAX_ENVS		256
@@ -54,6 +59,18 @@
 static void linux_params_init (ulong start, char * commandline);
 static void linux_env_set (char * env_name, char * env_val);
 
+#ifdef CONFIG_WASP_SUPPORT
+void wasp_set_cca(void)
+{
+	/* set cache coherency attribute */
+	asm(	"mfc0	$t0,	$16\n"		/* CP0_CONFIG == 16 */
+		"li	$t1,	~7\n"
+		"and	$t0,	$t0,	$t1\n"
+		"ori	$t0,	3\n"		/* CONF_CM_CACHABLE_NONCOHERENT */
+		"mtc0	$t0,	$16\n"		/* CP0_CONFIG == 16 */
+		"nop\n": : );
+}
+#endif
 
 void do_bootm_linux (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[],
 		     ulong addr, ulong * len_ptr, int verify)
@@ -61,13 +78,24 @@
 	ulong len = 0, checksum;
 	ulong initrd_start, initrd_end;
 	ulong data;
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+	int flash_size_mbytes;
+	void (*theKernel) (int, char **, char **, int);
+#else
 	void (*theKernel) (int, char **, char **, int *);
+#endif
 	image_header_t *hdr = &header;
 	char *commandline = getenv ("bootargs");
 	char env_buf[12];
 
+
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+	theKernel =
+		(void (*)(int, char **, char **, int)) ntohl (hdr->ih_ep);
+#else
 	theKernel =
 		(void (*)(int, char **, char **, int *)) ntohl (hdr->ih_ep);
+#endif
 
 	/*
 	 * Check if there is an initrd image
@@ -213,12 +241,22 @@
 	/* we assume that the kernel is in place */
 	printf ("\nStarting kernel ...\n\n");
 
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+#ifdef CONFIG_WASP_SUPPORT
+	wasp_set_cca();
+#endif
+	/* Pass the flash size as expected by current Linux kernel for AR7100 */
+	flash_size_mbytes = gd->bd->bi_flashsize/(1024 * 1024);
+	theKernel (linux_argc, linux_argv, linux_env, flash_size_mbytes);
+#else
 	theKernel (linux_argc, linux_argv, linux_env, 0);
+#endif
 }
 
 static void linux_params_init (ulong start, char *line)
 {
 	char *next, *quote, *argp;
+	char memstr[32];
 
 	linux_argc = 1;
 	linux_argv = (char **) start;
@@ -227,6 +265,12 @@
 
 	next = line;
 
+	if (strstr(line, "mem=")) {
+		memstr[0] = 0;
+	} else {
+		memstr[0] = 1;
+	}
+
 	while (line && *line && linux_argc < LINUX_MAX_ARGS) {
 		quote = strchr (line, '"');
 		next = strchr (line, ' ');
@@ -249,6 +293,18 @@
 		linux_argv[linux_argc] = argp;
 		memcpy (argp, line, next - line);
 		argp[next - line] = 0;
+#if defined(CONFIG_AR7240)
+#define REVSTR	"REVISIONID"
+#define PYTHON	"python"
+#define VIRIAN	"virian"
+		if (strcmp(argp, REVSTR) == 0) {
+			if (is_ar7241() || is_ar7242()) {
+				strcpy(argp, VIRIAN);
+			} else {
+				strcpy(argp, PYTHON);
+			}
+		}
+#endif
 
 		argp += next - line + 1;
 		linux_argc++;
@@ -259,6 +315,17 @@
 		line = next;
 	}
 
+#if defined(CONFIG_AR9100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+	/* Add mem size to command line */
+	if (memstr[0]) {
+		sprintf(memstr, "mem=%luM", gd->ram_size >> 20);
+		memcpy (argp, memstr, strlen(memstr)+1);
+		linux_argv[linux_argc] = argp;
+		linux_argc++;
+		argp += strlen(memstr) + 1;
+	}
+#endif
+
 	linux_env = (char **) (((ulong) argp + 15) & ~15);
 	linux_env[0] = 0;
 	linux_env_p = (char *) (linux_env + LINUX_MAX_ENVS);
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//MAKEALL u-boot_1.1//MAKEALL
--- u-boot//MAKEALL	2014-02-18 01:46:21.355048508 -0800
+++ u-boot_1.1//MAKEALL	2014-02-18 01:46:23.739050176 -0800
@@ -228,7 +228,10 @@
 
 LIST_au1xx0="dbau1000 dbau1100 dbau1500 dbau1550 dbau1550_el"
 
-LIST_mips="${LIST_mips4kc} ${LIST_mips5kc} ${LIST_au1xx0}"
+LIST_mips24k="ar7100"
+
+LIST_mips="${LIST_mips4kc} ${LIST_mips5kc} ${LIST_au1xx0} ${LIST_MIPS24k}"
+
 
 #########################################################################
 ## MIPS Systems		(little endian)
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//Makefile u-boot_1.1//Makefile
--- u-boot//Makefile	2014-02-18 01:46:21.355048508 -0800
+++ u-boot_1.1//Makefile	2014-02-18 01:46:23.759050188 -0800
@@ -2,6 +2,8 @@
 # (C) Copyright 2000-2006
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
 # See file CREDITS for list of people who contributed to this
 # project.
 #
@@ -49,6 +51,10 @@
 TOPDIR	:= $(shell if [ "$$PWD" != "" ]; then echo $$PWD; else pwd; fi)
 export	TOPDIR
 
+ifndef COMPRESSED_UBOOT
+COMPRESSED_UBOOT = 0
+endif 
+
 ifeq (include/config.mk,$(wildcard include/config.mk))
 # load ARCH, BOARD, and CPU configuration
 include include/config.mk
@@ -71,7 +77,7 @@
 endif
 endif
 ifeq ($(ARCH),mips)
-CROSS_COMPILE = mips_4KC-
+CROSS_COMPILE = mips-linux-
 endif
 ifeq ($(ARCH),nios)
 CROSS_COMPILE = nios-elf-
@@ -99,8 +105,12 @@
 
 #########################################################################
 # U-Boot objects....order is important (i.e. start must be first)
-
 OBJS  = cpu/$(CPU)/start.o
+
+ifeq ($(COMPRESSED_UBOOT),1)
+OBJS_BOOTSTRAP  = cpu/$(CPU)/start_bootstrap.o
+endif
+
 ifeq ($(CPU),i386)
 OBJS += cpu/$(CPU)/start16.o
 OBJS += cpu/$(CPU)/reset.o
@@ -120,25 +130,48 @@
 endif
 
 LIBS  = lib_generic/libgeneric.a
+LIBS += common/libcommon.a
 LIBS += board/$(BOARDDIR)/lib$(BOARD).a
 LIBS += cpu/$(CPU)/lib$(CPU).a
 ifdef SOC
 LIBS += cpu/$(CPU)/$(SOC)/lib$(SOC).a
 endif
 LIBS += lib_$(ARCH)/lib$(ARCH).a
-LIBS += fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a \
-	fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a
+
+#ifeq ($(KERNELVER),2.6.31)
+LIBS += drivers/libdrivers.a
+#endif
+#ifeq ($(COMPRESSED_UBOOT),0)
+#LIBS += fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a \
+#	fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a
+#LIBS += disk/libdisk.a
+#LIBS += dtt/libdtt.a
+#ifneq ($(KERNELVER),2.6.31)
+#LIBS += drivers/libdrivers.a
+#endif
+#LIBS += drivers/sk98lin/libsk98lin.a
+#endif
+
 LIBS += net/libnet.a
-LIBS += disk/libdisk.a
 LIBS += rtc/librtc.a
-LIBS += dtt/libdtt.a
-LIBS += drivers/libdrivers.a
-LIBS += drivers/sk98lin/libsk98lin.a
-LIBS += post/libpost.a post/cpu/libcpu.a
-LIBS += common/libcommon.a
+#LIBS += post/libpost.a post/cpu/libcpu.a
 LIBS += $(BOARDLIBS)
+
+ifeq ($(COMPRESSED_UBOOT),1)
+LIBS_BOOTSTRAP = lib_bootstrap/libbootstrap.a 
+#LIBS_BOOTSTRAP += lib_$(CPU)/lib$(CPU).a
+LIBS_BOOTSTRAP += board/$(BOARDDIR)/lib$(BOARD).a 
+LIBS_BOOTSTRAP += cpu/$(CPU)/lib$(CPU).a
+ifneq ($(SOC),)
+LIBS_BOOTSTRAP += cpu/$(CPU)/$(SOC)/lib$(SOC).a
+endif
+endif
 .PHONY : $(LIBS)
 
+ifeq ($(COMPRESSED_UBOOT),1)
+.PHONY : $(LIBS_BOOTSTRAP)
+endif
+
 # Add GCC lib
 PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc
 
@@ -146,7 +179,6 @@
 # The "tools" are needed early, so put this first
 # Don't include stuff already done in $(LIBS)
 SUBDIRS	= tools \
-	  examples \
 	  post \
 	  post/cpu
 .PHONY : $(SUBDIRS)
@@ -156,7 +188,11 @@
 
 ALL = u-boot.srec u-boot.bin System.map
 
+ifeq ($(COMPRESSED_UBOOT),1)
+all:		$(ALL) tuboot.bin
+else
 all:		$(ALL)
+endif
 
 u-boot.hex:	u-boot
 		$(OBJCOPY) ${OBJCFLAGS} -O ihex $< $@
@@ -179,7 +215,7 @@
 
 u-boot:		depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)
 		UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) |sed  -n -e 's/.*\(__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
-		$(LD) $(LDFLAGS) $$UNDEF_SYM $(OBJS) \
+		$(LD) $(LDFLAGS) $$UNDEF_SYM $(OBJS) $(BOARD_EXTRA_OBJS) \
 			--start-group $(LIBS) --end-group $(PLATFORM_LIBS) \
 			-Map u-boot.map -o u-boot
 
@@ -189,6 +225,34 @@
 $(SUBDIRS):
 		$(MAKE) -C $@ all
 
+ifeq ($(COMPRESSED_UBOOT),1)
+
+LZMA = $(BUILD_DIR)/util/lzma
+
+tuboot.bin:	System.map bootstrap.bin u-boot.lzimg	
+		@cat bootstrap.bin > $@
+		@cat u-boot.lzimg >> $@
+
+u-boot.lzimg: $(obj)u-boot.bin System.map 
+		@$(LZMA) e $(obj)u-boot.bin u-boot.bin.lzma
+		@./tools/mkimage -A mips -T firmware -C lzma \
+		-a 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-n 'u-boot image' -d $(obj)u-boot.bin.lzma $@
+
+bootstrap.bin:	bootstrap
+		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+bootstrap:	depend version $(SUBDIRS) $(OBJS_BOOTSTRAP) $(LIBS_BOOTSTRAP) $(LDSCRIPT_BOOTSTRAP)
+		UNDEF_SYM=`$(OBJDUMP) -x $(LIBS_BOOTSTRAP) |sed  -n -e 's/.*\(__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
+		$(LD) $(LDFLAGS_BOOTSTRAP) $$UNDEF_SYM $(OBJS_BOOTSTRAP) \
+			--start-group $(LIBS_BOOTSTRAP) --end-group $(PLATFORM_LIBS) \
+			-Map bootstrap.map -o bootstrap
+
+$(LIBS_BOOTSTRAP):
+		$(MAKE) -C `dirname $@`
+endif
+
 version:
 		@echo -n "#define U_BOOT_VERSION \"U-Boot " > $(VERSION_FILE); \
 		echo -n "$(U_BOOT_VERSION)" >> $(VERSION_FILE); \
@@ -1799,6 +1863,1526 @@
 purple_config :		unconfig
 	@./mkconfig $(@:_config=) mips mips purple
 
+#########################################################################
+## MIPS32 AR7100 (24K)
+#########################################################################
+tb225_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a tb225 mips mips tb225 ar7100 ar7100
+
+pb42_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a pb42 mips mips pb42 ar7100 ar7100
+
+tb243_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@echo "#define CONFIG_AR9100 1" >>include/config.h
+	@./mkconfig -a tb243 mips mips tb243 ar7100 ar7100
+
+ap83_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@echo "#define CONFIG_AR9100 1" >>include/config.h
+	@./mkconfig -a ap83 mips mips ap83 ar7100 ar7100
+
+ap81_config		: 	unconfig
+	@ >include/config.h
+	@echo '#ifndef _INCLUDE_CONFIG_H' >>include/config.h
+	@echo '#define _INCLUDE_CONFIG_H' >>include/config.h
+	@echo '#define CONFIG_AR7100 1' >>include/config.h
+	@echo '#define CONFIG_AR9100 1' >>include/config.h
+
+ifeq ($(CONFIG_AP81_CARRIER_CUS109), 1)
+	@echo '#define CONFIG_AP81_CUS109 1' >>include/config.h
+endif
+ifeq ($(BUILD_CONFIG), _4m)
+ifeq ($(CONFIG_CARRIER_4MB), 1)
+	@echo '#define BUILD_CONFIG_OVERRIDE 1' >>include/config.h
+	@echo '#define CFG_FLASH_SIZE 0x00400000' >>include/config.h
+	@echo '#define CONFIG_BOOTARGS "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7100-nor0:256k(u-boot),128k(u-boot-env),2112k(rootfs),384k(config),1024k(uImage),64k(nvram),64k(lang),64k(ART)"' >>include/config.h
+	@echo '#define MTDPARTS_DEFAULT "mtdparts=ar7100-nor0:256k(u-boot),128k(u-boot-env),2112k(rootfs),384k(config),1024k(uImage),64k(nvram),64k(lang),64k(ART)"' >>include/config.h
+	@echo '#define CONFIG_BOOTCOMMAND "bootm 0xbf300000"' >>include/config.h
+else
+	@echo '#define BUILD_CONFIG_OVERRIDE 1' >>include/config.h
+	@echo '#define CFG_FLASH_SIZE 0x00400000' >>include/config.h
+	@echo '#define CONFIG_BOOTARGS "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7100-nor0:256k(u-boot),64k(u-boot-env),2688k(rootfs),1024k(uImage),64k(ART)"' >>include/config.h
+	@echo '#define MTDPARTS_DEFAULT "mtdparts=ar7100-nor0:256k(u-boot),64k(u-boot-env),2688k(rootfs),1024k(uImage),64k(ART)"' >>include/config.h
+	@echo '#define CONFIG_BOOTCOMMAND "bootm 0xbf300000"' >>include/config.h
+endif
+endif
+	@echo '#endif /* _INCLUDE_CONFIG_H */' >>include/config.h
+	@./mkconfig -a ap81 mips mips ap81 ar7100 ar7100
+
+ap94_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a ap94 mips mips ap94 ar7100 ar7100
+
+ap94min_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a ap94min mips mips ap94 ar7100 ar7100
+
+pb44_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a pb44 mips mips pb44 ar7100 ar7100
+
+pb45_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a pb45 mips mips pb45 ar7100 ar7100
+
+pb47_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a pb47 mips mips pb47 ar7100 ar7100
+
+ap96_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a ap96 mips mips ap96 ar7100 ar7100
+
+cus97_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@echo "#define CONFIG_AR9100 1" >>include/config.h
+	@./mkconfig -a cus97 mips mips cus97 ar7100 ar7100
+ar7240_emu_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ar7240_emu mips mips ar7240_emu ar7240 ar7240
+
+wasp_emu_config			: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+	@./mkconfig -a wasp_emu mips mips wasp_emu ar7240 ar7240
+
+db12x_config			: 	unconfig
+	@ >include/config.h
+
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f2e)
+	@echo '#define CONFIG_F2E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1' >>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT  1' >>include/config.h
+endif
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+ifeq ($(DB12X_P2P_ENV), 1)
+        @echo "#define CONFIG_DB12X_P2P 1" >>include/config.h
+endif
+	@./mkconfig -a db12x mips mips db12x ar7240 ar7240
+
+board953x_config		:	unconfig
+	@ >include/config.h
+	@echo '#define CONFIG_ATHEROS		1'	>include/config.h
+	@echo '#define CONFIG_MACH_QCA953x	1'	>>include/config.h
+	@echo '#define CFG_INIT_STACK_IN_SRAM	1'	>>include/config.h
+	@echo '#define CONFIG_'`echo $(CFG_BOARD_TYPE) | tr [a-z] [A-Z] | sed s/-/_/g`'	1' >>include/config.h
+	@echo '#define __CONFIG_BOARD_NAME $(CFG_BOARD_TYPE)' >>include/config.h
+	@echo '#define CONFIG_BOARD_NAME "$(CFG_BOARD_TYPE)"' >>include/config.h
+	@echo "#define BUILD_VERSION "\"$(BUILDVERSION)\" >>include/config.h
+
+ifdef pll
+	@echo '#define CFG_PLL_FREQ		$(pll)'	>>include/config.h
+else
+	@echo '#define CFG_PLL_FREQ		CFG_PLL_550_400_200'	>>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS 1' >>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS 2' >>include/config.h
+endif
+
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a board953x mips mips board953x atheros
+
+ap120_config			: 	unconfig
+	@ >include/config.h
+
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f2e)
+	@echo '#define CONFIG_F2E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1' >>include/config.h
+endif
+ifeq ($(or $(BOOT_FROM_NAND),$(ATH_DUAL_FLASH)),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+endif
+	@./mkconfig -a ap120 mips mips ap120 ar7240 ar7240
+
+db12x-lte_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f2e)
+	@echo '#define CONFIG_F2E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+#
+# U-Boot from spi flash. Kernel & FS in NAND
+#
+ifdef ATH_DUAL_FLASH
+	@echo "#define ATH_DUAL_FLASH 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a db12x mips mips db12x ar7240 ar7240
+
+db12x-hgw_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f2e)
+	@echo '#define CONFIG_F2E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+ifneq ($(findstring db12x-hgw,$(BOARD_TYPE)),)
+	@echo '#define CONFIG_DB12X-HGW 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1' >>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+endif
+#
+# U-Boot from spi flash. Kernel & FS in NAND
+#
+ifdef ATH_DUAL_FLASH
+	@echo "#define ATH_DUAL_FLASH 1" >>include/config.h
+endif
+
+	@./mkconfig -a db12x-hybrid mips mips db12x-hybrid ar7240 ar7240
+
+zte-mf28l_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f2e)
+	@echo '#define CONFIG_F2E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1' >>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+endif
+
+	@./mkconfig -a db12x mips mips db12x ar7240 ar7240
+
+
+wah132_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a wah132 mips mips wah132 ar7240 ar7240
+
+reh132_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a reh132 mips mips reh132 ar7240 ar7240
+
+db12x-hybrid_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a db12x-hybrid mips mips db12x-hybrid ar7240 ar7240
+
+aph126_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a aph126 mips mips aph126 ar7240 ar7240
+
+aph128_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a aph128 mips mips aph128 ar7240 ar7240
+
+dhp1565_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a dhp1565 mips mips dhp1565 ar7240 ar7240
+
+
+db12x-extender_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a db12x-extender mips mips db12x-extender ar7240 ar7240
+
+ap123_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+	@echo '#define CONFIG_ROOTFS_TYPE "rootfstype=squashfs"' >>include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+ifeq ($(DB12X_P2P_ENV), 1)
+	@echo "#define CONFIG_DB12X_P2P 1" >>include/config.h
+endif
+
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1' >>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+endif
+
+	@./mkconfig -a ap123 mips mips ap123 ar7240 ar7240
+
+
+ap91_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap91 mips mips ap91 ar7240 ar7240
+ap91-2MB_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap91-2MB mips mips ap91-2MB ar7240 ar7240
+ap91-2x8_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap91-2x8 mips mips ap91-2x8 ar7240 ar7240
+ap93_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap93 mips mips ap93 ar7240 ar7240
+ap91-router_config	: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap91-router mips mips ap91-router ar7240 ar7240
+ap93-hgw_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap93-hgw mips mips ap93-hgw ar7240 ar7240
+cus136_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a cus136 mips mips cus136 ar7240 ar7240
+wrt54g_config           :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a wrt54g mips mips wrt54g ar7240 ar7240
+pb90_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a pb90 mips mips pb90 ar7240 ar7240
+tb327_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a tb327 mips mips tb327 ar7240 ar7240
+pb93_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a pb93 mips mips pb93 ar7240 ar7240
+pb9x_config             :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a pb9x mips mips pb9x ar7240 ar7240
+
+pb9x-2x8_config             :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a pb9x-2x8 mips mips pb9x-2x8 ar7240 ar7240
+ap98_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a ap98 mips mips ap98 ar7240 ar7240
+
+pb9x-2.6.31_config             :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a pb9x-2.6.31 mips mips pb9x-2.6.31 ar7240 ar7240
+
+pb9x-offload_config             :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+ifdef ROOTFS
+	@echo "#define ROOTFS $(ROOTFS)" >>include/config.h
+endif
+	@./mkconfig -a pb9x-2.6.31 mips mips pb9x-2.6.31 ar7240 ar7240
+
+pb92_config             :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a pb92 mips mips pb92 ar7240 ar7240
+
+ap99_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a ap99 mips mips ap99 ar7240 ar7240
+
+ap99-small_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a ap99-small mips mips ap99-small ar7240 ar7240
+
+
+ap99-2.6.31_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a ap99-2.6.31 mips mips ap99-2.6.31 ar7240 ar7240
+
+ap99-hgw_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a ap99-hgw mips mips ap99-hgw ar7240 ar7240
+ap99-ivi_config     :   unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a ap99-ivi mips mips ap99-ivi ar7240 ar7240
+
+ap101_config             :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap101 mips mips ap101 ar7240 ar7240
+
+ap101-small_config       :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap101-small mips mips ap101-small ar7240 ar7240
+
+ap101-2.6.31_config      :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap101-2.6.31 mips mips ap101-2.6.31 ar7240 ar7240
+
+mi93_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a mi93 mips mips mi93 ar7240 ar7240
+
+ap111_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap111 mips mips ap111 ar7240 ar7240
+
+ap111-2.6.31_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap111-2.6.31 mips mips ap111-2.6.31 ar7240 ar7240
+
+hornet_common_config        :
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_MACH_HORNET 1" >>include/config.h
+ifdef BUILD_EMU
+	@echo "#define CONFIG_HORNET_EMU 1" >>include/config.h
+ifeq ($(BUILD_EMU), 24)
+	@echo "#define CONFIG_HORNET_EMU_HARDI 1" >>include/config.h
+	@echo "#define CONFIG_HORNET_EMU_HARDI_WLAN 1" >>include/config.h
+else
+
+ifeq ($(BUILD_EMU), 40)
+    #
+	# No need to include CONFIG_HORNET_EMU_HARDI_WLAN in 40Mhz, only for emulation and 24Mhz board
+	#	
+else
+    #
+	# Configure it as 24Mhz by default
+	#
+	@export BUILD_EMU=24
+	@echo "#define CONFIG_HORNET_EMU_HARDI_WLAN 1" >>include/config.h
+endif
+endif
+endif
+ifeq ($(CONFIG_HORNET_XTAL), 40)
+	@echo "#define CONFIG_40MHZ_XTAL_SUPPORT 1" >>include/config.h
+endif
+ifeq ($(CONFIG_HORNET_1_1_WAR), 1)
+	@echo "#define CONFIG_HORNET_1_1_WAR 1" >>include/config.h
+endif
+ifeq ($(AG7240_BROADCAST_ENABLE), 1)
+	@echo "#define AG7240_BROADCAST_ENABLE 1" >>include/config.h
+endif
+ifeq ($(NEW_DDR_TAP_CAL), 1)
+	@echo "#define NEW_DDR_TAP_CAL 1" >>include/config.h
+endif
+
+ap121_config		    : 	unconfig    hornet_common_config
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+ifdef BOARD_STRING
+	@echo "#define BOARD_STRING 1" >>include/config.h
+endif
+	@./mkconfig -a ap121 mips mips ap121 ar7240 ar7240
+ap121-2x16_config		    : 	unconfig    hornet_common_config
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+	@./mkconfig -a ap121 mips mips ap121 ar7240 ar7240
+
+ap121-2.6.31_config		    : 	unconfig    hornet_common_config
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+	@./mkconfig -a ap121 mips mips ap121 ar7240 ar7240
+
+ap121-2.6.31-2MB_config		: 	unconfig    hornet_common_config
+	@./mkconfig -a ap121 mips mips ap121 ar7240 ar7240
+ifeq ($(VXWORKS_UBOOT), 1)
+	@echo "#define VXWORKS_UBOOT 1" >>include/config.h
+endif
+
+ap121-2MB_config		: 	unconfig   hornet_common_config
+	@./mkconfig -a ap121 mips mips ap121 ar7240 ar7240
+
+ap121-hgw_config		    : 	unconfig    hornet_common_config
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+	@./mkconfig -a ap121 mips mips ap121 ar7240 ar7240
+
+hornet_emu_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_MACH_HORNET 1" >>include/config.h
+ifdef BUILD_EMU
+	@echo "#define CONFIG_HORNET_EMU 1" >>include/config.h
+ifeq ($(BUILD_EMU), 24)
+	@echo "#define CONFIG_HORNET_EMU_HARDI 1" >>include/config.h
+	@echo "#define CONFIG_HORNET_EMU_HARDI_WLAN 1" >>include/config.h
+else
+
+ifeq ($(BUILD_EMU), 40)
+    #
+	# No need to include CONFIG_HORNET_EMU_HARDI_WLAN in 40Mhz, only for emulation and 24Mhz board
+	#	
+else
+    #
+	# Configure it as 24Mhz by default
+	#
+	@export BUILD_EMU=24
+	@echo "#define CONFIG_HORNET_EMU_HARDI_WLAN 1" >>include/config.h
+endif
+endif
+endif
+	@./mkconfig -a hornet_emu mips mips hornet_emu ar7240 ar7240
+
+scoemu_config: 	unconfig
+	@echo '#define CONFIG_ATHEROS		1'	>include/config.h
+	@echo '#define CONFIG_MACH_QCA955x	1'	>>include/config.h
+	@echo '#define CFG_INIT_STACK_IN_SRAM	1'	>>include/config.h
+	@echo '#define CONFIG_ATH_EMULATION	1'	>>include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f2e)
+	@echo '#define CONFIG_F2E_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+endif
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1'	>>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifdef FLASH_SIZE
+	@echo '#define FLASH_SIZE	$(FLASH_SIZE)'	>>include/config.h
+endif
+	@./mkconfig -a scoemu mips mips scoemu atheros
+
+
+ifneq ($(findstring $(BOARD_TYPE), board955x-offload-target),) #{
+ifneq ($(findstring $(BUILD_CONFIG), _ap136),)
+CFG_BOARD_TYPE=ap136
+endif
+ifneq ($(findstring $(BUILD_CONFIG), _ap132),)
+CFG_BOARD_TYPE=ap132
+endif
+ifneq ($(findstring $(BUILD_CONFIG), _ap135),)
+CFG_BOARD_TYPE=ap135
+endif
+endif #}
+
+ifneq ($(findstring $(BOARD_TYPE), board955x-offload-host),)
+ifneq ($(findstring $(BUILD_CONFIG), _ap136 _ap136_bootrom),)
+CFG_BOARD_TYPE=ap136
+
+ifneq ($(findstring $(BUILD_CONFIG), _ap136_bootrom),) #{
+ETH_CONFIG=_s17
+ATH_GMAC_GE0_IS_CONNECTED=1
+ATH_GMAC_GE1_IS_CONNECTED=1
+ATH_GMAC0_MII=ATHR_RGMII
+ATH_GMAC1_MII=ATHR_SGMII
+#sgmii defines
+ATH_CFG_SGMII=1
+ATH_CONFIG_SWAP_SGMII=0
+AH_CAL_IN_FLASH_PCI=1
+ATH_S17_PHY0_WAN=1
+ATH_SGMII_FORCED=1
+#LED defines
+ATH_SUPPORT_LED=1
+GPIO_PIN_FUNC_0=7
+GPIO_PIN_FUNC_1=7
+GPIO_PIN_FUNC_2=7
+ATH_LED_CUSTOMER=CUSTOMER_ATHEROS_SCORPION
+endif #}
+
+endif
+endif
+
+
+board955x_config: 	unconfig
+	@echo '#define CONFIG_ATHEROS		1'	>include/config.h
+	@echo '#define CONFIG_MACH_QCA955x	1'	>>include/config.h
+	@echo '#define CFG_INIT_STACK_IN_SRAM	1'	>>include/config.h
+	@echo '#define CONFIG_'`echo $(CFG_BOARD_TYPE) | tr [a-z] [A-Z] | sed s/-/_/g`'	1' >>include/config.h
+	@echo '#define __CONFIG_BOARD_NAME $(CFG_BOARD_TYPE)' >>include/config.h
+	@echo '#define CONFIG_BOARD_NAME "$(CFG_BOARD_TYPE)"' >>include/config.h
+ifdef pll
+	@echo '#define CFG_PLL_FREQ		$(pll)'	>>include/config.h
+else
+	@echo '#define CFG_PLL_FREQ		CFG_PLL_720_600_200'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+endif
+
+ifeq ($(ATH_SGMII_FORCED),1)
+	@echo '#define ATH_SGMII_FORCED		1'	>>include/config.h
+endif
+ifneq (,$(findstring _s17,$(ETH_CONFIG))) #{
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+
+ifneq (,$(findstring $(CFG_BOARD_TYPE),ap136 ap135)) #{
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+	@echo '#define CFG_ATH_GE1_IS_CONNECTED 1' 	>>include/config.h
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII  1'      >>include/config.h
+
+ifeq ($(ATH_S17_PHY0_WAN),1)
+	@echo "#define CONFIG_ATH_S17_WAN 1" >> include/config.h
+endif
+
+endif #}
+ifeq ($(S17_SWMAC6_CONNECTED),1)
+	@echo "#define CONFIG_S17_SWMAC6_CONNECTED 1" >> include/config.h
+endif
+endif
+
+ifeq ($(CFG_BOARD_TYPE), ap132)
+	@echo '#define CFG_ATH_GMAC_NMACS       2'      >>include/config.h
+	@echo '#define CFG_ATH_GE1_IS_CONNECTED 1'      >>include/config.h
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII  1'      >>include/config.h
+	@echo '#define CONFIG_MGMT_INIT         1'      >>include/config.h
+ifeq ($(ATH_SWITCH_ONLY_MODE),1)
+	@echo "#define CONFIG_ATHR_SWITCH_ONLY_MODE 1" >> include/config.h
+endif
+endif
+
+ifeq ($(ATH_S17_MAC0_SGMII),1)
+	@echo "#define ATH_S17_MAC0_SGMII 1" >> include/config.h
+endif
+
+
+#ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+#	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+#	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+#else
+#ifeq ($(ETH_CONFIG), _s17_hwaccel)
+#	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+#	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+#endif
+ifeq ($(ETH_CONFIG2), _ar8033) #{
+	@echo '#define CONFIG_ATHR_8033_PHY     1'      >>include/config.h
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII  1'      >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+ifeq ($(ATH_MDC_GPIO),1)
+	@echo '#define ATH_MDC_GPIO       1'      >>include/config.h
+endif
+
+endif #}
+ifeq ($(ETH_CONFIG), _vir) #{
+
+ifneq ($(findstring ATHR_MII,$(ATH_GMAC0_MII)),)
+	@echo "#define GMAC0_MII 1" >> include/config.h
+
+else
+	@echo '#define CONFIG_VIR_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+
+ifeq ($(ATH_SLAVE_CONNECTED),1)
+	@echo "#define CONFIG_SCO_SLAVE_CONNECTED 1" >> include/config.h
+endif
+
+endif #}
+ifeq ($(ATH_SGMII_FORCED),1)
+	@echo "#define ATH_SGMII_FORCED_MODE 1" >> include/config.h
+endif
+
+ifeq ($(ATH_RGMII_CAL),1)
+	@echo "#define ATH_RGMII_CAL 1" >> include/config.h
+endif
+
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1'	>>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifdef FLASH_SIZE
+	@echo '#define FLASH_SIZE	$(FLASH_SIZE)'	>>include/config.h
+endif
+	@./mkconfig -a board955x mips mips board955x atheros
+
+ap135_config: 	unconfig
+	@echo '#define CONFIG_ATHEROS		1'	>include/config.h
+	@echo '#define CONFIG_MACH_QCA955x	1'	>>include/config.h
+	@echo '#define CFG_INIT_STACK_IN_SRAM	1'	>>include/config.h
+	@echo '#define CONFIG_'`echo $(CFG_BOARD_TYPE) | tr [a-z] [A-Z] | sed s/-/_/g`'	1' >>include/config.h
+	@echo '#define __CONFIG_BOARD_NAME $(CFG_BOARD_TYPE)' >>include/config.h
+	@echo '#define CONFIG_BOARD_NAME "$(CFG_BOARD_TYPE)"' >>include/config.h
+ifdef pll
+	@echo '#define CFG_PLL_FREQ		$(pll)'	>>include/config.h
+else
+	@echo '#define CFG_PLL_FREQ		CFG_PLL_720_600_200'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+endif
+
+ifeq ($(ATH_SGMII_FORCED),1)
+	@echo '#define ATH_SGMII_FORCED		1'	>>include/config.h
+endif
+ifneq (,$(findstring _s17,$(ETH_CONFIG))) #{
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+
+ifneq (,$(findstring $(CFG_BOARD_TYPE),ap136 ap135)) #{
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+	@echo '#define CFG_ATH_GE1_IS_CONNECTED 1' 	>>include/config.h
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII  1'      >>include/config.h
+
+ifeq ($(ATH_S17_PHY0_WAN),1)
+	@echo "#define CONFIG_ATH_S17_WAN 1" >> include/config.h
+endif
+
+endif #}
+ifeq ($(S17_SWMAC6_CONNECTED),1)
+	@echo "#define CONFIG_S17_SWMAC6_CONNECTED 1" >> include/config.h
+endif
+endif
+
+ifeq ($(CFG_BOARD_TYPE), ap132)
+	@echo '#define CFG_ATH_GMAC_NMACS       2'      >>include/config.h
+	@echo '#define CFG_ATH_GE1_IS_CONNECTED 1'      >>include/config.h
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII  1'      >>include/config.h
+	@echo '#define CONFIG_MGMT_INIT         1'      >>include/config.h
+ifeq ($(ATH_SWITCH_ONLY_MODE),1)
+	@echo "#define CONFIG_ATHR_SWITCH_ONLY_MODE 1" >> include/config.h
+endif
+endif
+
+ifeq ($(ATH_S17_MAC0_SGMII),1)
+	@echo "#define ATH_S17_MAC0_SGMII 1" >> include/config.h
+endif
+
+
+#ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+#	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+#	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+#else
+#ifeq ($(ETH_CONFIG), _s17_hwaccel)
+#	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+#	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+#endif
+ifeq ($(ETH_CONFIG2), _ar8033) #{
+	@echo '#define CONFIG_ATHR_8033_PHY     1'      >>include/config.h
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII  1'      >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+ifeq ($(ATH_MDC_GPIO),1)
+	@echo '#define ATH_MDC_GPIO       1'      >>include/config.h
+endif
+
+endif #}
+ifeq ($(ETH_CONFIG), _vir) #{
+
+ifneq ($(findstring ATHR_MII,$(ATH_GMAC0_MII)),)
+	@echo "#define GMAC0_MII 1" >> include/config.h
+
+else
+	@echo '#define CONFIG_VIR_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+
+ifeq ($(ATH_SLAVE_CONNECTED),1)
+	@echo "#define CONFIG_SCO_SLAVE_CONNECTED 1" >> include/config.h
+endif
+
+endif #}
+ifeq ($(ATH_SGMII_FORCED),1)
+	@echo "#define ATH_SGMII_FORCED_MODE 1" >> include/config.h
+endif
+
+ifeq ($(ATH_RGMII_CAL),1)
+	@echo "#define ATH_RGMII_CAL 1" >> include/config.h
+endif
+
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1'	>>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifdef FLASH_SIZE
+	@echo '#define FLASH_SIZE	$(FLASH_SIZE)'	>>include/config.h
+endif
+	@./mkconfig -a board955x mips mips board955x atheros
+
+
+board956x_config: unconfig
+	@echo '#define CONFIG_ATHEROS		1'	>include/config.h
+	@echo '#define CONFIG_MACH_QCA956x	1'	>>include/config.h
+	@echo '#define CFG_INIT_STACK_IN_SRAM	1'	>>include/config.h
+	@echo '#define CONFIG_'`echo $(CFG_BOARD_TYPE) | tr [a-z] [A-Z] | sed s/-/_/g`'	1' >>include/config.h
+	@echo '#define __CONFIG_BOARD_NAME $(CFG_BOARD_TYPE)' >>include/config.h
+	@echo '#define CONFIG_BOARD_NAME "$(CFG_BOARD_TYPE)"' >>include/config.h
+ifdef pll
+	@echo '#define CFG_PLL_FREQ		$(pll)'	>>include/config.h
+else
+	@echo '#define CFG_PLL_FREQ		CFG_PLL_750_400_250'	>>include/config.h
+endif
+ifdef ddr_cas
+	@echo '#define CFG_DDR2_DRAGONFLY_CAS_LATENCY		$(ddr_cas)'	>>include/config.h
+endif
+ifneq (,$(findstring $(CFG_BOARD_TYPE),cus249 tb753)) #{
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+	@echo '#define CFG_ATH_GE1_IS_CONNECTED 1' 	>>include/config.h
+endif #}
+ifneq (,$(findstring $(CFG_BOARD_TYPE),ap151 ap151-020 tb754)) #{
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+	@echo '#define CFG_ATH_GE1_IS_CONNECTED 1' 	>>include/config.h
+endif #}
+ifneq (,$(findstring $(CFG_BOARD_TYPE), ap152 tb755)) #{
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+	@echo '#define CFG_ATH_GE1_IS_CONNECTED 1' 	>>include/config.h
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII  1'      >>include/config.h
+	@echo '#define ATH_S17_MAC0_SGMII	1'	>>include/config.h
+endif #}
+
+ifneq (,$(findstring $(CFG_BOARD_TYPE), ap152)) #{
+	@echo '#define UART_RX18_TX22           1'      >>include/config.h
+endif #}
+ifeq ($(CFG_BOARD_TYPE), ap151-020)
+	@echo '#define UART_RX24_TX20           1'      >>include/config.h
+endif 
+ifeq ($(CFG_BOARD_TYPE), ap151)
+	@echo '#define UART_RX18_TX20           1'      >>include/config.h
+endif
+ifneq (,$(findstring $(CFG_BOARD_TYPE), tb755)) #{
+	@echo '#define UART_RX20_TX22           1'      >>include/config.h
+endif #}
+
+ifneq (,$(findstring $(CFG_BOARD_TYPE), tb753 tb754)) #{
+	@echo '#define TEST_BOARD_UART          1'      >>include/config.h
+endif #}
+
+ifneq (,$(findstring $(CFG_BOARD_TYPE),dragonflyemu)) #{
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+	@echo '#define CFG_ATH_GE1_IS_CONNECTED 1' 	>>include/config.h
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII  1'      >>include/config.h
+endif #}
+
+ifeq ($(CFG_BOARD_TYPE), ap152)
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII	1'	>>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY		1'	>>include/config.h	
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+endif
+
+ifeq ($(ATH_SGMII_FORCED),1)
+	@echo '#define ATH_SGMII_FORCED_MODE    1'	>>include/config.h
+endif
+
+ifdef FLASH_SIZE
+	@echo '#define FLASH_SIZE	$(FLASH_SIZE)'	>>include/config.h
+endif
+	@./mkconfig -a board956x mips mips board956x atheros
+
+
+ap138_config: 	unconfig
+	@echo '#define CONFIG_ATHEROS		1'	>include/config.h
+	@echo '#define CONFIG_MACH_QCA955x	1'	>>include/config.h
+	@echo '#define CFG_INIT_STACK_IN_SRAM	1'	>>include/config.h
+ifdef pll
+	@echo '#define CFG_PLL_FREQ		$(pll)'	>>include/config.h
+else
+	@echo '#define CFG_PLL_FREQ		CFG_PLL_720_600_240'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f2e)
+	@echo '#define CONFIG_F2E_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+endif
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1'	>>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifdef FLASH_SIZE
+	@echo '#define FLASH_SIZE	$(FLASH_SIZE)'	>>include/config.h
+endif
+	@./mkconfig -a board955x mips mips board955x atheros
+
+
 #========================================================================
 # Nios
 #========================================================================
@@ -1903,37 +3487,44 @@
 #########################################################################
 
 clean:
-	find . -type f \
+	@echo Making $@
+	@find . -type f \
 		\( -name 'core' -o -name '*.bak' -o -name '*~' \
-		-o -name '*.o'  -o -name '*.a'  \) -print \
+		-o -name '*.o'  -o -name '*.a' -o -name .depend \) -print \
 		| xargs rm -f
-	rm -f examples/hello_world examples/timer \
+	@rm -f examples/hello_world examples/timer \
 	      examples/eepro100_eeprom examples/sched \
 	      examples/mem_to_mem_idma2intr examples/82559_eeprom \
 	      examples/smc91111_eeprom \
 	      examples/test_burst
-	rm -f tools/img2srec tools/mkimage tools/envcrc tools/gen_eth_addr
-	rm -f tools/mpc86x_clk tools/ncb
-	rm -f tools/easylogo/easylogo tools/bmp_logo
-	rm -f tools/gdb/astest tools/gdb/gdbcont tools/gdb/gdbsend
-	rm -f tools/env/fw_printenv tools/env/fw_setenv
-	rm -f board/cray/L1/bootscript.c board/cray/L1/bootscript.image
-	rm -f board/netstar/eeprom board/netstar/crcek
-	rm -f board/netstar/*.srec board/netstar/*.bin
-	rm -f board/trab/trab_fkt board/voiceblue/eeprom
-	rm -f board/integratorap/u-boot.lds board/integratorcp/u-boot.lds
+	@rm -f tools/img2srec tools/mkimage tools/envcrc tools/gen_eth_addr
+	@rm -f tools/mpc86x_clk tools/ncb
+	@rm -f tools/easylogo/easylogo tools/bmp_logo
+	@rm -f tools/gdb/astest tools/gdb/gdbcont tools/gdb/gdbsend
+	@rm -f tools/env/fw_printenv tools/env/fw_setenv
+	@rm -f board/cray/L1/bootscript.c board/cray/L1/bootscript.image
+	@rm -f board/netstar/eeprom board/netstar/crcek
+	@rm -f board/netstar/*.srec board/netstar/*.bin
+	@rm -f board/trab/trab_fkt board/voiceblue/eeprom
+	@rm -f board/integratorap/u-boot.lds board/integratorcp/u-boot.lds
+ifeq ($(COMPRESSED_UBOOT),1)
+	@rm -f lib_bootstrap/*.o
+	@rm -f lib_bootstrap/*.a
+	@rm -f bootstrap bootstrap.bin tuboot.bin u-boot.lzimg
+endif
 
 clobber:	clean
-	find . -type f \( -name .depend \
+	@echo Making $@
+	@find . -type f \( -name .depend \
 		-o -name '*.srec' -o -name '*.bin' -o -name u-boot.img \) \
 		-print0 \
 		| xargs -0 rm -f
-	rm -f $(OBJS) *.bak tags TAGS include/version_autogenerated.h
-	rm -fr *.*~
-	rm -f u-boot u-boot.map u-boot.hex $(ALL)
-	rm -f tools/crc32.c tools/environment.c tools/env/crc32.c
-	rm -f tools/inca-swap-bytes cpu/mpc824x/bedbug_603e.c
-	rm -f include/asm/proc include/asm/arch include/asm
+	@rm -f $(OBJS) *.bak tags TAGS include/version_autogenerated.h
+	@rm -fr *.*~
+	@rm -f u-boot u-boot.map u-boot.hex $(ALL)
+	@rm -f tools/crc32.c tools/environment.c tools/env/crc32.c
+	@rm -f tools/inca-swap-bytes cpu/mpc824x/bedbug_603e.c
+	@rm -f include/asm/proc include/asm/arch include/asm
 
 mrproper \
 distclean:	clobber unconfig
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//mips_config.mk u-boot_1.1//mips_config.mk
--- u-boot//mips_config.mk	2014-02-18 01:46:23.627050097 -0800
+++ u-boot_1.1//mips_config.mk	2014-02-18 01:46:29.455054165 -0800
@@ -2,6 +2,8 @@
 # (C) Copyright 2003
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
 # See file CREDITS for list of people who contributed to this
 # project.
 #
@@ -22,3 +24,11 @@
 #
 
 PLATFORM_CPPFLAGS += -DCONFIG_MIPS -D__MIPS__
+
+#When compiling the assemble source code, it will 
+#miss these options if we use gcc-4.6.1
+PLATFORM_CPPFLAGS += -mabicalls -fpic
+
+ifeq ($(FLASH_TYPE),S25FL128P)
+   PLATFORM_CPPFLAGS += -D$(FLASH_TYPE)
+endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//net/eth.c u-boot_1.1//net/eth.c
--- u-boot//net/eth.c	2014-02-18 01:46:23.627050097 -0800
+++ u-boot_1.1//net/eth.c	2014-02-18 01:46:29.463054171 -0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2001-2004
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -231,6 +233,15 @@
 #if defined(CONFIG_RTL8169)
 	rtl8169_initialize(bis);
 #endif
+#if defined(CONFIG_AR7100)
+	ag7100_enet_initialize(bis);
+#endif
+#if defined(CONFIG_AR7240)
+	ag7240_enet_initialize(bis);
+#endif
+#if defined(CONFIG_ATHEROS) && !defined(CONFIG_ATH_EMULATION)
+	ath_gmac_enet_initialize(bis);
+#endif
 
 	if (!eth_devices) {
 		puts ("No ethernet found.\n");
@@ -258,6 +269,7 @@
 					tmp = (*end) ? end+1 : end;
 			}
 
+#if !defined(CONFIG_AR9100) && !defined(CONFIG_AR7240) && !defined(CONFIG_ATHEROS)
 			if (memcmp(env_enetaddr, "\0\0\0\0\0\0", 6)) {
 				if (memcmp(dev->enetaddr, "\0\0\0\0\0\0", 6) &&
 				    memcmp(dev->enetaddr, env_enetaddr, 6))
@@ -278,6 +290,7 @@
 
 				memcpy(dev->enetaddr, env_enetaddr, 6);
 			}
+#endif
 
 			eth_number++;
 			dev = dev->next;
@@ -343,8 +356,9 @@
 
 	old_current = eth_current;
 	do {
+#if !defined(CFG_ATHRS26_PHY) && !defined(CFG_ATHRHDR_EN)
 		debug ("Trying %s\n", eth_current->name);
-
+#endif
 		if (eth_current->init(eth_current, bis)) {
 			eth_current->state = ETH_STATE_ACTIVE;
 
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//net/Makefile u-boot_1.1//net/Makefile
--- u-boot//net/Makefile	2014-02-18 01:46:23.627050097 -0800
+++ u-boot_1.1//net/Makefile	2014-02-18 01:46:29.455054165 -0800
@@ -2,6 +2,8 @@
 # (C) Copyright 2000
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
 # See file CREDITS for list of people who contributed to this
 # project.
 #
@@ -26,8 +28,12 @@
 # CFLAGS += -DET_DEBUG -DDEBUG
 
 LIB	= libnet.a
-
+ifeq ($(COMPRESSED_UBOOT),1)
+OBJS	= net.o tftp.o rarp.o eth.o
+else
 OBJS	= net.o tftp.o bootp.o rarp.o eth.o nfs.o sntp.o
+endif
+
 all:	$(LIB)
 
 $(LIB):	$(START) $(OBJS)
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//net/net.c u-boot_1.1//net/net.c
--- u-boot//net/net.c	2014-02-18 01:46:23.631050100 -0800
+++ u-boot_1.1//net/net.c	2014-02-18 01:46:29.463054171 -0800
@@ -6,6 +6,7 @@
  *	Copyright 2000 Roland Borde
  *	Copyright 2000 Paolo Scaffardi
  *	Copyright 2000-2002 Wolfgang Denk, wd@denx.de
+ *	Copyright (c) 2013 Qualcomm Atheros, Inc.
  */
 
 /*
@@ -155,6 +156,9 @@
 
 static void PingStart(void);
 #endif
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+extern void athr_hdr_func(void);
+#endif
 
 #if (CONFIG_COMMANDS & CFG_CMD_CDP)
 static void CDPStart(void);
@@ -269,6 +273,9 @@
 NetLoop(proto_t protocol)
 {
 	bd_t *bd = gd->bd;
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+	static int AthrHdr_Flag = 0;
+#endif
 
 #ifdef CONFIG_NET_MULTI
 	NetRestarted = 0;
@@ -300,15 +307,36 @@
 		NetArpWaitTxPacket -= (ulong)NetArpWaitTxPacket % PKTALIGN;
 		NetArpWaitTxPacketSize = 0;
 	}
-
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+	if(!AthrHdr_Flag) {
+	        eth_halt();
+		if (eth_init(bd) < 0) {
+            	    eth_halt();
+               	 return(-1);
+        	}
+		AthrHdr_Flag = 1;
+	}
+#else
 	eth_halt();
 #ifdef CONFIG_NET_MULTI
+#if defined(CFG_VITESSE_73XX_NOPHY) || defined(CFG_REH132)
+	/*
+	 * There is no PHY in the DNI AP83 board with vitesse switch
+	 * VSC7395XYV, so set the eth1 interface to switch ports, so
+	 * that u-boot can route all the traffic through the switch
+	 * ports.
+	 */
+	setenv("ethact", "eth1");
+#else
+        setenv("ethact", "eth0");
+#endif
 	eth_set_current();
 #endif
 	if (eth_init(bd) < 0) {
 		eth_halt();
 		return(-1);
 	}
+#endif
 
 restart:
 #ifdef CONFIG_NET_MULTI
@@ -380,9 +408,18 @@
 		NetOurVLAN = getenv_VLAN("vlan");	/* VLANs must be read */
 		NetOurNativeVLAN = getenv_VLAN("nvlan");
 		break;
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+	case ATHRHDR:
+		athr_hdr_func();
+		break;
+#endif
 	default:
 		break;
 	}
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+	if(protocol == ATHRHDR)
+		goto skip_netloop;
+#endif
 
 	switch (net_check_prereq (protocol)) {
 	case 1:
@@ -415,7 +452,7 @@
 			DhcpRequest();		/* Basically same as BOOTP */
 			break;
 #endif /* CFG_CMD_DHCP */
-
+#ifndef COMPRESSED_UBOOT
 		case BOOTP:
 			BootpTry = 0;
 			BootpRequest ();
@@ -425,11 +462,13 @@
 			RarpTry = 0;
 			RarpRequest ();
 			break;
+#endif
 #if (CONFIG_COMMANDS & CFG_CMD_PING)
 		case PING:
 			PingStart();
 			break;
 #endif
+
 #if (CONFIG_COMMANDS & CFG_CMD_NFS)
 		case NFS:
 			NfsStart();
@@ -475,6 +514,7 @@
 	 *	Main packet reception loop.  Loop receiving packets until
 	 *	someone sets `NetState' to a state that terminates.
 	 */
+skip_netloop:
 	for (;;) {
 		WATCHDOG_RESET();
 #ifdef CONFIG_SHOW_ACTIVITY
@@ -497,8 +537,12 @@
 			puts ("\nAbort\n");
 			return (-1);
 		}
-
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+                if(protocol != ATHRHDR)
+			ArpTimeoutCheck();
+#else
 		ArpTimeoutCheck();
+#endif
 
 		/*
 		 *	Check for a timeout, and run the timeout handler
@@ -506,7 +550,7 @@
 		 */
 		if (timeHandler && ((get_timer(0) - timeStart) > timeDelta)) {
 			thand_f *x;
-
+#if !defined(CFG_ATHRS26_PHY) && !defined(CFG_ATHRHDR_EN)
 #if defined(CONFIG_MII) || (CONFIG_COMMANDS & CFG_CMD_MII)
 #  if defined(CFG_FAULT_ECHO_LINK_DOWN) && \
       defined(CONFIG_STATUS_LED) &&	   \
@@ -521,12 +565,11 @@
 			}
 #  endif /* CFG_FAULT_ECHO_LINK_DOWN, ... */
 #endif /* CONFIG_MII, ... */
+#endif
 			x = timeHandler;
 			timeHandler = (thand_f *)0;
 			(*x)();
 		}
-
-
 		switch (NetState) {
 
 		case NETLOOP_RESTART:
@@ -536,11 +579,17 @@
 			goto restart;
 
 		case NETLOOP_SUCCESS:
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+			if(protocol == ATHRHDR)
+				return 1;
+#endif
+
 			if (NetBootFileXferSize > 0) {
 				char buf[10];
 				printf("Bytes transferred = %ld (%lx hex)\n",
 					NetBootFileXferSize,
 					NetBootFileXferSize);
+
 				sprintf(buf, "%lx", NetBootFileXferSize);
 				setenv("filesize", buf);
 
@@ -1140,6 +1189,9 @@
 	IPaddr_t tmp;
 	int	x;
 	uchar *pkt;
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+        uint8_t type;
+#endif
 #if (CONFIG_COMMANDS & CFG_CMD_CDP)
 	int iscdp;
 #endif
@@ -1149,9 +1201,26 @@
 	printf("packet received\n");
 #endif
 
-	NetRxPkt = inpkt;
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+	type = (inpkt[1] & 0xf);
+	/* check for ack */
+       if(type == 0x6){
+               (*packetHandler)(inpkt,0,0,0);
+		return;
+	}
+	else if (type == 0x0) {
+	   inpkt = inpkt + ATHRHDR_LEN;  /* Remove ATHRHDR */
+	   len = len - ATHRHDR_LEN;
+	}
+	else{
+		printf("Packet dropped! Type invalid.\n");
+		return;
+	}
+#endif
+
+        NetRxPkt = inpkt;
 	NetRxPktLen = len;
-	et = (Ethernet_t *)inpkt;
+        et = (Ethernet_t *)inpkt;
 
 	/* too small packet? */
 	if (len < ETHER_HDR_SIZE)
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//Notice.txt u-boot_1.1//Notice.txt
--- u-boot//Notice.txt	1969-12-31 16:00:00.000000000 -0800
+++ u-boot_1.1//Notice.txt	2014-02-18 01:46:23.759050188 -0800
@@ -0,0 +1,407 @@
+This Notice.txt file contains certain notices of software components  
+included with the software that QUALCOMM ATHEROS Incorporated (Qualcomm Atheros)  
+is required to provide you. Notwithstanding anything in the notices in this file,  
+your use of these software components together with the Qualcomm Atheros software  
+(Qualcomm Atheros software hereinafter referred to as Software) is subject  
+to the terms of your license from Qualcomm Atheros.  Compliance with all copyright  
+laws and software license agreements included in the notice section of this file  
+are the responsibility of the user.  Except as may be granted by separate express  
+written agreement, this file provides no license to any Qualcomm Atheros patents,  
+trademarks, copyrights, or other intellectual property.
+
+Copyright (c) 2012 QUALCOMM ATHEROS Incorporated.  All rights reserved. 
+
+QUALCOMM ATHEROS is a registered trademark and registered service mark of QUALCOMM 
+ATHEROS Incorporated.  
+
+All other trademarks and service marks are the property of their respective owners. 
+
+NOTICES:
+--------------- Notice: LZMA SDK ----------------------
+LZMA SDK 4.42
+-------------
+
+LZMA SDK   Copyright (C) 1999-2006 Igor Pavlov
+
+LZMA SDK provides the documentation, samples, header files, libraries, 
+and tools you need to develop applications that use LZMA compression.
+
+LZMA is default and general compression method of 7z format
+in 7-Zip compression program (www.7-zip.org). LZMA provides high 
+compression ratio and very fast decompression.
+
+LZMA is an improved version of famous LZ77 compression algorithm. 
+It was improved in way of maximum increasing of compression ratio,
+keeping high decompression speed and low memory requirements for 
+decompressing.
+
+
+
+LICENSE
+-------
+
+LZMA SDK is available under any of the following licenses:
+
+1) GNU Lesser General Public License (GNU LGPL)
+2) Common Public License (CPL)
+3) Simplified license for unmodified code (read SPECIAL EXCEPTION) 
+4) Proprietary license 
+
+It means that you can select one of these four options and follow rules of that license.
+
+
+1,2) GNU LGPL and CPL licenses are pretty similar and both these
+licenses are classified as 
+ - "Free software licenses" at http://www.gnu.org/ 
+ - "OSI-approved" at http://www.opensource.org/
+
+
+3) SPECIAL EXCEPTION
+
+Igor Pavlov, as the author of this code, expressly permits you 
+to statically or dynamically link your code (or bind by name) 
+to the files from LZMA SDK without subjecting your linked 
+code to the terms of the CPL or GNU LGPL. 
+Any modifications or additions to files from LZMA SDK, however, 
+are subject to the GNU LGPL or CPL terms.
+
+SPECIAL EXCEPTION allows you to use LZMA SDK in applications with closed code, 
+while you keep LZMA SDK code unmodified.
+
+
+SPECIAL EXCEPTION #2: Igor Pavlov, as the author of this code, expressly permits 
+you to use this code under the same terms and conditions contained in the License 
+Agreement you have for any previous version of LZMA SDK developed by Igor Pavlov.
+
+SPECIAL EXCEPTION #2 allows owners of proprietary licenses to use latest version 
+of LZMA SDK as update for previous versions.
+
+
+SPECIAL EXCEPTION #3: Igor Pavlov, as the author of this code, expressly permits 
+you to use code of the following files: 
+BranchTypes.h, LzmaTypes.h, LzmaTest.c, LzmaStateTest.c, LzmaAlone.cpp, 
+LzmaAlone.cs, LzmaAlone.java
+as public domain code. 
+
+
+4) Proprietary license
+
+LZMA SDK also can be available under a proprietary license which 
+can include:
+
+1) Right to modify code without subjecting modified code to the 
+terms of the CPL or GNU LGPL
+2) Technical support for code
+
+To request such proprietary license or any additional consultations,
+send email message from that page:
+http://www.7-zip.org/support.html
+
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+You should have received a copy of the Common Public License
+along with this library.
+--------------- Notice: LZMA SDK ends here ----------------------
+
+
+  NOTE! This copyright does *not* cover the so-called "standalone"
+applications that use U-Boot services by means of the jump table
+provided by U-Boot exactly for this purpose - this is merely
+considered normal use of U-Boot, and does *not* fall under the
+heading of "derived work".
+
+  The header files "include/image.h" and "include/asm-*/u-boot.h"
+define interfaces to U-Boot. Including these (unmodified) header
+files in another file is considered normal use of U-Boot, and does
+*not* fall under the heading of "derived work".
+
+  Also note that the GPL below is copyrighted by the Free Software
+Foundation, but the instance of code that it refers to (the U-Boot
+source code) is copyrighted by me and others who actually wrote it.
+-- Wolfgang Denk
+
+=======================================================================
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary u-boot//tools/mkimage.c u-boot_1.1//tools/mkimage.c
--- u-boot//tools/mkimage.c	2014-02-18 01:46:23.671050128 -0800
+++ u-boot_1.1//tools/mkimage.c	2014-02-18 01:46:29.583054255 -0800
@@ -4,6 +4,8 @@
  * Wolfgang Denk, wd@denx.de
  * All rights reserved.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
  * published by the Free Software Foundation; either version 2 of
@@ -137,6 +139,7 @@
     {	IH_COMP_NONE,	"none",		"uncompressed",		},
     {	IH_COMP_BZIP2,	"bzip2",	"bzip2 compressed",	},
     {	IH_COMP_GZIP,	"gzip",		"gzip compressed",	},
+    {   IH_COMP_LZMA,   "lzma",         "lzma compressed",      },
     {	-1,		"",		"",			},
 };
 
